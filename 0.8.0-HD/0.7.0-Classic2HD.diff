diff -ruNp ./src.orig/config_unix.h.in ./src/config_unix.h.in
--- ./src.orig/config_unix.h.in	2017-10-23 11:42:13 -0700
+++ ./src/config_unix.h.in	2017-10-23 11:41:31 -0700
@@ -14,7 +14,7 @@
 #define CONTENTDIR "@CONTENTDIR@"
 
 /* Directory where game data will be stored */
-#define USERDIR "~/.uqm/"
+#define USERDIR "~/.uqmhd/"
 
 /* Directory where config files will be stored */
 #define CONFIGDIR USERDIR
diff -ruNp ./src.orig/config_vc6.h ./src/config_vc6.h
--- ./src.orig/config_vc6.h	2017-10-23 11:42:13 -0700
+++ ./src/config_vc6.h	2017-10-23 11:41:31 -0700
@@ -15,7 +15,7 @@
 
 /* Directory where game data will be stored */
 //#define USERDIR "../userdata/"
-#define USERDIR "%APPDATA%/uqm/"
+#define USERDIR "%APPDATA%/uqmhd/"
 
 /* Directory where config files will be stored */
 #define CONFIGDIR USERDIR
diff -ruNp ./src.orig/config_win.h.in ./src/config_win.h.in
--- ./src.orig/config_win.h.in	2017-10-23 11:42:13 -0700
+++ ./src/config_win.h.in	2017-10-23 11:41:31 -0700
@@ -15,7 +15,7 @@
 
 /* Directory where game data will be stored */
 //#define USERDIR "../userdata/"
-#define USERDIR "%APPDATA%/uqm/"
+#define USERDIR "%APPDATA%/uqmhd/"
 
 /* Directory where config files will be stored */
 #define CONFIGDIR USERDIR
diff -ruNp ./src.orig/darwin/SDLMain.h ./src/darwin/SDLMain.h
--- ./src.orig/darwin/SDLMain.h	2017-10-23 11:42:13 -0700
+++ ./src/darwin/SDLMain.h	2017-10-23 11:41:31 -0700
@@ -17,3 +17,10 @@
 
 @interface SDLApplication : NSApplication
 @end
+
+/* For some reaon, Apple removed setAppleMenu from the headers in 10.4,
+ but the method still is there and works. To avoid warnings, we declare
+ it ourselves here. */
+@interface NSApplication(SDL_Missing_Methods)
+- (void)setAppleMenu:(NSMenu *)menu;
+@end
diff -ruNp ./src.orig/libs/gfxlib.h ./src/libs/gfxlib.h
--- ./src.orig/libs/gfxlib.h	2017-10-23 11:42:13 -0700
+++ ./src/libs/gfxlib.h	2017-10-23 11:41:31 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2011: Added DPOINT type - a coordinate point with larger values to avoid overflows in hires modes.
+
 #ifndef _GFXLIB_H
 #define _GFXLIB_H
 
@@ -149,11 +151,23 @@ typedef struct extent
 	COORD width, height;
 } EXTENT;
 
+// JMS: Extent with larger values to avoid overflows in hires modes.
+typedef struct dextent
+{
+	SDWORD width, height;
+} DEXTENT;
+
 typedef struct point
 {
 	COORD x, y;
 } POINT;
 
+// JMS: coordinate point with larger values to avoid overflows in hires modes.
+typedef struct dpoint
+{
+	SDWORD x, y;
+} DPOINT;
+
 typedef struct stamp
 {
 	POINT origin;
@@ -410,7 +424,7 @@ extern FRAME DecFrameIndex (FRAME Frame)
 extern DRAWABLE CopyFrameRect (FRAME Frame, const RECT *area);
 extern DRAWABLE CloneFrame (FRAME Frame);
 extern DRAWABLE RotateFrame (FRAME Frame, int angle_deg);
-extern DRAWABLE RescaleFrame (FRAME, int width, int height);
+extern DRAWABLE RescaleFrame (FRAME, int width, int height, BOOLEAN eight_to_32);
 // This pair works for both paletted and trucolor frames
 extern BOOLEAN ReadFramePixelColors (FRAME frame, Color *pixels,
 		int width, int height);
@@ -418,7 +432,7 @@ extern BOOLEAN WriteFramePixelColors (FR
 		int width, int height);
 // This pair only works for paletted frames
 extern BOOLEAN ReadFramePixelIndexes (FRAME frame, BYTE *pixels,
-		int width, int height);
+		int width, int height, BOOLEAN paletted);
 extern BOOLEAN WriteFramePixelIndexes (FRAME frame, const BYTE *pixels,
 		int width, int height);
 extern void SetFrameTransparentColor (FRAME, Color);
diff -ruNp ./src.orig/libs/graphics/dcqueue.c ./src/libs/graphics/dcqueue.c
--- ./src.orig/libs/graphics/dcqueue.c	2017-10-23 11:42:13 -0700
+++ ./src/libs/graphics/dcqueue.c	2017-10-23 11:41:31 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "port.h"
 #include "libs/threadlib.h"
 #include "libs/graphics/drawcmd.h"
@@ -554,13 +556,13 @@ TFB_FlushGraphics (void)
 				int oldWidth = ScreenWidthActual;
 				int oldHeight = ScreenHeightActual;
 				if (TFB_ReInitGraphics (cmd->driver, cmd->flags,
-						cmd->width, cmd->height))
+						cmd->width, cmd->height, resolutionFactor, forceAspectRatio)) // JMS_GFX: Added resolutionFactor
 				{
 					log_add (log_Error, "Could not provide requested mode: "
 							"reverting to last known driver.");
 					// We don't know what exactly failed, so roll it all back
 					if (TFB_ReInitGraphics (oldDriver, oldFlags,
-							oldWidth, oldHeight))
+							oldWidth, oldHeight, resolutionFactor, forceAspectRatio)) // JMS_GFX: Added resolutionFactor
 					{
 						log_add (log_Fatal,
 								"Couldn't reinit at that point either. "
diff -ruNp ./src.orig/libs/graphics/drawable.c ./src/libs/graphics/drawable.c
--- ./src.orig/libs/graphics/drawable.c	2017-10-23 11:42:13 -0700
+++ ./src/libs/graphics/drawable.c	2017-10-23 11:41:32 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+#include "libs/graphics/sdl/sdl_common.h"
+#include "libs/graphics/gfx_common.h"
 #include "libs/gfxlib.h"
 #include "libs/graphics/context.h"
 #include "libs/graphics/drawable.h"
@@ -23,6 +25,7 @@
 #include "libs/memlib.h"
 #include "tfb_draw.h"
 #include <math.h>
+#include "libs/log.h"
 
 #ifndef M_PI
 #	define M_PI 3.14159265358979323846
@@ -402,7 +405,7 @@ CloneFrame (FRAME frame)
 // Creates a new DRAWABLE of specified size and scales the passed
 // frame onto it. The aspect ratio is not preserved.
 DRAWABLE
-RescaleFrame (FRAME frame, int width, int height)
+RescaleFrame (FRAME frame, int width, int height, BOOLEAN eight_to_32)
 {
 	FRAME newFrame;
 	TFB_Image *img;
@@ -427,6 +430,20 @@ RescaleFrame (FRAME frame, int width, in
 	//   reference to it yet!
 	src = img->NormalImg;
 	dst = newFrame->image->NormalImg;
+	
+	// JMS_GFX
+	if (eight_to_32)
+	{
+		SDL_Surface *src_sdl = src;
+		SDL_Surface *dst_sdl = dst;
+		
+		if (src_sdl->format->BytesPerPixel == 1)
+		{
+			dst_sdl->format->BytesPerPixel = src_sdl->format->BytesPerPixel;
+			dst_sdl->format->BitsPerPixel = 8 * (src_sdl->format->BytesPerPixel);
+		}
+	}
+	
 	TFB_DrawCanvas_Rescale_Nearest (src, dst, -1, NULL, NULL, NULL);
 	
 	UnlockMutex (img->mutex);
@@ -468,7 +485,7 @@ WriteFramePixelColors (FRAME frame, cons
 }
 
 BOOLEAN
-ReadFramePixelIndexes (FRAME frame, BYTE *pixels, int width, int height)
+ReadFramePixelIndexes (FRAME frame, BYTE *pixels, int width, int height, BOOLEAN paletted)
 {
 	TFB_Image *img;
 
@@ -479,8 +496,13 @@ ReadFramePixelIndexes (FRAME frame, BYTE
 
 	// TODO: Do we need to lock the img->mutex here?
 	img = frame->image;
-	return TFB_DrawCanvas_GetPixelIndexes (img->NormalImg, pixels,
+	
+	// JMS_GFX: Don't try to read pixel indexes for non-indexed images.
+	if (paletted)
+		return TFB_DrawCanvas_GetPixelIndexes (img->NormalImg, pixels,
 			width, height);
+	else
+		return FALSE;
 }
 
 // Warning: this functions bypasses DCQ, which is why it is not a DrawXXX
diff -ruNp ./src.orig/libs/graphics/gfx_common.c ./src/libs/graphics/gfx_common.c
--- ./src.orig/libs/graphics/gfx_common.c	2017-10-23 11:42:13 -0700
+++ ./src/libs/graphics/gfx_common.c	2017-10-23 11:41:32 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "gfxintrn.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/drawcmd.h"
@@ -23,6 +25,11 @@
 #include "libs/misc.h"
 		// for TFB_DEBUG_HALT
 
+// JMS_GFX
+unsigned int resolutionFactor;
+int fs_height = 0; 
+int fs_width  = 0;
+// End JMS_GFX
 
 int ScreenWidth;
 int ScreenHeight;
@@ -44,12 +51,26 @@ DrawFromExtraScreen (RECT *r)
 	TFB_DrawScreen_Copy(r, TFB_SCREEN_EXTRA, TFB_SCREEN_MAIN);
 }
 
+// JMS_GFX
+void
+DrawFromExtraScreen_Fs (RECT *r)
+{
+	TFB_DrawScreen_Copy_Fs(r, TFB_SCREEN_EXTRA, TFB_SCREEN_MAIN);
+}
+
 void
 LoadIntoExtraScreen (RECT *r)
 {
 	TFB_DrawScreen_Copy(r, TFB_SCREEN_MAIN, TFB_SCREEN_EXTRA);
 }
 
+// JMS_GFX
+void
+LoadIntoExtraScreen_Fs (RECT *r)
+{
+	TFB_DrawScreen_Copy_Fs(r, TFB_SCREEN_MAIN, TFB_SCREEN_EXTRA);
+}
+
 int
 SetGraphicScale (int scale)
 {
diff -ruNp ./src.orig/libs/graphics/gfx_common.h ./src/libs/graphics/gfx_common.h
--- ./src.orig/libs/graphics/gfx_common.h	2017-10-23 11:42:13 -0700
+++ ./src/libs/graphics/gfx_common.h	2017-10-23 11:41:32 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef GFX_COMMON_H
 #define GFX_COMMON_H
 
@@ -23,6 +25,8 @@
 #include <stdlib.h>
 
 #include "libs/gfxlib.h"
+//#include "libs/graphics/sdl/opengl.h"
+//#include "libs/graphics/sdl/sdl_common.h"
 
 // driver for TFB_InitGraphics
 enum
@@ -63,8 +67,8 @@ extern int GfxFlags;
 
 // The following functions are driver-defined
 void TFB_PreInit (void);
-int TFB_InitGraphics (int driver, int flags, int width, int height);
-int TFB_ReInitGraphics (int driver, int flags, int width, int height);
+int TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor, BOOLEAN forceAspectRatio); // JMS_GFX: Added resolutionFactor
+int TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor, BOOLEAN forceAspectRatio); // JMS_GFX: Added resolutionFactor
 void TFB_UninitGraphics (void);
 void TFB_ProcessEvents (void);
 void TFB_SetGamma (float gamma);
@@ -82,7 +86,9 @@ typedef enum {
 } SCALE;
 
 void LoadIntoExtraScreen (RECT *r);
+void LoadIntoExtraScreen_Fs (RECT *r); // JMS_GFX
 void DrawFromExtraScreen (RECT *r);
+void DrawFromExtraScreen_Fs (RECT *r); // JMS_GFX
 int SetGraphicScale (int scale);
 int GetGraphicScale (void);
 int SetGraphicScaleMode (int mode /* enum SCALE */);
@@ -99,6 +105,13 @@ extern int FrameRateTickBase;
 
 void TFB_FlushGraphics (void); // Only call from main thread!!
 
+// JMS_GFX
+extern unsigned int resolutionFactor;
+extern BOOLEAN forceAspectRatio;
+extern int fs_height; 
+extern int fs_width;
+// END JMS_GFX
+
 extern int ScreenWidth;
 extern int ScreenHeight;
 extern int ScreenWidthActual;
diff -ruNp ./src.orig/libs/graphics/intersec.c ./src/libs/graphics/intersec.c
--- ./src.orig/libs/graphics/intersec.c	2017-10-23 11:42:13 -0700
+++ ./src/libs/graphics/intersec.c	2017-10-23 11:41:32 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "libs/graphics/context.h"
 #include "libs/graphics/drawable.h"
 #include "libs/graphics/tfb_draw.h"
@@ -27,23 +29,24 @@ static inline BOOLEAN
 images_intersect (IMAGE_BOX *box1, IMAGE_BOX *box2, const RECT *rect)
 {
 	return TFB_DrawImage_Intersect (box1->FramePtr->image, box1->Box.corner,
-			box2->FramePtr->image, box2->Box.corner, rect);
+									box2->FramePtr->image, box2->Box.corner, rect);
 }
 
+// JMS: Changed SIZEs to SDWORDs to prevent overflows. Ditto for COUNTs -> to DWORDs.
 static TIME_VALUE
 frame_intersect (INTERSECT_CONTROL *pControl0, RECT *pr0,
-		INTERSECT_CONTROL *pControl1, RECT *pr1, TIME_VALUE t0,
-		TIME_VALUE t1)
+				 INTERSECT_CONTROL *pControl1, RECT *pr1, TIME_VALUE t0,
+				 TIME_VALUE t1)
 {
-	SIZE time_error0, time_error1;
-	SIZE cycle0, cycle1;
-	SIZE dx_0, dy_0, dx_1, dy_1;
-	SIZE xincr0, yincr0, xincr1, yincr1;
-	SIZE xerror0, xerror1, yerror0, yerror1;
+	SDWORD time_error0, time_error1;
+	SDWORD cycle0, cycle1;
+	SDWORD dx_0, dy_0, dx_1, dy_1;
+	SDWORD xincr0, yincr0, xincr1, yincr1;
+	SDWORD xerror0, xerror1, yerror0, yerror1;
 	RECT r_intersect;
 	IMAGE_BOX IB0, IB1;
 	BOOLEAN check0, check1;
-
+	
 	IB0.FramePtr = pControl0->IntersectStamp.frame;
 	IB0.Box.corner = pr0->corner;
 	IB0.Box.extent.width = GetFrameWidth (IB0.FramePtr);
@@ -52,7 +55,7 @@ frame_intersect (INTERSECT_CONTROL *pCon
 	IB1.Box.corner = pr1->corner;
 	IB1.Box.extent.width = GetFrameWidth (IB1.FramePtr);
 	IB1.Box.extent.height = GetFrameHeight (IB1.FramePtr);
-
+	
 	dx_0 = pr0->extent.width;
 	dy_0 = pr0->extent.height;
 	if (dx_0 >= 0)
@@ -74,7 +77,7 @@ frame_intersect (INTERSECT_CONTROL *pCon
 	else
 		cycle0 = dy_0;
 	xerror0 = yerror0 = cycle0;
-			
+	
 	dx_1 = pr1->extent.width;
 	dy_1 = pr1->extent.height;
 	if (dx_1 >= 0)
@@ -96,7 +99,7 @@ frame_intersect (INTERSECT_CONTROL *pCon
 	else
 		cycle1 = dy_1;
 	xerror1 = yerror1 = cycle1;
-			
+	
 	check0 = check1 = FALSE;
 	if (t0 <= 1)
 	{
@@ -109,61 +112,61 @@ frame_intersect (INTERSECT_CONTROL *pCon
 	}
 	else
 	{
-		SIZE delta;
-		COUNT start;
+		SDWORD delta;
+		DWORD start;
 		long error;
-
-		start = (COUNT)cycle0 * (COUNT)(t0 - 1);
+		
+		start = (DWORD)cycle0 * (DWORD)(t0 - 1);
 		time_error0 = start & ((1 << TIME_SHIFT) - 1);
-		if ((start >>= (COUNT)TIME_SHIFT) > 0)
+		if ((start >>= (DWORD)TIME_SHIFT) > 0)
 		{
 			if ((error = (long)xerror0
-					- (long)dx_0 * (long)start) > 0)
-				xerror0 = (SIZE)error;
+				 - (long)dx_0 * (long)start) > 0)
+				xerror0 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle0) + 1;
+				delta = -(SDWORD)(error / (long)cycle0) + 1;
 				IB0.Box.corner.x += xincr0 * delta;
-				xerror0 = (SIZE)(error + (long)cycle0 * (long)delta);
+				xerror0 = (SDWORD)(error + (long)cycle0 * (long)delta);
 			}
 			if ((error = (long)yerror0
-					- (long)dy_0 * (long)start) > 0)
-				yerror0 = (SIZE)error;
+				 - (long)dy_0 * (long)start) > 0)
+				yerror0 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle0) + 1;
+				delta = -(SDWORD)(error / (long)cycle0) + 1;
 				IB0.Box.corner.y += yincr0 * delta;
-				yerror0 = (SIZE)(error + (long)cycle0 * (long)delta);
+				yerror0 = (SDWORD)(error + (long)cycle0 * (long)delta);
 			}
 			pr0->corner = IB0.Box.corner;
 		}
-	
-		start = (COUNT)cycle1 * (COUNT)(t0 - 1);
+		
+		start = (DWORD)cycle1 * (DWORD)(t0 - 1);
 		time_error1 = start & ((1 << TIME_SHIFT) - 1);
-		if ((start >>= (COUNT)TIME_SHIFT) > 0)
+		if ((start >>= (DWORD)TIME_SHIFT) > 0)
 		{
 			if ((error = (long)xerror1
-					- (long)dx_1 * (long)start) > 0)
-				xerror1 = (SIZE)error;
+				 - (long)dx_1 * (long)start) > 0)
+				xerror1 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle1) + 1;
+				delta = -(SDWORD)(error / (long)cycle1) + 1;
 				IB1.Box.corner.x += xincr1 * delta;
-				xerror1 = (SIZE)(error + (long)cycle1 * (long)delta);
+				xerror1 = (SDWORD)(error + (long)cycle1 * (long)delta);
 			}
 			if ((error = (long)yerror1
-					- (long)dy_1 * (long)start) > 0)
-				yerror1 = (SIZE)error;
+				 - (long)dy_1 * (long)start) > 0)
+				yerror1 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle1) + 1;
+				delta = -(SDWORD)(error / (long)cycle1) + 1;
 				IB1.Box.corner.y += yincr1 * delta;
-				yerror1 = (SIZE)(error + (long)cycle1 * (long)delta);
+				yerror1 = (SDWORD)(error + (long)cycle1 * (long)delta);
 			}
 			pr1->corner = IB1.Box.corner;
 		}
 	}
-
+	
 	pControl0->last_time_val = pControl1->last_time_val = t0;
 	do
 	{
@@ -180,11 +183,11 @@ frame_intersect (INTERSECT_CONTROL *pCon
 				IB0.Box.corner.y += yincr0;
 				yerror0 += cycle0;
 			}
-
+			
 			check0 = TRUE;
 			time_error0 -= (1 << TIME_SHIFT);
 		}
-			
+		
 		if ((time_error1 += cycle1) >= (1 << TIME_SHIFT))
 		{
 			if ((xerror1 -= dx_1) <= 0)
@@ -197,22 +200,22 @@ frame_intersect (INTERSECT_CONTROL *pCon
 				IB1.Box.corner.y += yincr1;
 				yerror1 += cycle1;
 			}
-
+			
 			check1 = TRUE;
 			time_error1 -= (1 << TIME_SHIFT);
 		}
-
+		
 		if (check0 || check1)
 		{ /* if check0 && check1, this may not be quite right --
-						 * if shapes had a pixel's separation to begin with
-						 * and both moved toward each other, you would actually
-						 * get a pixel overlap but since the last positions were
-						 * separated by a pixel, the shapes wouldn't be touching
-						 * each other.
-						 */
-CheckFirstIntersection:
+		   * if shapes had a pixel's separation to begin with
+		   * and both moved toward each other, you would actually
+		   * get a pixel overlap but since the last positions were
+		   * separated by a pixel, the shapes wouldn't be touching
+		   * each other.
+		   */
+		CheckFirstIntersection:
 			if (BoxIntersect (&IB0.Box, &IB1.Box, &r_intersect)
-					&& images_intersect (&IB0, &IB1, &r_intersect))
+				&& images_intersect (&IB0, &IB1, &r_intersect))
 				return (t0);
 			
 			if (check0)
@@ -229,76 +232,78 @@ CheckFirstIntersection:
 			}
 		}
 	} while (t0 <= t1);
-
+	
 	return ((TIME_VALUE)0);
 }
 
+// JMS: Changed SIZEs to SDWORDs to preven overflows.
 TIME_VALUE
-DrawablesIntersect (INTERSECT_CONTROL *pControl0,
-		INTERSECT_CONTROL *pControl1, TIME_VALUE max_time_val)
+DrawablesIntersect (INTERSECT_CONTROL *pControl0, INTERSECT_CONTROL *pControl1, TIME_VALUE max_time_val)
 {
-	SIZE dy;
-	SIZE time_y_0, time_y_1;
+	SDWORD dy;
+	SDWORD time_y_0, time_y_1;
 	RECT r0, r1;
 	FRAME FramePtr0, FramePtr1;
-
+	
 	if (!ContextActive () || max_time_val == 0)
 		return ((TIME_VALUE)0);
 	else if (max_time_val > MAX_TIME_VALUE)
 		max_time_val = MAX_TIME_VALUE;
-
+	
 	pControl0->last_time_val = pControl1->last_time_val = 0;
-
+	
 	r0.corner = pControl0->IntersectStamp.origin;
 	r1.corner = pControl1->IntersectStamp.origin;
-
+	
 	r0.extent.width = pControl0->EndPoint.x - r0.corner.x;
 	r0.extent.height = pControl0->EndPoint.y - r0.corner.y;
 	r1.extent.width = pControl1->EndPoint.x - r1.corner.x;
 	r1.extent.height = pControl1->EndPoint.y - r1.corner.y;
-		
+	
 	FramePtr0 = pControl0->IntersectStamp.frame;
 	if (FramePtr0 == 0)
 		return(0);
 	r0.corner.x -= FramePtr0->HotSpot.x;
 	r0.corner.y -= FramePtr0->HotSpot.y;
-
+	
 	FramePtr1 = pControl1->IntersectStamp.frame;
 	if (FramePtr1 == 0)
 		return(0);
 	r1.corner.x -= FramePtr1->HotSpot.x;
 	r1.corner.y -= FramePtr1->HotSpot.y;
-
+	
+	//log_add (log_Debug, "r0 x:%d y:%d w:%d h:%d r1 x:%d y:%d w:%d h:%d", r0.corner.x, r0.corner.y,GetFrameWidth (FramePtr0), GetFrameHeight (FramePtr0), r1.corner.x, r1.corner.y, GetFrameWidth(FramePtr1), GetFrameHeight (FramePtr1));
+	
 	dy = r1.corner.y - r0.corner.y;
 	time_y_0 = dy - GetFrameHeight (FramePtr0) + 1;
 	time_y_1 = dy + GetFrameHeight (FramePtr1) - 1;
 	dy = r0.extent.height - r1.extent.height;
-
+	
 	if ((time_y_0 <= 0 && time_y_1 >= 0)
-			|| (time_y_0 > 0 && dy >= time_y_0)
-			|| (time_y_1 < 0 && dy <= time_y_1))
+		|| (time_y_0 > 0 && dy >= time_y_0)
+		|| (time_y_1 < 0 && dy <= time_y_1))
 	{
-		SIZE dx;
-		SIZE time_x_0, time_x_1;
-
+		SDWORD dx;
+		SDWORD time_x_0, time_x_1;
+		
 		dx = r1.corner.x - r0.corner.x;
 		time_x_0 = dx - GetFrameWidth (FramePtr0) + 1;
 		time_x_1 = dx + GetFrameWidth (FramePtr1) - 1;
 		dx = r0.extent.width - r1.extent.width;
-
+		
 		if ((time_x_0 <= 0 && time_x_1 >= 0)
-				|| (time_x_0 > 0 && dx >= time_x_0)
-				|| (time_x_1 < 0 && dx <= time_x_1))
+			|| (time_x_0 > 0 && dx >= time_x_0)
+			|| (time_x_1 < 0 && dx <= time_x_1))
 		{
 			TIME_VALUE intersect_time;
-
+			
 			if (dx == 0 && dy == 0)
 				time_y_0 = time_y_1 = 0;
 			else
 			{
-				SIZE t;
+				SDWORD t;
 				long time_beg, time_end, fract;
-
+				
 				if (time_y_1 < 0)
 				{
 					t = time_y_0;
@@ -315,10 +320,10 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 					dy = -dy;
 				if (dy < time_y_1)
 					time_y_1 = dy;
-					/* just to be safe, widen search area */
+				/* just to be safe, widen search area */
 				--time_y_0;
 				++time_y_1;
-
+				
 				if (time_x_1 < 0)
 				{
 					t = time_x_0;
@@ -335,19 +340,19 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 					dx = -dx;
 				if (dx < time_x_1)
 					time_x_1 = dx;
-					/* just to be safe, widen search area */
+				/* just to be safe, widen search area */
 				--time_x_0;
 				++time_x_1;
-
+				
 #ifdef DEBUG_INTERSEC
 				log_add (log_Debug, "FramePtr0<%d, %d> --> <%d, %d>",
-						GetFrameWidth (FramePtr0), GetFrameHeight (FramePtr0),
-						r0.corner.x, r0.corner.y);
+						 GetFrameWidth (FramePtr0), GetFrameHeight (FramePtr0),
+						 r0.corner.x, r0.corner.y);
 				log_add (log_Debug, "FramePtr1<%d, %d> --> <%d, %d>",
-						GetFrameWidth (FramePtr1), GetFrameHeight (FramePtr1),
-						r1.corner.x, r1.corner.y);
+						 GetFrameWidth (FramePtr1), GetFrameHeight (FramePtr1),
+						 r1.corner.x, r1.corner.y);
 				log_add (log_Debug, "time_x(%d, %d)-%d, time_y(%d, %d)-%d",
-						time_x_0, time_x_1, dx, time_y_0, time_y_1, dy);
+						 time_x_0, time_x_1, dx, time_y_0, time_y_1, dy);
 #endif /* DEBUG_INTERSEC */
 				if (dx == 0)
 				{
@@ -364,39 +369,39 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 				else
 				{
 					long time_x, time_y;
-
+					
 					time_x = (long)time_x_0 * (long)dy;
 					time_y = (long)time_y_0 * (long)dx;
 					time_beg = time_x < time_y ? time_y : time_x;
-
+					
 					time_x = (long)time_x_1 * (long)dy;
 					time_y = (long)time_y_1 * (long)dx;
 					time_end = time_x > time_y ? time_y : time_x;
-
+					
 					fract = (long)dx * (long)dy;
 				}
-
+				
 				if ((time_beg <<= TIME_SHIFT) < fract)
 					time_y_0 = 0;
 				else
-					time_y_0 = (SIZE)(time_beg / fract);
-
+					time_y_0 = (SDWORD)(time_beg / fract);
+				
 				if (time_end >= fract /* just in case of overflow */
-						|| (time_end <<= TIME_SHIFT) >=
-						fract * (long)max_time_val)
+					|| (time_end <<= TIME_SHIFT) >=
+					fract * (long)max_time_val)
 					time_y_1 = max_time_val - 1;
 				else
-					time_y_1 = (SIZE)((time_end + fract - 1) / fract) - 1;
+					time_y_1 = (SDWORD)((time_end + fract - 1) / fract) - 1;
 			}
-
+			
 #ifdef DEBUG_INTERSEC
 			log_add (log_Debug, "start_time = %d, end_time = %d",
-					time_y_0, time_y_1);
+					 time_y_0, time_y_1);
 #endif /* DEBUG_INTERSEC */
 			if (time_y_0 <= time_y_1
-					&& (intersect_time = frame_intersect (
-					pControl0, &r0, pControl1, &r1,
-					(TIME_VALUE)time_y_0, (TIME_VALUE)time_y_1)))
+				&& (intersect_time = frame_intersect (
+													  pControl0, &r0, pControl1, &r1,
+													  (TIME_VALUE)time_y_0, (TIME_VALUE)time_y_1)))
 			{
 				FramePtr0 = pControl0->IntersectStamp.frame;
 				pControl0->EndPoint.x = r0.corner.x + FramePtr0->HotSpot.x;
@@ -404,12 +409,16 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 				FramePtr1 = pControl1->IntersectStamp.frame;
 				pControl1->EndPoint.x = r1.corner.x + FramePtr1->HotSpot.x;
 				pControl1->EndPoint.y = r1.corner.y + FramePtr1->HotSpot.y;
-
+				
+#ifdef DEBUG_INTERSEC
+				log_add (log_Debug, "intersecttime = %d",
+						 intersect_time);
+#endif /* DEBUG_INTERSEC */
+				
 				return (intersect_time);
 			}
 		}
 	}
-
 	return ((TIME_VALUE)0);
 }
 
diff -ruNp ./src.orig/libs/graphics/sdl/canvas.c ./src/libs/graphics/sdl/canvas.c
--- ./src.orig/libs/graphics/sdl/canvas.c	2017-10-23 11:42:13 -0700
+++ ./src/libs/graphics/sdl/canvas.c	2017-10-23 11:41:32 -0700
@@ -2119,7 +2119,7 @@ TFB_DrawCanvas_TransferIndexes (TFB_Canv
 	if (!TFB_DrawCanvas_IsPaletted (canvas) || fmt->BitsPerPixel != 8)
 	{
 		log_add (log_Warning, "ERROR: TFB_DrawCanvas_TransferIndexes "
-				"unimplemeted function: not an 8bpp indexed canvas");
+			 "unimplemeted function: %d not an 8bpp indexed canvas", fmt->BitsPerPixel);
 		return FALSE;
 	}
 
diff -ruNp ./src.orig/libs/graphics/sdl/opengl.c ./src/libs/graphics/sdl/opengl.c
--- ./src.orig/libs/graphics/sdl/opengl.c	2017-10-23 11:42:13 -0700
+++ ./src/libs/graphics/sdl/opengl.c	2017-10-23 11:41:32 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifdef HAVE_OPENGL
 
 #include "libs/graphics/sdl/opengl.h"
@@ -54,6 +56,8 @@ static void TFB_GL_Preprocess (int force
 static void TFB_GL_Postprocess (void);
 static void TFB_GL_Scaled_ScreenLayer (SCREEN screen, Uint8 a, SDL_Rect *rect);
 static void TFB_GL_Unscaled_ScreenLayer (SCREEN screen, Uint8 a, SDL_Rect *rect);
+static void TFB_GL_Unscaled_ScreenLayer_2x (SCREEN screen, Uint8 a, SDL_Rect *rect);
+static void TFB_GL_Unscaled_ScreenLayer_4x (SCREEN screen, Uint8 a, SDL_Rect *rect);
 static void TFB_GL_ColorLayer (Uint8 r, Uint8 g, Uint8 b, Uint8 a, SDL_Rect *rect);
 
 static TFB_GRAPHICS_BACKEND opengl_scaled_backend = {
@@ -68,6 +72,18 @@ static TFB_GRAPHICS_BACKEND opengl_unsca
 	TFB_GL_Unscaled_ScreenLayer,
 	TFB_GL_ColorLayer };
 
+static TFB_GRAPHICS_BACKEND opengl_unscaled_backend_2x = {
+	TFB_GL_Preprocess,
+	TFB_GL_Postprocess,
+	TFB_GL_Unscaled_ScreenLayer_2x,
+	TFB_GL_ColorLayer };
+
+static TFB_GRAPHICS_BACKEND opengl_unscaled_backend_4x = {
+	TFB_GL_Preprocess,
+	TFB_GL_Postprocess,
+	TFB_GL_Unscaled_ScreenLayer_4x,
+	TFB_GL_ColorLayer };
+
 
 static SDL_Surface *
 Create_Screen (SDL_Surface *template, int w, int h)
@@ -94,13 +110,11 @@ ReInit_Screen (SDL_Surface **screen, SDL
 }
 
 static int
-AttemptColorDepth (int flags, int width, int height, int bpp)
+AttemptColorDepth (int flags, int width, int height, int bpp, unsigned int resolutionFactor, BOOLEAN forceAspectRatio)  // JMS_GFX: Added resolutionFactor
 {
 	int videomode_flags;
 	ScreenColorDepth = bpp;
-	ScreenWidthActual = width;
-	ScreenHeightActual = height;
-
+	
 	switch (bpp) {
 		case 15:
 			SDL_GL_SetAttribute (SDL_GL_RED_SIZE, 5);
@@ -137,38 +151,66 @@ AttemptColorDepth (int flags, int width,
 		videomode_flags |= SDL_FULLSCREEN;
 	videomode_flags |= SDL_ANYFORMAT;
 
-	SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, 
-		bpp, videomode_flags);
+	if (resolutionFactor > 0 && flags & TFB_GFXFLAGS_FULLSCREEN)
+	{
+		height = fs_height;
+		width  = fs_width;
+			
+		log_add (log_Debug,"X:%d y:%d", width, height);
+	}
+	
+	ScreenWidthActual = width;
+	ScreenHeightActual = height;
+
+	SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, bpp, videomode_flags);
+	
 	if (SDL_Video == NULL)
 	{
 		log_add (log_Error, "Couldn't set OpenGL %ix%ix%i video mode: %s",
 				ScreenWidthActual, ScreenHeightActual, bpp,
 				SDL_GetError ());
+		
+		if (flags & TFB_GFXFLAGS_FULLSCREEN)
+		{
+			videomode_flags &= ~SDL_FULLSCREEN;
+			log_add (log_Error, "Falling back to windowed mode!!");
+			SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, bpp, videomode_flags);
+			
+			if (SDL_Video != NULL)
+				goto successful_change;
+		}
+		
 		return -1;
 	}
 	else
 	{
+	successful_change:
 		log_add (log_Info, "Set the resolution to: %ix%ix%i"
-				" (surface reports %ix%ix%i)",
+				" (surface reports %ix%ix%i) (res_cat %u)",
 				width, height, bpp,			 
 				SDL_GetVideoSurface()->w, SDL_GetVideoSurface()->h,
-				SDL_GetVideoSurface()->format->BitsPerPixel);
+				SDL_GetVideoSurface()->format->BitsPerPixel, resolutionFactor);
 
 		log_add (log_Info, "OpenGL renderer: %s version: %s",
 				glGetString (GL_RENDERER), glGetString (GL_VERSION));
+		
+		// JMS: Now, this makes the game center horizontally
+		// between the black bars on the sides.
+		ScreenWidthActual = SDL_GetVideoSurface()->w;
+		
 	}
 	return 0;
 }
 
 int
-TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen)
+TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor, BOOLEAN forceAspectRatio)  // JMS_GFX: Added resolutionFactor
 {
 	int i, texture_width, texture_height;
 	GraphicsDriver = driver;
 
-	if (AttemptColorDepth (flags, width, height, 32) &&
-			AttemptColorDepth (flags, width, height, 24) &&
-			AttemptColorDepth (flags, width, height, 16))
+	if (AttemptColorDepth (flags, width, height, 32, resolutionFactor, forceAspectRatio) &&
+			AttemptColorDepth (flags, width, height, 24, resolutionFactor, forceAspectRatio) &&
+			AttemptColorDepth (flags, width, height, 16, resolutionFactor, forceAspectRatio))
 	{
 		log_add (log_Error, "Couldn't set any OpenGL %ix%i video mode!",
 			 width, height);
@@ -233,11 +275,26 @@ TFB_GL_ConfigureVideo (int driver, int f
 	}
 	else
 	{
-		texture_width = 512;
-		texture_height = 256;
+		if (resolutionFactor == 0)
+		{
+			texture_width = 512;
+			texture_height = 256;
+			graphics_backend = &opengl_unscaled_backend;
+		}
+		else if (resolutionFactor == 1)
+		{
+			texture_width = 1024;
+			texture_height = 512;
+			graphics_backend = &opengl_unscaled_backend_2x;
+		}
+		else if (resolutionFactor == 2)
+		{
+			texture_width = 2048;
+			texture_height = 1024;
+			graphics_backend = &opengl_unscaled_backend_4x;
+		}
 
 		scaler = NULL;
-		graphics_backend = &opengl_unscaled_backend;
 	}
 
 
@@ -245,7 +302,7 @@ TFB_GL_ConfigureVideo (int driver, int f
 		ScreenFilterMode = GL_LINEAR;
 	else
 		ScreenFilterMode = GL_NEAREST;
-
+	
 	glViewport (0, 0, ScreenWidthActual, ScreenHeightActual);
 	glClearColor (0,0,0,0);
 	glClear (GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
@@ -263,15 +320,15 @@ TFB_GL_ConfigureVideo (int driver, int f
 		glPixelStorei (GL_UNPACK_ALIGNMENT, 1);
 		glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 		glTexParameterf (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-		glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, texture_width, texture_height,
-				0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
+		glTexImage2D (GL_TEXTURE_2D, 0, GL_RGB, texture_width,
+			texture_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
 	}
 
 	return 0;
 }
 
 int
-TFB_GL_InitGraphics (int driver, int flags, int width, int height)
+TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor, BOOLEAN forceAspectRatio)  // JMS_GFX: Added resolutionFactor
 {
 	char VideoName[256];
 
@@ -282,10 +339,10 @@ TFB_GL_InitGraphics (int driver, int fla
 	log_add (log_Info, "SDL initialized.");
 	log_add (log_Info, "Initializing Screen.");
 
-	ScreenWidth = 320;
-	ScreenHeight = 240;
+	ScreenWidth =  (320 << resolutionFactor); // JMS_GFX
+	ScreenHeight = (240 << resolutionFactor); // JMS_GFX
 
-	if (TFB_GL_ConfigureVideo (driver, flags, width, height, 0))
+	if (TFB_GL_ConfigureVideo (driver, flags, width, height, 0, resolutionFactor, forceAspectRatio)) 
 	{
 		log_add (log_Fatal, "Could not initialize video: "
 				"no fallback at start of program!");
@@ -419,6 +476,172 @@ TFB_GL_DrawQuad (SDL_Rect *r)
 }
 
 static void
+TFB_GL_DrawQuad_2x (SDL_Rect *r)
+{
+	BOOLEAN keep_aspect_ratio = optKeepAspectRatio;
+	int x1 = 0, y1 = 0, x2 = ScreenWidthActual, y2 = ScreenHeightActual;
+	int sx = 0, sy = 0;
+	int sw, sh;
+	float sx_multiplier = 1;
+	float sy_multiplier = 1;
+	
+	if (keep_aspect_ratio)
+	{
+		float threshold = 0.75f;
+		float ratio = ScreenHeightActual / (float)ScreenWidthActual;
+		
+		if (ratio > threshold)
+		{
+			// screen is narrower than 4:3
+			int height = (int)(ScreenWidthActual * threshold);
+			y1 = (ScreenHeightActual - height) / 2;
+			y2 = ScreenHeightActual - y1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+				sy_multiplier = height / (float)ScreenHeight;
+				sx = (int)(r->x * sx_multiplier);
+				sy = (int)(((ScreenHeight - (r->y + r->h)) * sy_multiplier) + y1);
+			}
+		}
+		else if (ratio < threshold)
+		{
+			// screen is wider than 4:3
+			int width = (int)(ScreenHeightActual / threshold);
+			x1 = (ScreenWidthActual - width) / 2;
+			x2 = ScreenWidthActual - x1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = width / (float)ScreenWidth;
+				sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+				sx = (int)((r->x * sx_multiplier) + x1);
+				sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+			}
+		}
+		else
+		{
+			// screen is 4:3
+			keep_aspect_ratio = 0;
+		}
+	}
+	
+	if (r != NULL)
+	{
+		if (!keep_aspect_ratio)
+		{
+			sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+			sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+			sx = (int)(r->x * sx_multiplier);
+			sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+		}
+		sw = (int)(r->w * sx_multiplier);
+		sh = (int)(r->h * sy_multiplier);
+		glScissor (sx, sy, sw, sh);
+		glEnable (GL_SCISSOR_TEST);
+	}
+	
+	glBegin (GL_TRIANGLE_FAN);
+	glTexCoord2f (0, 0);
+	glVertex2i (x1, y1);
+	glTexCoord2f (ScreenWidth / 1024.0f, 0);
+	glVertex2i (x2, y1);	
+	glTexCoord2f (ScreenWidth / 1024.0f, ScreenHeight / 512.0f);
+	glVertex2i (x2, y2);
+	glTexCoord2f (0, ScreenHeight / 512.0f);
+	glVertex2i (x1, y2);
+	glEnd ();
+	if (r != NULL)
+	{
+		glDisable (GL_SCISSOR_TEST);
+	}
+}
+
+static void
+TFB_GL_DrawQuad_4x (SDL_Rect *r)
+{
+	BOOLEAN keep_aspect_ratio = optKeepAspectRatio;
+	int x1 = 0, y1 = 0, x2 = ScreenWidthActual, y2 = ScreenHeightActual;
+	int sx = 0, sy = 0;
+	int sw, sh;
+	float sx_multiplier = 1;
+	float sy_multiplier = 1;
+	
+	if (keep_aspect_ratio)
+	{
+		float threshold = 0.75f;
+		float ratio = ScreenHeightActual / (float)ScreenWidthActual;
+		
+		if (ratio > threshold)
+		{
+			// screen is narrower than 4:3
+			int height = (int)(ScreenWidthActual * threshold);
+			y1 = (ScreenHeightActual - height) / 2;
+			y2 = ScreenHeightActual - y1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+				sy_multiplier = height / (float)ScreenHeight;
+				sx = (int)(r->x * sx_multiplier);
+				sy = (int)(((ScreenHeight - (r->y + r->h)) * sy_multiplier) + y1);
+			}
+		}
+		else if (ratio < threshold)
+		{
+			// screen is wider than 4:3
+			int width = (int)(ScreenHeightActual / threshold);
+			x1 = (ScreenWidthActual - width) / 2;
+			x2 = ScreenWidthActual - x1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = width / (float)ScreenWidth;
+				sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+				sx = (int)((r->x * sx_multiplier) + x1);
+				sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+			}
+		}
+		else
+		{
+			// screen is 4:3
+			keep_aspect_ratio = 0;
+		}
+	}
+	
+	if (r != NULL)
+	{
+		if (!keep_aspect_ratio)
+		{
+			sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+			sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+			sx = (int)(r->x * sx_multiplier);
+			sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+		}
+		sw = (int)(r->w * sx_multiplier);
+		sh = (int)(r->h * sy_multiplier);
+		glScissor (sx, sy, sw, sh);
+		glEnable (GL_SCISSOR_TEST);
+	}
+	
+	glBegin (GL_TRIANGLE_FAN);
+	glTexCoord2f (0, 0);
+	glVertex2i (x1, y1);
+	glTexCoord2f (ScreenWidth / 2048.0f, 0);
+	glVertex2i (x2, y1);	
+	glTexCoord2f (ScreenWidth / 2048.0f, ScreenHeight / 1024.0f);
+	glVertex2i (x2, y2);
+	glTexCoord2f (0, ScreenHeight / 1024.0f);
+	glVertex2i (x1, y2);
+	glEnd ();
+	if (r != NULL)
+	{
+		glDisable (GL_SCISSOR_TEST);
+	}
+}
+
+static void
 TFB_GL_Preprocess (int force_full_redraw, int transition_amount, int fade_amount)
 {
 	glMatrixMode (GL_PROJECTION);
@@ -498,6 +721,100 @@ TFB_GL_Unscaled_ScreenLayer (SCREEN scre
 }
 
 static void
+TFB_GL_Unscaled_ScreenLayer_2x (SCREEN screen, Uint8 a, SDL_Rect *rect)
+{
+	glBindTexture (GL_TEXTURE_2D, GL_Screens[screen].texture);
+	glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+	
+	if (GL_Screens[screen].dirty)
+	{
+		int PitchWords = SDL_Screens[screen]->pitch / 4;
+		glPixelStorei (GL_UNPACK_ROW_LENGTH, PitchWords);
+		/* Matrox OpenGL drivers do not handle GL_UNPACK_SKIP_*
+		 correctly */
+		glPixelStorei (GL_UNPACK_SKIP_ROWS, 0);
+		glPixelStorei (GL_UNPACK_SKIP_PIXELS, 0);
+		SDL_LockSurface (SDL_Screens[screen]);
+		glTexSubImage2D (GL_TEXTURE_2D, 0, GL_Screens[screen].updated.x, 
+						 GL_Screens[screen].updated.y,
+						 GL_Screens[screen].updated.w, 
+						 GL_Screens[screen].updated.h,
+						 GL_RGBA, GL_UNSIGNED_BYTE,
+						 (Uint32 *)SDL_Screens[screen]->pixels +
+						 (GL_Screens[screen].updated.y * PitchWords + 
+						  GL_Screens[screen].updated.x));
+		SDL_UnlockSurface (SDL_Screens[screen]);
+		GL_Screens[screen].dirty = FALSE;
+	}
+	
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, ScreenFilterMode);
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, ScreenFilterMode);
+	glEnable (GL_TEXTURE_2D);
+	
+	if (a == 255)
+	{
+		glDisable (GL_BLEND);
+		glColor4f (1, 1, 1, 1);
+	}
+	else
+	{
+		float a_f = a / 255.0f;
+		glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+		glEnable (GL_BLEND);
+		glColor4f (1, 1, 1, a_f);
+	}
+	
+	TFB_GL_DrawQuad_2x (rect);
+}
+
+static void
+TFB_GL_Unscaled_ScreenLayer_4x (SCREEN screen, Uint8 a, SDL_Rect *rect)
+{
+	glBindTexture (GL_TEXTURE_2D, GL_Screens[screen].texture);
+	glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+	
+	if (GL_Screens[screen].dirty)
+	{
+		int PitchWords = SDL_Screens[screen]->pitch / 4;
+		glPixelStorei (GL_UNPACK_ROW_LENGTH, PitchWords);
+		/* Matrox OpenGL drivers do not handle GL_UNPACK_SKIP_*
+		 correctly */
+		glPixelStorei (GL_UNPACK_SKIP_ROWS, 0);
+		glPixelStorei (GL_UNPACK_SKIP_PIXELS, 0);
+		SDL_LockSurface (SDL_Screens[screen]);
+		glTexSubImage2D (GL_TEXTURE_2D, 0, GL_Screens[screen].updated.x, 
+						 GL_Screens[screen].updated.y,
+						 GL_Screens[screen].updated.w, 
+						 GL_Screens[screen].updated.h,
+						 GL_RGBA, GL_UNSIGNED_BYTE,
+						 (Uint32 *)SDL_Screens[screen]->pixels +
+						 (GL_Screens[screen].updated.y * PitchWords + 
+						  GL_Screens[screen].updated.x));
+		SDL_UnlockSurface (SDL_Screens[screen]);
+		GL_Screens[screen].dirty = FALSE;
+	}
+	
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, ScreenFilterMode);
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, ScreenFilterMode);
+	glEnable (GL_TEXTURE_2D);
+	
+	if (a == 255)
+	{
+		glDisable (GL_BLEND);
+		glColor4f (1, 1, 1, 1);
+	}
+	else
+	{
+		float a_f = a / 255.0f;
+		glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+		glEnable (GL_BLEND);
+		glColor4f (1, 1, 1, a_f);
+	}
+	
+	TFB_GL_DrawQuad_4x (rect);
+}
+
+static void
 TFB_GL_Scaled_ScreenLayer (SCREEN screen, Uint8 a, SDL_Rect *rect)
 {
 	glBindTexture (GL_TEXTURE_2D, GL_Screens[screen].texture);
diff -ruNp ./src.orig/libs/graphics/sdl/opengl.h ./src/libs/graphics/sdl/opengl.h
--- ./src.orig/libs/graphics/sdl/opengl.h	2017-10-23 11:42:13 -0700
+++ ./src/libs/graphics/sdl/opengl.h	2017-10-23 11:41:32 -0700
@@ -21,8 +21,8 @@
 
 #include "libs/graphics/sdl/sdl_common.h"
 
-int TFB_GL_InitGraphics (int driver, int flags, int width, int height);
-int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
+int TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor, BOOLEAN	forceAspectRatio);  // JMS_GFX: Added resolutionFactor
+int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor, BOOLEAN forceAspectRatio);  // JMS_GFX: Added resolutionFactor
 void TFB_GL_UploadTransitionScreen (void);
 
 #ifdef HAVE_OPENGL
diff -ruNp ./src.orig/libs/graphics/sdl/pure.c ./src/libs/graphics/sdl/pure.c
--- ./src.orig/libs/graphics/sdl/pure.c	2017-10-23 11:42:14 -0700
+++ ./src/libs/graphics/sdl/pure.c	2017-10-23 11:41:32 -0700
@@ -124,7 +124,7 @@ CalcAlphaFormat (const SDL_PixelFormat*
 }
 
 int
-TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen)
+TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor)  // JMS_GFX: Added resolutionFactor
 {
 	int i, videomode_flags;
 	SDL_PixelFormat conv_fmt;
@@ -143,19 +143,36 @@ TFB_Pure_ConfigureVideo (int driver, int
 	else
 	{
 		videomode_flags = SDL_SWSURFACE;
-		ScreenWidthActual = 640;
-		ScreenHeightActual = 480;
-		graphics_backend = &pure_scaled_backend;
-
-		if (width != 640 || height != 480)
-			log_add (log_Error, "Screen resolution of %dx%d not supported "
-					"under pure SDL, using 640x480", width, height);
+		
+		// JMS_GFX: Resolution is calculated with the help of a Resolution factor.
+		if (resolutionFactor == 0)
+		{
+			// Check the sanity of resolution.
+			if (width != 640 || height != 480)
+			{
+				log_add (log_Error, "Screen resolution of %dx%d not supported "
+						 "under pure SDL, using 640x480", width, height);
+			
+				width = 640;
+				height = 480;
+			}
+			
+			ScreenWidthActual  = width;
+			ScreenHeightActual = height;
+			graphics_backend = &pure_scaled_backend;
+		}
+		else
+		{
+			ScreenWidthActual  = (320 << resolutionFactor);
+			ScreenHeightActual = (240 << resolutionFactor);
+			graphics_backend = &pure_unscaled_backend;
+		}
 	}
 
 	videomode_flags |= SDL_ANYFORMAT;
 	if (flags & TFB_GFXFLAGS_FULLSCREEN)
 		videomode_flags |= SDL_FULLSCREEN;
-
+	
 	/* We'll ask for a 32bpp frame, but it doesn't really matter, because we've set
 	   SDL_ANYFORMAT */
 	SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, 
@@ -255,7 +272,7 @@ TFB_Pure_ConfigureVideo (int driver, int
 }
 
 int
-TFB_Pure_InitGraphics (int driver, int flags, int width, int height)
+TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor)  // JMS_GFX: Added resolutionFactor
 {
 	char VideoName[256];
 
@@ -271,10 +288,11 @@ TFB_Pure_InitGraphics (int driver, int f
 	log_add (log_Info, "SDL initialized.");
 	log_add (log_Info, "Initializing Screen.");
 
-	ScreenWidth = 320;
-	ScreenHeight = 240;
+	// JMS_GFX: Resolution is calculated with the help of a Resolution factor.
+	ScreenWidth  = (320 << resolutionFactor); //320
+	ScreenHeight = (240 << resolutionFactor); //240
 
-	if (TFB_Pure_ConfigureVideo (driver, flags, width, height, 0))
+	if (TFB_Pure_ConfigureVideo (driver, flags, width, height, 0, resolutionFactor)) // JMS_GFX: Added resolutionFactor
 	{
 		log_add (log_Fatal, "Could not initialize video: "
 				"no fallback at start of program!");
diff -ruNp ./src.orig/libs/graphics/sdl/pure.h ./src/libs/graphics/sdl/pure.h
--- ./src.orig/libs/graphics/sdl/pure.h	2017-10-23 11:42:14 -0700
+++ ./src/libs/graphics/sdl/pure.h	2017-10-23 11:41:32 -0700
@@ -21,8 +21,8 @@
 
 #include "libs/graphics/sdl/sdl_common.h"
 
-int TFB_Pure_InitGraphics (int driver, int flags, int width, int height);
-int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
+int TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor);  // JMS_GFX: Added resolutionFactor
+int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resolutionFactor); // JMS_GFX: Added resolutionFactor
 void Scale_PerfTest (void);
 
 #endif
diff -ruNp ./src.orig/libs/graphics/sdl/sdl_common.c ./src/libs/graphics/sdl/sdl_common.c
--- ./src.orig/libs/graphics/sdl/sdl_common.c	2017-10-23 11:42:14 -0700
+++ ./src/libs/graphics/sdl/sdl_common.c	2017-10-23 11:41:32 -0700
@@ -43,6 +43,8 @@ SDL_Surface *SDL_Screens[TFB_GFX_NUMSCRE
 
 SDL_Surface *format_conv_surf = NULL;
 
+const SDL_VideoInfo *SDL_screen_info; // JMS_GFX
+
 static volatile BOOLEAN abortFlag = FALSE;
 
 int GfxFlags = 0;
@@ -79,7 +81,7 @@ TFB_PreInit (void)
 }
 
 int
-TFB_ReInitGraphics (int driver, int flags, int width, int height)
+TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor, BOOLEAN forceAspectRatio) // JMS_GFX: Added resolutionFactor
 {
 	int result;
 	int togglefullscreen = 0;
@@ -98,19 +100,19 @@ TFB_ReInitGraphics (int driver, int flag
 	{
 #ifdef HAVE_OPENGL
 		result = TFB_GL_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+				togglefullscreen, resolutionFactor, forceAspectRatio); // JMS_GFX: Added resolutionFactor
 #else
 		driver = TFB_GFXDRIVER_SDL_PURE;
 		log_add (log_Warning, "OpenGL support not compiled in,"
 				" so using pure SDL driver");
 		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+				togglefullscreen, resolutionFactor); // JMS_GFX: Added resolutionFactor
 #endif
 	}
 	else
 	{
 		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+				togglefullscreen, resolutionFactor); // JMS_GFX: Added resolutionFactor
 	}
 
 	sprintf (caption, "The Ur-Quan Masters v%d.%d.%d%s",
@@ -127,7 +129,7 @@ TFB_ReInitGraphics (int driver, int flag
 }
 
 int
-TFB_InitGraphics (int driver, int flags, int width, int height)
+TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int resolutionFactor, BOOLEAN forceAspectRatio) // JMS_GFX: added resolutionFactor
 {
 	int result, i;
 	char caption[200];
@@ -139,21 +141,48 @@ TFB_InitGraphics (int driver, int flags,
 	}
 
 	GfxFlags = flags;
+	
+	// JMS_GFX: Let's read the size of the desktop so we can scale the
+	// fullscreen game according to it.
+	SDL_screen_info = SDL_GetVideoInfo ();
+	
+	// JMS_GFX: Upon starting the game, let's find out the resolution
+	// of the desktop.
+	if (fs_height == 0)
+	{
+		int curr_h = SDL_screen_info->current_h;
+		int curr_w = SDL_screen_info->current_w;
+		
+		// JMS_GFX: This makes it sure on certain HD 16:9 monitors
+		// that a bogus stretched 1600x1200 mode isn't used.
+		if (curr_w == 1920 && curr_h == 1080)
+		{
+			fs_height = curr_h;
+			fs_width  = curr_w;
+		}
+		else
+		{
+			fs_height = curr_h;
+			fs_width  = 4 * fs_height / 3;
+		}
+		
+		log_add (log_Debug, "fs_height %u, fs_width %u, current_w %u", fs_height, fs_width, SDL_screen_info->current_w);
+	}
 
 	if (driver == TFB_GFXDRIVER_SDL_OPENGL)
 	{
 #ifdef HAVE_OPENGL
-		result = TFB_GL_InitGraphics (driver, flags, width, height);
+		result = TFB_GL_InitGraphics (driver, flags, width, height, resolutionFactor, forceAspectRatio); // JMS_GFX: added resolutionFactor
 #else
 		driver = TFB_GFXDRIVER_SDL_PURE;
 		log_add (log_Warning, "OpenGL support not compiled in,"
 				" so using pure SDL driver");
-		result = TFB_Pure_InitGraphics (driver, flags, width, height);
+		result = TFB_Pure_InitGraphics (driver, flags, width, height, resolutionFactor); // JMS_GFX: added resolutionFactor
 #endif
 	}
 	else
 	{
-		result = TFB_Pure_InitGraphics (driver, flags, width, height);
+		result = TFB_Pure_InitGraphics (driver, flags, width, height, resolutionFactor);  // JMS_GFX: added resolutionFactor
 	}
 
 	sprintf (caption, "The Ur-Quan Masters v%d.%d.%d%s", 
@@ -267,6 +296,7 @@ TFB_SwapBuffers (int force_full_redraw)
 	if (transition_amount != 255)
 	{
 		SDL_Rect r;
+		
 		r.x = TransitionClipRect.corner.x;
 		r.y = TransitionClipRect.corner.y;
 		r.w = TransitionClipRect.extent.width;
diff -ruNp ./src.orig/libs/graphics/sdl/sdl_common.h ./src/libs/graphics/sdl/sdl_common.h
--- ./src.orig/libs/graphics/sdl/sdl_common.h	2017-10-23 11:42:14 -0700
+++ ./src/libs/graphics/sdl/sdl_common.h	2017-10-23 11:41:32 -0700
@@ -46,6 +46,8 @@ extern SDL_Surface *SDL_Screens[TFB_GFX_
 
 extern SDL_Surface *format_conv_surf;
 
+extern const SDL_VideoInfo *SDL_screen_info; // JMS_GFX
+
 SDL_Surface* TFB_DisplayFormatAlpha (SDL_Surface *surface);
 
 #endif
diff -ruNp ./src.orig/libs/graphics/tfb_draw.c ./src/libs/graphics/tfb_draw.c
--- ./src.orig/libs/graphics/tfb_draw.c	2017-10-23 11:42:14 -0700
+++ ./src/libs/graphics/tfb_draw.c	2017-10-23 11:41:32 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "gfx_common.h"
 #include "tfb_draw.h"
 #include "drawcmd.h"
@@ -154,6 +156,28 @@ TFB_DrawScreen_Copy (const RECT *r, SCRE
 	TFB_EnqueueDrawCommand (&DC);
 }
 
+// JMS_GFX: This ensures the whole screen area is updated in screen transition.
+// Useful at least in hires when landing at planet and transitioning to planetside view.
+// (The planet is cut uglily in about half when using normal TFB_DrawScreen_Copy).
+void
+TFB_DrawScreen_Copy_Fs (RECT *r, SCREEN src, SCREEN dest)
+{
+	RECT locRect;
+	TFB_DrawCommand DC;
+	
+	locRect.corner.x = locRect.corner.y = 0;
+	locRect.extent.width = ScreenWidth;
+	locRect.extent.height = ScreenHeight;
+	r = &locRect;
+	
+	DC.Type = TFB_DRAWCOMMANDTYPE_COPY;
+	DC.data.copy.rect = locRect;
+	DC.data.copy.srcBuffer = src;
+	DC.data.copy.destBuffer = dest;
+	
+	TFB_EnqueueDrawCommand (&DC);
+}
+
 void
 TFB_DrawScreen_SetMipmap (TFB_Image *img, TFB_Image *mmimg, int hotx, int hoty)
 {
diff -ruNp ./src.orig/libs/graphics/tfb_draw.h ./src/libs/graphics/tfb_draw.h
--- ./src.orig/libs/graphics/tfb_draw.h	2017-10-23 11:42:14 -0700
+++ ./src/libs/graphics/tfb_draw.h	2017-10-23 11:41:32 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef TFB_DRAW_H
 #define TFB_DRAW_H
 
@@ -84,6 +86,7 @@ void TFB_DrawScreen_Rect (RECT *rect, Co
 void TFB_DrawScreen_Image (TFB_Image *img, int x, int y, int scale,
 		int scaleMode, TFB_ColorMap *, DrawMode, SCREEN dest);
 void TFB_DrawScreen_Copy (const RECT *r, SCREEN src, SCREEN dest);
+void TFB_DrawScreen_Copy_Fs (RECT *r, SCREEN src, SCREEN dest); // JMS_GFX
 void TFB_DrawScreen_FilledImage (TFB_Image *img, int x, int y, int scale,
 		int scaleMode, Color, DrawMode, SCREEN dest);
 void TFB_DrawScreen_FontChar (TFB_Char *, TFB_Image *backing, int x, int y,
diff -ruNp ./src.orig/libs/graphics/widgets.c ./src/libs/graphics/widgets.c
--- ./src.orig/libs/graphics/widgets.c	2017-10-23 11:42:14 -0700
+++ ./src/libs/graphics/widgets.c	2017-10-23 11:41:32 -0700
@@ -14,9 +14,15 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+/*
+ * HD Mod: Copied verbatim from p6014 as of r2364, with RESOLUTION_FACTOR
+ * search-and-replaced to RESOLUTION_FACTOR and the applicable include added.
+ */
+
 #include "gfx_common.h"
 #include "widgets.h"
 #include "libs/strlib.h"
+#include "uqm/units.h"
 
 WIDGET *widget_focus = NULL;
 
@@ -98,7 +104,7 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 		oldfont = SetContextFont (cur_font);
 
 	/* Compute the dimensions of the label */
-	win_h = label->height ((WIDGET *)label) + 16;
+	win_h = label->height ((WIDGET *)label) + 16; // JMS_GFX
 	win_w = 0;
 	for (i = 0; i < label->line_count; i++)
 	{
@@ -108,7 +114,7 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 			win_w = len;
 		}
 	}
-	win_w = (win_w * 6) + 16;
+	win_w = (win_w * (6 << RES_CASE(0,1,1))) + 16; // JMS_GFX
 
 	BatchGraphics ();
 	r.corner.x = (ScreenWidth - win_w) >> 1;
@@ -118,14 +124,14 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 	DrawShadowedBox (&r, win_bg_clr, win_dark_clr, win_medium_clr);
 
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + 16;
+	t.baseline.y = r.corner.y + (16 << RES_CASE(0,0,1)); // JMS_GFX
 	for (i = 0; i < label->line_count; i++)
 	{
 		t.pStr = label->lines[i];
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 8;
+		t.baseline.y += (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 
 	UnbatchGraphics ();
@@ -139,10 +145,10 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 		// Add the outer border added by DrawShadowedBox.
 		// XXX: It may be nicer to add a border size parameter to
 		// DrawShadowedBox, instead of assuming 2 here.
-		windowRect->corner.x = r.corner.x - 2;
-		windowRect->corner.y = r.corner.y - 2;
-		windowRect->extent.width = r.extent.width + 4;
-		windowRect->extent.height = r.extent.height + 4;
+		windowRect->corner.x = r.corner.x - 2 * (1 + RESOLUTION_FACTOR);
+		windowRect->corner.y = r.corner.y - 2 * (1 + RESOLUTION_FACTOR);
+		windowRect->extent.width = r.extent.width + 4 * (1 + RESOLUTION_FACTOR);
+		windowRect->extent.height = r.extent.height + 4 * (1 + RESOLUTION_FACTOR);
 	}
 }
 
@@ -165,6 +171,9 @@ Widget_SetFont (FONT newFont)
 static void
 Widget_DrawToolTips (int numlines, const char **tips)
 {
+	// This functions draws the text at the bottom of the screen
+	// which explains what the current option does.
+	
 	RECT r;
 	FONT  oldfont = 0;
 	FRAME oldFontEffect = SetContextFontEffect (NULL);
@@ -175,21 +184,21 @@ Widget_DrawToolTips (int numlines, const
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 
-	r.corner.x = 2;
-	r.corner.y = 2;
-	r.extent.width = ScreenWidth - 4;
-	r.extent.height = ScreenHeight - 4;
+	r.corner.x = 2 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = 2 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.width = ScreenWidth - (4 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.height = ScreenHeight - (4 << RESOLUTION_FACTOR); // JMS_GFX
 
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + (r.extent.height - 8 - 8 * numlines);
+	t.baseline.y = r.corner.y + (r.extent.height - (8 << RESOLUTION_FACTOR) - (8 << RESOLUTION_FACTOR) * numlines); // JMS_GFX
 
 	for (i = 0; i < numlines; i++)
 	{
 		t.pStr = tips[i];
 		font_DrawText(&t);
-		t.baseline.y += 8;
+		t.baseline.y += (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 
 	SetContextFontEffect (oldFontEffect);
@@ -214,10 +223,10 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 	
-	r.corner.x = 2;
-	r.corner.y = 2;
-	r.extent.width = ScreenWidth - 4;
-	r.extent.height = ScreenHeight - 4;
+	r.corner.x = (2 << RESOLUTION_FACTOR) + 2 * RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = (2 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.width = ScreenWidth - (4 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.height = ScreenHeight - (4 << RESOLUTION_FACTOR); // JMS_GFX
 	
 	title = WIDGET_INACTIVE_SELECTED_COLOR;
 	selected = WIDGET_ACTIVE_COLOR;
@@ -228,12 +237,12 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	
 	oldtext = SetContextForeGroundColor (title);
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + 8;
+	t.baseline.y = r.corner.y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	t.pStr = self->title;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
 	font_DrawText (&t);
-	t.baseline.y += 8;
+	t.baseline.y += 8 << RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = self->subtitle;
 	font_DrawText (&t);
 
@@ -242,17 +251,17 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	{
 		WIDGET *child = self->child[widget_index];
 		height += (*child->height)(child);
-		height += 8;  /* spacing */
+		height += 8 << RESOLUTION_FACTOR; // JMS_GFX  /* spacing */
 	}
 
-	height -= 8;
+	height -= 8 << RESOLUTION_FACTOR; // JMS_GFX
 
 	widget_y = (ScreenHeight - height) >> 1;
 	for (widget_index = 0; widget_index < self->num_children; widget_index++)
 	{
 		WIDGET *c = self->child[widget_index];
 		(*c->draw)(c, 0, widget_y);
-		widget_y += (*c->height)(c) + 8;
+		widget_y += (*c->height)(c) + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 	
 	SetContextFontEffect (oldFontEffect);
@@ -282,7 +291,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = x + 64 * RESOLUTION_FACTOR; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -296,15 +305,18 @@ Widget_DrawChoice (WIDGET *_self, int x,
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
+	
+	t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX
 
 	home_x = t.baseline.x + 3 * (ScreenWidth / ((self->maxcolumns + 1) * 2));
 	home_y = t.baseline.y;
 	t.align = ALIGN_CENTER;
+	
 	for (i = 0; i < self->numopts; i++)
 	{
 		t.baseline.x = home_x + ((i % 3) *
 				(ScreenWidth / (self->maxcolumns + 1)));
-		t.baseline.y = home_y + (8 * (i / 3));
+		t.baseline.y = home_y + ((8 * (i / 3)) << RESOLUTION_FACTOR); // JMS_GFX
 		t.pStr = self->options[i].optname;
 		if ((widget_focus == _self) &&
 		    (self->highlighted == i))
@@ -322,6 +334,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 		}
 		font_DrawText (&t);
 	}
+	
 	SetContextFontEffect (oldFontEffect);
 	if (oldfont)
 		SetContextFont (oldfont);
@@ -344,7 +357,7 @@ Widget_DrawButton (WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = 160;
+	t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -379,7 +392,7 @@ Widget_DrawLabel (WIDGET *_self, int x,
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 	
-	t.baseline.x = 160;
+	t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -388,7 +401,7 @@ Widget_DrawLabel (WIDGET *_self, int x,
 	{
 		t.pStr = self->lines[i];
 		font_DrawText (&t);
-		t.baseline.y += 8;
+		t.baseline.y += (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 	SetContextFontEffect (oldFontEffect);
 	if (oldfont)
@@ -416,7 +429,7 @@ Widget_DrawSlider(WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = x + (64 * RESOLUTION_FACTOR); // JMS_GFX;
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -431,6 +444,8 @@ Widget_DrawSlider(WIDGET *_self, int x,
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
+	
+	t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX;
 
 	r.corner.x = t.baseline.x + 3 * tick;
 	r.corner.y = t.baseline.y - 4;
@@ -489,7 +504,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 
 	BatchGraphics ();
 
-	t.baseline.x = x;
+	t.baseline.x = x + (64 * RESOLUTION_FACTOR); // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -503,6 +518,8 @@ Widget_DrawTextEntry (WIDGET *_self, int
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
+	
+	t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX
 
 	/* Force string termination */
 	self->value[WIDGET_TEXTENTRY_WIDTH-1] = 0;
@@ -513,7 +530,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 
 	if (!(self->state & WTE_EDITING))
 	{	// normal or selected state
-		t.baseline.x = 160;
+		t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_CENTER;
 
 		if (widget_focus == _self)
@@ -535,7 +552,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 		RECT r;
 		SIZE leading;
 
-		t.baseline.x = 90;
+		t.baseline.x = 90 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_LEFT;
 
 		// calc background box dimensions
@@ -625,7 +642,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = x + (64 * RESOLUTION_FACTOR); // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -639,6 +656,8 @@ Widget_DrawControlEntry (WIDGET *_self,
 		oldtext = SetContextForeGroundColor (default_color);
 	}
 	font_DrawText (&t);
+	
+	t.baseline.x -= 64 * RESOLUTION_FACTOR; // JMS_GFX
 
         // 3 * ScreenWidth / ((self->maxcolumns + 1) * 2)) as per CHOICE, but only two options.
 	home_x = t.baseline.x + (ScreenWidth / 2); 
@@ -647,7 +666,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 	for (i = 0; i < 2; i++)
 	{
 		t.baseline.x = home_x + ((i % 3) * (ScreenWidth / 3));  // self->maxcolumns + 1 as per CHOICE.
-		t.baseline.y = home_y + (8 * (i / 3));
+		t.baseline.y = home_y + ((8 * (i / 3)) << RESOLUTION_FACTOR); // JMS_GFX;
 		t.pStr = self->controlname[i];
 		if (!t.pStr[0])
 		{
@@ -673,7 +692,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 int
 Widget_HeightChoice (WIDGET *_self)
 {
-	return ((((WIDGET_CHOICE *)_self)->numopts + 2) / 3) * 8;
+	return ((((WIDGET_CHOICE *)_self)->numopts + 2) / 3) * (8 << RESOLUTION_FACTOR); // JMS_GFX;
 }
 
 int
@@ -687,14 +706,14 @@ int
 Widget_HeightOneLine (WIDGET *_self)
 {
 	(void)_self;
-	return 8;
+	return (8 << RESOLUTION_FACTOR); // JMS_GFX
 }
 
 int
 Widget_HeightLabel (WIDGET *_self)
 {
 	WIDGET_LABEL *self = (WIDGET_LABEL *)_self;
-	return self->line_count * 8;
+	return self->line_count * (8 << RESOLUTION_FACTOR); // JMS_GFX
 }
 
 int
diff -ruNp ./src.orig/libs/input/sdl/input.c ./src/libs/input/sdl/input.c
--- ./src.orig/libs/input/sdl/input.c	2017-10-23 11:42:14 -0700
+++ ./src/libs/input/sdl/input.c	2017-10-23 11:41:32 -0700
@@ -73,6 +73,10 @@ static const char *menu_res_names[] = {
 	"editcancel",
 	"search",
 	"next",
+	"togglemap", // JMS: For showing SC1-era starmap.
+	"debug_2", // JMS: Secondary debug key.
+	"debug_3", // JMS: Tertiary debug key.
+	"debug_4", // JMS: Quaternary debug key.
 	NULL
 };
 
@@ -218,11 +222,13 @@ TFB_InitInput (int driver, int flags)
 {
 	int i;
 	int nJoysticks;
+	int signed_num_keys; // JMS: New variable to silence warnings
 	(void)driver;
 	(void)flags;
 
 	SDL_EnableUNICODE(1);
-	(void)SDL_GetKeyState (&num_keys);
+	(void)SDL_GetKeyState (&signed_num_keys);
+	num_keys = (unsigned int) signed_num_keys;
 	kbdstate = (int *)HMalloc (sizeof (int) * (num_keys + 1));
 	
 
diff -ruNp ./src.orig/libs/input/sdl/vcontrol.c ./src/libs/input/sdl/vcontrol.c
--- ./src.orig/libs/input/sdl/vcontrol.c	2017-10-23 11:42:14 -0700
+++ ./src/libs/input/sdl/vcontrol.c	2017-10-23 11:41:32 -0700
@@ -184,8 +184,10 @@ static void
 key_init (void)
 {
 	unsigned int i;
+	int signed_num_sdl_keys; // JMS: New variable to silence warnings
 	pool = allocate_key_chunk ();
-	(void)SDL_GetKeyState (&num_sdl_keys);
+	(void)SDL_GetKeyState (&signed_num_sdl_keys); // JMS: was num_sdl_keys
+	num_sdl_keys = (unsigned int) signed_num_sdl_keys; // JMS: new line
 	bindings = (keybinding **) HMalloc (sizeof (keybinding *) * num_sdl_keys);
 	for (i = 0; i < num_sdl_keys; i++)
 		bindings[i] = NULL;
diff -ruNp ./src.orig/libs/network/wspiapiwrap.h ./src/libs/network/wspiapiwrap.h
--- ./src.orig/libs/network/wspiapiwrap.h	2017-10-23 11:42:14 -0700
+++ ./src/libs/network/wspiapiwrap.h	2017-10-23 11:41:32 -0700
@@ -19,7 +19,10 @@
 #ifndef _WSPIAPIWRAP_H
 #define _WSPIAPIWRAP_H
 
-// HACK. See wspiapiwrap.c
+/* ************
+   DC: This whole section commented out due to VSC compiling issues. Found here: http://forum.uqm.stack.nl/index.php?topic=4353.0
+
+   // HACK. See wspiapiwrap.c
 #	define getaddrinfo WspiapiGetAddrInfo
 #	define getnameinfo WspiapiGetNameInfo
 #	define freeaddrinfo WspiapiFreeAddrInfo
@@ -28,6 +31,8 @@ int WINAPI WspiapiGetAddrInfo(const char
 		const struct addrinfo *hints, struct addrinfo **res);
 int WINAPI WspiapiGetNameInfo (const struct sockaddr *sa, socklen_t salen,
 		char *host, size_t hostlen, char *serv, size_t servlen, int flags);
+*/
+#include <wspiapi.h>  //DC: replaced upper section with this part to (hopefully) compile.
 
 #endif  /* _WSPIAPIWRAP_H */
 
diff -ruNp ./src.orig/libs/uio/uiostream.c ./src/libs/uio/uiostream.c
--- ./src.orig/libs/uio/uiostream.c	2017-10-23 11:42:15 -0700
+++ ./src/libs/uio/uiostream.c	2017-10-23 11:41:33 -0700
@@ -265,8 +265,18 @@ uio_ungetc(int c, uio_Stream *stream) {
 	assert(c >= 0 && c <= 255);
 
 	return (int) EOF;
-			// not implemented
-//	return c;
+						// XXX: not implemented
+	//return c;
+}
+
+// JMS: The datastream can be stepped back n bytes with this baby.
+int
+uio_backtrack(int rewinded_bytes, uio_Stream *stream) {
+	assert((stream->openFlags & O_ACCMODE) != O_WRONLY);
+
+	stream->operation = uio_StreamOperation_read;
+	stream->dataStart -= rewinded_bytes;
+	return rewinded_bytes;
 }
 
 // NB. POSIX allows errno to be set for vsprintf(), but does not require it:
diff -ruNp ./src.orig/libs/uio/uiostream.h ./src/libs/uio/uiostream.h
--- ./src.orig/libs/uio/uiostream.h	2017-10-23 11:42:15 -0700
+++ ./src/libs/uio/uiostream.h	2017-10-23 11:41:33 -0700
@@ -36,6 +36,7 @@ char *uio_fgets(char *buf, int size, uio
 int uio_fgetc(uio_Stream *stream);
 #define uio_getc uio_fgetc
 int uio_ungetc(int c, uio_Stream *stream);
+int uio_backtrack(int rewinded_bytes, uio_Stream *stream); // JMS
 int uio_vfprintf(uio_Stream *stream, const char *format, va_list args);
 int uio_fprintf(uio_Stream *stream, const char *format, ...);
 int uio_fputc(int c, uio_Stream *stream);
diff -ruNp ./src.orig/options.c ./src/options.c
--- ./src.orig/options.c	2017-10-23 11:42:15 -0700
+++ ./src/options.c	2017-10-23 11:41:33 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 /*
  * Eventually this should include all configuration stuff, 
  * for now there's few options which indicate 3do/pc flavors.
@@ -52,6 +54,20 @@ int optSmoothScroll;
 int optMeleeScale;
 const char **optAddons;
 
+// JMS_GFX
+unsigned int loresBlowupScale;
+unsigned int resolutionFactor;
+BOOLEAN forceAspectRatio;
+BOOLEAN resFactorWasChanged;
+
+// JMS
+BOOLEAN optMainmenuMusic;
+BOOLEAN optMineralSubmenu;
+BOOLEAN optNebulae;
+BOOLEAN optRotatingIpPlanets;
+BOOLEAN optTexturedIpPlanets;
+BOOLEAN optCheatMode;
+
 BOOLEAN opt3doMusic;
 BOOLEAN optRemixMusic;
 BOOLEAN optSubtitles;
diff -ruNp ./src.orig/options.h ./src/options.h
--- ./src.orig/options.h	2017-10-23 11:42:15 -0700
+++ ./src/options.h	2017-10-23 11:41:33 -0700
@@ -14,11 +14,14 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 /*
  * Eventually this should include all configuration stuff, 
  * for now there's few options which indicate 3do/pc flavors.
  */
 
+
 #ifndef OPTIONS_H
 #define OPTIONS_H
 
@@ -38,6 +41,20 @@ extern int optWhichShield;
 extern int optSmoothScroll;
 extern int optMeleeScale;
 
+// JMS_GFX
+extern unsigned int loresBlowupScale;
+extern unsigned int resolutionFactor;
+extern BOOLEAN forceAspectRatio;
+extern BOOLEAN resFactorWasChanged;
+
+// JMS
+extern BOOLEAN optMainmenuMusic;
+extern BOOLEAN optMineralSubmenu;
+extern BOOLEAN optNebulae;
+extern BOOLEAN optRotatingIpPlanets;
+extern BOOLEAN optTexturedIpPlanets;
+extern BOOLEAN optCheatMode;
+
 extern BOOLEAN opt3doMusic;
 extern BOOLEAN optRemixMusic;
 extern BOOLEAN optSubtitles;
diff -ruNp ./src.orig/port.h ./src/port.h
--- ./src.orig/port.h	2017-10-23 11:42:15 -0700
+++ ./src/port.h	2017-10-23 11:41:33 -0700
@@ -162,7 +162,7 @@ typedef unsigned short mode_t;
 #	include <stdarg.h>
 // Defined in port.c
 int snprintf(char *str, size_t size, const char *format, ...);
-int vsnprintf(char *str, size_t size, const char *format, va_list args);
+// int vsnprintf(char *str, size_t size, const char *format, va_list args);   //DC: Removed as recommended by http://forum.uqm.stack.nl/index.php?topic=4896.0
 #endif  /* _MSC_VER */
 
 // setenv()
@@ -546,4 +546,3 @@ typedef unsigned int wint_t;
 // "d:foo/bar" (without a slash after the drive letter) are to be rejected.
 
 #endif  /* _PORT_H */
-
diff -ruNp ./src.orig/res/darwin/Info.plist ./src/res/darwin/Info.plist
--- ./src.orig/res/darwin/Info.plist	2017-10-23 11:42:15 -0700
+++ ./src/res/darwin/Info.plist	2017-10-23 11:41:33 -0700
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 <plist version="1.0">
 <dict>
 	<key>CFBundleDevelopmentRegion</key>
 	<string>English</string>
 	<key>CFBundleExecutable</key>
-	<string>The Ur-Quan Masters</string>
+	<string>The Ur-Quan Masters HD</string>
 	<key>CFBundleIconFile</key>
 	<string>The Ur-Quan Masters.icns</string>
 	<key>CFBundleInfoDictionaryVersion</key>
Files ./src.orig/res/darwin/The Ur-Quan Masters old.icns and ./src/res/darwin/The Ur-Quan Masters old.icns differ
Files ./src.orig/res/darwin/The Ur-Quan Masters.icns and ./src/res/darwin/The Ur-Quan Masters.icns differ
Files ./src.orig/res/ur-quan3.ico and ./src/res/ur-quan3.ico differ
diff -ruNp ./src.orig/svnversion.h ./src/svnversion.h
--- ./src.orig/svnversion.h	1969-12-31 16:00:00 -0800
+++ ./src/svnversion.h	2017-10-23 11:41:33 -0700
@@ -0,0 +1 @@
+#define UQMHD_SVN_REVISION "1347M"
diff -ruNp ./src.orig/tools/LICENSE.txt ./src/tools/LICENSE.txt
--- ./src.orig/tools/LICENSE.txt	1969-12-31 16:00:00 -0800
+++ ./src/tools/LICENSE.txt	2017-10-23 11:41:33 -0700
@@ -0,0 +1,19 @@
+Copyright (C) 2010 Joris van de Donk
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+Joris van de Donk - joris@mooses.nl
\ No newline at end of file
Files ./src.orig/tools/lib/xstream-1.3.1.jar and ./src/tools/lib/xstream-1.3.1.jar differ
diff -ruNp ./src.orig/tools/savefont/LICENSE.txt ./src/tools/savefont/LICENSE.txt
--- ./src.orig/tools/savefont/LICENSE.txt	1969-12-31 16:00:00 -0800
+++ ./src/tools/savefont/LICENSE.txt	2017-10-23 11:41:33 -0700
@@ -0,0 +1,19 @@
+Copyright (C) 2010 Benjamin Wack
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+Benjamin Wack - benjamin.wack@free.fr
\ No newline at end of file
diff -ruNp ./src.orig/tools/savefont/readme.txt ./src/tools/savefont/readme.txt
--- ./src.orig/tools/savefont/readme.txt	1969-12-31 16:00:00 -0800
+++ ./src/tools/savefont/readme.txt	2017-10-23 11:41:33 -0700
@@ -0,0 +1,9 @@
+savefont.scm is a Gimp script.
+To use it, place it in <Home>/.gimp-2.6/script, restart Gimp and you'll find it under File/Create/Save font as images
+
+Given a font, a size in pixels and a destination directory, it creates a set of png images for each character (ascii code ranging from 33 to 125).
+Built-in features which are not accessible directly :
+- created characters are white
+- created characters are anti-aliased (using partial transparency)
+- pngs are cropped horizontally to the exact size of the character, and vertically to the maximum height occupied by font characters (unless the font is ill-defined)
+
diff -ruNp ./src.orig/tools/savefont/renumber.bat ./src/tools/savefont/renumber.bat
--- ./src.orig/tools/savefont/renumber.bat	1969-12-31 16:00:00 -0800
+++ ./src/tools/savefont/renumber.bat	2017-10-23 11:41:33 -0700
@@ -0,0 +1,292 @@
+REM !
+ren 33.png 00021.png
+
+REM "
+ren 34.png 00022.png
+
+
+REM #
+ren 35.png 0023.png
+
+REM $
+ren 36.png 0024.png
+
+REM %
+ren 37.png 0025.png
+
+REM &
+ren 38.png 0026.png
+
+
+REM '
+ren 39.png 0027.png
+
+REM (
+ren 40.png 0028.png
+
+REM ///
+ren 41.png 0029.png
+
+REM *
+ren 42.png 0002a.png
+
+REM +
+ren 43.png 0002b.png
+
+
+REM ,
+ren 44.png 0002c.png
+
+REM ,
+ren 45.png 0002d.png
+
+REM .
+ren 46.png 0002e.png
+
+REM .
+ren 47.png 0002f.png
+
+REM 0
+ren 48.png 00030.png
+
+REM 1
+ren 49.png 00031.png
+
+REM 2
+ren 50.png 00032.png
+
+REM 3
+ren 51.png 00033.png
+
+REM 4
+ren 52.png 00034.png
+
+REM 5
+ren 53.png 00035.png
+
+REM 6
+ren 54.png 00036.png
+
+REM 7
+ren 55.png 00037.png
+
+REM 8
+ren 56.png 00038.png
+
+
+REM 9
+ren 57.png 00039.png
+
+
+REM :
+ren 58.png 0003a.png
+
+REM ;
+ren 59.png 0003b.png
+
+
+REM <
+ren 60.png 0003c.png
+
+
+REM =
+ren 61.png 0003d.png
+
+
+REM >
+ren 62.png 0003e.png
+
+
+REM ?
+ren 63.png 0003f.png
+
+
+REM @
+ren 64.png 00040.png
+
+REM A
+ren 65.png 00041.png
+
+REM B
+ren 66.png 00042.png
+
+REM C
+ren 67.png 00043.png
+
+REM D
+ren 68.png 00044.png
+
+REM E
+ren 69.png 00045.png
+
+REM F
+ren 70.png 00046.png
+
+REM G
+ren 71.png 00047.png
+
+REM H
+ren 72.png 00048.png
+
+REM I
+ren 73.png 00049.png
+
+REM J
+ren 74.png 0004a.png
+
+REM K
+ren 75.png 0004b.png
+
+REM L
+ren 76.png 0004c.png
+
+REM M
+ren 77.png 0004d.png
+
+REM N
+ren 78.png 0004e.png
+
+REM O
+ren 79.png 0004f.png
+
+REM P
+ren 80.png 00050.png
+
+REM Q
+ren 81.png 00051.png
+
+REM R
+ren 82.png 00052.png
+
+REM S
+ren 83.png 00053.png
+
+REM T
+ren 84.png 00054.png
+
+REM U
+ren 85.png 00055.png
+
+REM V
+ren 86.png 00056.png
+
+REM W
+ren 87.png 00057.png
+
+REM W
+ren 88.png 00058.png
+
+REM Y
+ren 89.png 00059.png
+
+REM Z
+ren 90.png 0005a.png
+
+REM [
+ren 91.png 0005b.png
+
+REM \
+ren 92.png 0005c.png
+
+REM ]
+ren 93.png 0005d.png
+
+REM ^
+ren 94.png 0005e.png
+
+REM _
+ren 95.png 0005f.png
+
+REM `
+ren 96.png 0006a.png
+
+REM a
+ren 97.png 00061.png
+
+REM b
+ren 98.png 00062.png
+
+REM c
+ren 99.png 00063.png
+
+REM d
+ren 100.png 00064.png
+
+REM e
+ren 101.png 00065.png
+
+REM f
+ren 102.png 00066.png
+
+REM g
+ren 103.png 00067.png
+
+REM h
+ren 104.png 00068.png
+
+REM i
+ren 105.png 00069.png
+
+REM j
+ren 106.png 0006a.png
+
+REM k
+ren 107.png 0006b.png
+
+REM l
+ren 108.png 0006c.png
+
+REM m
+ren 109.png 0006d.png
+
+REM n
+ren 110.png 0006e.png
+
+REM o
+ren 111.png 0006f.png
+
+REM p
+ren 112.png 00070.png
+
+REM q
+ren 113.png 00071.png
+
+REM r
+ren 114.png 00072.png
+
+REM s
+ren 115.png 00073.png
+
+REM t
+ren 116.png 00074.png
+
+REM u
+ren 117.png 00075.png
+
+REM v
+ren 118.png 00076.png
+
+REM w
+ren 119.png 00077.png
+
+REM x
+ren 120.png 00078.png
+
+REM y
+ren 121.png 00079.png
+
+REM z
+ren 122.png 0007a.png
+
+REM {
+ren 123.png 0007b.png
+
+REM |
+ren 124.png 0007b.png
+
+REM }
+ren 125.png 0007d.png
+
+REM }
+ren 126.png 0007e.png
+
diff -ruNp ./src.orig/tools/savefont/savefont.scm ./src/tools/savefont/savefont.scm
--- ./src.orig/tools/savefont/savefont.scm	1969-12-31 16:00:00 -0800
+++ ./src/tools/savefont/savefont.scm	2017-10-23 11:41:33 -0700
@@ -0,0 +1,146 @@
+;; recurse save-character on Ascii codes from 33 to 125
+(define (sfsfrec inAscii inFont inFontsize inDir)
+  (if (<= inAscii 125)
+      (
+       (save-character inAscii inFont inFontsize inDir)
+       (sfsfrec (+ inAscii 1) inFont inFontsize inDir)
+       )
+      ()
+      )
+  )
+
+(define (script-fu-save-font inFont inFontsize inDir)
+  (sfsfrec 33 inFont inFontsize inDir)
+  )
+
+;; save a character by its ascii code into the given dir
+(define (save-character inAscii inFont inFontSize inDir)
+  (let*
+      (
+					; define our local variables
+					; create a new image:
+       (theImageWidth  1)
+       (theImageHeight 1)
+       (theImage (car
+		  (gimp-image-new
+		   theImageWidth
+		   theImageHeight
+		   RGB
+		   )
+		  )
+                 )
+       (theText)
+       (theFontSize inFontSize)
+       (theLayer
+	(car
+	 (gimp-layer-new
+	  theImage
+	  theImageWidth
+	  theImageHeight
+	  RGBA-IMAGE
+	  "layer 1"
+	  100
+	  NORMAL
+	  )
+	 )
+	)
+;       used to crop the image horizontally but not vertically
+       (theBaseLayer
+	(car
+	 (gimp-layer-new
+	  theImage
+	  theImageWidth
+	  theImageHeight
+	  RGBA-IMAGE
+	  "layer 0"
+	  100
+	  NORMAL
+	  )
+	 )
+	)
+       (theFilename (string-append inDir "/" (number->string inAscii) ".png"))
+       )
+    
+					; the function itself
+; create an image with the character and resize it
+    (gimp-image-add-layer theImage theLayer 0)
+    (gimp-image-add-layer theImage theBaseLayer 1)
+    (gimp-context-set-background '(0 0 0))
+    (gimp-context-set-foreground '(255 255 255))
+    (gimp-drawable-fill theLayer TRANSPARENT-FILL)
+    
+       (set! theText
+       	     (car
+       	      (gimp-text-fontname
+       	       theImage theLayer
+       	       0 0
+       	       (string (integer->char inAscii))
+       	       0
+       	       TRUE ; Anti-aliasing
+       	       theFontSize PIXELS
+       	       inFont)
+       	      )
+       	     )
+
+       (set! theImageHeight  (car (gimp-drawable-height theText) ) )
+
+       	(set! theImageWidth   (car (gimp-drawable-width  theText) ) )
+
+        (gimp-image-resize theImage theImageWidth theImageHeight 0 0)
+	
+	(gimp-layer-resize theLayer theImageWidth theImageHeight 0 0)
+
+	(gimp-layer-resize theBaseLayer theImageWidth theImageHeight 0 0)
+
+       (gimp-floating-sel-anchor theText)
+
+
+       ;; Height is resized before autocropping only to keep V-alignment of characters
+	;; Width is resized after to remove whitespaces
+
+	(plug-in-autocrop-layer RUN-NONINTERACTIVE theImage theLayer)
+
+	;; Character has to be pushed to the left
+	(let* (
+	       (ox (car (gimp-drawable-offsets theLayer)))
+	       (oy (cadr (gimp-drawable-offsets theLayer)))
+	       )
+	  
+	  (gimp-layer-translate theLayer (- ox) 0)
+	  )
+	
+        (set! theImageWidth   (car (gimp-drawable-width  theLayer) ) )
+
+        (gimp-image-resize theImage theImageWidth theImageHeight 0 0)
+	
+        (gimp-layer-resize theBaseLayer theImageWidth theImageHeight 0 0)
+
+	(gimp-image-merge-visible-layers theImage EXPAND-AS-NECESSARY)
+	
+;	(gimp-display-new theImage)
+
+;       (gimp-image-clean-all theImage) ; To prevent save prompt during testing
+
+       (file-png-save-defaults RUN-NONINTERACTIVE theImage (car (gimp-image-get-active-drawable theImage)) theFilename theFilename)
+       
+    )
+  )
+
+
+(script-fu-register
+    "script-fu-save-font"                        ;func name
+    "Save Font as Images"                                  ;menu label
+    "Creates pngs for each character in a\
+      font. Characters are white on a transparent\
+      background."              ;description
+    "Benjamin Wack"                             ;author
+    "copyright 2010, Benjamin Wack"        ;copyright notice
+    "November 25, 2010"                          ;date created
+    ""                     ;image type that the script works on
+;    SF-ADJUSTMENT  "Ascii code"          '(65 32 125 1 10 0 SF-SPINNER)   ;an ascii code
+    SF-FONT        "Font"          "Sans"    ;a font variable
+    SF-ADJUSTMENT  "Font size"     '(40 1 1000 1 10 0 1)
+    SF-DIRNAME     "Directory"     "D:/project6014/fontgen"
+;    SF-COLOR       "Color"         '(0 0 0)     ;color variable
+  )
+  (script-fu-menu-register "script-fu-save-font" "<Image>/File/Create")
Files ./src.orig/tools/starmap-4x.psd and ./src/tools/starmap-4x.psd differ
diff -ruNp ./src.orig/tools/uqmanimationtool.conf ./src/tools/uqmanimationtool.conf
--- ./src.orig/tools/uqmanimationtool.conf	1969-12-31 16:00:00 -0800
+++ ./src/tools/uqmanimationtool.conf	2017-10-23 11:41:33 -0700
@@ -0,0 +1,11 @@
+<UQMAnimationToolSettings>
+  <lastDirPath>E:\Dropbox\Batman\UQM-HD\content\addons\russian1x\shadow-content\addons\hires4x\ui</lastDirPath>
+  <hideDupe>false</hideDupe>
+  <showOnlySelected>false</showOnlySelected>
+  <hotspotColor>
+    <red>255</red>
+    <green>0</green>
+    <blue>0</blue>
+    <alpha>255</alpha>
+  </hotspotColor>
+</UQMAnimationToolSettings>
\ No newline at end of file
Files ./src.orig/tools/uqmanimationtool.jar and ./src/tools/uqmanimationtool.jar differ
diff -ruNp ./src.orig/uqm/border.c ./src/uqm/border.c
--- ./src.orig/uqm/border.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/border.c	2017-10-23 11:41:33 -0700
@@ -16,6 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
 
 #include "libs/gfxlib.h"
 #include "libs/threadlib.h"
@@ -52,29 +53,35 @@ DrawSISFrame (void)
 
 	BatchGraphics ();
 	{
+		// Middle grey rectangles around space window.
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+			//
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.extent.height = SIS_ORG_Y - 1;
 		DrawFilledRectangle (&r);
+			//
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_ORG_X - 1;
 		r.extent.height = SIS_ORG_Y + SIS_SCREEN_HEIGHT + 1;
 		DrawFilledRectangle (&r);
+			//
 		r.corner.x = 0;
 		r.corner.y = r.extent.height;
 		r.extent.width = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.extent.height = SCREEN_HEIGHT - SIS_ORG_Y + SIS_SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
+			//
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.corner.y = 0;
 		r.extent.width = SCREEN_WIDTH - r.corner.x;
 		r.extent.height = SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
-
+		
+		// Light and dark grey edges of the space window.
 		r.corner.x = SIS_ORG_X - 1;
 		r.corner.y = SIS_ORG_Y - 1;
 		r.extent.width = SIS_SCREEN_WIDTH + 2;
@@ -84,9 +91,9 @@ DrawSISFrame (void)
 				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
 				TRUE, BLACK_COLOR);
 
+		// The big Blue box in the upper edge of screen containing the star system name.
 		r.corner.y = 0;
 		r.extent.height = SIS_ORG_Y;
-
 		r.corner.x = SIS_ORG_X;
 		r.extent.width = SIS_MESSAGE_BOX_WIDTH;
 		DrawStarConBox (&r, 1,
@@ -94,6 +101,7 @@ DrawSISFrame (void)
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x01, 0x1C), 0x4E),
 				TRUE, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
 
+		// The smaller blue box.
 		r.extent.width = SIS_TITLE_BOX_WIDTH;
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH;
 		DrawStarConBox (&r, 1,
@@ -101,18 +109,22 @@ DrawSISFrame (void)
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x01, 0x1C), 0x4E),
 				TRUE, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
 
+		// Black border between menu area and space window area
 		SetContextForeGroundColor (BLACK_COLOR);
 		r.corner.x = SAFE_X + SPACE_WIDTH - 1;
 		r.corner.y = 0;
-		r.extent.width = 1;
+		r.extent.width = 1; // JMS_GFX
 		r.extent.height = SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
+		
 		r.corner.x = SAFE_X + SPACE_WIDTH;
-		r.corner.y = SAFE_Y + 139;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX
 		DrawPoint (&r.corner);
-		r.corner.x = SCREEN_WIDTH - 1;
+		
+		r.corner.x = SCREEN_WIDTH - 1; // JMS_GFX
 		DrawPoint (&r.corner);
 
+		// Light grey border on the left side of big blue box.
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 		r.corner.y = 1;
@@ -120,73 +132,93 @@ DrawSISFrame (void)
 		r.extent.height = SAFE_Y + SIS_TITLE_HEIGHT;
 		r.corner.x = SIS_ORG_X - 1;
 		DrawFilledRectangle (&r);
+		
+		// The same for small blue box
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - 1;
 		DrawFilledRectangle (&r);
 
+		// Light grey horizontal line at the bottom of the screen, space window side
 		r.corner.x = 0;
 		r.corner.y = SCREEN_HEIGHT - 1;
 		r.extent.width = SAFE_X + SPACE_WIDTH - 1;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		
+		// Light grey vertical line at the right side of space window
 		r.corner.x = SAFE_X + SPACE_WIDTH - 2;
 		r.corner.y = 0;
 		r.extent.width = 1;
 		r.extent.height = SCREEN_HEIGHT - 1;
 		DrawFilledRectangle (&r);
+		
+		// Vertical line at the right side of the menu window, upper part
 		r.corner.x = SCREEN_WIDTH - 1;
 		r.corner.y = 0;
 		r.extent.width = 1;
-		r.extent.height = SAFE_Y + 139;
+		r.extent.height = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX
 		DrawFilledRectangle (&r);
+		
+		// Horizontal line at the bottom of the screen, menu window side
 		r.corner.x = SAFE_X + SPACE_WIDTH;
 		r.corner.y = SCREEN_HEIGHT - 1;
 		r.extent.width = SCREEN_WIDTH - r.corner.x;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		
+		// Vertical line at the right side of the menu window, lower part
 		r.corner.x = SCREEN_WIDTH - 1;
-		r.corner.y = SAFE_Y + 140;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(139) + RES_CASE(1,0,0);
 		r.extent.width = 1;
 		r.extent.height = (SCREEN_HEIGHT - 1) - r.corner.y;
 		DrawFilledRectangle (&r);
 
+		// Dark grey border around blue boxes.
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
-		r.corner.y = 1;
+		// Vertical line on the right side of the big blue box
+		r.corner.y = 0; // JMS_GFX
 		r.extent.width = 1;
 		r.extent.height = SAFE_Y + SIS_MESSAGE_HEIGHT;
 		r.corner.x = SIS_ORG_X + SIS_MESSAGE_BOX_WIDTH;
 		DrawFilledRectangle (&r);
+		// Vertical line on the right side of the small blue box
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH;
 		++r.extent.height;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.y = 0;
 		r.extent.width = (SAFE_X + SPACE_WIDTH - 2) - r.corner.x;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = 0;
 		r.extent.width = SIS_ORG_X - r.corner.x;
 		DrawFilledRectangle (&r);
+		// Horizontal line between boxes
 		r.corner.x = SIS_ORG_X + SIS_MESSAGE_BOX_WIDTH;
 		r.extent.width = SIS_SPACER_BOX_WIDTH;
 		DrawFilledRectangle (&r);
-
+		//
 		r.corner.x = 0;
 		r.corner.y = 1;
 		r.extent.width = 1;
 		r.extent.height = (SCREEN_HEIGHT - 1) - r.corner.y;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = SAFE_X + SPACE_WIDTH;
 		r.corner.y = 0;
 		r.extent.width = 1;
-		r.extent.height = SAFE_Y + 139;
+		r.extent.height = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX 
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = SAFE_X + SPACE_WIDTH + 1;
-		r.corner.y = SAFE_Y + 139;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(139); // JMS_GFX
 		r.extent.width = STATUS_WIDTH - 2;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = SAFE_X + SPACE_WIDTH;
-		r.corner.y = SAFE_Y + 140;
+		r.corner.y = SAFE_Y + RES_STAT_SCALE(140); // JMS_GFX
 		r.extent.width = 1;
 		r.extent.height = SCREEN_HEIGHT - r.corner.y;
 		DrawFilledRectangle (&r);
diff -ruNp ./src.orig/uqm/cleanup.c ./src/uqm/cleanup.c
--- ./src.orig/uqm/cleanup.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/cleanup.c	2017-10-23 11:41:33 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "nameref.h"
 #include "libs/reslib.h"
 #include "gamestr.h"
@@ -67,6 +69,10 @@ UninitKernel (void)
 	DestroyFont (MicroFont);
 	DestroyStringTable (ReleaseStringTable (GameStrings));
 	DestroyDrawable (ReleaseDrawable (StatusFrame));
+	DestroyDrawable (ReleaseDrawable (SubmenuStarmapKeysFrame)); // JMS
+	DestroyDrawable (ReleaseDrawable (ConstellationsFrame)); // JMS
+	DestroyDrawable (ReleaseDrawable (nebulaeFrame));	// JMS
+	DestroyDrawable (ReleaseDrawable (hyperspacesuns));	// JMS
 	DestroyDrawable (ReleaseDrawable (ActivityFrame));
 	DestroyFont (TinyFont);
 	DestroyFont (StarConFont);
diff -ruNp ./src.orig/uqm/clock.c ./src/uqm/clock.c
--- ./src.orig/uqm/clock.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/clock.c	2017-10-23 11:41:33 -0700
@@ -84,6 +84,41 @@ nextClockDay (void)
 	DrawStatusMessage (NULL);
 }
 
+// Computes how many days have passed since the game has begun
+float
+daysElapsed (void)
+{
+	float days = 0;
+	COUNT index;
+	
+	// Years
+	for (index = START_YEAR ; index < GLOBAL (GameClock.year_index) ; index++ )
+		{
+			days += 365;
+			if(IsLeapYear(index))
+				days++;
+		}
+
+	if (GLOBAL (GameClock.month_index) == 1)
+		{
+			days = days - 31;
+		}
+	
+	// Months
+	for (index = 2 ; index < GLOBAL (GameClock.month_index) ; index++ )
+		{
+			days += DaysInMonth (index, GLOBAL (GameClock.year_index));
+		}
+	
+	// Days
+	days = days + GLOBAL (GameClock.day_index) - 17;
+
+	// Part of a day
+	days = days + (GLOBAL (GameClock.day_in_ticks) - GLOBAL (GameClock.tick_count)) / (float)GLOBAL (GameClock.day_in_ticks);
+
+	return days;
+}
+
 static void
 processClockDayEvents (void)
 {
diff -ruNp ./src.orig/uqm/clock.h ./src/uqm/clock.h
--- ./src.orig/uqm/clock.h	2017-10-23 11:42:15 -0700
+++ ./src/uqm/clock.h	2017-10-23 11:41:33 -0700
@@ -82,6 +82,8 @@ typedef enum
 extern BOOLEAN InitGameClock (void);
 extern BOOLEAN UninitGameClock (void);
 
+extern float daysElapsed (void);
+
 extern void SetGameClockRate (COUNT seconds_per_day);
 extern BOOLEAN ValidateEvent (EVENT_TYPE type, COUNT *pmonth_index,
 		COUNT *pday_index, COUNT *pyear_index);
diff -ruNp ./src.orig/uqm/cnctdlg.c ./src/uqm/cnctdlg.c
--- ./src.orig/uqm/cnctdlg.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/cnctdlg.c	2017-10-23 11:41:33 -0700
@@ -29,8 +29,8 @@
 #include "libs/graphics/widgets.h"
 #include "supermelee/netplay/netoptions.h"
 
-#define MCD_WIDTH 260
-#define MCD_HEIGHT 110
+#define MCD_WIDTH (260 << RESOLUTION_FACTOR) // JMS_GFX
+#define MCD_HEIGHT (110 << RESOLUTION_FACTOR) // JMS_GFX
 
 #define MENU_FRAME_RATE (ONE_SECOND / 20)
 
@@ -80,12 +80,12 @@ MCD_DrawMenuScreen (WIDGET *_self, int x
 
 	WIDGET_MENU_SCREEN *self = (WIDGET_MENU_SCREEN *)_self;
 	
-	widget_y = y + 8;
+	widget_y = y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	for (widget_index = 0; widget_index < self->num_children; widget_index++)
 	{
 		WIDGET *c = self->child[widget_index];
 		(*c->draw)(c, x, widget_y);
-		widget_y += (*c->height)(c) + 8;
+		widget_y += (*c->height)(c) + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 }
 
@@ -102,7 +102,7 @@ MCD_DrawButton (WIDGET *_self, int x, in
 	selected = MENU_HIGHLIGHT_COLOR;
 	inactive = MENU_TEXT_COLOR;
 
-	t.baseline.x = 160;
+	t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -212,7 +212,7 @@ MCD_DrawTextEntry (WIDGET *_self, int x,
 
 	if (!(self->state & WTE_EDITING))
 	{	// normal or selected state
-		t.baseline.x = 160;
+		t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_CENTER;
 
 		if (widget_focus == _self)
@@ -234,7 +234,7 @@ MCD_DrawTextEntry (WIDGET *_self, int x,
 		RECT r;
 		SIZE leading;
 
-		t.baseline.x = x + 90;
+		t.baseline.x = x + (90 << RESOLUTION_FACTOR); // JMS_GFX
 		t.align = ALIGN_LEFT;
 
 		// calc background box dimensions
diff -ruNp ./src.orig/uqm/colors.h ./src/uqm/colors.h
--- ./src.orig/uqm/colors.h	2017-10-23 11:42:15 -0700
+++ ./src/uqm/colors.h	2017-10-23 11:41:33 -0700
@@ -75,6 +75,13 @@
 #define BRIGHT_BLUE_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x1F), 0x01)
 
+/* uqm-hd */
+#define BRIGHT_YELLOW_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x00), 0x01)
+#define DULL_YELLOW_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x0F, 0x0F, 0x00), 0x01)
+/* end uqm-hd */
+
 #define NORMAL_ILLUMINATED_COLOR \
 		WHITE_COLOR
 #define NORMAL_SHADOWED_COLOR \
@@ -235,6 +242,14 @@
 #define STATUS_MESSAGE_TEXT_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x10, 0x00), 0x6B)
 
+// Text color for the status message when it's displaying a warning (yellow).
+#define STATUS_MESSAGE_WARNING_TEXT_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x00), 0x6B)
+
+// Text color for the status message then it's displaying an alert (red).
+#define STATUS_MESSAGE_ALERT_TEXT_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x00), 0x6B)
+
 // Background color of the status message.
 #define STATUS_MESSAGE_BACKGROUND_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x08, 0x00), 0x6E)
diff -ruNp ./src.orig/uqm/comm/arilou/arilouc.c ./src/uqm/comm/arilou/arilouc.c
--- ./src.orig/uqm/comm/arilou/arilouc.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/arilou/arilouc.c	2017-10-23 11:41:33 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA arilou_desc =
 {
+	ARILOU_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp ./src.orig/uqm/comm/blackur/blackurc.c ./src/uqm/comm/blackur/blackurc.c
--- ./src.orig/uqm/comm/blackur/blackurc.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/blackur/blackurc.c	2017-10-23 11:41:33 -0700
@@ -22,6 +22,7 @@
 
 static LOCDATA blackurq_desc =
 {
+	BLACKURQ_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -91,8 +92,7 @@ static LOCDATA blackurq_desc =
 		{
 			33, /* StartIndex */
 			5, /* NumFrames */
-			CIRCULAR_ANIM
-					| WAIT_TALKING, /* AnimFlags */
+			CIRCULAR_ANIM | WAIT_TALKING, /* AnimFlags */
 			ONE_SECOND / 10, 0, /* FrameRate */
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
 			0, /* BlockMask */
diff -ruNp ./src.orig/uqm/comm/chmmr/chmmrc.c ./src/uqm/comm/chmmr/chmmrc.c
--- ./src.orig/uqm/comm/chmmr/chmmrc.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/chmmr/chmmrc.c	2017-10-23 11:41:33 -0700
@@ -24,9 +24,12 @@
 #include "uqm/hyper.h"
 			// for SOL_X/SOL_Y
 
+#include "../../nameref.h"
+			// JMS_GFX: For LoadGraphic 
 
 static LOCDATA chmmr_desc =
 {
+	CHMMR_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -148,11 +151,6 @@ ExitConversation (RESPONSE_REF R)
 /* Magic numbers for Earth */
 #define EARTH_OUTER_X (-725)
 #define EARTH_OUTER_Y (597)
-#define EARTH_INNER_X (121)
-#define EARTH_INNER_Y (113)
-/* Magic numbers for Earth Starbase */
-#define STARBASE_INNER_X (86)
-#define STARBASE_INNER_Y (113)
 
 		/* transport player to Earth */
 		GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (SOL_X);
@@ -176,10 +174,9 @@ ExitConversation (RESPONSE_REF R)
 			for (i = NUM_BOMB_MODULES; i < NUM_MODULE_SLOTS; ++i)
 				GLOBAL_SIS (ModuleSlots[i]) = EMPTY_SLOT + 2;
 
-			/* XXX : this should be unhardcoded eventually */
 			/* transport to Starbase */
-			GLOBAL (ShipStamp.origin.x) = STARBASE_INNER_X - SAFE_X;
-			GLOBAL (ShipStamp.origin.y) = STARBASE_INNER_Y - SAFE_Y;
+			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
 		}
 		else
 		{	/* 'Beating Game Differently' mode - never visited Starbase,
@@ -211,10 +208,10 @@ ExitConversation (RESPONSE_REF R)
 
 			/* XXX : this should be unhardcoded eventually */
 			/* transport to Earth itself */
-			GLOBAL (ShipStamp.origin.x) = EARTH_INNER_X - SAFE_X;
-			GLOBAL (ShipStamp.origin.y) = EARTH_INNER_Y - SAFE_Y;
+			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
 		}
-
+		
 		/* install Chmmr-supplied modules */
 		for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
 			GLOBAL_SIS (DriveSlots[i]) = FUSION_THRUSTER;
@@ -558,6 +555,15 @@ Intro (void)
 			CommData.AlienColorMap = SetAbsColorMapIndex (
 					CommData.AlienColorMap, 1
 					);
+			
+			// JMS_GFX: Use separate graphics in hires instead of colormap transform.
+			if (RESOLUTION_FACTOR > 0)
+			{
+				CommData.AlienFrameRes = CHMMR_RED_PMAP_ANIM;
+				CommData.AlienFrame = CaptureDrawable (
+					LoadGraphic (CommData.AlienFrameRes));
+			}
+				
 			switch (NumVisits++)
 			{
 				case 0:
diff -ruNp ./src.orig/uqm/comm/chmmr/resinst.h ./src/uqm/comm/chmmr/resinst.h
--- ./src.orig/uqm/comm/chmmr/resinst.h	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/chmmr/resinst.h	2017-10-23 11:41:33 -0700
@@ -1,4 +1,5 @@
 #define CHMMR_PMAP_ANIM "comm.chmmr.graphics"
+#define CHMMR_RED_PMAP_ANIM "comm.chmmr.red.graphics"
 #define CHMMR_FONT "comm.chmmr.font"
 #define CHMMR_COLOR_MAP "comm.chmmr.colortable"
 #define CHMMR_CONVERSATION_PHRASES "comm.chmmr.dialogue"
diff -ruNp ./src.orig/uqm/comm/comandr/comandr.c ./src/uqm/comm/comandr/comandr.c
--- ./src.orig/uqm/comm/comandr/comandr.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/comandr/comandr.c	2017-10-23 11:41:33 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
@@ -25,8 +27,11 @@
 		// for DeltaSISGauges(), DrawLanders()
 #include "libs/graphics/gfx_common.h"
 
-static LOCDATA commander_desc =
+#include "uqm/units.h" // JMS_GFX
+
+static LOCDATA commander_desc_1x =
 {
+	COMMANDER_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -93,6 +98,75 @@ static LOCDATA commander_desc =
 	NULL,
 };
 
+static LOCDATA commander_desc_4x =
+{
+	COMMANDER_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	COMMANDER_PMAP_ANIM, /* AlienFrame */
+	COMMANDER_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	COMMANDER_COLOR_MAP, /* AlienColorMap */
+	COMMANDER_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	COMMANDER_CONVERSATION_PHRASES, /* PlayerPhrases */
+	3, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* Blink */
+			1, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Running light */
+			10, /* StartIndex */
+			27, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			ONE_SECOND * 2, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Staticcy, noisy anim before radioactives arrive */
+			78, /* StartIndex */
+			6, /* NumFrames */
+			RANDOM_ANIM,/* AnimFlags */
+			0, ONE_SECOND / 5, /* FrameRate */
+			0, ONE_SECOND / 4, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		4, /* StartIndex */
+		6, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 ByeBye (RESPONSE_REF R)
 {
@@ -225,7 +299,11 @@ NoRadioactives (RESPONSE_REF R)
 			NPCPhrase (WHAT_KIND_OF_IDIOT);
 		else if (PLAYER_SAID (R, i_lost_my_lander))
 		{
-			NPCPhrase (HERE_IS_A_NEW_LANDER);
+			if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+				NPCPhrase (HERE_IS_A_NEW_LANDER_CLEAN);
+			else
+				NPCPhrase (HERE_IS_A_NEW_LANDER);
+				
 			++GLOBAL_SIS (NumLanders);
 			LockMutex (GraphicsLock);
 			DrawLanders ();
@@ -236,7 +314,11 @@ NoRadioactives (RESPONSE_REF R)
 		}
 		else if (PLAYER_SAID (R, i_lost_another_lander))
 		{
-			NPCPhrase (HERE_IS_ANOTHER_LANDER);
+			if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+				NPCPhrase (HERE_IS_ANOTHER_LANDER_CLEAN);
+			else
+				NPCPhrase (HERE_IS_ANOTHER_LANDER);
+				
 			++GLOBAL_SIS (NumLanders);
 			LockMutex (GraphicsLock);
 			DrawLanders ();
@@ -295,7 +377,11 @@ AskAfterRadios (RESPONSE_REF R)
 {
 	if (PLAYER_SAID (R, i_lost_my_lander))
 	{
-		NPCPhrase (HERE_IS_A_NEW_LANDER);
+		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+			NPCPhrase (HERE_IS_A_NEW_LANDER_CLEAN);
+		else
+			NPCPhrase (HERE_IS_A_NEW_LANDER);
+			
 		++GLOBAL_SIS (NumLanders);
 		LockMutex (GraphicsLock);
 		DrawLanders ();
@@ -306,7 +392,11 @@ AskAfterRadios (RESPONSE_REF R)
 	}
 	else if (PLAYER_SAID (R, i_lost_another_lander))
 	{
-		NPCPhrase (HERE_IS_ANOTHER_LANDER);
+		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+			NPCPhrase (HERE_IS_ANOTHER_LANDER_CLEAN);
+		else
+			NPCPhrase (HERE_IS_ANOTHER_LANDER);
+			
 		++GLOBAL_SIS (NumLanders);
 		LockMutex (GraphicsLock);
 		DrawLanders ();
@@ -397,7 +487,11 @@ TellMoonBase (RESPONSE_REF R)
 	}
 	else if (PLAYER_SAID (R, i_lost_my_lander))
 	{
-		NPCPhrase (HERE_IS_A_NEW_LANDER);
+		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+			NPCPhrase (HERE_IS_A_NEW_LANDER_CLEAN);
+		else
+			NPCPhrase (HERE_IS_A_NEW_LANDER);
+			
 		++GLOBAL_SIS (NumLanders);
 		LockMutex (GraphicsLock);
 		DrawLanders ();
@@ -408,7 +502,11 @@ TellMoonBase (RESPONSE_REF R)
 	}
 	else if (PLAYER_SAID (R, i_lost_another_lander))
 	{
-		NPCPhrase (HERE_IS_ANOTHER_LANDER);
+		if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
+			NPCPhrase (HERE_IS_ANOTHER_LANDER_CLEAN);
+		else
+			NPCPhrase (HERE_IS_ANOTHER_LANDER);
+			
 		++GLOBAL_SIS (NumLanders);
 		LockMutex (GraphicsLock);
 		DrawLanders ();
@@ -590,11 +688,23 @@ GiveRadios (RESPONSE_REF R)
 		SET_GAME_STATE (RADIOACTIVES_PROVIDED, 1);
 
 		NPCPhrase (FUEL_UP0);
-		NPCPhrase (FUEL_UP1);		
+		NPCPhrase (FUEL_UP1);
 		AlienTalkSegue (1);
 
 		LockMutex (GraphicsLock);
-		CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		
+		// JMS_GFX: Disable noisy static animation in hi-res.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+			CommData.AlienAmbientArray[0].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[1].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		}
+		// End color transform anim in lo-res.
+		else
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		
 		UnlockMutex (GraphicsLock);
 
 		XFormColorMap (GetColorMapAddress (
@@ -689,32 +799,70 @@ post_commander_enc (void)
 LOCDATA*
 init_commander_comm ()
 {
+	static LOCDATA commander_desc;
 	LOCDATA *retval;
-
+	
+	// JMS_GFX
+	switch (RESOLUTION_FACTOR)
+	{
+		case 2:
+			commander_desc = commander_desc_4x;
+			break;
+		case 1:
+			commander_desc = commander_desc_4x;
+			break;
+		case 0:
+		default:
+			commander_desc = commander_desc_1x;
+			break;
+	}
+	
 	commander_desc.init_encounter_func = Intro;
 	commander_desc.post_encounter_func = post_commander_enc;
 	commander_desc.uninit_encounter_func = uninit_commander;
-
+	
+	// Power on - have radioactives.
 	if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
 	{
+		// JMS_GFX: Disable noisy static animation in hi-res.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			commander_desc.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+			commander_desc.AlienAmbientArray[0].AnimFlags &= ~ANIM_DISABLED;
+			commander_desc.AlienAmbientArray[1].AnimFlags &= ~ANIM_DISABLED;
+		}
+
 		commander_desc.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		
 		// regular track -- let's make sure
 		commander_desc.AlienSongFlags &= ~LDASF_USE_ALTERNATE;
 	}
+	// Low power - no radioactives.
 	else
 	{	
+		// JMS_GFX: Enable noisy static animation in hi-res.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			commander_desc.AlienTalkDesc.AnimFlags |= PAUSE_TALKING;
+			commander_desc.AlienAmbientArray[0].AnimFlags |= ANIM_DISABLED;
+			commander_desc.AlienAmbientArray[1].AnimFlags |= ANIM_DISABLED;
+		}
+		
 		commander_desc.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
+		
 		// use alternate 'low-power' track if available
 		commander_desc.AlienAltSongRes = COMMANDER_LOWPOW_MUSIC;
 		commander_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 	}
-
-	commander_desc.AlienTextWidth = 143;
-	commander_desc.AlienTextBaseline.x = 164;
-	commander_desc.AlienTextBaseline.y = 20;
-
+	
+	// JMS_GFX
+	commander_desc.AlienTextWidth = RES_SIS_SCALE(143); // JMS_GFX
+	commander_desc.AlienTextBaseline.x = RES_SIS_SCALE(164); // JMS_GFX
+	commander_desc.AlienTextBaseline.y = RES_SIS_SCALE(20); // JMS_GFX
+	
 	SET_GAME_STATE (BATTLE_SEGUE, 0);
-	retval = &commander_desc;
 
+	retval = &commander_desc;
+	
 	return (retval);
 }
diff -ruNp ./src.orig/uqm/comm/comandr/strings.h ./src/uqm/comm/comandr/strings.h
--- ./src.orig/uqm/comm/comandr/strings.h	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/comandr/strings.h	2017-10-23 11:41:33 -0700
@@ -28,11 +28,13 @@ enum
 	ARE_YOU_SUPPLY_SHIP,
 	DO_YOU_HAVE_RADIO_THIS_TIME,
 	HERE_IS_ANOTHER_LANDER,
+	HERE_IS_ANOTHER_LANDER_CLEAN,
 	THE_WHAT_FROM_WHERE,
 	ABOUT_TIME,
 	MESSAGE_GARBLED_1,
 	MESSAGE_GARBLED_2,
 	HERE_IS_A_NEW_LANDER,
+	HERE_IS_A_NEW_LANDER_CLEAN,
 	THIS_MAY_SEEM_SILLY,
 	OK_THE_NAFS,
 	OK_THE_CAN,
diff -ruNp ./src.orig/uqm/comm/druuge/druugec.c ./src/uqm/comm/druuge/druugec.c
--- ./src.orig/uqm/comm/druuge/druugec.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/druuge/druugec.c	2017-10-23 11:41:33 -0700
@@ -25,9 +25,9 @@
 #include "uqm/sis.h"
 		// for DeltaSISGauges()
 
-
-static LOCDATA druuge_desc =
+static LOCDATA druuge_desc_1x =
 {
+	DRUUGE_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -46,7 +46,8 @@ static LOCDATA druuge_desc =
 	DRUUGE_CONVERSATION_PHRASES, /* PlayerPhrases */
 	11, /* NumAnimations */
 	{ /* AlienAmbientArray (ambient animations) */
-		{
+	
+		{	// Biggest flame
 			5, /* StartIndex */
 			4, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
@@ -54,7 +55,7 @@ static LOCDATA druuge_desc =
 			ONE_SECOND * 3 / 40, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
+		{	// Flame on the right
 			9, /* StartIndex */
 			4, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
@@ -62,7 +63,7 @@ static LOCDATA druuge_desc =
 			ONE_SECOND * 3 / 40, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
+		{	// Smallest flame (behind the biggest flame)
 			13, /* StartIndex */
 			6, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
@@ -70,7 +71,141 @@ static LOCDATA druuge_desc =
 			ONE_SECOND * 3 / 40, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
+		{	// Flashing eyes
+			19, /* StartIndex */
+			3, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			22, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
 		{
+			25, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			28, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			31, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			33, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND * 7, ONE_SECOND * 3,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			40, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND * 3 / 10, 0, /* FrameRate */
+			ONE_SECOND * 3 / 10, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 5, 0, /* FrameRate */
+			ONE_SECOND / 5, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		4, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND / 12, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
+static LOCDATA druuge_desc_4x =
+{
+	DRUUGE_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	DRUUGE_PMAP_ANIM, /* AlienFrame */
+	DRUUGE_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	DRUUGE_COLOR_MAP, /* AlienColorMap */
+	DRUUGE_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	DRUUGE_CONVERSATION_PHRASES, /* PlayerPhrases */
+	11, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+	
+		{	// Biggest flame
+			5, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND * 3 / 20, 0, /* FrameRate */
+			ONE_SECOND * 3 / 20, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// Flame on the right
+			9, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND * 3 / 24, 0, /* FrameRate */
+			ONE_SECOND * 3 / 24, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// Smallest flame (behind the biggest flame)
+			13, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND * 3 / 30, 0, /* FrameRate */
+			ONE_SECOND * 3 / 30, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// Flashing eyes
 			19, /* StartIndex */
 			3, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
@@ -909,7 +1044,22 @@ post_druuge_enc (void)
 LOCDATA*
 init_druuge_comm (void)
 {
+	static LOCDATA druuge_desc;
 	LOCDATA *retval;
+	
+	switch (RESOLUTION_FACTOR)
+	{
+		case 2:
+			druuge_desc = druuge_desc_4x;
+			break;
+		case 1:
+			druuge_desc = druuge_desc_4x;
+			break;
+		case 0:
+		default:
+			druuge_desc = druuge_desc_1x;
+			break;
+	}
 
 	SlaveryCount = 0;
 	AttemptedSalvage = FALSE;
@@ -919,7 +1069,7 @@ init_druuge_comm (void)
 	druuge_desc.uninit_encounter_func = uninit_druuge;
 
 	druuge_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
-	druuge_desc.AlienTextBaseline.y = 70;
+	druuge_desc.AlienTextBaseline.y = RES_SIS_SCALE(70);
 	druuge_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if ((GET_GAME_STATE (DRUUGE_MANNER) == 0
diff -ruNp ./src.orig/uqm/comm/ilwrath/ilwrathc.c ./src/uqm/comm/ilwrath/ilwrathc.c
--- ./src.orig/uqm/comm/ilwrath/ilwrathc.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/ilwrath/ilwrathc.c	2017-10-23 11:41:33 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA ilwrath_desc =
 {
+	ILWRATH_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -629,7 +630,7 @@ init_ilwrath_comm (void)
 	ilwrath_desc.uninit_encounter_func = uninit_ilwrath;
 
 	ilwrath_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
-	ilwrath_desc.AlienTextBaseline.y = 70;
+	ilwrath_desc.AlienTextBaseline.y = RES_SIS_SCALE(70);
 	ilwrath_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if (GET_GAME_STATE (PROBE_ILWRATH_ENCOUNTER)
diff -ruNp ./src.orig/uqm/comm/melnorm/melnorm.c ./src/uqm/comm/melnorm/melnorm.c
--- ./src.orig/uqm/comm/melnorm/melnorm.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/melnorm/melnorm.c	2017-10-23 11:41:33 -0700
@@ -33,6 +33,8 @@
 		// for xxx_DISASTER
 #include "uqm/sis.h"
 
+#include "libs/log.h"
+
 
 #define NUM_HISTORY_ITEMS 9
 #define NUM_EVENT_ITEMS 8
@@ -41,8 +43,9 @@
 
 static const NUMBER_SPEECH_DESC melnorme_numbers_english;
 
-static LOCDATA melnorme_desc =
+static LOCDATA melnorme_desc_1x =
 {
+	MELNORME_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -117,6 +120,139 @@ static LOCDATA melnorme_desc =
 	NULL,
 };
 
+static LOCDATA melnorme_desc_4x =
+{
+	MELNORME_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	MELNORME_PMAP_ANIM, /* AlienFrame */
+	MELNORME_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	MELNORME_COLOR_MAP, /* AlienColorMap */
+	MELNORME_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	MELNORME_CONVERSATION_PHRASES, /* PlayerPhrases */
+	11, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{
+			6, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 4,/* RestartRate */
+			(1 << 1), /* BlockMask */
+		},
+		{
+			11, /* StartIndex */
+			9, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 4,/* RestartRate */
+			(1 << 0), /* BlockMask */
+		},
+		{
+			20, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 10), /* BlockMask */
+		},
+		{
+			22, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 10), /* BlockMask */
+		},
+		{
+			24, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 11, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			35, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			37, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			39, /* StartIndex */
+			10, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			49, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			51, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			53, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 11, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			(1 << 2) | (1 << 3) /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		5, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	&melnorme_numbers_english, /* AlienNumberSpeech - default */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static COUNT melnorme_digit_names[] =
 {
 	ENUMERATE_ZERO,
@@ -1350,12 +1486,34 @@ NatureOfConversation (RESPONSE_REF R)
 
 		if (R == 0)
 		{
-				/* Melnorme reports any news and turns purple */
+			/* Melnorme reports any news and turns purple */
 			NPCPhrase (BUY_OR_SELL);
 			AlienTalkSegue(1);
-			XFormColorMap (GetColorMapAddress (
+			
+			if (RESOLUTION_FACTOR == 0)
+			{
+				XFormColorMap (GetColorMapAddress (
 					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
 					), ONE_SECOND / 2);
+			}
+			else if (RESOLUTION_FACTOR > 0)
+			{
+				LockMutex (GraphicsLock);
+				
+				CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+				CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
+				CommData.AlienAmbientArray[4].AnimFlags &= ~ANIM_DISABLED;
+				CommData.AlienAmbientArray[5].AnimFlags &= ~ANIM_DISABLED;
+				CommData.AlienAmbientArray[6].AnimFlags &= ~ANIM_DISABLED;
+				CommData.AlienAmbientArray[7].AnimFlags |= ANIM_DISABLED;
+				CommData.AlienAmbientArray[8].AnimFlags |= ANIM_DISABLED;
+				CommData.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
+				
+				CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 33);
+				
+				UnlockMutex (GraphicsLock);
+			} 
+			
 			AlienTalkSegue((COUNT)~0);
 		}
 		else if (PLAYER_SAID (R, why_turned_purple))
@@ -1440,12 +1598,34 @@ DoBluster (RESPONSE_REF R)
 {
 	if (PLAYER_SAID (R, trade_is_for_the_weak))
 	{
-		XFormColorMap (GetColorMapAddress (
+		NPCPhrase (WERE_NOT_AFRAID);
+		AlienTalkSegue ((COUNT)~0);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
 				), ONE_SECOND / 2);
+		}
+		else if (RESOLUTION_FACTOR > 0)
+		{
+			LockMutex (GraphicsLock);
+			
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[7].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[8].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[9].AnimFlags &= ~ANIM_DISABLED;
+			
+			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
+			
+			UnlockMutex (GraphicsLock);
+		}
 
 		SET_GAME_STATE (MELNORME_YACK_STACK2, 4);
-		NPCPhrase (WERE_NOT_AFRAID);
 	}
 	else if (PLAYER_SAID (R, why_blue_light))
 	{
@@ -1636,18 +1816,65 @@ DoFirstMeeting (RESPONSE_REF R)
 	}
 	else if (PLAYER_SAID (R, yes_really_testing))
 	{
-		XFormColorMap (GetColorMapAddress (
+		NPCPhrase (TEST_RESULTS);
+		AlienTalkSegue ((COUNT)~0);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
 				), ONE_SECOND / 2);
-
-		NPCPhrase (TEST_RESULTS);
+		}
+		else if (RESOLUTION_FACTOR > 0)
+		{
+			LockMutex (GraphicsLock);
+	
+			CommData.AlienAmbientArray[10].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[3].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[7].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[8].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
+			
+			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 0);
+			
+			UnlockMutex (GraphicsLock);
+		}
 	}
 	else if (PLAYER_SAID (R, we_apologize))
 	{
 		SET_GAME_STATE (MELNORME_ANGER, 0);
-		XFormColorMap (GetColorMapAddress (
+		
+		NPCPhrase (APOLOGY_ACCEPTED);
+		AlienTalkSegue ((COUNT)~0);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
 				), ONE_SECOND / 2);
+		}
+		else if (RESOLUTION_FACTOR > 0)
+		{
+			LockMutex (GraphicsLock);
+			
+			CommData.AlienAmbientArray[10].AnimFlags &= ~ANIM_DISABLED;	
+			CommData.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[3].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[7].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[8].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
+			
+			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 0);
+			
+			UnlockMutex (GraphicsLock);
+		}
 
 		NPCPhrase (APOLOGY_ACCEPTED);
 	}
@@ -1684,9 +1911,31 @@ DoMelnormeMiffed (RESPONSE_REF R)
 		}
 		SET_GAME_STATE (MELNORME_MIFFED_COUNT, miffed_count);
 
-		XFormColorMap (GetColorMapAddress (
+		AlienTalkSegue ((COUNT)~0);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
 				), ONE_SECOND / 2);
+		}
+		else if (RESOLUTION_FACTOR > 0)
+		{
+			LockMutex (GraphicsLock);
+			
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[7].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[8].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[9].AnimFlags &= ~ANIM_DISABLED;
+			
+			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
+			
+			UnlockMutex (GraphicsLock);
+		}
 	}
 	else if (PLAYER_SAID (R, explore_relationship))
 	{
@@ -1756,9 +2005,31 @@ DoMelnormePissed (RESPONSE_REF R)
 		}
 		SET_GAME_STATE (MELNORME_PISSED_COUNT, pissed_count);
 
-		XFormColorMap (GetColorMapAddress (
+		AlienTalkSegue ((COUNT)~0);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
 				), ONE_SECOND / 2);
+		}
+		else if (RESOLUTION_FACTOR > 0)
+		{
+			LockMutex (GraphicsLock);
+			
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[7].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[8].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[9].AnimFlags &= ~ANIM_DISABLED;
+			
+			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
+			
+			UnlockMutex (GraphicsLock);
+		} 
 	}
 	else if (PLAYER_SAID (R, beg_forgiveness))
 	{
@@ -1811,9 +2082,31 @@ DoMelnormeHate (RESPONSE_REF R)
 	}
 	SET_GAME_STATE (MELNORME_HATE_COUNT, hate_count);
 
-	XFormColorMap (GetColorMapAddress (
+	AlienTalkSegue ((COUNT)~0);
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		XFormColorMap (GetColorMapAddress (
 			SetAbsColorMapIndex (CommData.AlienColorMap, 2)
 			), ONE_SECOND / 2);
+	}
+	else if (RESOLUTION_FACTOR > 0)
+	{
+		LockMutex (GraphicsLock);
+		
+		CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
+		CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+		CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+		CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+		CommData.AlienAmbientArray[7].AnimFlags &= ~ANIM_DISABLED;
+		CommData.AlienAmbientArray[8].AnimFlags &= ~ANIM_DISABLED;
+		CommData.AlienAmbientArray[9].AnimFlags &= ~ANIM_DISABLED;
+
+		CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
+		
+		UnlockMutex (GraphicsLock);
+	} 
 
 	Response (well_if_thats_the_way_you_feel, ExitConversation);
 	Response (you_hate_us_so_we_go_away, ExitConversation);
@@ -1871,7 +2164,22 @@ post_melnorme_enc (void)
 LOCDATA*
 init_melnorme_comm (void)
 {
+	static LOCDATA melnorme_desc;
 	LOCDATA *retval;
+	
+	switch (RESOLUTION_FACTOR)
+	{
+		case 2:
+			melnorme_desc = melnorme_desc_4x;
+			break;
+		case 1:
+			melnorme_desc = melnorme_desc_4x;
+			break;
+		case 0:
+		default:
+			melnorme_desc = melnorme_desc_1x;
+			break;
+	}
 
 	melnorme_desc.init_encounter_func = Intro;
 	melnorme_desc.post_encounter_func = post_melnorme_enc;
@@ -1879,7 +2187,20 @@ init_melnorme_comm (void)
 
 	melnorme_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	melnorme_desc.AlienTextBaseline.y = 0;
-	melnorme_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
+	melnorme_desc.AlienTextWidth = SIS_TEXT_WIDTH - (16 << RESOLUTION_FACTOR);
+	
+	if (RESOLUTION_FACTOR > 0)
+	{
+		melnorme_desc.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[3].AnimFlags &= ~ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[7].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[8].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[10].AnimFlags |= ANIM_DISABLED;
+	}
 
 	local_stack0 = 0;
 	local_stack1 = 0;
@@ -1888,6 +2209,7 @@ init_melnorme_comm (void)
 
 	SET_GAME_STATE (BATTLE_SEGUE, 0);
 	AskedToBuy = FALSE;
+
 	retval = &melnorme_desc;
 
 	return (retval);
diff -ruNp ./src.orig/uqm/comm/mycon/myconc.c ./src/uqm/comm/mycon/myconc.c
--- ./src.orig/uqm/comm/mycon/myconc.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/mycon/myconc.c	2017-10-23 11:41:33 -0700
@@ -26,6 +26,7 @@
 
 static LOCDATA mycon_desc =
 {
+	MYCON_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp ./src.orig/uqm/comm/orz/orzc.c ./src/uqm/comm/orz/orzc.c
--- ./src.orig/uqm/comm/orz/orzc.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/orz/orzc.c	2017-10-23 11:41:33 -0700
@@ -22,9 +22,16 @@
 
 #include "uqm/build.h"
 
+#include "../../nameref.h"
+		//JMS_GFX: For LoadGraphic 
+
+#include "uqm/setup.h"
+		// for GraphicsLock
+
 
 static LOCDATA orz_desc =
 {
+	ORZ_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -41,7 +48,7 @@ static LOCDATA orz_desc =
 	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	ORZ_CONVERSATION_PHRASES, /* PlayerPhrases */
-	12 /* 13 */, /* NumAnimations */
+	14, /* NumAnimations */
 	{ /* AlienAmbientArray (ambient animations) */
 		{
 			4, /* StartIndex */
@@ -147,6 +154,14 @@ static LOCDATA orz_desc =
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
 			(1 << 10), /* BlockMask */
 		},
+		{
+			129, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | WAIT_TALKING | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
 	},
 	{ /* AlienTransitionDesc */
 		0, /* StartIndex */
@@ -162,7 +177,7 @@ static LOCDATA orz_desc =
 		0, /* AnimFlags */
 		ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
 		ONE_SECOND / 12, ONE_SECOND * 3 / 8, /* RestartRate */
-		0, /* BlockMask */
+		(1 << 13), /* BlockMask */
 	},
 	NULL, /* AlienNumberSpeech - none */
 	/* Filler for loaded resources */
@@ -224,11 +239,32 @@ ExitConversation (RESPONSE_REF R)
 	else if (PLAYER_SAID (R, about_andro_3)
 			|| PLAYER_SAID (R, must_know_about_androsyn))
 	{
+		// JMS_GFX: Use separate graphics in hires instead of colormap transform.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			int ii;
+			for (ii = 0; ii < CommData.NumAnimations - 1; ii++)
+				CommData.AlienAmbientArray[ii].AnimFlags |= ANIM_DISABLED;
+			
+			CommData.AlienAmbientArray[13].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienFrameRes = ORZ_ANGRY_PMAP_ANIM;
+			CommData.AlienFrame = CaptureDrawable (LoadGraphic (CommData.AlienFrameRes));
+		}
+		
 		if (PLAYER_SAID (R, about_andro_3))
 			NPCPhrase (BLEW_IT);
 		else
 			NPCPhrase (KNOW_TOO_MUCH);
-
+		
+		// JMS_GFX: Use separate graphics in hires instead of colormap transform.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			int ii;
+			AlienTalkSegue (1);
+			for (ii = 0; ii < CommData.NumAnimations - 1; ii++)
+				CommData.AlienAmbientArray[ii].AnimFlags &= ~ANIM_DISABLED;
+		}
+		
 		SET_GAME_STATE (ORZ_VISITS, 0);
 		SET_GAME_STATE (ORZ_MANNER, 2);
 		SET_GAME_STATE (BATTLE_SEGUE, 1);
@@ -656,7 +692,15 @@ Intro (void)
 	{
 		CommData.AlienColorMap =
 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
-
+		
+		// JMS_GFX: Use separate red angry graphics in hires instead of colormap transform.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			CommData.AlienFrameRes = ORZ_ANGRY_PMAP_ANIM;
+			CommData.AlienFrame = CaptureDrawable (
+				LoadGraphic (CommData.AlienFrameRes));
+		}
+			
 		NumVisits = GET_GAME_STATE (ORZ_VISITS);
 		switch (NumVisits++)
 		{
diff -ruNp ./src.orig/uqm/comm/orz/resinst.h ./src/uqm/comm/orz/resinst.h
--- ./src.orig/uqm/comm/orz/resinst.h	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/orz/resinst.h	2017-10-23 11:41:33 -0700
@@ -1,4 +1,5 @@
 #define ORZ_PMAP_ANIM "comm.orz.graphics"
+#define ORZ_ANGRY_PMAP_ANIM "comm.orz.angry.graphics"
 #define ORZ_FONT "comm.orz.font"
 #define ORZ_COLOR_MAP "comm.orz.colortable"
 #define ORZ_CONVERSATION_PHRASES "comm.orz.dialogue"
diff -ruNp ./src.orig/uqm/comm/pkunk/pkunkc.c ./src/uqm/comm/pkunk/pkunkc.c
--- ./src.orig/uqm/comm/pkunk/pkunkc.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/pkunk/pkunkc.c	2017-10-23 11:41:34 -0700
@@ -26,6 +26,7 @@
 
 static LOCDATA pkunk_desc =
 {
+	PKUNK_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp ./src.orig/uqm/comm/rebel/rebel.c ./src/uqm/comm/rebel/rebel.c
--- ./src.orig/uqm/comm/rebel/rebel.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/rebel/rebel.c	2017-10-23 11:41:34 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA yehat_desc =
 {
+	YEHAT_REBEL_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -436,7 +437,7 @@ init_rebel_yehat_comm (void)
 	yehat_desc.uninit_encounter_func = uninit_yehat;
 
 	yehat_desc.AlienTextBaseline.x = SIS_SCREEN_WIDTH * 2 / 3;
-	yehat_desc.AlienTextBaseline.y = 60;
+	yehat_desc.AlienTextBaseline.y = RES_SIS_SCALE(60);
 	yehat_desc.AlienTextWidth = (SIS_TEXT_WIDTH - 16) * 2 / 3;
 
 	// use alternate "Rebels" track if available
diff -ruNp ./src.orig/uqm/comm/shofixt/shofixt.c ./src/uqm/comm/shofixt/shofixt.c
--- ./src.orig/uqm/comm/shofixt/shofixt.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/shofixt/shofixt.c	2017-10-23 11:41:34 -0700
@@ -23,8 +23,9 @@
 #include "uqm/gameev.h"
 
 
-static LOCDATA shofixti_desc =
+static LOCDATA shofixti_desc_1x =
 {
+	SHOFIXTI_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -156,6 +157,125 @@ static LOCDATA shofixti_desc =
 	NULL,
 };
 
+static LOCDATA shofixti_desc_4x =
+{
+	SHOFIXTI_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SHOFIXTI_PMAP_ANIM, /* AlienFrame */
+	SHOFIXTI_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	SHOFIXTI_COLOR_MAP, /* AlienColorMap */
+	SHOFIXTI_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SHOFIXTI_CONVERSATION_PHRASES, /* PlayerPhrases */
+	8, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* 0 bottom left star */
+			1, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 2), /* BlockMask */
+		},
+		{ /* 1 bottom right star */
+			7, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 3), /* BlockMask */
+		},
+		{ /* 2 top left star */
+			13, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 0), /* BlockMask */
+		},
+		{ /* 3 top right star */
+			18, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 1), /* BlockMask */
+		},
+		{ /* 4 eye blink */
+			23, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 5 right hand */
+			26, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			(ONE_SECOND >> 1), (ONE_SECOND >> 1) * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 6 radar */
+			34, /* StartIndex */
+			8, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			ONE_SECOND / 10, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 7 left hand */
+			42, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			(ONE_SECOND >> 1), (ONE_SECOND >> 1) * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+#ifdef WHEN_GRAPHICS_ARE_DONE
+		{ /* 8 upper-middle left star */
+			45, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 10), /* BlockMask */
+		},
+#endif
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		29, /* StartIndex */
+		5, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 20, 0, /* FrameRate */
+		ONE_SECOND / 15, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static RESPONSE_REF shofixti_name;
 
 static void
@@ -634,7 +754,22 @@ post_shofixti_enc (void)
 LOCDATA*
 init_shofixti_comm (void)
 {
+	static LOCDATA shofixti_desc;
 	LOCDATA *retval;
+	
+	switch (RESOLUTION_FACTOR)
+	{
+		case 2:
+			shofixti_desc = shofixti_desc_4x;
+			break;
+		case 1:
+			shofixti_desc = shofixti_desc_4x;
+			break;
+		case 0:
+		default:
+			shofixti_desc = shofixti_desc_1x;
+			break;
+	}
 
 	shofixti_desc.init_encounter_func = Intro;
 	shofixti_desc.post_encounter_func = post_shofixti_enc;
diff -ruNp ./src.orig/uqm/comm/slyhome/slyhome.c ./src/uqm/comm/slyhome/slyhome.c
--- ./src.orig/uqm/comm/slyhome/slyhome.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/slyhome/slyhome.c	2017-10-23 11:41:34 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA slylandro_desc =
 {
+	SLYLANDRO_HOME_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp ./src.orig/uqm/comm/slyland/slyland.c ./src/uqm/comm/slyland/slyland.c
--- ./src.orig/uqm/comm/slyland/slyland.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/slyland/slyland.c	2017-10-23 11:41:34 -0700
@@ -30,6 +30,7 @@ static const NUMBER_SPEECH_DESC probe_nu
 
 static LOCDATA slylandro_desc =
 {
+	SLYLANDRO_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -386,8 +387,8 @@ CombatIsInevitable (RESPONSE_REF R)
 					dy = 9812 - LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
 
 					NPCPhrase (THIS_IS_PROBE_40);
+					NPCPhrase (THIS_IS_PROBE_41);
 					sayCoord (dy);
-					NPCPhrase_splice (THIS_IS_PROBE_41);
 					sayCoord (dx);
 					NPCPhrase (THIS_IS_PROBE_42);
 
diff -ruNp ./src.orig/uqm/comm/spahome/spahome.c ./src/uqm/comm/spahome/spahome.c
--- ./src.orig/uqm/comm/spahome/spahome.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/spahome/spahome.c	2017-10-23 11:41:34 -0700
@@ -24,8 +24,9 @@
 #include "uqm/gameev.h"
 
 
-static LOCDATA spahome_desc =
+static LOCDATA spahome_desc_1x =
 {
+	SPATHI_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -183,6 +184,178 @@ static LOCDATA spahome_desc =
 	NULL,
 };
 
+static LOCDATA spahome_desc_4x =
+{
+	SPATHI_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SPATHI_HOME_PMAP_ANIM, /* AlienFrame */
+	SPATHI_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	SPATHI_HOME_COLOR_MAP, /* AlienColorMap */
+	SPATHI_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SPATHI_HOME_CONVERSATION_PHRASES, /* PlayerPhrases */
+	15, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{
+			1, /* StartIndex */
+			3, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0 | (1 << 14), /* BlockMask */
+		},
+		{
+			4, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0 | (1 << 14), /* BlockMask */
+		},
+		{
+			9, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 10) | (1 << 11) | (1 << 14), /* BlockMask */
+		},
+		{
+			13, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND / 20, 0, /* RestartRate */
+			(1 << 4) | (1 << 5) | (1 << 14) /* BlockMask */
+		},
+		{
+			19, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 3) | (1 << 5) | (1 << 14), /* BlockMask */
+		},
+		{
+			22, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* RestartRate */
+			(1 << 3) | (1 << 4)
+			| (1 << 10) | (1 << 14), /* BlockMask */
+		},
+		{
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 10) | (1 << 14), /* BlockMask */
+		},
+		{
+			29, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
+			0 | (1 << 14), /* BlockMask */
+		},
+		{
+			32, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND / 20, 0, /* RestartRate */
+			(1 << 9) | (1 << 10) | (1 << 14), /* BlockMask */
+		},
+		{
+			39, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 8) | (1 << 10) | (1 << 14), /* BlockMask */
+		},
+		{
+			42, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, 0, /* RestartRate */
+			(1 << 8) | (1 << 9)
+			| (1 << 6) | (1 << 2)
+			| (1 << 11) | (1 << 5)
+			 | (1 << 14), /* BlockMask */
+		},
+		{
+			46, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* RestartRate */
+			(1 << 2) | (1 << 10) | (1 << 14), /* BlockMask */
+		},
+		{
+			50, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND / 20, 0, /* RestartRate */
+			(1 << 13) | (1 << 14), /* BlockMask */
+		},
+		{
+			56, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 12) | (1 << 14), /* BlockMask */
+		},
+		{
+			59, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | WAIT_TALKING | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			0, 0,/* RestartRate */
+			(1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) 
+			| (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7) 
+			| (1 << 8) | (1 << 9) | (1 << 10) | (1 << 11) 
+			| (1 << 12) | (1 << 13) , /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 ExitConversation (RESPONSE_REF R)
 {
@@ -581,9 +754,26 @@ AllianceOffer (RESPONSE_REF R)
 	if (PLAYER_SAID (R, misunderstanding))
 	{
 		NPCPhrase (JUST_MISUNDERSTANDING);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND / 4);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
+					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
+					), ONE_SECOND / 4);
+		}
+		else
+		{
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		}
 
 		SET_GAME_STATE (SPATHI_MANNER, 3);
 		SET_GAME_STATE (SPATHI_VISITS, 0);
@@ -757,9 +947,26 @@ SpathiCouncil (RESPONSE_REF R)
 	else if (PLAYER_SAID (R, good_password))
 	{
 		NPCPhrase (YES_GOOD_PASSWORD);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND / 4);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
+					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
+					), ONE_SECOND / 4);
+		}
+		else
+		{
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		}
 
 		SET_GAME_STATE (KNOW_SPATHI_PASSWORD, 1);
 		SET_GAME_STATE (SPATHI_HOME_VISITS, 0);
@@ -901,6 +1108,10 @@ static void
 Intro (void)
 {
 	BYTE Manner;
+	
+	if (RESOLUTION_FACTOR > 0)
+		CommData.AlienFrame = SetAbsFrameIndex 
+			(CommData.AlienFrame, 59);
 
 	Manner = GET_GAME_STATE (SPATHI_MANNER);
 	if (Manner == 2)
@@ -917,22 +1128,73 @@ Intro (void)
 	}
 	else if (ActivateStarShip (SPATHI_SHIP, CHECK_ALLIANCE) == GOOD_GUY)
 	{
-		CommData.AlienColorMap =
+		if (RESOLUTION_FACTOR == 0)
+		{
+			CommData.AlienColorMap =
 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		}
+		else
+		{
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 1;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+			
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		}
+		
 		SpathiAllies ((RESPONSE_REF)0);
 	}
 	else if (GET_GAME_STATE (SPATHI_PARTY))
 	{
-		CommData.AlienColorMap =
+		if (RESOLUTION_FACTOR == 0)
+		{
+			CommData.AlienColorMap =
 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		}
+		else
+		{
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 1;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		}
+		
 		SpathiParty ((RESPONSE_REF)0);
 	}
 	else if (GET_GAME_STATE (SPATHI_QUEST))
 	{
 		if (GET_GAME_STATE (LIED_ABOUT_CREATURES) < 2)
 		{
-			CommData.AlienColorMap =
+			if (RESOLUTION_FACTOR == 0)
+			{
+				CommData.AlienColorMap =
 					SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+			}
+			else
+			{
+				COUNT i = 0;
+				COUNT limit = CommData.NumAnimations - 1;
+			
+				for (i = 0; i < limit; i++)
+					CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+				CommData.AlienFrame = SetAbsFrameIndex 
+					(CommData.AlienFrame, 0);
+				
+				CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+			}
+		
 			SpathiQuest ((RESPONSE_REF)0);
 		}
 		else
@@ -945,16 +1207,50 @@ Intro (void)
 	}
 	else if (GET_GAME_STATE (KNOW_SPATHI_QUEST))
 	{
-		CommData.AlienColorMap =
+		if (RESOLUTION_FACTOR == 0)
+		{
+			CommData.AlienColorMap =
 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		}
+		else
+		{
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 1;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		}
+		
 		LearnQuest ((RESPONSE_REF)0);
 	}
 	else if (GET_GAME_STATE (KNOW_SPATHI_PASSWORD)
 			&& (GET_GAME_STATE (FOUND_PLUTO_SPATHI)
 			|| GET_GAME_STATE (SPATHI_HOME_VISITS) != 7))
 	{
-		CommData.AlienColorMap =
+		if (RESOLUTION_FACTOR == 0)
+		{
+			CommData.AlienColorMap =
 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		}
+		else
+		{
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 1;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		}
+		
 		SpathiCouncil ((RESPONSE_REF)0);
 	}
 	else
@@ -989,7 +1285,22 @@ post_spahome_enc (void)
 LOCDATA*
 init_spahome_comm ()
 {
+	static LOCDATA spahome_desc;
 	LOCDATA *retval;
+	
+	switch (RESOLUTION_FACTOR)
+	{
+		case 2:
+			spahome_desc = spahome_desc_4x;
+			break;
+		case 1:
+			spahome_desc = spahome_desc_4x;
+			break;
+		case 0:
+		default:
+			spahome_desc = spahome_desc_1x;
+			break;
+	}
 
 	spahome_desc.init_encounter_func = Intro;
 	spahome_desc.post_encounter_func = post_spahome_enc;
@@ -1003,6 +1314,17 @@ init_spahome_comm ()
 	spahome_desc.AlienAltSongRes = SPAHOME_MUSIC;
 	spahome_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 
+	if (RESOLUTION_FACTOR > 0)
+	{
+		COUNT i;
+		COUNT limit = spahome_desc.NumAnimations;
+	
+		for (i = 0; i < limit; i++)
+			spahome_desc.AlienAmbientArray[i].AnimFlags |= ANIM_DISABLED;
+			
+		spahome_desc.AlienTalkDesc.AnimFlags |= PAUSE_TALKING;
+	}
+
 	if (GET_GAME_STATE (SPATHI_MANNER) == 3)
 	{
 		SET_GAME_STATE (BATTLE_SEGUE, 0);
diff -ruNp ./src.orig/uqm/comm/spathi/spathic.c ./src/uqm/comm/spathi/spathic.c
--- ./src.orig/uqm/comm/spathi/spathic.c	2017-10-23 11:42:15 -0700
+++ ./src/uqm/comm/spathi/spathic.c	2017-10-23 11:41:34 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA spathi_desc =
 {
+	SPATHI_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp ./src.orig/uqm/comm/starbas/starbas.c ./src/uqm/comm/starbas/starbas.c
--- ./src.orig/uqm/comm/starbas/starbas.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm/starbas/starbas.c	2017-10-23 11:41:34 -0700
@@ -35,8 +35,9 @@ static void TellMission (RESPONSE_REF R)
 static void SellMinerals (RESPONSE_REF R);
 
 
-static LOCDATA commander_desc =
+static LOCDATA commander_desc_1x =
 {
+	COMMANDER_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -159,6 +160,123 @@ static LOCDATA commander_desc =
 	NULL,
 };
 
+static LOCDATA commander_desc_4x =
+{
+	COMMANDER_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	COMMANDER_PMAP_ANIM, /* AlienFrame */
+	COMMANDER_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	COMMANDER_COLOR_MAP, /* AlienColorMap */
+	COMMANDER_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	STARBASE_CONVERSATION_PHRASES, /* PlayerPhrases */
+	9, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* Blink */
+			1, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Running light */
+			10, /* StartIndex */
+			27, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			ONE_SECOND * 2, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Flagship picture */
+			37, /* StartIndex */
+			1, /* NumFrames */
+			0, /* AnimFlags */
+			0, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Flagship side lights */
+			38, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND * 2, 0, /* FrameRate */
+			0, ONE_SECOND * 12, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Arc welder 1 */
+			40, /* StartIndex */
+			8, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Arc welder 2 */
+			48, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Arc welder 3 */
+			54, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Arc welder 4 */
+			60, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Arc welder 5 */
+			67, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		4, /* StartIndex */
+		6, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static DWORD CurBulletinMask;
 
 static void
@@ -1949,23 +2067,40 @@ post_starbase_enc (void)
 LOCDATA*
 init_starbase_comm ()
 {
+	static LOCDATA commander_desc;
 	LOCDATA *retval;
 
+	switch (RESOLUTION_FACTOR)
+	{
+		case 2:
+			commander_desc = commander_desc_4x;
+			break;
+		case 1:
+			commander_desc = commander_desc_4x;
+			break;
+		case 0:
+		default:
+			commander_desc = commander_desc_1x;
+			break;
+	}
+	
 	commander_desc.init_encounter_func = Intro;
 	commander_desc.post_encounter_func = post_starbase_enc;
 	commander_desc.uninit_encounter_func = uninit_starbase;
 
-	commander_desc.AlienTextWidth = 143;
-	commander_desc.AlienTextBaseline.x = 164;
-	commander_desc.AlienTextBaseline.y = 20;
+	commander_desc.AlienTextWidth = RES_SIS_SCALE(143); // JMS_GFX
+	commander_desc.AlienTextBaseline.x = RES_SIS_SCALE(164); // JMS_GFX
+	commander_desc.AlienTextBaseline.y = RES_SIS_SCALE(20); // JMS_GFX
 
 	// use alternate Starbase track if available
 	commander_desc.AlienAltSongRes = STARBASE_ALT_MUSIC;
 	commander_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
-
+	
+		
 	CurBulletinMask = 0;
 	SET_GAME_STATE (BATTLE_SEGUE, 0);
+	
 	retval = &commander_desc;
-
+	
 	return (retval);
 }
diff -ruNp ./src.orig/uqm/comm/supox/supoxc.c ./src/uqm/comm/supox/supoxc.c
--- ./src.orig/uqm/comm/supox/supoxc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm/supox/supoxc.c	2017-10-23 11:41:34 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA supox_desc =
 {
+	SUPOX_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp ./src.orig/uqm/comm/syreen/syreenc.c ./src/uqm/comm/syreen/syreenc.c
--- ./src.orig/uqm/comm/syreen/syreenc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm/syreen/syreenc.c	2017-10-23 11:41:34 -0700
@@ -23,9 +23,13 @@
 #include "libs/sound/sound.h"
 #include "uqm/build.h"
 
+#include "uqm/setup.h"
+		// for GraphicsLock
 
-static LOCDATA syreen_desc =
+
+static LOCDATA syreen_desc_1x =
 {
+	SYREEN_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -190,6 +194,191 @@ static LOCDATA syreen_desc =
 	NULL,
 };
 
+static LOCDATA syreen_desc_4x =
+{
+	SYREEN_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SYREEN_PMAP_ANIM, /* AlienFrame */
+	SYREEN_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	SYREEN_COLOR_MAP, /* AlienColorMap */
+	SYREEN_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SYREEN_CONVERSATION_PHRASES, /* PlayerPhrases */
+	17, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{
+			5, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			7, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			9, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			11, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			13, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			15, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 12), /* BlockMask */
+		},
+		{
+			17, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			19, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 13),
+		},
+		{
+			21, /* StartIndex */
+			6, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			27, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 14), /* BlockMask */
+		},
+		{
+			31, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			37, /* StartIndex */
+			4, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5), /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM
+					| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 6, 0, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND, /* RestartRate */
+			(1 << 7) | (1 << 14), /* BlockMask */
+		},
+		{
+			48, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+					| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND * 2 / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND,/* RestartRate */
+			(1 << 9) | (1 << 13), /* BlockMask */
+		},
+		{
+			51, /* StartIndex */
+			13, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM 
+				| WAIT_TALKING | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			0, 0,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			64, /* StartIndex */
+			13, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM 
+				| WAIT_TALKING | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			0, 0,/* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		4, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 FriendlyExit (RESPONSE_REF R)
 {
@@ -219,10 +408,33 @@ FriendlyExit (RESPONSE_REF R)
 		NPCPhrase (SEX_GOODBYE);
 
 		AlienTalkSegue (2);
-		XFormColorMap (GetColorMapAddress (
+
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
 				), ONE_SECOND / 2);
-		AlienTalkSegue ((COUNT)~0);
+				
+			AlienTalkSegue ((COUNT)~0);
+		}
+		else
+		{
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations;
+			
+			CommData.AlienAmbientArray[limit-1].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+			
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+			
+			AlienTalkSegue ((COUNT)~0);
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+			
+			CommData.AlienAmbientArray[limit-2].AnimFlags |= ANIM_DISABLED;
+		}
 
 		SET_GAME_STATE (PLAYER_HAD_SEX, 1);
 		SET_GAME_STATE (PLAYER_HAVING_SEX, 0);
@@ -282,11 +494,31 @@ Foreplay (RESPONSE_REF R)
 			NPCPhrase (HERES_REWARD);
 		else
 			NPCPhrase (ABOUT_US);
+		
 		NPCPhrase (MORE_COMFORTABLE);
 		AlienTalkSegue (1);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
+					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
+					), ONE_SECOND);
+		}
+		else
+		{
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 2;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags |= ANIM_DISABLED;
+				
+			CommData.AlienAmbientArray[limit].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 63);
+				
+			CommData.AlienTalkDesc.AnimFlags |= PAUSE_TALKING;
+		}
+				
 		AlienTalkSegue ((COUNT)~0);
 
 		SET_GAME_STATE (PLAYER_HAVING_SEX, 1);
@@ -861,7 +1093,22 @@ post_syreen_enc (void)
 LOCDATA*
 init_syreen_comm (void)
 {
+	static LOCDATA syreen_desc;
 	LOCDATA *retval;
+	
+	switch (RESOLUTION_FACTOR)
+	{
+		case 2:
+			syreen_desc = syreen_desc_4x;
+			break;
+		case 1:
+			syreen_desc = syreen_desc_4x;
+			break;
+		case 0:
+		default:
+			syreen_desc = syreen_desc_1x;
+			break;
+	}
 
 	syreen_desc.init_encounter_func = Intro;
 	syreen_desc.post_encounter_func = post_syreen_enc;
diff -ruNp ./src.orig/uqm/comm/talkpet/talkpet.c ./src/uqm/comm/talkpet/talkpet.c
--- ./src.orig/uqm/comm/talkpet/talkpet.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm/talkpet/talkpet.c	2017-10-23 11:41:34 -0700
@@ -28,6 +28,7 @@
 
 static LOCDATA talkpet_desc =
 {
+	TALKING_PET_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp ./src.orig/uqm/comm/thradd/thraddc.c ./src/uqm/comm/thradd/thraddc.c
--- ./src.orig/uqm/comm/thradd/thraddc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm/thradd/thraddc.c	2017-10-23 11:41:34 -0700
@@ -26,6 +26,7 @@
 
 static LOCDATA thradd_desc =
 {
+	THRADD_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp ./src.orig/uqm/comm/umgah/umgahc.c ./src/uqm/comm/umgah/umgahc.c
--- ./src.orig/uqm/comm/umgah/umgahc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm/umgah/umgahc.c	2017-10-23 11:41:34 -0700
@@ -25,6 +25,7 @@
 
 static LOCDATA umgah_desc =
 {
+	UMGAH_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp ./src.orig/uqm/comm/urquan/urquanc.c ./src/uqm/comm/urquan/urquanc.c
--- ./src.orig/uqm/comm/urquan/urquanc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm/urquan/urquanc.c	2017-10-23 11:41:34 -0700
@@ -22,6 +22,7 @@
 
 static LOCDATA urquan_desc =
 {
+	URQUAN_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp ./src.orig/uqm/comm/utwig/utwigc.c ./src/uqm/comm/utwig/utwigc.c
--- ./src.orig/uqm/comm/utwig/utwigc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm/utwig/utwigc.c	2017-10-23 11:41:34 -0700
@@ -26,6 +26,7 @@
 
 static LOCDATA utwig_desc =
 {
+	UTWIG_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -968,7 +969,7 @@ init_utwig_comm (void)
 	utwig_desc.uninit_encounter_func = uninit_utwig;
 
 	utwig_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
-	utwig_desc.AlienTextBaseline.y = 70;
+	utwig_desc.AlienTextBaseline.y = RES_SIS_SCALE(70);
 	utwig_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if (GET_GAME_STATE (UTWIG_HAVE_ULTRON))
diff -ruNp ./src.orig/uqm/comm/vux/vuxc.c ./src/uqm/comm/vux/vuxc.c
--- ./src.orig/uqm/comm/vux/vuxc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm/vux/vuxc.c	2017-10-23 11:41:34 -0700
@@ -20,8 +20,9 @@
 #include "resinst.h"
 #include "strings.h"
 
-static LOCDATA vux_desc =
+static LOCDATA vux_desc_1x =
 {
+	VUX_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -200,6 +201,195 @@ static LOCDATA vux_desc =
 	NULL,
 };
 
+static LOCDATA vux_desc_4x =
+{
+	VUX_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	VUX_PMAP_ANIM, /* AlienFrame */
+	VUX_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* (SIS_TEXT_WIDTH - 16) >> 1, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	VUX_COLOR_MAP, /* AlienColorMap */
+	VUX_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	VUX_CONVERSATION_PHRASES, /* PlayerPhrases */
+	18, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{
+			12, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			15, /* StartIndex */
+			5, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			20, /* StartIndex */
+			14, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND / 30, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			34, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			6, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			47, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			58, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			61, /* StartIndex */
+			4, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			65, /* StartIndex */
+			4, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			69, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			71, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			74, /* StartIndex */
+			6, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			80, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* RestartRate */
+			(1 << 14), /* BlockMask */
+		},
+		{
+			85, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			90, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* RestartRate */
+			(1 << 12), /* BlockMask */
+		},
+		{
+			95, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 5, ONE_SECOND * 5,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			99, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 5, ONE_SECOND * 5,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			103, /* StartIndex */
+			13, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | WAIT_TALKING | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			0, 0,/* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		11, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		(1 << 18), /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 CombatIsInevitable (RESPONSE_REF R)
 {
@@ -213,9 +403,28 @@ CombatIsInevitable (RESPONSE_REF R)
 		NPCPhrase (FOOL_AIEE1);
 
 		AlienTalkSegue (1);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND / 4);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
+					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
+					), ONE_SECOND / 4);
+		}
+		else
+		{
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 1;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags |= ANIM_DISABLED;
+				
+			CommData.AlienAmbientArray[limit].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 115);
+				
+			CommData.AlienTalkDesc.AnimFlags |= PAUSE_TALKING;
+		}
+		
 		AlienTalkSegue ((COUNT)~0);
 
 		SET_GAME_STATE (VUX_BEAST_ON_SHIP, 0);
@@ -770,7 +979,22 @@ post_vux_enc (void)
 LOCDATA*
 init_vux_comm (void)
 {
+	static LOCDATA vux_desc;
 	LOCDATA *retval;
+	
+	switch (RESOLUTION_FACTOR)
+	{
+		case 2:
+			vux_desc = vux_desc_4x;
+			break;
+		case 1:
+			vux_desc = vux_desc_4x;
+			break;
+		case 0:
+		default:
+			vux_desc = vux_desc_1x;
+			break;
+	}
 
 	vux_desc.init_encounter_func = Intro;
 	vux_desc.post_encounter_func = post_vux_enc;
diff -ruNp ./src.orig/uqm/comm/yehat/yehatc.c ./src/uqm/comm/yehat/yehatc.c
--- ./src.orig/uqm/comm/yehat/yehatc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm/yehat/yehatc.c	2017-10-23 11:41:34 -0700
@@ -25,8 +25,9 @@
 #include "libs/mathlib.h"
 
 
-static LOCDATA yehat_desc =
+static LOCDATA yehat_desc_1x =
 {
+	YEHAT_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -191,6 +192,309 @@ static LOCDATA yehat_desc =
 	NULL,
 };
 
+
+static LOCDATA yehat_desc_2x =
+{
+	YEHAT_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	YEHAT_PMAP_ANIM, /* AlienFrame */
+	YEHAT_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* (SIS_TEXT_WIDTH - 16) * 2 / 3, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	YEHAT_COLOR_MAP, /* AlienColorMap */
+	YEHAT_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	YEHAT_CONVERSATION_PHRASES, /* PlayerPhrases */
+	13, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* right hand-wing tapping keyboard; front guy */
+			4, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{ /* left hand-wing tapping keyboard; front guy */
+			7, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{
+			10, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5) | (1 << 12),
+		},
+		{
+			13, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5),
+		},
+		{
+			16, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			0,
+		},
+		{
+			21, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			(1 << 2) | (1 << 3) | (1 << 12),
+		},
+		{
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			29, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			32, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			35, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			38, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 2) | (1 << 5),
+		},
+	},
+	{ /* AlienTransitionDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		3, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
+static LOCDATA yehat_desc_4x =
+{
+	YEHAT_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	YEHAT_PMAP_ANIM, /* AlienFrame */
+	YEHAT_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* (SIS_TEXT_WIDTH - 16) * 2 / 3, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	YEHAT_COLOR_MAP, /* AlienColorMap */
+	YEHAT_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	YEHAT_CONVERSATION_PHRASES, /* PlayerPhrases */
+	13, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* right hand-wing tapping keyboard; front guy */
+			4, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{ /* left hand-wing tapping keyboard; front guy */
+			7, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{
+			10, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5) | (1 << 12),
+		},
+		{
+			13, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5),
+		},
+		{
+			16, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			0,
+		},
+		{
+			21, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			(1 << 2) | (1 << 3) | (1 << 12),
+		},
+		{
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			29, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			32, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			35, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			38, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 2) | (1 << 5),
+		},
+	},
+	{ /* AlienTransitionDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		3, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 ExitConversation (RESPONSE_REF R)
 {
@@ -661,14 +965,29 @@ post_yehat_enc (void)
 LOCDATA*
 init_yehat_comm (void)
 {
+	static LOCDATA yehat_desc;
 	LOCDATA *retval;
+	
+	switch (RESOLUTION_FACTOR)
+	{
+		case 2:
+			yehat_desc = yehat_desc_4x;
+			break;
+		case 1:
+			yehat_desc = yehat_desc_2x;
+			break;
+		case 0:
+		default:
+			yehat_desc = yehat_desc_1x;
+			break;
+	}
 
 	yehat_desc.init_encounter_func = Intro;
 	yehat_desc.post_encounter_func = post_yehat_enc;
 	yehat_desc.uninit_encounter_func = uninit_yehat;
 
 	yehat_desc.AlienTextBaseline.x = SIS_SCREEN_WIDTH * 2 / 3;
-	yehat_desc.AlienTextBaseline.y = 60;
+	yehat_desc.AlienTextBaseline.y = RES_SIS_SCALE(60);
 	yehat_desc.AlienTextWidth = (SIS_TEXT_WIDTH - 16) * 2 / 3;
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) != WON_LAST_BATTLE)
diff -ruNp ./src.orig/uqm/comm/zoqfot/zoqfotc.c ./src/uqm/comm/zoqfot/zoqfotc.c
--- ./src.orig/uqm/comm/zoqfot/zoqfotc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm/zoqfot/zoqfotc.c	2017-10-23 11:41:34 -0700
@@ -27,7 +27,7 @@
 #define ZOQ_FG_COLOR WHITE_COLOR
 #define ZOQ_BG_COLOR BLACK_COLOR
 #define ZOQ_BASE_X (TEXT_X_OFFS + ((SIS_TEXT_WIDTH >> 1) >> 1))
-#define ZOQ_BASE_Y 24
+#define ZOQ_BASE_Y RES_SIS_SCALE(24)
 #define ZOQ_TALK_INDEX 18
 #define ZOQ_TALK_FRAMES 5
 #define FOT_TO_ZOQ 23
@@ -35,13 +35,14 @@
 #define PIK_FG_COLOR WHITE_COLOR
 #define PIK_BG_COLOR BLACK_COLOR
 #define PIK_BASE_X (SIS_SCREEN_WIDTH - (TEXT_X_OFFS + ((SIS_TEXT_WIDTH >> 1) >> 1)))
-#define PIK_BASE_Y 24
+#define PIK_BASE_Y RES_SIS_SCALE(24)
 #define PIK_TALK_INDEX 29
 #define PIK_TALK_FRAMES 2
 #define FOT_TO_PIK 26
 
 static LOCDATA zoqfot_desc =
 {
+	ZOQFOTPIK_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp ./src.orig/uqm/comm.c ./src/uqm/comm.c
--- ./src.orig/uqm/comm.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #define COMM_INTERNAL
 #include "comm.h"
 
@@ -55,18 +57,24 @@
 // XXX: was 32 picked experimentally?
 #define OSCILLOSCOPE_RATE   (ONE_SECOND / 32)
 
+// JMS_GFX
+#define RESPONSE_EXTRA_Y (RES_CASE(0,12,22))
+
 // Maximum comm animation frame rate (actual execution rate)
 // A gfx frame is not always produced during an execution frame,
 // and several animations are combined into one gfx frame.
 // The rate was originally 120fps which allowed for more animation
 // precision which is ultimately wasted on the human eye anyway.
 // The highest known stable animation rate is 40fps, so that's what we use.
-#define COMM_ANIM_RATE   (ONE_SECOND / 40)
+//
+// JMS: Changed this back to 120 fps since hires4x seems to like it... 
+#define COMM_ANIM_RATE   (ONE_SECOND / 120)
 
 static CONTEXT AnimContext;
 
 LOCDATA CommData;
 UNICODE shared_phrase_buf[2048];
+FONT ComputerFont;
 
 static BOOLEAN TalkingFinished;
 static CommIntroMode curIntroMode = CIM_DEFAULT;
@@ -105,7 +113,7 @@ static FRAME TextCacheFrame;
 
 RECT CommWndRect = {
 	// default values; actually inited by HailAlien()
-	{SIS_ORG_X, SIS_ORG_Y},
+	{0, 0}, //was {SIS_ORG_X, SIS_ORG_Y}, // JMS_GFX
 	{0, 0}
 };
 
@@ -157,7 +165,8 @@ add_text (int status, TEXT *pTextIn)
 	static COORD last_baseline;
 	BOOLEAN eol;
 	CONTEXT OldContext = NULL;
-	
+	COUNT computerOn = 0;
+
 	BatchGraphics ();
 
 	maxchars = (COUNT)~0;
@@ -192,13 +201,13 @@ add_text (int status, TEXT *pTextIn)
 	}
 	else if (GetContextFontLeading (&leading), status <= -4)
 	{
-		text_width = (SIZE) (SIS_SCREEN_WIDTH - 8 - (TEXT_X_OFFS << 2));
+		text_width = (SIZE) (SIS_SCREEN_WIDTH - (8 << RESOLUTION_FACTOR) - (TEXT_X_OFFS << 2)); // JMS_GFX
 
 		pText = pTextIn;
 	}
 	else
 	{
-		text_width = (SIZE) (SIS_SCREEN_WIDTH - 8 - (TEXT_X_OFFS << 2));
+		text_width = (SIZE) (SIS_SCREEN_WIDTH - (8 << RESOLUTION_FACTOR) - (TEXT_X_OFFS << 2)); // JMS_GFX
 
 		switch (status)
 		{
@@ -219,7 +228,7 @@ add_text (int status, TEXT *pTextIn)
 
 		maxchars = pTextIn->CharCount;
 		locText = *pTextIn;
-		locText.baseline.x -= 8;
+		locText.baseline.x -= (8 << RESOLUTION_FACTOR) - 4 * RESOLUTION_FACTOR; // JMS_GFX
 		locText.CharCount = (COUNT)~0;
 		locText.pStr = STR_BULLET;
 		font_DrawText (&locText);
@@ -273,8 +282,109 @@ add_text (int status, TEXT *pTextIn)
 		else
 		{
 			// Alien speech
-			font_DrawTracedText (pText,
-					CommData.AlienTextFColor, CommData.AlienTextBColor);
+			if (CommData.AlienConv == ORZ_CONVERSATION)
+			{
+				// BW : special case for the Orz conversations
+				// the character $ is recycled as a marker to
+				// switch from and to computer font
+				
+				const char *ptr;
+				RECT rect;
+				COORD baselinex = pText->baseline.x;
+				COORD width = 0;
+				COUNT remChars = pText->CharCount;
+			        // Remaining chars until end of line within width
+				const char *bakptr;
+				COUNT bakChars = remChars;
+				COUNT bakcompOn = computerOn;
+				FONT bakFont = SetContextFont(ComputerFont);
+				
+				SetContextFont(bakFont);
+				ptr = pText->pStr;
+				bakptr = ptr;
+				
+				// We need to manually center the line because
+				// the computer font is larger than the Orzfont
+				
+				// This loop computes the width of the line
+				while (remChars > 0)
+					{
+						while ((*ptr != '$') && remChars > 0)
+							{
+								getCharFromString (&ptr);
+								remChars--;
+							}
+						
+						pText->CharCount -= remChars;
+						TextRect (pText, &rect, NULL);
+						
+						width += rect.extent.width;
+						
+						if (*ptr == '$')
+							{
+								getCharFromString (&ptr);
+								remChars--;
+								computerOn = 1 - computerOn;
+								if (computerOn)
+									SetContextFont (ComputerFont);
+								else
+									SetContextFont (CommData.AlienFont);
+							}
+						pText->CharCount = remChars;
+						pText->pStr = ptr;
+					}
+
+				// This to simulate a centered line
+				pText->baseline.x = baselinex - (width >> 1);
+				pText->align = ALIGN_LEFT;
+				
+				// Put everything back in place for the
+				// actual display 
+				remChars = bakChars;
+				pText->CharCount = bakChars;
+				ptr = bakptr;
+				pText->pStr = bakptr;
+				computerOn = bakcompOn;
+				SetContextFont(bakFont);
+				
+				// This loop is used to look up for $
+				while (remChars > 0)
+					{
+						while ((*ptr != '$') && remChars > 0)
+							{
+								getCharFromString (&ptr);
+								remChars--;
+							}
+						
+						pText->CharCount -= remChars;
+						TextRect (pText, &rect, NULL);
+						
+						font_DrawTracedText (pText,
+								     CommData.AlienTextFColor, CommData.AlienTextBColor);
+						
+						pText->baseline.x += rect.extent.width;
+						
+						if (*ptr == '$')
+							{
+								getCharFromString (&ptr);
+								remChars--;
+								computerOn = 1 - computerOn;
+								if (computerOn)
+									SetContextFont (ComputerFont);
+								else
+									SetContextFont (CommData.AlienFont);
+							}
+						pText->CharCount = remChars;
+						pText->pStr = ptr;
+					}
+				pText->baseline.x = baselinex;
+				pText->align = ALIGN_CENTER;
+			}
+			else
+			{
+				// Normal case : other races than Orz
+				font_DrawTracedText (pText, CommData.AlienTextFColor, CommData.AlienTextBColor);
+			}
 		}
 	} while (!eol && maxchars);
 	pText->pStr = pStr;
@@ -416,19 +526,23 @@ RefreshResponses (ENCOUNTER_STATE *pES)
 	BYTE response;
 	SIZE leading;
 	STAMP s;
-
+	BYTE extra_y; // JMS_GFX
+	
 	SetContext (SpaceContext);
 	GetContextFontLeading (&leading);
 	BatchGraphics ();
 
 	DrawSISComWindow ();
-	y = SLIDER_Y + SLIDER_HEIGHT + 1;
+	y = SLIDER_Y + SLIDER_HEIGHT + (1 << RESOLUTION_FACTOR); // JMS_GFX
 	for (response = pES->top_response; response < pES->num_responses;
 			++response)
 	{
-		pES->response_list[response].response_text.baseline.x = TEXT_X_OFFS + 8;
-		pES->response_list[response].response_text.baseline.y = y + leading;
+		extra_y = (response == pES->top_response ? 0 : RESPONSE_EXTRA_Y); // JMS_GFX
+		
+		pES->response_list[response].response_text.baseline.x = TEXT_X_OFFS + (8 << RESOLUTION_FACTOR); // JMS_GFX
+		pES->response_list[response].response_text.baseline.y = y + leading + extra_y; // JMS_GFX
 		pES->response_list[response].response_text.align = ALIGN_LEFT;
+		
 		if (response == pES->cur_response)
 			y = add_text (-1, &pES->response_list[response].response_text);
 		else
@@ -471,7 +585,7 @@ FeedbackPlayerPhrase (UNICODE *pStr)
 		TEXT ct;
 
 		ct.baseline.x = SIS_SCREEN_WIDTH >> 1;
-		ct.baseline.y = SLIDER_Y + SLIDER_HEIGHT + 13;
+		ct.baseline.y = SLIDER_Y + SLIDER_HEIGHT + (13 << RESOLUTION_FACTOR); // JMS_GFX
 		ct.align = ALIGN_CENTER;
 		ct.CharCount = (COUNT)~0;
 
@@ -480,7 +594,7 @@ FeedbackPlayerPhrase (UNICODE *pStr)
 		SetContextForeGroundColor (COMM_RESPONSE_INTRO_TEXT_COLOR);
 		font_DrawText (&ct);
 
-		ct.baseline.y += 16;
+		ct.baseline.y += (16 << RESOLUTION_FACTOR); // JMS_GFX
 		SetContextForeGroundColor (COMM_FEEDBACK_TEXT_COLOR);
 		ct.pStr = pStr;
 		add_text (-4, &ct);
@@ -804,9 +918,9 @@ typedef struct summary_state
 static BOOLEAN
 DoConvSummary (SUMMARY_STATE *pSS)
 {
-#define DELTA_Y_SUMMARY 8
-#define MAX_SUMM_ROWS ((SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT) \
-			/ DELTA_Y_SUMMARY) - 1
+#define DELTA_Y_SUMMARY (8 << RESOLUTION_FACTOR) // JMS_GFX
+	//#define MAX_SUMM_ROWS ((SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT) / DELTA_Y_SUMMARY
+#define MAX_SUMM_ROWS (SLIDER_Y	/ DELTA_Y_SUMMARY) - (1 << RESOLUTION_FACTOR) // JMS_GFX
 
 	if (!pSS->Initialized)
 	{
@@ -843,7 +957,7 @@ DoConvSummary (SUMMARY_STATE *pSS)
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_SCREEN_WIDTH;
-		r.extent.height = SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2;
+		r.extent.height = SLIDER_Y; //SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + (2 << RESOLUTION_FACTOR) + 16 * RESOLUTION_FACTOR; // JMS_GFX
 
 		LockMutex (GraphicsLock);
 		SetContext (AnimContext);
@@ -853,7 +967,7 @@ DoConvSummary (SUMMARY_STATE *pSS)
 		SetContextForeGroundColor (COMM_HISTORY_TEXT_COLOR);
 
 		r.extent.width -= 2 + 2;
-		t.baseline.x = 2;
+		t.baseline.x = 2 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_LEFT;
 		t.baseline.y = DELTA_Y_SUMMARY;
 		SetContextFont (TinyFont);
@@ -1031,8 +1145,7 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 
 			LockMutex (GraphicsLock);
 			BatchGraphics ();
-			add_text (-2,
-					&pES->response_list[pES->cur_response].response_text);
+			// add_text (-2, &pES->response_list[pES->cur_response].response_text);
 
 			pES->cur_response = response;
 
@@ -1041,13 +1154,14 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 			if (response < pES->top_response)
 			{
 				pES->top_response = 0;
-				RefreshResponses (pES);
+				// RefreshResponses (pES);
 			}
 			else if (y > SIS_SCREEN_HEIGHT)
 			{
 				pES->top_response = response;
-				RefreshResponses (pES);
+				// RefreshResponses (pES);
 			}
+			RefreshResponses (pES);
 			UnbatchGraphics ();
 			UnlockMutex (GraphicsLock);
 		}
@@ -1208,6 +1322,7 @@ HailAlien (void)
 
 	ES.InputFunc = DoCommunication;
 	PlayerFont = LoadFont (PLAYER_FONT);
+	ComputerFont = LoadFont (COMPUTER_FONT);
 
 	CommData.AlienFrame = CaptureDrawable (
 			LoadGraphic (CommData.AlienFrameRes));
@@ -1232,9 +1347,13 @@ HailAlien (void)
 
 	// init subtitle cache context
 	TextCacheContext = CreateContext ("TextCacheContext");
+	// TextCacheFrame = CaptureDrawable (
+	// 		CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
+	// 		SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2, 1));
+	// BW: previous lines were just a complex and wrong way of obtaining 107
 	TextCacheFrame = CaptureDrawable (
 			CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
-			SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2, 1));
+			SLIDER_Y, 1));
 	SetContext (TextCacheContext);
 	SetContextFGFrame (TextCacheFrame);
 	TextBack = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x10), 0x00);
@@ -1256,12 +1375,17 @@ HailAlien (void)
 		SetContextFGFrame (Screen);
 		GetFrameRect (CommData.AlienFrame, &r);
 		r.extent.width = SIS_SCREEN_WIDTH;
+		CommWndRect.corner.x = SIS_ORG_X; // JMS_GFX: Added these lines because of the 
+		CommWndRect.corner.y = SIS_ORG_Y; // changed init of CommWndRect in the beginning of comm.c
 		CommWndRect.extent = r.extent;
 		
 		SetTransitionSource (NULL);
 		BatchGraphics ();
 		if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 		{
+			// set the position of outtakes comm
+			CommWndRect.corner.x = ((SCREEN_WIDTH - CommWndRect.extent.width) / 2); // JMS_GFX
+			CommWndRect.corner.y = RES_CASE(5,0,0); // JMS_GFX
 			r.corner = CommWndRect.corner;
 			SetContextClipRect (&r);
 		}
@@ -1317,6 +1441,7 @@ HailAlien (void)
 	DestroyDrawable (ReleaseDrawable (TextCacheFrame));
 
 	DestroyFont (PlayerFont);
+	DestroyFont (ComputerFont);
 
 	// Some support code tests either of these to see if the
 	// game is currently in comm or encounter
diff -ruNp ./src.orig/uqm/comm.h ./src/uqm/comm.h
--- ./src.orig/uqm/comm.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/comm.h	2017-10-23 11:41:34 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef _COMM_H
 #define _COMM_H
 
@@ -26,8 +28,8 @@
 
 #ifdef COMM_INTERNAL
 
-#define SLIDER_Y 107
-#define SLIDER_HEIGHT 15
+#define SLIDER_Y ((107 << RESOLUTION_FACTOR) + RES_CASE(0,6,46)) // JMS_GFX
+#define SLIDER_HEIGHT RES_CASE(15, 15, 30) // JMS_GFX
 
 #include "commanim.h"
 
@@ -101,8 +103,8 @@ signaledStopTalkingAnim (void)
 
 #endif
 
-#define TEXT_X_OFFS 1
-#define TEXT_Y_OFFS 1
+#define TEXT_X_OFFS (1 << RESOLUTION_FACTOR) // JMS_GFX
+#define TEXT_Y_OFFS (1 << RESOLUTION_FACTOR) // JMS_GFX
 #define SIS_TEXT_WIDTH (SIS_SCREEN_WIDTH - (TEXT_X_OFFS << 1))
 
 extern void init_communication (void);
diff -ruNp ./src.orig/uqm/commanim.c ./src/uqm/commanim.c
--- ./src.orig/uqm/commanim.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/commanim.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #define COMM_INTERNAL
 #include "commanim.h"
 
@@ -465,6 +467,37 @@ ProcessCommAnimations (BOOLEAN FullRedra
 					CanTalk = FALSE;
 				}
 			}
+			
+			// BW: to be checked. I've tried to remove what's supposed to be removed while keeping the Syreen zoom-in feature.
+			// It may have to be re-programmed in the new commanim style.
+			if (pSeq->AnimType == PICTURE_ANIM
+				&& (ADPtr->AnimFlags & CommData.AlienTalkDesc.AnimFlags & WAIT_TALKING)
+				&& pSeq->Direction != NO_DIR)
+			{
+				// JMS: Cut marked animations short when starting talk.
+				// The animations are marked with FAST_STOP_AT_TALK_START in the races' comm source codes.
+				if (ADPtr->AnimFlags & FAST_STOP_AT_TALK_START)
+				{	CanTalk = TRUE;
+					//pSeq->AnimObj.CurFrame = SetAbsFrameIndex(pSeq->AnimObj.CurFrame, ADPtr->StartIndex);
+					pSeq->Direction = NO_DIR;
+				}
+			}
+			
+			// JMS: This handles ambient animations which should occur only during talk
+			// A lot of conditions are necessary to eliminate unwanted animations
+			// from the duration of talk transition!
+			if (pSeq->AnimType == PICTURE_ANIM
+				&& ADPtr->AnimFlags & WHEN_TALKING 
+				&& (!(CommData.AlienTalkDesc.AnimFlags & WAIT_TALKING) 
+					|| (CommData.AlienTalkDesc.AnimFlags & TALK_INTRO)
+					|| (CommData.AlienTalkDesc.AnimFlags & TALK_DONE))
+				&& !(CommData.AlienTransitionDesc.AnimFlags & PAUSE_TALKING)
+				&& pSeq->Direction != NO_DIR)
+			{
+				// Stop the anim if not talking
+				pSeq->Direction = NO_DIR;
+			}
+			
 		}
 		// All ambient animations have been processed. Advance the mask.
 		ActiveMask = NextActiveMask;
diff -ruNp ./src.orig/uqm/commanim.h ./src/uqm/commanim.h
--- ./src.orig/uqm/commanim.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/commanim.h	2017-10-23 11:41:34 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef _COMMANIM_H
 #define _COMMANIM_H
 
@@ -52,7 +54,11 @@
 #define TALK_DONE (1 << 6)
 		// In AlienTransitionDesc: indicates a transition to silent state
 		// In AlienTalkDesc: signals the end of talking animation
-#define ANIM_DISABLED (1 << 7)
+#define WHEN_TALKING (1L << 7) // JMS
+#define ANIM_DISABLED (1L << 8) // BW (needed for news anchor and animated background)
+
+#define FAST_STOP_AT_TALK_START (TALK_DONE) // JMS: If there's a very loooong animation, it can be forced to stop when talking with this.
+// (otherwise there'll be nasty, unwanted pauses in the conversation.) 
 
 #define COLORXFORM_ANIM PAUSE_TALKING
 
@@ -68,9 +74,10 @@ typedef struct
 	BYTE NumFrames;
 			// Number of frames in the animation.
 
-	BYTE AnimFlags;
+	COUNT AnimFlags;
 			// One of RANDOM_ANIM, CIRCULAR_ANIM, or YOYO_ANIM
 			// plus flags (WAIT_TALKING, ANIM_DISABLED)
+			// JMS: Changed from BYTE to COUNT to house more possible flags
 
 	COUNT BaseFrameRate;
 			// Minimum interframe delay
@@ -89,7 +96,7 @@ typedef struct
 			// due to the image overlap conflicts.
 } ANIMATION_DESC;
 
-#define MAX_ANIMATIONS 20
+#define MAX_ANIMATIONS 30 // JMS: Was 20
 
 
 #ifdef COMM_INTERNAL
diff -ruNp ./src.orig/uqm/commglue.h ./src/uqm/commglue.h
--- ./src.orig/uqm/commglue.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/commglue.h	2017-10-23 11:41:34 -0700
@@ -23,36 +23,6 @@
 #include "resinst.h"
 #include "libs/sound/trackplayer.h"
 
-typedef enum {
-	ARILOU_CONVERSATION,
-	CHMMR_CONVERSATION,
-	COMMANDER_CONVERSATION,
-	ORZ_CONVERSATION,
-	PKUNK_CONVERSATION,
-	SHOFIXTI_CONVERSATION,
-	SPATHI_CONVERSATION,
-	SUPOX_CONVERSATION,
-	THRADD_CONVERSATION,
-	UTWIG_CONVERSATION,
-	VUX_CONVERSATION,
-	YEHAT_CONVERSATION,
-	MELNORME_CONVERSATION,
-	DRUUGE_CONVERSATION,
-	ILWRATH_CONVERSATION,
-	MYCON_CONVERSATION,
-	SLYLANDRO_CONVERSATION,
-	UMGAH_CONVERSATION,
-	URQUAN_CONVERSATION,
-	ZOQFOTPIK_CONVERSATION,
-	SYREEN_CONVERSATION,
-	BLACKURQ_CONVERSATION,
-	TALKING_PET_CONVERSATION,
-	SLYLANDRO_HOME_CONVERSATION,
-	URQUAN_DRONE_CONVERSATION,
-	YEHAT_REBEL_CONVERSATION,
-	INVALID_CONVERSATION,
-} CONVERSATION;
-
 extern LOCDATA CommData;
 extern UNICODE shared_phrase_buf[2048];
 
diff -ruNp ./src.orig/uqm/confirm.c ./src/uqm/confirm.c
--- ./src.orig/uqm/confirm.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/confirm.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "controls.h"
 #include "colors.h"
 #include "settings.h"
@@ -32,8 +34,8 @@
 #include <stdlib.h>
 
 
-#define CONFIRM_WIN_WIDTH 80
-#define CONFIRM_WIN_HEIGHT 22
+#define CONFIRM_WIN_WIDTH (80 << RESOLUTION_FACTOR) // JMS_GFX
+#define CONFIRM_WIN_HEIGHT (22 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 DrawConfirmationWindow (BOOLEAN answer)
@@ -53,12 +55,12 @@ DrawConfirmationWindow (BOOLEAN answer)
 			SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
 
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + 8;
+	t.baseline.y = r.corner.y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	t.pStr = GAME_STRING (QUITMENU_STRING_BASE); // "Really Quit?"
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
-	t.baseline.y += 10;
+	t.baseline.y += (10 << RESOLUTION_FACTOR); // JMS_GFX
 	t.baseline.x = r.corner.x + (r.extent.width >> 2);
 	t.pStr = GAME_STRING (QUITMENU_STRING_BASE + 1); // "Yes"
 	SetContextForeGroundColor (answer ? MENU_HIGHLIGHT_COLOR : MENU_TEXT_COLOR);
diff -ruNp ./src.orig/uqm/controls.h ./src/uqm/controls.h
--- ./src.orig/uqm/controls.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/controls.h	2017-10-23 11:41:34 -0700
@@ -58,6 +58,10 @@ enum {
 	KEY_MENU_EDIT_CANCEL,
 	KEY_MENU_SEARCH,
 	KEY_MENU_NEXT,
+	KEY_MENU_TOGGLEMAP, // JMS: For showing SC1-era starmap
+	KEY_DEBUG_2,  // JMS: Secondary debug key
+	KEY_DEBUG_3,  // JMS: Tertiary debug key
+	KEY_DEBUG_4,  // JMS: Quaternary debug key
 	KEY_MENU_ANY, /* abstract char key */
 	NUM_MENU_KEYS
 };
@@ -161,6 +165,7 @@ typedef struct textentry_state
 } TEXTENTRY_STATE;
 
 extern BOOLEAN DoTextEntry (TEXTENTRY_STATE *pTES);
+extern BOOLEAN DoTextEntrySavename (TEXTENTRY_STATE *pTES);
 
 #endif
 
diff -ruNp ./src.orig/uqm/credits.c ./src/uqm/credits.c
--- ./src.orig/uqm/credits.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/credits.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "credits.h"
 
 #include "controls.h"
@@ -32,10 +34,10 @@
 #include <math.h>
 
 // Rates in pixel lines per second
-#define CREDITS_BASE_RATE   9
-#define CREDITS_MAX_RATE    130
+#define CREDITS_BASE_RATE   (20 << RESOLUTION_FACTOR) // JMS_GFX
+#define CREDITS_MAX_RATE    (130 << RESOLUTION_FACTOR) // JMS_GFX
 // Maximum frame rate
-#define CREDITS_FRAME_RATE  36
+#define CREDITS_FRAME_RATE  (RES_CASE(36,54,72)) // JMS_GFX
 
 #define CREDITS_TIMEOUT   (ONE_SECOND * 5)
 
@@ -267,6 +269,8 @@ Credits_RenderTextFrame (CONTEXT TempCon
 		{	// DOES NOT COMPUTE! :)
 			continue;
 		}
+		
+		x <<= RESOLUTION_FACTOR; // JMS_GFX
 
 		switch (c)
 		{
@@ -803,9 +807,8 @@ Credits (BOOLEAN WithOuttakes)
 	UnlockMutex (GraphicsLock);
 
 	// set the position of outtakes comm
-	CommWndRect.corner.x = (screenRect.extent.width - CommWndRect.extent.width)
-			/ 2;
-	CommWndRect.corner.y = 5;
+	CommWndRect.corner.x = ((screenRect.extent.width - CommWndRect.extent.width) / 2); // JMS_GFX
+	CommWndRect.corner.y = RES_CASE(5,0,0); // JMS_GFX
 	
 	InitCredits ();
 	SetInputCallback (on_input_frame);
diff -ruNp ./src.orig/uqm/cyborg.c ./src/uqm/cyborg.c
--- ./src.orig/uqm/cyborg.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/cyborg.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX:	 - Added RESOLUTION_FACTORs to LONG_RANGE_WEAPONs and CLOSE_RANGE_WEAPONs
+//			 - Amended some constant values with RESOLUTION_FACTOR
+
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "colors.h"
 #include "collide.h"
 #include "element.h"
@@ -31,17 +36,19 @@
 
 COUNT
 PlotIntercept (ELEMENT *ElementPtr0, ELEMENT *ElementPtr1,
-		COUNT max_turns, COUNT margin_of_error)
+			   COUNT max_turns, COUNT margin_of_error)
 {
-	SIZE dy;
-	SIZE time_y_0, time_y_1;
-	POINT dst[2];
+	SDWORD dy;
+	SDWORD time_y_0, time_y_1;
+	DPOINT dst[2];
 	RECT r0 = {{0, 0}, {0, 0}};
 	RECT r1 = {{0, 0}, {0, 0}};
-	SIZE dx_0, dy_0, dx_1, dy_1;
-
+	SDWORD dx_0, dy_0, dx_1, dy_1; // JMS:These were SIZE. No overflows now.
+	
 	if ((ElementPtr0->state_flags | ElementPtr1->state_flags) & FINITE_LIFE)
 	{
+		//log_add (log_Debug, "E0:%d, E1:%d, max:%d",ElementPtr0->life_span,ElementPtr1->life_span, max_turns);
+		
 		if (!(ElementPtr0->state_flags & FINITE_LIFE))
 		{
 			if (ElementPtr1->life_span < max_turns)
@@ -60,17 +67,19 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 				max_turns = ElementPtr1->life_span;
 		}
 	}
-
-	dst[0] = ElementPtr0->current.location;
-	GetCurrentVelocityComponents (&ElementPtr0->velocity, &dx_0, &dy_0);
-	dx_0 = (SIZE)VELOCITY_TO_WORLD ((long)dx_0 * (long)max_turns);
-	dy_0 = (SIZE)VELOCITY_TO_WORLD ((long)dy_0 * (long)max_turns);
-
-	dst[1] = ElementPtr1->current.location;
-	GetCurrentVelocityComponents (&ElementPtr1->velocity, &dx_1, &dy_1);
-	dx_1 = (SIZE)VELOCITY_TO_WORLD ((long)dx_1 * (long)max_turns);
-	dy_1 = (SIZE)VELOCITY_TO_WORLD ((long)dy_1 * (long)max_turns);
-
+	
+	dst[0].x = (SDWORD)ElementPtr0->current.location.x;
+	dst[0].y = (SDWORD)ElementPtr0->current.location.y;
+	GetCurrentVelocityComponentsSdword (&ElementPtr0->velocity, &dx_0, &dy_0);
+	dx_0 = (SDWORD)VELOCITY_TO_WORLD ((long)dx_0 * (long)max_turns);
+	dy_0 = (SDWORD)VELOCITY_TO_WORLD ((long)dy_0 * (long)max_turns);
+	
+	dst[1].x = (SDWORD)ElementPtr1->current.location.x;
+	dst[1].y = (SDWORD)ElementPtr1->current.location.y;
+	GetCurrentVelocityComponentsSdword (&ElementPtr1->velocity, &dx_1, &dy_1);
+	dx_1 = (SDWORD)VELOCITY_TO_WORLD ((long)dx_1 * (long)max_turns);
+	dy_1 = (SDWORD)VELOCITY_TO_WORLD ((long)dy_1 * (long)max_turns);
+	
 	if (margin_of_error)
 	{
 		dst[1].y -= margin_of_error;
@@ -81,25 +90,25 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 	{
 		GetFrameRect (ElementPtr0->IntersectControl.IntersectStamp.frame, &r0);
 		GetFrameRect (ElementPtr1->IntersectControl.IntersectStamp.frame, &r1);
-
+		
 		dst[0].y += DISPLAY_TO_WORLD (r0.corner.y);
 		dst[1].y += DISPLAY_TO_WORLD (r1.corner.y);
 		time_y_0 = DISPLAY_TO_WORLD (r0.extent.height);
 		time_y_1 = DISPLAY_TO_WORLD (r1.extent.height);
 	}
-
+	
 	dy = dst[1].y - dst[0].y;
 	time_y_0 = dy - time_y_0 + 1;
 	time_y_1 = dy + time_y_1 - 1;
 	dy = dy_0 - dy_1;
-
+	
 	if ((time_y_0 <= 0 && time_y_1 >= 0)
-			|| (time_y_0 > 0 && dy >= time_y_0)
-			|| (time_y_1 < 0 && dy <= time_y_1))
+		|| (time_y_0 > 0 && dy >= time_y_0)
+		|| (time_y_1 < 0 && dy <= time_y_1))
 	{
-		SIZE dx;
-		SIZE time_x_0, time_x_1;
-
+		SDWORD dx;
+		SDWORD time_x_0, time_x_1;
+		
 		if (margin_of_error)
 		{
 			dst[1].x -= margin_of_error;
@@ -113,23 +122,23 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 			time_x_0 = DISPLAY_TO_WORLD (r0.extent.width);
 			time_x_1 = DISPLAY_TO_WORLD (r1.extent.width);
 		}
-
+		
 		dx = dst[1].x - dst[0].x;
 		time_x_0 = dx - time_x_0 + 1;
 		time_x_1 = dx + time_x_1 - 1;
 		dx = dx_0 - dx_1;
-
+		
 		if ((time_x_0 <= 0 && time_x_1 >= 0)
-				|| (time_x_0 > 0 && dx >= time_x_0)
-				|| (time_x_1 < 0 && dx <= time_x_1))
+			|| (time_x_0 > 0 && dx >= time_x_0)
+			|| (time_x_1 < 0 && dx <= time_x_1))
 		{
 			if (dx == 0 && dy == 0)
 				time_y_0 = time_y_1 = 0;
 			else
 			{
-				SIZE t;
+				SDWORD t;
 				long time_beg, time_end, fract;
-
+				
 				if (time_y_1 < 0)
 				{
 					t = time_y_0;
@@ -146,7 +155,7 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 					dy = -dy;
 				if (dy < time_y_1)
 					time_y_1 = dy;
-
+				
 				if (time_x_1 < 0)
 				{
 					t = time_x_0;
@@ -163,7 +172,7 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 					dx = -dx;
 				if (dx < time_x_1)
 					time_x_1 = dx;
-
+				
 				if (dx == 0)
 				{
 					time_beg = time_y_0;
@@ -179,100 +188,103 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 				else
 				{
 					long time_x, time_y;
-
+					
 					time_x = (long)time_x_0 * (long)dy;
 					time_y = (long)time_y_0 * (long)dx;
 					time_beg = time_x < time_y ? time_y : time_x;
-
+					
 					time_x = (long)time_x_1 * (long)dy;
 					time_y = (long)time_y_1 * (long)dx;
 					time_end = time_x > time_y ? time_y : time_x;
-
+					
 					fract = (long)dx * (long)dy;
 				}
-
+				
 				if ((time_beg *= max_turns) < fract)
 					time_y_0 = 0;
 				else
-					time_y_0 = (SIZE)(time_beg / fract);
-
+					time_y_0 = (SDWORD)(time_beg / fract);
+				
 				if (time_end >= fract) /* just in case of overflow */
 					time_y_1 = max_turns - 1;
 				else
-					time_y_1 = (SIZE)((time_end * max_turns) / fract);
+					time_y_1 = (SDWORD)((time_end * max_turns) / fract);
 			}
-
+			
 			if (time_y_0 <= time_y_1)
 			{
 				if (margin_of_error != 0)
 					return ((COUNT)time_y_0 + 1);
 				else
 				{
-					POINT Pt0, Pt1;
+					DPOINT Pt0, Pt1;
 					VELOCITY_DESC Velocity0, Velocity1;
 					INTERSECT_CONTROL Control0, Control1;
-
-					Pt0 = ElementPtr0->current.location;
+					
+					Pt0.x = (SDWORD)ElementPtr0->current.location.x;
+					Pt0.y = (SDWORD)ElementPtr0->current.location.y;
 					Velocity0 = ElementPtr0->velocity;
 					Control0 = ElementPtr0->IntersectControl;
-
-					Pt1 = ElementPtr1->current.location;
+					
+					Pt1.x = (SDWORD)ElementPtr1->current.location.x;
+					Pt1.y = (SDWORD)ElementPtr1->current.location.y;
 					Velocity1 = ElementPtr1->velocity;
 					Control1 = ElementPtr1->IntersectControl;
-
+					
 					if (time_y_0)
 					{
-						GetNextVelocityComponents (&Velocity0, &dx_0, &dy_0, time_y_0);
+						GetNextVelocityComponentsSdword (&Velocity0, &dx_0, &dy_0, time_y_0);
 						Pt0.x += dx_0;
 						Pt0.y += dy_0;
 						Control0.EndPoint.x = WORLD_TO_DISPLAY (Pt0.x);
 						Control0.EndPoint.y = WORLD_TO_DISPLAY (Pt0.y);
 						
-						GetNextVelocityComponents (&Velocity1, &dx_1, &dy_1, time_y_0);
+						GetNextVelocityComponentsSdword (&Velocity1, &dx_1, &dy_1, time_y_0);
 						Pt1.x += dx_1;
 						Pt1.y += dy_1;
 						Control1.EndPoint.x = WORLD_TO_DISPLAY (Pt1.x);
 						Control1.EndPoint.y = WORLD_TO_DISPLAY (Pt1.y);
 					}
-
+					
 					do
 					{
 						TIME_VALUE when;
-
+						
 						++time_y_0;
-
-						GetNextVelocityComponents (&Velocity0, &dx_0, &dy_0, 1);
+						
+						GetNextVelocityComponentsSdword (&Velocity0, &dx_0, &dy_0, 1);
 						Pt0.x += dx_0;
 						Pt0.y += dy_0;
-
-						GetNextVelocityComponents (&Velocity1, &dx_1, &dy_1, 1);
+						
+						GetNextVelocityComponentsSdword (&Velocity1, &dx_1, &dy_1, 1);
 						Pt1.x += dx_1;
 						Pt1.y += dy_1;
-
+						
 						Control0.IntersectStamp.origin = Control0.EndPoint;
 						Control0.EndPoint.x = WORLD_TO_DISPLAY (Pt0.x);
 						Control0.EndPoint.y = WORLD_TO_DISPLAY (Pt0.y);
-
+						
 						Control1.IntersectStamp.origin = Control1.EndPoint;
 						Control1.EndPoint.x = WORLD_TO_DISPLAY (Pt1.x);
 						Control1.EndPoint.y = WORLD_TO_DISPLAY (Pt1.y);
-						when = DrawablesIntersect (&Control0,
-								&Control1, MAX_TIME_VALUE);
+						
+						when = DrawablesIntersect (&Control0, &Control1, MAX_TIME_VALUE);
+						
 						if (when)
 						{
 							if (when == 1
-									&& time_y_0 == 1
-									&& ((ElementPtr0->state_flags
-									| ElementPtr1->state_flags) & APPEARING))
+								&& time_y_0 == 1
+								&& ((ElementPtr0->state_flags
+									 | ElementPtr1->state_flags) & APPEARING))
 							{
 								when = 0;
 								Control0.EndPoint.x = WORLD_TO_DISPLAY (Pt0.x);
 								Control0.EndPoint.y = WORLD_TO_DISPLAY (Pt0.y);
-
+								
 								Control1.EndPoint.x = WORLD_TO_DISPLAY (Pt1.x);
 								Control1.EndPoint.y = WORLD_TO_DISPLAY (Pt1.y);
 							}
-
+							
 							if (when)
 								return ((COUNT)time_y_0);
 						}
@@ -281,7 +293,7 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 			}
 		}
 	}
-
+	
 	return (0);
 }
 
@@ -289,24 +301,24 @@ static void
 InitCyborg (STARSHIP *StarShipPtr)
 {
 	COUNT Index, Divisor;
-
+	
 	Index = StarShipPtr->RaceDescPtr->characteristics.max_thrust
-			* StarShipPtr->RaceDescPtr->characteristics.thrust_increment;
+	* StarShipPtr->RaceDescPtr->characteristics.thrust_increment;
 	if ((Divisor = StarShipPtr->RaceDescPtr->characteristics.turn_wait
-			+ StarShipPtr->RaceDescPtr->characteristics.thrust_wait) > 0)
+		 + StarShipPtr->RaceDescPtr->characteristics.thrust_wait) > 0)
 		Index /= Divisor;
 	else
 		Index >>= 1;
 #ifdef PRINT_MI
 	{
 		char *shipName;
-
+		
 		shipName = GetStringAddress (
-				StarShipPtr->RaceDescPtr->ship_data.race_strings);
+									 StarShipPtr->RaceDescPtr->ship_data.race_strings);
 		log_add (log_Debug, "MI(%s) -- <%u:%u> = %u", shipName,
-				StarShipPtr->RaceDescPtr->characteristics.max_thrust *
-				StarShipPtr->RaceDescPtr->characteristics.thrust_increment,
-				Divisor, Index);
+				 StarShipPtr->RaceDescPtr->characteristics.max_thrust *
+				 StarShipPtr->RaceDescPtr->characteristics.thrust_increment,
+				 Divisor, Index);
 	}
 #endif /* PRINT_MI */
 	StarShipPtr->RaceDescPtr->cyborg_control.ManeuverabilityIndex = Index;
@@ -317,7 +329,7 @@ ship_movement (ELEMENT *ShipPtr, EVALUAT
 {
 	if (EvalDescPtr->which_turn == 0)
 		EvalDescPtr->which_turn = 1;
-
+	
 	switch (EvalDescPtr->MoveState)
 	{
 		case PURSUE:
@@ -336,37 +348,38 @@ ship_movement (ELEMENT *ShipPtr, EVALUAT
 	}
 }
 
+// JMS:GFX Made SIZEs SDWORDs and changed the GetNextVelocityComponents to GetNextVelocityComponentsSdword
 BOOLEAN
 ship_weapons (ELEMENT *ShipPtr, ELEMENT *OtherPtr, COUNT margin_of_error)
 {
-	SIZE delta_x, delta_y;
+	SDWORD delta_x, delta_y;
 	COUNT n, num_weapons;
 	ELEMENT Ship;
 	HELEMENT Weapon[6];
 	STARSHIP *StarShipPtr;
-
+	
 	if (OBJECT_CLOAKED (OtherPtr))
-		margin_of_error += DISPLAY_TO_WORLD (40);
-
+		margin_of_error += DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR); // JMS_GFX
+	
 	Ship = *ShipPtr;
-	GetNextVelocityComponents (&Ship.velocity,
-			&delta_x, &delta_y, 1);
+	GetNextVelocityComponentsSdword (&Ship.velocity, &delta_x, &delta_y, 1);
 	Ship.next.location.x =
-			Ship.current.location.x + delta_x;
+		Ship.current.location.x + delta_x;
 	Ship.next.location.y =
-			Ship.current.location.y + delta_y;
+		Ship.current.location.y + delta_y;
+	
 	Ship.current.location = Ship.next.location;
-
+	
 	GetElementStarShip (&Ship, &StarShipPtr);
 	num_weapons =
-			(*StarShipPtr->RaceDescPtr->init_weapon_func) (&Ship, Weapon);
-
+	(*StarShipPtr->RaceDescPtr->init_weapon_func) (&Ship, Weapon);
+	
 	if ((n = num_weapons))
 	{
 		HELEMENT *WeaponPtr, w;
 		//STARSHIP *StarShipPtr;
 		ELEMENT *EPtr;
-
+		
 		WeaponPtr = &Weapon[0];
 		do
 		{
@@ -381,20 +394,19 @@ ship_weapons (ELEMENT *ShipPtr, ELEMENT
 					InitIntersectEndPoint (EPtr);
 					InitIntersectFrame (EPtr);
 				}
-
-				if (PlotIntercept (EPtr, OtherPtr,
-						EPtr->life_span, margin_of_error))
+				
+				if (PlotIntercept (EPtr, OtherPtr, EPtr->life_span, margin_of_error))
 				{
 					UnlockElement (w);
 					break;
 				}
-
+				
 				UnlockElement (w);
 				FreeElement (w);
 			}
 			++WeaponPtr;
 		} while (--n);
-
+		
 		if ((num_weapons = n))
 		{
 			do
@@ -405,26 +417,30 @@ ship_weapons (ELEMENT *ShipPtr, ELEMENT
 			} while (--n);
 		}
 	}
-
+	
+	//if (num_weapons > 0)
+	//	log_add (log_Debug, "dx:%d, dy:%d, currx:%d, curry:%d, nextx:%d, nexty:%d", delta_x, delta_y, Ship.current.location.x, Ship.current.location.y, Ship.next.location.x, Ship.next.location.y);
+	
 	return (num_weapons > 0);
 }
 
 void
 ship_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+				   COUNT ConcernCounter)
 {
 	BOOLEAN ShipMoved, ShipFired;
 	COUNT margin_of_error;
 	STARSHIP *StarShipPtr;
-
+	EVALUATE_DESC *ObjectsOfConcernEWeapon;
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-
+	
 	ShipMoved = TRUE;
 	if (ShipPtr->turn_wait == 0)
 		ShipMoved = FALSE;
 	if (ShipPtr->thrust_wait == 0)
 		ShipMoved = FALSE;
-
+	
 	ShipFired = TRUE;
 	if (StarShipPtr->weapon_counter == 0)
 	{
@@ -432,42 +448,49 @@ ship_intelligence (ELEMENT *ShipPtr, EVA
 		if (!(StarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON))
 			ShipFired = FALSE;
 	}
-
+	
 	if (StarShipPtr->control & AWESOME_RATING)
 		margin_of_error = 0;
 	else if (StarShipPtr->control & GOOD_RATING)
-		margin_of_error = DISPLAY_TO_WORLD (20);
+		margin_of_error = DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR); // JMS_GFX
 	else /* if (StarShipPtr->control & STANDARD_RATING) */
-		margin_of_error = DISPLAY_TO_WORLD (40);
-
+		margin_of_error = DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR); // JMS_GFX
+	
 	ObjectsOfConcern += ConcernCounter;
+	
+	ObjectsOfConcernEWeapon = ObjectsOfConcern - ConcernCounter + ENEMY_WEAPON_INDEX;
+	
 	while (ConcernCounter--)
 	{
 		--ObjectsOfConcern;
 		if (ObjectsOfConcern->ObjectPtr)
 		{
 			if (!ShipMoved
-					&& (ConcernCounter != ENEMY_WEAPON_INDEX
+				&& (ConcernCounter != ENEMY_WEAPON_INDEX
 					|| ObjectsOfConcern->MoveState == PURSUE
 					|| (ObjectsOfConcern->ObjectPtr->state_flags & CREW_OBJECT)
 					|| MANEUVERABILITY (
-							&StarShipPtr->RaceDescPtr->cyborg_control
-							) >= MEDIUM_SHIP))
+										&StarShipPtr->RaceDescPtr->cyborg_control
+										) >= RESOLUTION_COMPENSATED(MEDIUM_SHIP) // JMS_GFX
+					)
+				)
 			{
 				ship_movement (ShipPtr, ObjectsOfConcern);
 				ShipMoved = TRUE;
 			}
 			if (!ShipFired
-					&& (ConcernCounter == ENEMY_SHIP_INDEX
+				&& (ConcernCounter == ENEMY_SHIP_INDEX
 					|| (ConcernCounter == ENEMY_WEAPON_INDEX
-					&& ObjectsOfConcern->MoveState != AVOID
+						&& ObjectsOfConcern->MoveState != AVOID
 #ifdef NEVER
-					&& !(StarShipPtr->control & STANDARD_RATING)
-#endif /* NEVER */
-					)))
+						&& !(StarShipPtr->control & STANDARD_RATING)
+#endif /* NEVER */		
+						)
+					)
+				)
 			{
-				ShipFired = ship_weapons (ShipPtr,
-						ObjectsOfConcern->ObjectPtr, margin_of_error);
+				ShipFired = ship_weapons (ShipPtr,ObjectsOfConcern->ObjectPtr, margin_of_error);
+				
 				if (ShipFired)
 					StarShipPtr->ship_input_state |= WEAPON;
 			}
@@ -480,7 +503,7 @@ TurnShip (ELEMENT *ShipPtr, COUNT angle)
 {
 	COUNT f, ship_delta_facing;
 	STARSHIP *StarShipPtr;
-
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	f = StarShipPtr->ShipFacing;
 	ship_delta_facing = NORMALIZE_FACING (ANGLE_TO_FACING (angle) - f);
@@ -488,39 +511,39 @@ TurnShip (ELEMENT *ShipPtr, COUNT angle)
 	{
 		if (ship_delta_facing == ANGLE_TO_FACING (HALF_CIRCLE))
 			ship_delta_facing =
-					NORMALIZE_FACING (ship_delta_facing +
-					(TFB_Random () & 1 ?
-					ANGLE_TO_FACING (OCTANT >> 1) :
-					-ANGLE_TO_FACING (OCTANT >> 1)));
-
+			NORMALIZE_FACING (ship_delta_facing +
+							  (TFB_Random () & 1 ?
+							   ANGLE_TO_FACING (OCTANT >> 1) :
+							   -ANGLE_TO_FACING (OCTANT >> 1)));
+		
 		if (ship_delta_facing < ANGLE_TO_FACING (HALF_CIRCLE))
 		{
 			StarShipPtr->ship_input_state |= RIGHT;
 			++f;
 			ShipPtr->next.image.frame =
-					IncFrameIndex (ShipPtr->current.image.frame);
+			IncFrameIndex (ShipPtr->current.image.frame);
 		}
 		else
 		{
 			StarShipPtr->ship_input_state |= LEFT;
 			--f;
 			ShipPtr->next.image.frame =
-					DecFrameIndex (ShipPtr->current.image.frame);
+			DecFrameIndex (ShipPtr->current.image.frame);
 		}
-
+		
 #ifdef NOTYET
 		if (((StarShipPtr->ship_input_state & (LEFT | RIGHT))
-				^ (StarShipPtr->cur_status_flags & (LEFT | RIGHT))) == (LEFT | RIGHT))
+			 ^ (StarShipPtr->cur_status_flags & (LEFT | RIGHT))) == (LEFT | RIGHT))
 			StarShipPtr->ship_input_state &= ~(LEFT | RIGHT);
 		else
 #endif /* NOTYET */
 		{
 			StarShipPtr->ShipFacing = NORMALIZE_FACING (f);
-
+			
 			return (TRUE);
 		}
 	}
-
+	
 	return (FALSE);
 }
 
@@ -529,224 +552,237 @@ ThrustShip (ELEMENT *ShipPtr, COUNT angl
 {
 	BOOLEAN ShouldThrust;
 	STARSHIP *StarShipPtr;
-
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	if (StarShipPtr->ship_input_state & THRUST)
 		ShouldThrust = TRUE;
 	else if (NORMALIZE_FACING (ANGLE_TO_FACING (angle)
-			- ANGLE_TO_FACING (GetVelocityTravelAngle (&ShipPtr->velocity))) == 0
-			&& (StarShipPtr->cur_status_flags
-			& (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
-			&& !(StarShipPtr->cur_status_flags & SHIP_IN_GRAVITY_WELL))
+							   - ANGLE_TO_FACING (GetVelocityTravelAngle (&ShipPtr->velocity))) == 0
+			 && (StarShipPtr->cur_status_flags
+				 & (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
+			 && !(StarShipPtr->cur_status_flags & SHIP_IN_GRAVITY_WELL))
 		ShouldThrust = FALSE;
 	else
 	{
 		SIZE ship_delta_facing;
-
+		
 		ship_delta_facing =
-				NORMALIZE_FACING (ANGLE_TO_FACING (angle)
-				- StarShipPtr->ShipFacing + ANGLE_TO_FACING (QUADRANT));
+		NORMALIZE_FACING (ANGLE_TO_FACING (angle)
+						  - StarShipPtr->ShipFacing + ANGLE_TO_FACING (QUADRANT));
 		if (ship_delta_facing == ANGLE_TO_FACING (QUADRANT)
-				|| ((StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED)
+			|| ((StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED)
 				&& ship_delta_facing <= ANGLE_TO_FACING (HALF_CIRCLE)))
 			ShouldThrust = TRUE;
 		else
 			ShouldThrust = FALSE;
 	}
-
+	
 	if (ShouldThrust)
 	{
 		inertial_thrust (ShipPtr);
-
+		
 		StarShipPtr->ship_input_state |= THRUST;
 	}
-
+	
 	return (ShouldThrust);
 }
 
+// JMS:GFX Made SIZEs SDWORDs and changed the GetNextVelocityComponents to GetNextVelocityComponentsSdword
 void
 Pursue (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr)
 {
 	BYTE maneuver_state;
 	COUNT desired_thrust_angle, desired_turn_angle;
-	SIZE delta_x, delta_y;
-	SIZE ship_delta_x, ship_delta_y;
-	SIZE other_delta_x, other_delta_y;
+	SDWORD delta_x, delta_y;
+	SDWORD ship_delta_x, ship_delta_y;
+	SDWORD other_delta_x, other_delta_y;
 	ELEMENT *OtherObjPtr;
 	VELOCITY_DESC ShipVelocity, OtherVelocity;
-
+	COUNT distance_to_give_up_and_turn; // JMS
+	
 	ShipVelocity = ShipPtr->velocity;
-	GetNextVelocityComponents (&ShipVelocity,
-			&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
+	GetNextVelocityComponentsSdword (&ShipVelocity,
+		&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
 	ShipPtr->next.location.x =
-			ShipPtr->current.location.x + ship_delta_x;
+		ShipPtr->current.location.x + ship_delta_x;
 	ShipPtr->next.location.y =
-			ShipPtr->current.location.y + ship_delta_y;
-
+		ShipPtr->current.location.y + ship_delta_y;
+	
 	OtherObjPtr = EvalDescPtr->ObjectPtr;
+	
 	OtherVelocity = OtherObjPtr->velocity;
-	GetNextVelocityComponents (&OtherVelocity,
-			&other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
-
+	GetNextVelocityComponentsSdword (&OtherVelocity,
+							   &other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
+	
 	delta_x = (OtherObjPtr->current.location.x + other_delta_x)
-			- ShipPtr->next.location.x;
+		- ShipPtr->next.location.x;
 	delta_y = (OtherObjPtr->current.location.y + other_delta_y)
-			- ShipPtr->next.location.y;
+		- ShipPtr->next.location.y;
 	delta_x = WRAP_DELTA_X (delta_x);
 	delta_y = WRAP_DELTA_Y (delta_y);
 	desired_thrust_angle = ARCTAN (delta_x, delta_y);
-
+	
 	maneuver_state = 0;
 	if (ShipPtr->turn_wait == 0)
 		maneuver_state |= LEFT | RIGHT;
 	if (ShipPtr->thrust_wait == 0
-			&& ((OtherObjPtr->state_flags & PLAYER_SHIP)
+		&& ((OtherObjPtr->state_flags & PLAYER_SHIP)
 			|| elementsOfSamePlayer (OtherObjPtr, ShipPtr)
-			|| OtherObjPtr->preprocess_func == crew_preprocess))
+			|| OtherObjPtr->preprocess_func == crew_preprocess
+			)
+		)
 		maneuver_state |= THRUST;
-
+	
 	desired_turn_angle = NORMALIZE_ANGLE (desired_thrust_angle + HALF_CIRCLE);
-		/* other player's ship */
+	/* other player's ship */
 	if ((OtherObjPtr->state_flags & PLAYER_SHIP)
-			&& OtherObjPtr->mass_points <= MAX_SHIP_MASS)
+		&& OtherObjPtr->mass_points <= MAX_SHIP_MASS)
 	{
 		STARSHIP *StarShipPtr;
 		STARSHIP *EnemyStarShipPtr;
-
+		
 		GetElementStarShip (ShipPtr, &StarShipPtr);
 		GetElementStarShip (OtherObjPtr, &EnemyStarShipPtr);
 		if ((MANEUVERABILITY (
-				&StarShipPtr->RaceDescPtr->cyborg_control
-				) >= FAST_SHIP
-				&& WEAPON_RANGE (&StarShipPtr->RaceDescPtr->cyborg_control)
-				> CLOSE_RANGE_WEAPON)
-				|| (EvalDescPtr->which_turn >= 24
+							  &StarShipPtr->RaceDescPtr->cyborg_control
+							  ) >= RESOLUTION_COMPENSATED(FAST_SHIP) // JMS_GFX
+			 && WEAPON_RANGE (&StarShipPtr->RaceDescPtr->cyborg_control)
+			 > (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)) // JMS_GFX
+			|| (EvalDescPtr->which_turn >= 24
 				&& (StarShipPtr->RaceDescPtr->characteristics.max_thrust * 2 / 3 <
-				EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust
-				|| (EnemyStarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))))
+					EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust
+					|| (EnemyStarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))))
 		{
 			UWORD ship_flags;
-
+			
 			ship_flags = EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags;
-						/* you're maneuverable */
+			/* you're maneuverable */
 			if (MANEUVERABILITY (
-					&StarShipPtr->RaceDescPtr->cyborg_control
-					) >= MEDIUM_SHIP)
+				&StarShipPtr->RaceDescPtr->cyborg_control
+				) >= RESOLUTION_COMPENSATED(MEDIUM_SHIP)) // JMS_GFX
 			{
 				UWORD fire_flags;
 				COUNT facing;
-
+				
 				for (fire_flags = FIRES_FORE, facing = EvalDescPtr->facing;
-						fire_flags <= FIRES_LEFT;
-						fire_flags <<= 1, facing += QUADRANT)
+					 fire_flags <= FIRES_LEFT;
+					 fire_flags <<= 1, facing += QUADRANT)
 				{
 					if
-					(
-							/* he's dangerous in this direction */
-						(ship_flags & fire_flags)
-							/* he's facing direction you want to go */
-						&& NORMALIZE_ANGLE (
-						desired_turn_angle - facing + OCTANT
-						) <= QUADRANT
-						&& (
-							/* he's moving */
-						(other_delta_x != 0 || other_delta_y != 0)
-						&&
-							/* he's coasting backwards */
-						NORMALIZE_ANGLE (
-						(GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
-						- facing + (OCTANT + (OCTANT >> 1)))
-						<= ((OCTANT + (OCTANT >> 1)) << 1))
-					)
+						(
+						 /* he's dangerous in this direction */
+						 (ship_flags & fire_flags)
+						 /* he's facing direction you want to go */
+						 && NORMALIZE_ANGLE (
+							desired_turn_angle - facing + OCTANT) <= QUADRANT
+						 && (
+							 /* he's moving */
+							 (other_delta_x != 0 || other_delta_y != 0)
+							 &&
+							 /* he's coasting backwards */
+							 NORMALIZE_ANGLE (
+								(GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
+								- facing + (OCTANT + (OCTANT >> 1)))
+							 <= ((OCTANT + (OCTANT >> 1)) << 1))
+						 )
 					{
-							/* catch him on the back side */
+						/* catch him on the back side */
 						desired_thrust_angle = desired_turn_angle;
 						break;
 					}
 				}
 			}
-
+			
+			// This code prevents Kohr-Ah, Ur-Quan and ISD from turning around mid-chase while pursuing Earthling.
+			if (StarShipPtr->SpeciesID == (KOHR_AH_ID | UR_QUAN_ID)
+				&& EnemyStarShipPtr->SpeciesID == EARTHLING_ID 
+				&& !(EnemyStarShipPtr->cur_status_flags & (SHIP_BEYOND_MAX_SPEED | SHIP_IN_GRAVITY_WELL)))
+				distance_to_give_up_and_turn = 44;
+			else
+				distance_to_give_up_and_turn = 24;
+			
 			if (desired_thrust_angle != desired_turn_angle
-					&& (other_delta_x || other_delta_y)
-					&& EvalDescPtr->which_turn >= 24
-					&& NORMALIZE_ANGLE (desired_thrust_angle
-					- GetVelocityTravelAngle (&OtherVelocity)
-					+ OCTANT) <= QUADRANT
-					&& ((NORMALIZE_ANGLE (
-					GetVelocityTravelAngle (&OtherVelocity)
-					- GetVelocityTravelAngle (&ShipVelocity)
-					+ OCTANT) <= QUADRANT
-					&& (((StarShipPtr->cur_status_flags & SHIP_AT_MAX_SPEED)
-					&& !(StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))
-					|| (ship_flags & DONT_CHASE)))
+				&& (other_delta_x || other_delta_y)
+				&& EvalDescPtr->which_turn >= distance_to_give_up_and_turn
+				&& NORMALIZE_ANGLE (desired_thrust_angle
+									- GetVelocityTravelAngle (&OtherVelocity)
+									+ OCTANT) <= QUADRANT
+				&& ((NORMALIZE_ANGLE (
+									  GetVelocityTravelAngle (&OtherVelocity)
+									  - GetVelocityTravelAngle (&ShipVelocity)
+									  + OCTANT) <= QUADRANT
+					 && (((StarShipPtr->cur_status_flags & SHIP_AT_MAX_SPEED)
+						  && !(StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))
+						 || (ship_flags & DONT_CHASE)))
 					|| NORMALIZE_ANGLE (
-					desired_turn_angle
-					- FACING_TO_ANGLE (StarShipPtr->ShipFacing)
-					+ OCTANT) <= QUADRANT))
+										desired_turn_angle
+										- FACING_TO_ANGLE (StarShipPtr->ShipFacing)
+										+ OCTANT) <= QUADRANT))
 				desired_thrust_angle = desired_turn_angle;
 		}
 	}
-
+	
 	if (maneuver_state & (LEFT | RIGHT))
 		TurnShip (ShipPtr, desired_thrust_angle);
-
+	
 	if (maneuver_state & THRUST)
 		ThrustShip (ShipPtr, desired_thrust_angle);
 }
 
+// JMS:GFX Made SIZEs SDWORDs and changed the GetNextVelocityComponents to GetNextVelocityComponentsSdword
 void
 Entice (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr)
 {
 	BYTE maneuver_state;
 	COUNT desired_thrust_angle, desired_turn_angle;
 	COUNT cone_of_fire, travel_angle;
-	SIZE delta_x, delta_y;
-	SIZE ship_delta_x, ship_delta_y;
-	SIZE other_delta_x, other_delta_y;
+	SDWORD delta_x, delta_y;
+	SDWORD ship_delta_x, ship_delta_y;
+	SDWORD other_delta_x, other_delta_y;
 	ELEMENT *OtherObjPtr;
 	VELOCITY_DESC ShipVelocity, OtherVelocity;
 	STARSHIP *StarShipPtr;
 	RACE_DESC *RDPtr;
-
+	
 	ShipVelocity = ShipPtr->velocity;
-	GetNextVelocityComponents (&ShipVelocity,
-			&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
+	GetNextVelocityComponentsSdword (&ShipVelocity,
+		&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
 	ShipPtr->next.location.x =
-			ShipPtr->current.location.x + ship_delta_x;
+		ShipPtr->current.location.x + ship_delta_x;
 	ShipPtr->next.location.y =
-			ShipPtr->current.location.y + ship_delta_y;
-
+		ShipPtr->current.location.y + ship_delta_y;
+	
 	OtherObjPtr = EvalDescPtr->ObjectPtr;
 	OtherVelocity = OtherObjPtr->velocity;
-	GetNextVelocityComponents (&OtherVelocity,
-			&other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
-
+	GetNextVelocityComponentsSdword (&OtherVelocity,
+		&other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
+	
 	delta_x = (OtherObjPtr->current.location.x + other_delta_x)
-			- ShipPtr->next.location.x;
+		- ShipPtr->next.location.x;
 	delta_y = (OtherObjPtr->current.location.y + other_delta_y)
-			- ShipPtr->next.location.y;
+		- ShipPtr->next.location.y;
 	delta_x = WRAP_DELTA_X (delta_x);
 	delta_y = WRAP_DELTA_Y (delta_y);
 	desired_thrust_angle = ARCTAN (delta_x, delta_y);
-
+	
 	maneuver_state = 0;
 	if (ShipPtr->turn_wait == 0)
 		maneuver_state |= LEFT | RIGHT;
 	if (ShipPtr->thrust_wait == 0)
 		maneuver_state |= THRUST;
-
+	
 	delta_x = ship_delta_x - other_delta_x;
 	delta_y = ship_delta_y - other_delta_y;
 	travel_angle = ARCTAN (delta_x, delta_y);
 	desired_turn_angle = NORMALIZE_ANGLE (desired_thrust_angle + HALF_CIRCLE);
-
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	RDPtr = StarShipPtr->RaceDescPtr;
 	if (EvalDescPtr->MoveState == AVOID)
 	{
 		desired_turn_angle =
-				NORMALIZE_ANGLE (desired_turn_angle - EvalDescPtr->facing);
-
+		NORMALIZE_ANGLE (desired_turn_angle - EvalDescPtr->facing);
+		
 		if (NORMALIZE_FACING (ANGLE_TO_FACING (desired_turn_angle)))
 		{
 			if (desired_turn_angle <= HALF_CIRCLE)
@@ -757,162 +793,156 @@ Entice (ELEMENT *ShipPtr, EVALUATE_DESC
 		else
 		{
 			desired_turn_angle = NORMALIZE_ANGLE (
-					FACING_TO_ANGLE (StarShipPtr->ShipFacing)
-					- EvalDescPtr->facing
-					);
+				FACING_TO_ANGLE (StarShipPtr->ShipFacing)
+				- EvalDescPtr->facing);
 			if ((desired_turn_angle & (HALF_CIRCLE - 1)) == 0)
 				desired_thrust_angle = TFB_Random () & 1 ? RIGHT : LEFT;
 			else
 				desired_thrust_angle = desired_turn_angle < HALF_CIRCLE ? RIGHT : LEFT;
 		}
-
+		
 		if (desired_thrust_angle == LEFT)
 		{
 #define FLANK_LEFT -QUADRANT
 #define SHIP_LEFT -OCTANT
 			desired_thrust_angle = EvalDescPtr->facing
-					+ FLANK_LEFT - (SHIP_LEFT >> 1);
+			+ FLANK_LEFT - (SHIP_LEFT >> 1);
 		}
 		else
 		{
 #define FLANK_RIGHT QUADRANT
 #define SHIP_RIGHT OCTANT
 			desired_thrust_angle = EvalDescPtr->facing
-					+ FLANK_RIGHT - (SHIP_RIGHT >> 1);
+			+ FLANK_RIGHT - (SHIP_RIGHT >> 1);
 		}
-
+		
 		desired_thrust_angle = NORMALIZE_ANGLE (desired_thrust_angle);
 	}
 	else if (GRAVITY_MASS (OtherObjPtr->mass_points))
 	{
 		COUNT planet_facing;
-
+		
 		planet_facing = NORMALIZE_FACING (ANGLE_TO_FACING (desired_thrust_angle));
-		cone_of_fire = NORMALIZE_FACING (
-				planet_facing
-				- StarShipPtr->ShipFacing
-				+ ANGLE_TO_FACING (QUADRANT));
-
+		cone_of_fire = NORMALIZE_FACING (planet_facing - StarShipPtr->ShipFacing
+			+ ANGLE_TO_FACING (QUADRANT));
+		
 		if (RDPtr->characteristics.thrust_increment !=
-				RDPtr->characteristics.max_thrust)
+			RDPtr->characteristics.max_thrust)
 			maneuver_state &= ~THRUST;
-
-				/* if not pointing towards planet */
+		
+		/* if not pointing towards planet */
 		if (cone_of_fire > ANGLE_TO_FACING (QUADRANT << 1))
 			desired_turn_angle = desired_thrust_angle;
-				/* if pointing directly at planet */
+		/* if pointing directly at planet */
 		else if (cone_of_fire == ANGLE_TO_FACING (QUADRANT)
-				&& NORMALIZE_FACING (ANGLE_TO_FACING (travel_angle)) != planet_facing)
+				 && NORMALIZE_FACING (ANGLE_TO_FACING (travel_angle)) != planet_facing)
 			desired_turn_angle = travel_angle;
 		else if (cone_of_fire == 0
-				|| cone_of_fire == ANGLE_TO_FACING (QUADRANT << 1)
-				|| (!(maneuver_state & THRUST)
-				&& (cone_of_fire < ANGLE_TO_FACING (OCTANT)
-				|| cone_of_fire > ANGLE_TO_FACING ((QUADRANT << 1) - OCTANT))))
+				 || cone_of_fire == ANGLE_TO_FACING (QUADRANT << 1)
+				 || (!(maneuver_state & THRUST)
+					 && (cone_of_fire < ANGLE_TO_FACING (OCTANT)
+						 || cone_of_fire > ANGLE_TO_FACING ((QUADRANT << 1) - OCTANT))))
 		{
 			desired_turn_angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 			if (NORMALIZE_ANGLE (desired_turn_angle
-					- travel_angle + QUADRANT) > HALF_CIRCLE)
+								 - travel_angle + QUADRANT) > HALF_CIRCLE)
 				desired_turn_angle = travel_angle;
 			if (ShipPtr->thrust_wait == 0)
 				maneuver_state |= THRUST;
 		}
-
+		
 		desired_thrust_angle = desired_turn_angle;
 	}
 	else
 	{
 		COUNT WRange;
-
+		
 		WRange = WEAPON_RANGE (
-				&RDPtr->cyborg_control
-				);
-
+							   &RDPtr->cyborg_control
+							   );
+		
 		cone_of_fire = NORMALIZE_ANGLE (desired_turn_angle
-				- EvalDescPtr->facing + OCTANT);
+										- EvalDescPtr->facing + OCTANT);
 		if (OtherObjPtr->state_flags & PLAYER_SHIP)
 		{
 			UWORD fire_flags, ship_flags;
 			COUNT facing;
 			STARSHIP *EnemyStarShipPtr;
-
+			
 			GetElementStarShip (OtherObjPtr, &EnemyStarShipPtr);
 			ship_flags = EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags;
 			for (fire_flags = FIRES_FORE, facing = EvalDescPtr->facing;
-					fire_flags <= FIRES_LEFT;
-					fire_flags <<= 1, facing += QUADRANT)
+				 fire_flags <= FIRES_LEFT;
+				 fire_flags <<= 1, facing += QUADRANT)
 			{
 				if
-				(
-						/* he's dangerous in this direction */
-					(ship_flags & fire_flags)
-						/* he's facing direction you want to go */
-					&& (cone_of_fire = NORMALIZE_ANGLE (
-					desired_turn_angle - facing + OCTANT
-					)) <= QUADRANT
-						/* he's moving */
-					&& ((other_delta_x != 0 || other_delta_y != 0)
-						/* he's coasting backwards */
-					&& NORMALIZE_ANGLE (
-					(GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
-					- facing + OCTANT) <= QUADRANT)
-				)
-				{
-						/* need to be close for a kill */
-					if (WRange < LONG_RANGE_WEAPON
-							&& EvalDescPtr->which_turn <= 32)
+					(
+					 /* he's dangerous in this direction */
+					 (ship_flags & fire_flags)
+					 /* he's facing direction you want to go */
+					 && (cone_of_fire = NORMALIZE_ANGLE (
+						desired_turn_angle - facing + OCTANT)) <= QUADRANT
+					 /* he's moving */
+					 && ((other_delta_x != 0 || other_delta_y != 0)
+						 /* he's coasting backwards */
+						 && NORMALIZE_ANGLE (
+											 (GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
+											 - facing + OCTANT) <= QUADRANT)
+					 )
+				{
+					/* need to be close for a kill */
+					if (WRange < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+						&& EvalDescPtr->which_turn <= 32)
 					{
 						/* catch him on the back side */
 						desired_thrust_angle = desired_turn_angle;
 						goto DoManeuver;
 					}
-
+					
 					break;
 				}
 			}
-
+			
 			if (EvalDescPtr->which_turn <= 8
-					&& RDPtr->characteristics.max_thrust <=
-					EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust)
+				&& RDPtr->characteristics.max_thrust <=
+				EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust)
 				goto DoManeuver;
 		}
-
+		
 		if
-		(
+			(
 #ifdef NOTYET
-			WRange < LONG_RANGE_WEAPON
-			&&
+			 WRange < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+			 &&
 #endif /* NOTYET */
-					/* not at full speed */
-			!(StarShipPtr->cur_status_flags
-			& (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
-			&& (PlotIntercept (
-					ShipPtr, OtherObjPtr, 40, CLOSE_RANGE_WEAPON << 1
-					)
+			 /* not at full speed */
+			 !(StarShipPtr->cur_status_flags
+			   & (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
+			 && (PlotIntercept (ShipPtr, OtherObjPtr, 40, (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR) << 1) // JMS_GFX
 #ifdef NOTYET
-			||
-			(
-					/* object's facing direction you want to go */
-				cone_of_fire <= QUADRANT
-					/* and you're basically going in that direction */
-				&& (travel_angle == FULL_CIRCLE
-				|| NORMALIZE_ANGLE (travel_angle
-				- desired_thrust_angle + QUADRANT) <= HALF_CIRCLE)
-					/* and object's in range */
-				&& PlotIntercept (ShipPtr, OtherObjPtr, 1, WRange)
-			)
+				 ||
+				 (
+				  /* object's facing direction you want to go */
+				  cone_of_fire <= QUADRANT
+				  /* and you're basically going in that direction */
+				  && (travel_angle == FULL_CIRCLE
+					  || NORMALIZE_ANGLE (travel_angle
+										  - desired_thrust_angle + QUADRANT) <= HALF_CIRCLE)
+				  /* and object's in range */
+				  && PlotIntercept (ShipPtr, OtherObjPtr, 1, WRange)
+				  )
 #endif /* NOTYET */
-			)
-		)
+				 )
+			 )
 		{
 			if
-			(
-					/* pointed straight at him */
-				NORMALIZE_ANGLE (desired_thrust_angle
-				- FACING_TO_ANGLE (StarShipPtr->ShipFacing) + OCTANT) <= QUADRANT
-					/* or not exposed to business end */
-				|| cone_of_fire > QUADRANT
-			)
+				(
+				 /* pointed straight at him */
+				 NORMALIZE_ANGLE (desired_thrust_angle
+								  - FACING_TO_ANGLE (StarShipPtr->ShipFacing) + OCTANT) <= QUADRANT
+				 /* or not exposed to business end */
+				 || cone_of_fire > QUADRANT
+				 )
 			{
 				desired_thrust_angle = desired_turn_angle;
 			}
@@ -920,78 +950,76 @@ Entice (ELEMENT *ShipPtr, EVALUATE_DESC
 			{
 #ifdef NOTYET
 				if
-				(
-					travel_angle != FULL_CIRCLE
-					&& NORMALIZE_ANGLE (travel_angle
-					- desired_turn_angle + OCTANT) <= QUADRANT
-				)
+					(
+					 travel_angle != FULL_CIRCLE
+					 && NORMALIZE_ANGLE (travel_angle
+										 - desired_turn_angle + OCTANT) <= QUADRANT
+					 )
 				{
 					desired_turn_angle =
-							NORMALIZE_ANGLE ((EvalDescPtr->facing + HALF_CIRCLE)
-							+ (travel_angle - desired_turn_angle));
+					NORMALIZE_ANGLE ((EvalDescPtr->facing + HALF_CIRCLE)
+									 + (travel_angle - desired_turn_angle));
 					if (!(maneuver_state & (LEFT | RIGHT)))
 						maneuver_state &= ~THRUST;
 				}
-
+				
 				if (maneuver_state & (LEFT | RIGHT))
 				{
 					TurnShip (ShipPtr, desired_turn_angle);
 					maneuver_state &= ~(LEFT | RIGHT);
 				}
 #endif /* NOTYET */
-
+				
 				desired_thrust_angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
-desired_turn_angle = desired_thrust_angle;
+				desired_turn_angle = desired_thrust_angle;
 			}
 		}
 		else if ((cone_of_fire = PlotIntercept (
-				ShipPtr, OtherObjPtr, 10, WRange
+												ShipPtr, OtherObjPtr, 10, WRange
 #ifdef OLD
-				- (WRange >> 3)
+												- (WRange >> 3)
 #else /* !OLD */
-				- (WRange >> 2)
+												- (WRange >> 2)
 #endif /* OLD */
-				)))
+												)))
 		{
 			if (RDPtr->characteristics.thrust_increment !=
-					RDPtr->characteristics.max_thrust
-							/* and already at full speed */
-					&& (StarShipPtr->cur_status_flags
+				RDPtr->characteristics.max_thrust
+				/* and already at full speed */
+				&& (StarShipPtr->cur_status_flags
 					& (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
-							/* and facing away from enemy */
-					&& (NORMALIZE_ANGLE (desired_turn_angle
-					- ARCTAN (ship_delta_x, ship_delta_y)
-					+ (OCTANT + 2)) <= ((OCTANT + 2) << 1)
-							/* or not on collision course */
-					|| !PlotIntercept (
-							ShipPtr, OtherObjPtr, 30, CLOSE_RANGE_WEAPON << 1
-							)))
+				/* and facing away from enemy */
+				&& (NORMALIZE_ANGLE (desired_turn_angle
+									 - ARCTAN (ship_delta_x, ship_delta_y)
+									 + (OCTANT + 2)) <= ((OCTANT + 2) << 1)
+					/* or not on collision course */
+					|| !PlotIntercept (ShipPtr, OtherObjPtr, 30, (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR) << 1))) // JMS_GFX
 				maneuver_state &= ~THRUST;
-					/* veer off */
+			/* veer off */
 			else if (cone_of_fire == 1
-					|| RDPtr->characteristics.thrust_increment !=
-					RDPtr->characteristics.max_thrust)
+					 || RDPtr->characteristics.thrust_increment !=
+					 RDPtr->characteristics.max_thrust)
 			{
 				if (maneuver_state & (LEFT | RIGHT))
 				{
 					TurnShip (ShipPtr, desired_turn_angle);
 					maneuver_state &= ~(LEFT | RIGHT);
 				}
-
+				
 				if (NORMALIZE_ANGLE (desired_thrust_angle
-						- ARCTAN (ship_delta_x, ship_delta_y)
-						+ (OCTANT + 2)) <= ((OCTANT + 2) << 1))
+									 - ARCTAN (ship_delta_x, ship_delta_y)
+									 + (OCTANT + 2)) <= ((OCTANT + 2) << 1))
 					desired_thrust_angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 				else
 					desired_thrust_angle = desired_turn_angle;
 			}
 		}
 	}
-
+	
 DoManeuver:
 	if (maneuver_state & (LEFT | RIGHT))
 		TurnShip (ShipPtr, desired_thrust_angle);
-
+	
 	if (maneuver_state & THRUST)
 		ThrustShip (ShipPtr, desired_thrust_angle);
 }
@@ -1016,49 +1044,48 @@ tactical_intelligence (ComputerInputCont
 	STARSHIP *EnemyStarShipPtr;
 	RACE_DESC *RDPtr;
 	RACE_DESC *EnemyRDPtr;
-
+	
 	RDPtr = StarShipPtr->RaceDescPtr;
-
+	
 	if (RDPtr->cyborg_control.ManeuverabilityIndex == 0)
 		InitCyborg (StarShipPtr);
-
+	
 	LockElement (StarShipPtr->hShip, &ShipPtr);
 	if (RDPtr->ship_info.crew_level == 0
-			|| GetPrimType (&DisplayArray[ShipPtr->PrimIndex]) == NO_PRIM)
+		|| GetPrimType (&DisplayArray[ShipPtr->PrimIndex]) == NO_PRIM)
 	{
 		UnlockElement (StarShipPtr->hShip);
 		return (0);
 	}
-
+	
 	ShipMoved = TRUE;
 	/* Disable ship's special completely for the Standard AI */
 	if (StarShipPtr->control & STANDARD_RATING)
 		++StarShipPtr->special_counter;
-
+	
 #ifdef DEBUG_CYBORG
-if (!(ShipPtr->state_flags & FINITE_LIFE)
+	if (!(ShipPtr->state_flags & FINITE_LIFE)
 		&& ShipPtr->life_span == NORMAL_LIFE)
-	ShipPtr->life_span += 2; /* make ship invulnerable */
+		ShipPtr->life_span += 2; /* make ship invulnerable */
 #endif /* DEBUG_CYBORG */
 	Ship = *ShipPtr;
 	UnlockElement (StarShipPtr->hShip);
 	ShipFacing = StarShipPtr->ShipFacing;
-
+	
 	for (ConcernCounter = 0;
-			ConcernCounter <= FIRST_EMPTY_INDEX; ++ConcernCounter)
+		 ConcernCounter <= FIRST_EMPTY_INDEX; ++ConcernCounter)
 	{
 		ObjectsOfConcern[ConcernCounter].ObjectPtr = 0;
 		ObjectsOfConcern[ConcernCounter].MoveState = NO_MOVEMENT;
 		ObjectsOfConcern[ConcernCounter].which_turn = (COUNT)~0;
 	}
 	--ConcernCounter;
-
+	
 	UltraManeuverable = (BOOLEAN)(
-			RDPtr->characteristics.thrust_increment ==
-			RDPtr->characteristics.max_thrust
-			&& MANEUVERABILITY (&RDPtr->cyborg_control) >= MEDIUM_SHIP
-			);
-
+		RDPtr->characteristics.thrust_increment == RDPtr->characteristics.max_thrust
+		&& MANEUVERABILITY (&RDPtr->cyborg_control) >= RESOLUTION_COMPENSATED(MEDIUM_SHIP) // JMS_GFX
+		);
+	
 	if (Ship.turn_wait == 0)
 	{
 		ShipMoved = FALSE;
@@ -1069,65 +1096,65 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 		ShipMoved = FALSE;
 		StarShipPtr->ship_input_state &= ~THRUST;
 	}
-
+	
 	for (hElement = GetHeadElement ();
-			hElement != 0; hElement = hNextElement)
+		 hElement != 0; hElement = hNextElement)
 	{
 		EVALUATE_DESC ed;
-
+		
 		ed.MoveState = NO_MOVEMENT;
-
+		
 		LockElement (hElement, &ed.ObjectPtr);
 		hNextElement = GetSuccElement (ed.ObjectPtr);
 		if (CollisionPossible (ed.ObjectPtr, &Ship))
 		{
-			SIZE dx, dy;
-
+			SDWORD dx, dy;
+			
 			dx = ed.ObjectPtr->next.location.x
-					- Ship.next.location.x;
+				- Ship.next.location.x;
 			dy = ed.ObjectPtr->next.location.y
-					- Ship.next.location.y;
+				- Ship.next.location.y;
 			dx = WRAP_DELTA_X (dx);
 			dy = WRAP_DELTA_Y (dy);
 			if (GRAVITY_MASS (ed.ObjectPtr->mass_points))
 			{
 				COUNT maneuver_turn, ship_bounds;
 				RECT ship_footprint;
-
+				
 				if (UltraManeuverable)
 					maneuver_turn = 16;
-				else if (MANEUVERABILITY (&RDPtr->cyborg_control) <= MEDIUM_SHIP)
+				else if (MANEUVERABILITY (&RDPtr->cyborg_control) <= RESOLUTION_COMPENSATED(MEDIUM_SHIP)) // JMS_GFX
 					maneuver_turn = 48;
 				else
 					maneuver_turn = 32;
-
+				
 				GetFrameRect (SetAbsFrameIndex (
-						Ship.IntersectControl.IntersectStamp.frame, 0
-						), &ship_footprint);
+												Ship.IntersectControl.IntersectStamp.frame, 0
+												), &ship_footprint);
 				ship_bounds = (COUNT)(ship_footprint.extent.width
-						+ ship_footprint.extent.height);
-
+									  + ship_footprint.extent.height);
+				
 				if (!ShipMoved && (ed.which_turn =
-						PlotIntercept (ed.ObjectPtr, &Ship, maneuver_turn,
-						DISPLAY_TO_WORLD (30 + (ship_bounds * 3 /* << 2 */)))))
+								   PlotIntercept (ed.ObjectPtr, &Ship, maneuver_turn,
+												  DISPLAY_TO_WORLD ((30 << RESOLUTION_FACTOR) + (ship_bounds * 3 /* << 2 */))))) // JMS_GFX
 				{
 					if (ed.which_turn > 1
-							|| PlotIntercept (ed.ObjectPtr, &Ship, 1,
-							DISPLAY_TO_WORLD (35 + ship_bounds))
-							|| PlotIntercept (ed.ObjectPtr, &Ship,
-							maneuver_turn << 1,
-							DISPLAY_TO_WORLD (40 + ship_bounds)) > 1)
+						|| PlotIntercept (ed.ObjectPtr, &Ship, 1,
+										  DISPLAY_TO_WORLD ((35 << RESOLUTION_FACTOR) + ship_bounds)) // JMS_GFX
+						|| PlotIntercept (ed.ObjectPtr, &Ship,
+										  maneuver_turn << 1,
+										  DISPLAY_TO_WORLD ((40 << RESOLUTION_FACTOR) + ship_bounds)) > 1) // JMS_GFX
 					{
 						ed.facing = ARCTAN (-dx, -dy);
 						if (UltraManeuverable)
 							ed.MoveState = AVOID;
 						else // Try a gravity whip
 							ed.MoveState = ENTICE;
-
+						
 						ObjectsOfConcern[GRAVITY_MASS_INDEX] = ed;
 					}
 					else if (!UltraManeuverable &&
-							!IsVelocityZero (&Ship.velocity))
+							 !IsVelocityZero (&Ship.velocity))
 					{	// Try an orbital insertion, don't thrust
 						++Ship.thrust_wait;
 						if (Ship.turn_wait)
@@ -1141,54 +1168,56 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 				EnemyRDPtr = EnemyStarShipPtr->RaceDescPtr;
 				if (EnemyRDPtr->cyborg_control.ManeuverabilityIndex == 0)
 					InitCyborg (EnemyStarShipPtr);
-
-				ed.which_turn = WORLD_TO_TURN (
-						square_root ((long)dx * dx + (long)dy * dy));
-				if (ed.which_turn >
-						ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn)
+				
+				ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy)));
+				
+				//log_add(log_Debug,"SQR:%d (dx:%d), (dy:%d), norm:%d rezzed:%d", square_root ((long)dx * dx + (long)dy * dy), dx, dy, (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))), ed.which_turn);
+				
+				if ((ed.which_turn >> RESOLUTION_FACTOR) > ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn)
 				{
 					UnlockElement (hElement);
 					continue;
 				}
 				else if (ed.which_turn == 0)
 					ed.which_turn = 1;
-
+				
+				ed.which_turn >>= RESOLUTION_FACTOR; // JMS_GFX
+				
 				ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr = ed.ObjectPtr;
 				ObjectsOfConcern[ENEMY_SHIP_INDEX].facing =
 #ifdef MAYBE
-						OBJECT_CLOAKED (ed.ObjectPtr) ?
-						GetVelocityTravelAngle (&ed.ObjectPtr->velocity) :
+				OBJECT_CLOAKED (ed.ObjectPtr) ? GetVelocityTravelAngle (&ed.ObjectPtr->velocity) :
 #endif /* MAYBE */
-						FACING_TO_ANGLE (EnemyStarShipPtr->ShipFacing);
+				FACING_TO_ANGLE (EnemyStarShipPtr->ShipFacing);
 				ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn = ed.which_turn;
-
+				
 				if (ShipMoved
-						|| ed.ObjectPtr->mass_points > MAX_SHIP_MASS
-						|| (WEAPON_RANGE (&RDPtr->cyborg_control) < LONG_RANGE_WEAPON
-						&& (WEAPON_RANGE (&RDPtr->cyborg_control) <= CLOSE_RANGE_WEAPON
-						|| (WEAPON_RANGE (&EnemyRDPtr->cyborg_control) >= LONG_RANGE_WEAPON
-						&& (EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON))
-						|| (
+					|| ed.ObjectPtr->mass_points > MAX_SHIP_MASS
+					|| (WEAPON_RANGE (&RDPtr->cyborg_control) < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+						&& (WEAPON_RANGE (&RDPtr->cyborg_control) <= (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)
+							|| (WEAPON_RANGE (&EnemyRDPtr->cyborg_control) >= (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+								&& (EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON))
+							|| (
 #ifdef OLD
-						MANEUVERABILITY (&RDPtr->cyborg_control) <
-						MANEUVERABILITY (&EnemyRDPtr->cyborg_control)
+								MANEUVERABILITY (&RDPtr->cyborg_control) <
+								MANEUVERABILITY (&EnemyRDPtr->cyborg_control)
 #else /* !OLD */
-						RDPtr->characteristics.max_thrust <
-						EnemyRDPtr->characteristics.max_thrust
+								RDPtr->characteristics.max_thrust <
+								EnemyRDPtr->characteristics.max_thrust
 #endif /* !OLD */
-						&& WEAPON_RANGE (&RDPtr->cyborg_control) <
-						WEAPON_RANGE (&EnemyRDPtr->cyborg_control)))))
+								&& WEAPON_RANGE (&RDPtr->cyborg_control) <
+								WEAPON_RANGE (&EnemyRDPtr->cyborg_control)))))
 					ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = PURSUE;
 				else
 					ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = ENTICE;
-
+				
 				if ((EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & IMMEDIATE_WEAPON)
-						&& ship_weapons (ed.ObjectPtr, &Ship, 0))
+					&& ship_weapons (ed.ObjectPtr, &Ship, 0))
 				{
 					ed.which_turn = 1;
 					ed.MoveState = AVOID;
 					ed.facing = ObjectsOfConcern[ENEMY_SHIP_INDEX].facing;
-
+					
 					ObjectsOfConcern[ENEMY_WEAPON_INDEX] = ed;
 				}
 			}
@@ -1196,64 +1225,49 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 			{
 				if (!(ed.ObjectPtr->state_flags & FINITE_LIFE))
 				{
-					ed.which_turn = WORLD_TO_TURN (
-							square_root ((long)dx * dx + (long)dy * dy)
-							);
-
-					if (ed.which_turn <
-							ObjectsOfConcern[FIRST_EMPTY_INDEX].which_turn)
+					ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX
+					
+					if (ed.which_turn < ObjectsOfConcern[FIRST_EMPTY_INDEX].which_turn)
 					{
 						ed.MoveState = PURSUE;
 						ed.facing = GetVelocityTravelAngle (
-								&ed.ObjectPtr->velocity
-								);
-
+									&ed.ObjectPtr->velocity);
+						
 						ObjectsOfConcern[FIRST_EMPTY_INDEX] = ed;
 					}
 				}
 			}
 			else if (!elementsOfSamePlayer (ed.ObjectPtr, &Ship)
-					&& ed.ObjectPtr->preprocess_func != crew_preprocess
-					&& ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn > 1
-					&& ed.ObjectPtr->life_span > 0)
+					 && ed.ObjectPtr->preprocess_func != crew_preprocess
+					 && ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn > 1
+					 && ed.ObjectPtr->life_span > 0)
 			{
 				GetElementStarShip (ed.ObjectPtr, &EnemyStarShipPtr);
 				EnemyRDPtr = EnemyStarShipPtr->RaceDescPtr;
 				if (((EnemyRDPtr->ship_info.ship_flags & SEEKING_WEAPON)
-						&& ed.ObjectPtr->next.image.farray !=
-						EnemyRDPtr->ship_data.special)
-						|| ((EnemyRDPtr->ship_info.ship_flags & SEEKING_SPECIAL)
+					 && ed.ObjectPtr->next.image.farray !=
+					 EnemyRDPtr->ship_data.special)
+					|| ((EnemyRDPtr->ship_info.ship_flags & SEEKING_SPECIAL)
 						&& ed.ObjectPtr->next.image.farray ==
 						EnemyRDPtr->ship_data.special))
 				{
 					if ((!(ed.ObjectPtr->state_flags & (FINITE_LIFE | CREW_OBJECT))
-							&& RDPtr->characteristics.max_thrust > DISPLAY_TO_WORLD (8))
-							|| NORMALIZE_ANGLE (GetVelocityTravelAngle (
-									&ed.ObjectPtr->velocity
-									) - ARCTAN (-dx, -dy)
-									+ QUADRANT) > HALF_CIRCLE)
+						 && RDPtr->characteristics.max_thrust > DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR)) // JMS_GFX
+						|| NORMALIZE_ANGLE (GetVelocityTravelAngle (
+							&ed.ObjectPtr->velocity
+							) - ARCTAN (-dx, -dy) + QUADRANT) > HALF_CIRCLE)
 						ed.which_turn = 0;
 					else
 					{
-						ed.which_turn = WORLD_TO_TURN (
-								square_root ((long)dx * dx + (long)dy * dy)
-								);
-
+						ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX;
+						
 						ed.MoveState = ENTICE;
-						if (UltraManeuverable)
-						{
-							if (ed.which_turn == 0)
-								ed.which_turn = 1;
-							else if (ed.which_turn > 16)
-								ed.which_turn = 0;
-						}
-						else if (ed.which_turn == 0)
+						
+						if (ed.which_turn == 0)
 							ed.which_turn = 1;
-						else if (ed.which_turn > 16
-								|| (MANEUVERABILITY (
-								&RDPtr->cyborg_control
-								) > MEDIUM_SHIP
-								&& ed.which_turn > 8))
+						/* Shiver: The cap on which_turn for seeking weapons raised from 16 to 20.
+						 The horrible cap of 8 for above-medium speed ships has been obliterated. */
+						else if (ed.which_turn > 20)
 							ed.which_turn = 0;
 					}
 				}
@@ -1262,44 +1276,41 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 				else
 				{
 					ed.which_turn =
-							PlotIntercept (ed.ObjectPtr,
-							&Ship, ed.ObjectPtr->life_span,
-							DISPLAY_TO_WORLD (40));
+					PlotIntercept (ed.ObjectPtr,
+						&Ship, ed.ObjectPtr->life_span,
+						DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR)); // JMS_GFX
 					ed.MoveState = AVOID;
 				}
-
+				
 				if (ed.which_turn > 0
-						&& (ed.which_turn <
+					&& (ed.which_turn <
 						ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn
 						|| (ed.which_turn ==
-						ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn
-						&& ed.MoveState == AVOID)))
+							ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn
+							&& ed.MoveState == AVOID)))
 				{
 					ed.facing = GetVelocityTravelAngle (
-							&ed.ObjectPtr->velocity
-							);
-
+									&ed.ObjectPtr->velocity);
+					
 					ObjectsOfConcern[ENEMY_WEAPON_INDEX] = ed;
 				}
 			}
 			else if ((ed.ObjectPtr->state_flags & CREW_OBJECT)
-					&& ((!(ed.ObjectPtr->state_flags & IGNORE_SIMILAR)
-					&& elementsOfSamePlayer (ed.ObjectPtr, &Ship))
-					|| ed.ObjectPtr->preprocess_func == crew_preprocess)
-					&& ObjectsOfConcern[CREW_OBJECT_INDEX].which_turn > 1)
+					 && ((!(ed.ObjectPtr->state_flags & IGNORE_SIMILAR)
+						  && elementsOfSamePlayer (ed.ObjectPtr, &Ship))
+						 || ed.ObjectPtr->preprocess_func == crew_preprocess)
+					 && ObjectsOfConcern[CREW_OBJECT_INDEX].which_turn > 1)
 			{
-				ed.which_turn = WORLD_TO_TURN (
-						square_root ((long)dx * dx + (long)dy * dy)
-						);
-
+				ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX
+				
 				if (ed.which_turn == 0)
 					ed.which_turn = 1;
-
+				
 				if (ObjectsOfConcern[CREW_OBJECT_INDEX].which_turn >
-						ed.which_turn
-						&& (ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 32
+					ed.which_turn
+					&& (ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 32
 						|| (ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 8
-						&& StarShipPtr->hShip == ed.ObjectPtr->hTarget)))
+							&& StarShipPtr->hShip == ed.ObjectPtr->hTarget)))
 				{
 					ed.MoveState = PURSUE;
 					ed.facing = 0;
@@ -1309,17 +1320,17 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 		}
 		UnlockElement (hElement);
 	}
-
+	
 	RDPtr->cyborg_control.intelligence_func (&Ship, ObjectsOfConcern,
-			ConcernCounter);
+											 ConcernCounter);
 #ifdef DEBUG_CYBORG
-StarShipPtr->ship_input_state &= ~SPECIAL;
+	StarShipPtr->ship_input_state &= ~SPECIAL;
 #endif /* DEBUG_CYBORG */
-
+	
 	StarShipPtr->ShipFacing = ShipFacing;
 	{
 		BATTLE_INPUT_STATE InputState;
-
+		
 		InputState = 0;
 		if (StarShipPtr->ship_input_state & LEFT)
 			InputState |= BATTLE_LEFT;
@@ -1331,7 +1342,7 @@ StarShipPtr->ship_input_state &= ~SPECIA
 			InputState |= BATTLE_WEAPON;
 		if (StarShipPtr->ship_input_state & SPECIAL)
 			InputState |= BATTLE_SPECIAL;
-
+		
 		(void) context;
 		return (InputState);
 	}
diff -ruNp ./src.orig/uqm/element.h ./src/uqm/element.h
--- ./src.orig/uqm/element.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/element.h	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef _ELEMENT_H
 #define _ELEMENT_H
 
@@ -191,7 +193,7 @@ extern PRIMITIVE DisplayArray[MAX_DISPLA
 #define MAX_ENERGY_SIZE 42
 #define MAX_SHIP_MASS 10
 #define GRAVITY_MASS(m) ((m) > MAX_SHIP_MASS * 10)
-#define GRAVITY_THRESHOLD (COUNT)255
+#define GRAVITY_THRESHOLD (COUNT)(255 << RESOLUTION_FACTOR) // JMS_GFX
 
 #define OBJECT_CLOAKED(eptr) \
 		(GetPrimType (&GLOBAL (DisplayArray[(eptr)->PrimIndex])) >= NUM_PRIMS \
@@ -225,7 +227,7 @@ extern COUNT PlotIntercept (ELEMENT *Ele
 		ELEMENT *ElementPtr1, COUNT max_turns, COUNT margin_of_error);
 
 extern void InitGalaxy (void);
-extern void MoveGalaxy (VIEW_STATE view_state, SIZE dx, SIZE dy);
+extern void MoveGalaxy (VIEW_STATE view_state, SDWORD dx, SDWORD dy);
 
 extern BOOLEAN CalculateGravity (ELEMENT *ElementPtr);
 
diff -ruNp ./src.orig/uqm/encount.c ./src/uqm/encount.c
--- ./src.orig/uqm/encount.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/encount.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "encount.h"
 
 #include "battle.h"
@@ -38,6 +40,7 @@
 #include "settings.h"
 #include "setup.h"
 #include "sounds.h"
+#include "util.h" // JMS: For SaveContextFrame()
 #include "libs/graphics/gfx_common.h"
 #include "libs/log.h"
 #include "libs/mathlib.h"
@@ -294,7 +297,7 @@ InitEncounter (void)
 
 //    t.baseline.x = SIS_SCREEN_WIDTH >> 1;
 	t.baseline.x = (SIS_SCREEN_WIDTH >> 1) + 1;
-	t.baseline.y = 10;
+	t.baseline.y = 10 << RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_CENTER;
 
 	SetContextFont (MicroFont);
@@ -306,7 +309,7 @@ InitEncounter (void)
 				// "ENCOUNTER IN"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
 		t.pStr = GAME_STRING (ENCOUNTER_STRING_BASE + 1);
 				// "DEEP SPACE"
 		t.CharCount = (COUNT)~0;
@@ -320,12 +323,12 @@ InitEncounter (void)
 				// "ENCOUNTER AT"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
 		GetClusterName (CurStarDescPtr, buf);
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
 		t.pStr = GLOBAL_SIS (PlanetName);
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
@@ -367,6 +370,7 @@ InitEncounter (void)
 				hNextShip = hStarShip;
 
 			s.origin = display_pt[i % NUM_DISPLAY_PTS];
+			
 			if (i >= NUM_DISPLAY_PTS)
 			{
 				COUNT angle, radius;
@@ -374,11 +378,19 @@ InitEncounter (void)
 				radius = square_root ((long)s.origin.x * s.origin.x
 						+ (long)s.origin.y * s.origin.y)
 						+ ((i / NUM_DISPLAY_PTS) * 18);
+				
+				radius <<= RESOLUTION_FACTOR; // JMS_GFX
 
 				angle = ARCTAN (s.origin.x, s.origin.y);
-				s.origin.x = COSINE (angle, radius);
-				s.origin.y = SINE (angle, radius);
+				s.origin.x = (COSINE (angle, radius));
+				s.origin.y = (SINE (angle, radius));
 			}
+			else
+			{
+				s.origin.x <<= RESOLUTION_FACTOR; // JMS_GFX
+				s.origin.y <<= RESOLUTION_FACTOR; // JMS_GFX
+			}
+				
 			s.frame = SetAbsFrameIndex (FragPtr->icons, 0);
 			GetFrameRect (s.frame, &r);
 			s.origin.x += (SIS_SCREEN_WIDTH >> 1) - (r.extent.width >> 1);
@@ -423,6 +435,7 @@ DrawFadeText (const UNICODE *str1, const
 	SIZE i;
 	DWORD TimeIn;
 	TEXT t1, t2;
+	RECT r1, r2;
 	static const Color fade_cycle[] =
 	{
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x0A, 0x0A), 0x1D),
@@ -435,13 +448,13 @@ DrawFadeText (const UNICODE *str1, const
 	};
 #define NUM_FADES (sizeof (fade_cycle) / sizeof (fade_cycle[0]))
 
-	t1.baseline.x = pRect->corner.x + 100;
-	t1.baseline.y = pRect->corner.y + 45;
+	t1.baseline.x = pRect->corner.x + (100 << RESOLUTION_FACTOR); // JMS_GFX
+	t1.baseline.y = pRect->corner.y + (45 << RESOLUTION_FACTOR); // JMS_GFX
 	t1.align = ALIGN_CENTER;
 	t1.pStr = str1;
 	t1.CharCount = (COUNT)~0;
 	t2 = t1;
-	t2.baseline.y += 11;
+	t2.baseline.y += 11 << RESOLUTION_FACTOR; // JMS_GFX
 	t2.pStr = str2;
 
 	FlushInput ();
@@ -477,10 +490,18 @@ DrawFadeText (const UNICODE *str1, const
 			SleepThreadUntil (TimeIn + (ONE_SECOND / 20));
 			TimeIn = GetTimeCounter ();
 		}
+		// SetContextForeGroundColor (
+		//		BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+		// font_DrawText (&t1);
+		// font_DrawText (&t2);
+		// BW: previous lines don't work with anti-aliased fonts
 		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
-		font_DrawText (&t1);
-		font_DrawText (&t2);
+				   BUILD_COLOR_RGBA (0x50, 0x50, 0x50, 0xff));
+		TextRect(&t1, &r1, NULL);
+		TextRect(&t2, &r2, NULL);
+		DrawFilledRectangle (&r1);
+		DrawFilledRectangle (&r2);
+
 	}
 }
 
@@ -521,6 +542,11 @@ UninitEncounter (void)
 		UNICODE buf[80];
 		HSHIPFRAG hStarShip;
 		SHIP_FRAGMENT *FragPtr;
+		
+		// JMS: These are for fixing a bug at drawing "debris scavenged" in hires4x
+		RECT	save_r;
+		STAMP	saveMetallicFrame;
+		
 		static const Color fade_ship_cycle[] =
 		{
 			BUILD_COLOR (MAKE_RGB15_INIT (0x07, 0x00, 0x00), 0x2F),
@@ -619,8 +645,8 @@ UninitEncounter (void)
 
 								DrawStatusMessage (NULL);
 								
-								ship_s.origin.x = scavenge_r.corner.x + 32;
-								ship_s.origin.y = scavenge_r.corner.y + 56;
+								ship_s.origin.x = scavenge_r.corner.x + (32 << RESOLUTION_FACTOR); // JMS_GFX
+								ship_s.origin.y = scavenge_r.corner.y + (56 << RESOLUTION_FACTOR); // JMS_GFX
 								ship_s.frame = IncFrameIndex (FragPtr->icons);
 								DrawStamp (&ship_s);
 								SetContextForeGroundColor (
@@ -632,13 +658,13 @@ UninitEncounter (void)
 								// XXX: this will not work with UTF-8 strings
 								strupr (buf);
 
-								t.baseline.x = scavenge_r.corner.x + 100;
-								t.baseline.y = scavenge_r.corner.y + 68;
+								t.baseline.x = scavenge_r.corner.x + (100 << RESOLUTION_FACTOR); // JMS_GFX
+								t.baseline.y = scavenge_r.corner.y + (68 << RESOLUTION_FACTOR); // JMS_GFX
 								t.align = ALIGN_CENTER;
 								t.pStr = buf;
 								t.CharCount = (COUNT)~0;
 								font_DrawText (&t);
-								t.baseline.y += 6;
+								t.baseline.y += 6 << RESOLUTION_FACTOR; // JMS_GFX
 								t.pStr = GAME_STRING (
 										ENCOUNTER_STRING_BASE + 3);
 										// "BATTLE GROUP"
@@ -648,6 +674,24 @@ UninitEncounter (void)
 								ship_s.frame = FragPtr->icons;
 
 								SetContextFont (MicroFont);
+								
+								// JMS: Let's store the rectangle behind "Enemy ships destroyed" (before drawing the text on it).
+								if (RESOLUTION_FACTOR != 0)
+								{
+									// These values are inferred from DrawFadeText.
+									// However, they're not the same (100 and 45) because the text there is centered,
+									// but these rect coords are for the upper-left corner, not center.
+									save_r.corner.x = scavenge_r.corner.x + (70 << RESOLUTION_FACTOR); // JMS_GFX
+									save_r.corner.y = scavenge_r.corner.y + (35 << RESOLUTION_FACTOR); // JMS_GFX
+									
+									// These are wild-assed guesses.
+									save_r.extent.width  = 60 << RESOLUTION_FACTOR;
+									save_r.extent.height = 30 << RESOLUTION_FACTOR; 
+									
+									// Now that we have the size and placement of the rectangle, let's store it.
+									saveMetallicFrame = SaveContextFrame (&save_r);
+								}
+								
 								str1 = GAME_STRING (
 										ENCOUNTER_STRING_BASE + 4);
 										// "Enemy Ships"
@@ -657,23 +701,23 @@ UninitEncounter (void)
 								DrawFadeText (str1, str2, TRUE, &scavenge_r);
 							}
 
-							r.corner.y = scavenge_r.corner.y + 9;
-							r.extent.height = 22;
+							r.corner.y = scavenge_r.corner.y + (9 << RESOLUTION_FACTOR); // JMS_GFX
+							r.extent.height = 22 << RESOLUTION_FACTOR; // JMS_GFX
 
 							SetContextForeGroundColor (BLACK_COLOR);
 
-							r.extent.width = 34;
+							r.extent.width = 34 << RESOLUTION_FACTOR; // JMS_GFX
 							r.corner.x = scavenge_r.corner.x +
 									scavenge_r.extent.width
-									- (10 + r.extent.width);
+									- ((10 << RESOLUTION_FACTOR) + r.extent.width); // JMS_GFX
 							DrawFilledRectangle (&r);
 
 							/* collect bounty ResUnits */
 							j = race_bounty[EncounterRace] >> 3;
 							RecycleAmount += j;
 							sprintf (buf, "%u", RecycleAmount);
-							t.baseline.x = r.corner.x + r.extent.width - 1;
-							t.baseline.y = r.corner.y + 14;
+							t.baseline.x = r.corner.x + r.extent.width - 1 - 5 * RESOLUTION_FACTOR; // JMS_GFX;
+							t.baseline.y = r.corner.y + (14 << RESOLUTION_FACTOR); // JMS_GFX
 							t.align = ALIGN_RIGHT;
 							t.pStr = buf;
 							t.CharCount = (COUNT)~0;
@@ -683,17 +727,17 @@ UninitEncounter (void)
 							DeltaSISGauges (0, 0, j);
 
 							if ((VictoryState++ - 1) % MAX_DEAD_DISPLAYED)
-								ship_s.origin.x += 17;
+								ship_s.origin.x += (17 << RESOLUTION_FACTOR); // JMS_GFX
 							else
 							{
 								SetContextForeGroundColor (BLACK_COLOR);
 
-								r.corner.x = scavenge_r.corner.x + 10;
-								r.extent.width = 104;
+								r.corner.x = scavenge_r.corner.x + (10 << RESOLUTION_FACTOR); // JMS_GFX
+								r.extent.width = (104 << RESOLUTION_FACTOR); // JMS_GFX
 								DrawFilledRectangle (&r);
 
-								ship_s.origin.x = r.corner.x + 2;
-								ship_s.origin.y = scavenge_r.corner.y + 12;
+								ship_s.origin.x = r.corner.x + (2 << RESOLUTION_FACTOR); // JMS_GFX
+								ship_s.origin.y = scavenge_r.corner.y + (12 << RESOLUTION_FACTOR); // JMS_GFX
 							}
 
 							if (Sleepy)
@@ -746,13 +790,13 @@ UninitEncounter (void)
 				if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 				{
 					SetContextForeGroundColor (BLACK_COLOR);
-					r.corner.x = scavenge_r.corner.x + 10;
-					r.extent.width = 132;
+					r.corner.x = scavenge_r.corner.x + (10 << RESOLUTION_FACTOR); // JMS_GFX
+					r.extent.width = 132 << RESOLUTION_FACTOR; // JMS_GFX
 					DrawFilledRectangle (&r);
 					sprintf (buf, "%u %s", RecycleAmount,
 							GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
 					t.baseline.x = r.corner.x + (r.extent.width >> 1);
-					t.baseline.y = r.corner.y + 14;
+					t.baseline.y = r.corner.y + (14 << RESOLUTION_FACTOR); // JMS_GFX
 					t.align = ALIGN_CENTER;
 					t.pStr = buf;
 					t.CharCount = (COUNT)~0;
@@ -764,12 +808,22 @@ UninitEncounter (void)
 							// "Debris"
 					str2 = GAME_STRING (ENCOUNTER_STRING_BASE + 7);
 							// "Scavenged"
+					
+					// JMS: Now we draw the clean metallic frame to erase the "Enemy ships destroyed"
+					// text before drawing "debris scavenged."
+					if(RESOLUTION_FACTOR != 0)
+						DrawStamp (&saveMetallicFrame);
+					
 					DrawFadeText (str1, str2, TRUE, &scavenge_r);
 					UnlockMutex (GraphicsLock);
 					WaitForAnyButton (TRUE, ONE_SECOND * 2, FALSE);
 					LockMutex (GraphicsLock);
 					if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 						DrawFadeText (str1, str2, FALSE, &scavenge_r);
+					
+					// JMS: The final cleanup of the "Debris scavenged". Without this, an ugly grey ghost-text would remain.
+					if(RESOLUTION_FACTOR != 0)
+						DrawStamp (&saveMetallicFrame);
 				}
 			}
 
diff -ruNp ./src.orig/uqm/encount.h ./src/uqm/encount.h
--- ./src.orig/uqm/encount.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/encount.h	2017-10-23 11:41:34 -0700
@@ -124,7 +124,9 @@ enum
 	RAINBOW_DEFINED,
 	ILWRATH_DEFINED,
 	ANDROSYNTH_DEFINED,
-	MYCON_TRAP_DEFINED
+	MYCON_TRAP_DEFINED,
+	ZOQ_COLONY0_DEFINED,
+	ZOQ_COLONY1_DEFINED,
 };
 
 #define UMGAH_DEFINED TALKING_PET_DEFINED
diff -ruNp ./src.orig/uqm/flash.c ./src/uqm/flash.c
--- ./src.orig/uqm/flash.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/flash.c	2017-10-23 11:41:34 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 // NOTE: A lot of this code is untested. Only highlite and overlay flash
 //       areas, drawing directly to the screen, using a cache, are
 //       currently in use.
@@ -31,7 +33,7 @@
 #include "flash.h"
 
 #include "setup.h"
-		// For GraphicsLock.
+// For GraphicsLock.
 #include "libs/log.h"
 #include "libs/memlib.h"
 #include "libs/threadlib.h"
@@ -44,58 +46,58 @@ static void Flash_clearCache (FlashConte
 static void Flash_initCache (FlashContext *context);
 static void Flash_grabOriginal (FlashContext *context);
 static void Flash_blendFraction (FlashContext *context, int numer, int denom,
-		int *resNumer, int *resDenom);
+								 int *resNumer, int *resDenom);
 static void Flash_makeFrame (FlashContext *context,
-		FRAME dest, int numer, int denom);
+							 FRAME dest, int numer, int denom);
 static inline void Flash_prepareCacheFrame (FlashContext *context,
-		COUNT index);
+											COUNT index);
 static void Flash_drawFrame (FlashContext *context, FRAME frame);
 static void Flash_drawCacheFrame (FlashContext *context, COUNT index);
 static inline void Flash_drawUncachedFrame (FlashContext *context,
-		int numer, int denom);
+											int numer, int denom);
 static inline void Flash_drawCachedFrame (FlashContext *context,
-		int numer, int denom);
+										  int numer, int denom);
 static void Flash_drawCurrentFrame (FlashContext *context);
 
 static CONTEXT workGfxContext;
-		// Off-screen internal drawing context
+// Off-screen internal drawing context
 
 static FlashContext *
 Flash_create (CONTEXT gfxContext)
 {
 	FlashContext *context = HMalloc (sizeof (FlashContext));
-
+	
 	context->gfxContext     = gfxContext;
-
+	
 	context->original       = 0;
-
+	
 	context->startNumer     = 0;
 	context->endNumer       = 1;
 	context->denom          = 1;
-
+	
 	context->fadeInTime     = Flash_DEFAULT_FADE_IN_TIME;
 	context->onTime         = Flash_DEFAULT_ON_TIME;
 	context->fadeOutTime    = Flash_DEFAULT_FADE_OUT_TIME;
 	context->offTime        = Flash_DEFAULT_OFF_TIME;
-
+	
 	context->frameTime      = 0;
-
+	
 	context->state          = FlashState_off;
 	context->lastStateTime  = 0;
 	context->lastFrameTime  = 0;
 	
 	context->started        = false;
 	context->paused         = false;
-
+	
 	context->cache          = 0;
 	context->cacheSize      = Flash_DEFAULT_CACHE_SIZE;
 	
 	context->lastFrameIndex = (COUNT) -1;
-
+	
 	// TODO: Delete the context somewhere
 	if (!workGfxContext)
 		workGfxContext = CreateContext ("Flash.workGfxContext");
-
+	
 	return context;
 }
 
@@ -106,7 +108,7 @@ FlashContext *
 Flash_createHighlight (CONTEXT gfxContext, const RECT *rect)
 {
 	FlashContext *context = Flash_create (gfxContext);
-
+	
 	if (rect == NULL)
 	{
 		// No rectangle specified. It should be specified later with
@@ -119,18 +121,18 @@ Flash_createHighlight (CONTEXT gfxContex
 	else
 		context->rect = *rect;
 	context->type = FlashType_highlight;
-
+	
 	return context;
 }
 
 FlashContext *
 Flash_createTransition (CONTEXT gfxContext, const POINT *origin,
-		FRAME first, FRAME final)
+						FRAME first, FRAME final)
 {
 	FlashContext *context = Flash_create (gfxContext);
 	
 	context->type = FlashType_transition;
-
+	
 	context->u.transition.first = first;
 	context->u.transition.final = final;
 	GetFrameRect (final, &context->rect);
@@ -143,9 +145,9 @@ FlashContext *
 Flash_createOverlay (CONTEXT gfxContext, const POINT *origin, FRAME overlay)
 {
 	FlashContext *context = Flash_create (gfxContext);
-
+	
 	context->type = FlashType_overlay;
-
+	
 	if (origin == NULL || overlay == NULL) {
 		// No overlay specified. It should be specified later with
 		// Flash_setOverlay(), before calling Flash_start().
@@ -155,7 +157,7 @@ Flash_createOverlay (CONTEXT gfxContext,
 		context->rect.extent.width = 0;
 		context->rect.extent.height = 0;
 	} else
-		Flash_setOverlay (context, origin, overlay);
+		Flash_setOverlay (context, origin, overlay, FALSE);
 	
 	return context;
 }
@@ -164,18 +166,18 @@ Flash_createOverlay (CONTEXT gfxContext,
 // be considered to be already spent in this state.
 void
 Flash_setState (FlashContext *context, FlashState state,
-		TimeCount timeSpentInState)
+				TimeCount timeSpentInState)
 {
 	TimeCount now;
 	
 	now = GetTimeCounter ();
-
+	
 	context->state = state;
 	Flash_fixState (context);
 	
 	context->lastStateTime = now - timeSpentInState;
 	context->lastFrameTime = now;
-
+	
 	if (context->started)
 		Flash_drawCurrentFrame (context);
 }
@@ -186,18 +188,18 @@ Flash_start (FlashContext *context)
 	if (context->started)
 	{
 		log_add (log_Warning, "Flash_start() called on already started "
-				"FlashContext.\n");
+				 "FlashContext.\n");
 		return;
 	}
 	
 	Flash_initCache (context);
-
+	
 	context->started = true;
 	context->paused = false;
-
+	
 	Flash_grabOriginal (context);
 	context->lastFrameIndex = 0;
-
+	
 	Flash_fixState (context);
 	Flash_drawCurrentFrame (context);
 }
@@ -209,11 +211,11 @@ Flash_terminate (FlashContext *context)
 	{
 		// Restore the flash rectangle:
 		Flash_drawFrame (context, context->original);
-
+		
 		Flash_clearCache (context);
 		DestroyDrawable (ReleaseDrawable (context->original));
 	}
-
+	
 	HFree (context);
 }
 
@@ -268,12 +270,12 @@ void
 Flash_process (FlashContext *context)
 {
 	TimeCount now;
-
+	
 	if (!context->started || context->paused)
 		return;
 	
 	now = GetTimeCounter ();
-
+	
 	if (context->state == FlashState_fadeIn)
 	{
 		if (now >= context->lastStateTime + context->fadeInTime)
@@ -306,13 +308,13 @@ Flash_process (FlashContext *context)
 		Flash_nextState (context);
 		context->lastStateTime = now;
 	}
-
+	
 	Flash_drawCurrentFrame (context);
 }
 
 void
 Flash_setSpeed (FlashContext *context, TimeCount fadeInTime,
-		TimeCount onTime, TimeCount fadeOutTime, TimeCount offTime)
+				TimeCount onTime, TimeCount fadeOutTime, TimeCount offTime)
 {
 	context->fadeInTime = fadeInTime;
 	context->onTime = onTime;
@@ -339,17 +341,17 @@ Flash_setSpeed (FlashContext *context, T
 // These numbers are relative to the brighness of each original image.
 void
 Flash_setMergeFactors(FlashContext *context, int startNumer, int endNumer,
-		int denom) {
+					  int denom) {
 	if (context->started)
 	{
 		Flash_drawFrame (context, context->original);
 		Flash_clearCache (context);
 	}
-
+	
 	context->startNumer = startNumer;
 	context->endNumer = endNumer;
 	context->denom = denom;
-
+	
 	if (context->started)
 	{
 		Flash_grabOriginal (context);
@@ -370,9 +372,9 @@ Flash_nextTime (FlashContext *context)
 {
 	if (!context->started || context->paused)
 		return (TimeCount) -1;
-
+	
 	if (context->state == FlashState_fadeIn ||
-			context->state == FlashState_fadeOut)
+		context->state == FlashState_fadeOut)
 	{
 		// When we're fading in or out, we need updates during
 		// the fade.
@@ -393,10 +395,10 @@ static void
 Flash_clearCache (FlashContext *context)
 {
 	COUNT i;
-
+	
 #ifdef BEGIN_AND_END_FRAME_EXCEPTIONS
 	if (context->type == FlashType_transition ||
-			context->type == FlashType_overlay)
+		context->type == FlashType_overlay)
 	{
 		// First frame is not allocated by the flash code, so
 		// we shouldn't free it.
@@ -424,16 +426,16 @@ void
 Flash_setRect (FlashContext *context, const RECT *rect)
 {
 	assert(context->type == FlashType_highlight);
-
+	
 	if (context->started)
 	{
 		Flash_drawFrame (context, context->original);
 		Flash_clearCache (context);
 	}
-
+	
 	context->rect = *rect;
 	context->lastFrameIndex = (COUNT) -1;
-
+	
 	if (context->started)
 	{
 		Flash_grabOriginal (context);
@@ -445,26 +447,31 @@ void
 Flash_getRect (FlashContext *context, RECT *rect)
 {
 	assert (!context->type == FlashType_highlight);
-
+	
 	*rect = context->rect;
 }
 
+// JMS_GFX: The cleanup boolean can be used when changing between normal and hi-res modes.
+// It ensures that an ugly wrong-sized flash overlay from previous resolution is cleaned
+// from the flash process.
 void
-Flash_setOverlay (FlashContext *context, const POINT *origin, FRAME overlay)
+Flash_setOverlay (FlashContext *context, const POINT *origin, FRAME overlay, BOOLEAN cleanup)
 {
 	assert(context->type == FlashType_overlay);
-
-	if (context->started)
+	
+	if (context->started && !cleanup)
 	{
 		Flash_drawFrame (context, context->original);
 		Flash_clearCache (context);
 	}
 	
-	context->u.overlay.frame = overlay;
+	if (!cleanup)
+		context->u.overlay.frame = overlay;
+	
 	GetFrameRect (overlay, &context->rect);
 	context->rect.corner.x += origin->x;
 	context->rect.corner.y += origin->y;
-
+	
 	if (context->started)
 	{
 		Flash_grabOriginal (context);
@@ -499,7 +506,7 @@ static void
 Flash_initCache (FlashContext *context)
 {
 	COUNT i;
-
+	
 	context->cache = HMalloc (context->cacheSize * sizeof (FRAME));
 	for (i = 0; i < context->cacheSize; i++)
 		context->cache[i] = (FRAME) 0;
@@ -509,16 +516,16 @@ void
 Flash_setCacheSize (FlashContext *context, COUNT size)
 {
 	assert (size == 0 || size >= 2);
-
+	
 	if (context->cache != NULL)
 	{
 		Flash_clearCache (context);
 		HFree (context->cache);
 		context->cache = NULL;
 	}
-
+	
 	context->cacheSize = size;
-
+	
 	if (size != 0)
 		Flash_initCache (context);
 }
@@ -533,24 +540,24 @@ static void
 Flash_grabOriginal (FlashContext *context)
 {
 	CONTEXT oldGfxContext;
-
+	
 	if (context->original != (FRAME) 0)
 		DestroyDrawable (ReleaseDrawable (context->original));
-
+	
 	LockMutex (GraphicsLock);
 	oldGfxContext = SetContext (context->gfxContext);
 	context->original = CaptureDrawable (CopyContextRect (&context->rect));
 	SetContext (oldGfxContext);
 	FlushGraphics ();
-			// CopyContextRect() may have queued the command to read
-			// a rectangle from the screen; a FlushGraphics()
-			// is necessary to ensure that it can actually be used.
+	// CopyContextRect() may have queued the command to read
+	// a rectangle from the screen; a FlushGraphics()
+	// is necessary to ensure that it can actually be used.
 	UnlockMutex (GraphicsLock);
 }
 
 static inline void
 Flash_blendFraction (FlashContext *context, int numer, int denom,
-		int *resNumer, int *resDenom)
+					 int *resNumer, int *resDenom)
 {
 	// This function merges two fractions (F0 and F1),
 	// based on another fraction (P) (yielding R).
@@ -562,9 +569,9 @@ Flash_blendFraction (FlashContext *conte
 	//     (denom - numer) * startNumer / denom * context->denom
 	
 	assert (numer >= 0 && numer <= denom);
-
+	
 	*resNumer = numer * context->endNumer +
-			(denom - numer) * context->startNumer;
+	(denom - numer) * context->startNumer;
 	*resDenom = denom * context->denom;
 }
 
@@ -575,16 +582,16 @@ Flash_makeFrame (FlashContext *context,
 	STAMP s;
 	int blendedNumer;
 	int blendedDenom;
-
+	
 	s.origin.x = 0;
 	s.origin.y = 0;
-
+	
 	Flash_blendFraction (context, numer, denom, &blendedNumer, &blendedDenom);
-
+	
 	LockMutex (GraphicsLock);
 	oldGfxContext = SetContext (workGfxContext);
 	SetContextFGFrame (dest);
-
+	
 	switch (context->type) {
 		case FlashType_highlight:
 		{
@@ -593,7 +600,7 @@ Flash_makeFrame (FlashContext *context,
 			ClearDrawable ();
 			// Draw the frame at modulated strength (0 < strength <= 128)
 			SetContextDrawMode (MAKE_DRAW_MODE (DRAW_ADDITIVE,
-					DRAW_FACTOR_1 * blendedNumer / blendedDenom));
+												DRAW_FACTOR_1 * blendedNumer / blendedDenom));
 			s.frame = context->original;
 			DrawStamp (&s);
 			break;
@@ -602,21 +609,21 @@ Flash_makeFrame (FlashContext *context,
 		{
 			FRAME first;
 			FRAME final;
-
+			
 			first = context->u.transition.first;
 			if (first == (FRAME) 0)
 				first = context->original;
 			final = context->u.transition.final;
 			if (final == (FRAME) 0)
 				final = context->original;
-
+			
 			// Draw the first frame at full strength
 			SetContextDrawMode (DRAW_REPLACE_MODE);
 			s.frame = first;
 			DrawStamp (&s);
 			// Merge in the final frame
 			SetContextDrawMode (MAKE_DRAW_MODE (DRAW_ALPHA,
-					DRAW_FACTOR_1 * blendedNumer / blendedDenom));
+												DRAW_FACTOR_1 * blendedNumer / blendedDenom));
 			s.frame = final;
 			DrawStamp (&s);
 			break;
@@ -624,14 +631,14 @@ Flash_makeFrame (FlashContext *context,
 		case FlashType_overlay:
 		{
 			POINT oldOrigin;
-
+			
 			// Draw the original at full strength
 			SetContextDrawMode (DRAW_REPLACE_MODE);
 			s.frame = context->original;
 			DrawStamp (&s);
 			// Add or subtract the overlay at partial strength
 			SetContextDrawMode (MAKE_DRAW_MODE (DRAW_ADDITIVE,
-					DRAW_FACTOR_1 * blendedNumer / blendedDenom));
+												DRAW_FACTOR_1 * blendedNumer / blendedDenom));
 			s.frame = context->u.overlay.frame;
 			// Offset the draw origin to hit the right area
 			oldOrigin = SetContextOrigin (GetFrameHot (s.frame));
@@ -640,7 +647,7 @@ Flash_makeFrame (FlashContext *context,
 			break;
 		}
 	}
-
+	
 	SetContext (oldGfxContext);
 	UnlockMutex (GraphicsLock);
 }
@@ -651,24 +658,24 @@ Flash_prepareCacheFrame (FlashContext *c
 {
 	if (context->cache[index] != (FRAME) 0)
 		return;
-
+	
 #ifdef BEGIN_AND_END_FRAME_EXCEPTIONS
 	if (index == 0 && context->type == FlashType_overlay)
 		context->cache[index] = context->original;
 	else if (index == 0 && context->type == FlashType_transition)
 		context->cache[index] = context->u.transition.first != (FRAME) 0 ?
-				context->u.transition.first : context->original;
+		context->u.transition.first : context->original;
 	else if (index == context->cacheSize - 1 &&
-			context->type == FlashType_transition)
+			 context->type == FlashType_transition)
 		context->cache[index] = context->u.transition.final != (FRAME) 0 ?
-				context->u.transition.final : context->original;
+		context->u.transition.final : context->original;
 	else
 #endif  /* BEGIN_AND_END_FRMAE_EXCEPTIONS */
 	{
 		context->cache[index] = CaptureDrawable (CreateDrawable (WANT_PIXMAP,
-				context->rect.extent.width, context->rect.extent.height, 1));
+																 context->rect.extent.width, context->rect.extent.height, 1));
 		Flash_makeFrame (context, context->cache[index],
-				index, context->cacheSize - 1);
+						 index, context->cacheSize - 1);
 	}
 }
 
@@ -677,14 +684,14 @@ Flash_drawFrame (FlashContext *context,
 {
 	CONTEXT oldGfxContext;
 	STAMP stamp;
-
+	
 	LockMutex (GraphicsLock);
 	oldGfxContext = SetContext (context->gfxContext);
-
+	
 	stamp.origin = context->rect.corner;
 	stamp.frame = frame;
 	DrawStamp(&stamp);
-
+	
 	SetContext (oldGfxContext);
 	UnlockMutex (GraphicsLock);
 }
@@ -693,10 +700,10 @@ static void
 Flash_drawCacheFrame (FlashContext *context, COUNT index)
 {
 	FRAME frame;
-
+	
 	if (context->lastFrameIndex == index)
 		return;
-
+	
 	frame = context->cache[index];
 	Flash_drawFrame (context, frame);
 	context->lastFrameIndex = index;
@@ -708,12 +715,12 @@ Flash_drawUncachedFrame (FlashContext *c
 #ifdef BEGIN_AND_END_FRAME_EXCEPTIONS
 	// 'lastFrameIndex' is 0 for the first image, 1 for the final
 	// image, and 2 otherwise.
-
+	
 	if (numer == 0 && context->type == FlashType_overlay)
 	{
 		if (context->lastFrameIndex != 0)
 			return;
-
+		
 		Flash_drawFrame (context, context->original);
 		context->lastFrameIndex = 0;
 		return;
@@ -722,7 +729,7 @@ Flash_drawUncachedFrame (FlashContext *c
 	{
 		if (context->lastFrameIndex == 0)
 			return;
-
+		
 		Flash_drawFrame (context, context->u.transition.first);
 		context->lastFrameIndex = 0;
 		return;
@@ -731,24 +738,24 @@ Flash_drawUncachedFrame (FlashContext *c
 	{
 		if (context->lastFrameIndex == 1)
 			return;
-
+		
 		Flash_drawFrame (context, context->u.transition.final);
 		context->lastFrameIndex = 1;
 		return;
 	}
-
+	
 	context->lastFrameIndex = 2;
 #endif  /* BEGIN_AND_END_FRMAE_EXCEPTIONS */
-
+	
 	{
 		// Painting to the screen; we need a temporary frame to draw to.
 		FRAME work;
-
+		
 		work = CaptureDrawable (CreateDrawable (WANT_PIXMAP,
-				context->rect.extent.width, context->rect.extent.height, 1));
+												context->rect.extent.width, context->rect.extent.height, 1));
 		Flash_makeFrame (context, work, numer, denom);
 		Flash_drawFrame (context, work);
-
+		
 		DestroyDrawable (ReleaseDrawable (work));
 	}
 }
@@ -757,7 +764,7 @@ static inline void
 Flash_drawCachedFrame (FlashContext *context, int numer, int denom)
 {
 	COUNT cachePos;
-
+	
 	cachePos = ((context->cacheSize - 1) * numer + (denom / 2)) / denom;
 	Flash_prepareCacheFrame (context, cachePos);
 	Flash_drawCacheFrame (context, cachePos);
@@ -768,7 +775,7 @@ Flash_drawCurrentFrame (FlashContext *co
 {
 	int numer;
 	int denom;
-
+	
 	if (context->state == FlashState_off)
 	{
 		numer = 0;
@@ -782,26 +789,24 @@ Flash_drawCurrentFrame (FlashContext *co
 	else
 	{
 		TimeCount now = GetTimeCounter ();
-
+		
 		if (context->state == FlashState_fadeIn)
 			denom = (int) context->fadeInTime;
 		else
 			denom = (int) context->fadeOutTime;
-
+		
 		numer = (int) (now - context->lastStateTime);
-
+		
 		if (numer > denom)
 			numer = denom;
-
+		
 		if (context->state == FlashState_fadeOut)
 			numer = (int) context->fadeOutTime - numer;
 	}
-
+	
 	if (context->cacheSize == 0)
 		Flash_drawUncachedFrame (context, numer, denom);
 	else
 		Flash_drawCachedFrame (context, numer, denom);
 }
 
-
-
diff -ruNp ./src.orig/uqm/flash.h ./src/uqm/flash.h
--- ./src.orig/uqm/flash.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/flash.h	2017-10-23 11:41:34 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef _FLASH_H
 #define _FLASH_H
 
@@ -204,7 +206,7 @@ TimeCount Flash_nextTime (FlashContext *
 void Flash_setRect (FlashContext *context, const RECT *rect);
 void Flash_getRect (FlashContext *context, RECT *rect);
 void Flash_setOverlay(FlashContext *context, const POINT *origin,
-		FRAME overlay);
+		FRAME overlay, BOOLEAN cleanup); // JMS_GFX
 void Flash_preUpdate (FlashContext *context);
 void Flash_postUpdate (FlashContext *context);
 void Flash_setCacheSize (FlashContext *context, COUNT size);
diff -ruNp ./src.orig/uqm/fmv.c ./src/uqm/fmv.c
--- ./src.orig/uqm/fmv.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/fmv.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "fmv.h"
 
 #include "controls.h"
@@ -82,7 +84,29 @@ SplashScreen (void (* DoProcessing)(DWOR
 	LockMutex (GraphicsLock);
 	SetContext (ScreenContext);
 	s.origin.x = s.origin.y = 0;
-	s.frame = CaptureDrawable (LoadGraphic (TITLE_ANIM));
+
+	//s.frame = CaptureDrawable (LoadGraphic (TITLE_ANIM));
+	
+	//DC: Title Splashscreen.
+	if (resolutionFactor < 1)
+	{
+		printf("Loading 1x Splashscreen\n");
+		s.frame = CaptureDrawable (LoadGraphic (TITLE_ANIM));
+	}
+
+	else if (resolutionFactor == 1)
+	{
+		printf("Loading 2x Splashscreen\n");
+		s.frame = CaptureDrawable (LoadGraphic (TITLE_2X));
+	}
+
+	else if(resolutionFactor > 1)
+	{
+		printf("Loading 4x Splashscreen\n");
+		s.frame = CaptureDrawable (LoadGraphic (TITLE_4X));
+	}
+	// DC: End of spashscreen resolutions.
+	
 	DrawStamp (&s);
 	DestroyDrawable (ReleaseDrawable (s.frame));
 	UnlockMutex (GraphicsLock);
diff -ruNp ./src.orig/uqm/galaxy.c ./src/uqm/galaxy.c
--- ./src.orig/uqm/galaxy.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/galaxy.c	2017-10-23 11:41:34 -0700
@@ -18,6 +18,8 @@
 
 /* background starfield - used to generate agalaxy.asm */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "element.h"
 #include "globdata.h"
 #include "init.h"
@@ -41,8 +43,9 @@ extern PRIM_LINKS DisplayLinks;
 			+ MED_STAR_COUNT \
 			+ SML_STAR_COUNT)
 
-POINT SpaceOrg;
-static POINT log_star_array[NUM_STARS];
+// JMS: Changed from POINT to DPOINT
+DPOINT SpaceOrg;
+static DPOINT log_star_array[NUM_STARS];
 
 #define NUM_STAR_PLANES 3
 
@@ -50,9 +53,9 @@ typedef struct
 {
 	COUNT min_star_index;
 	COUNT num_stars;
-	POINT *star_array;
-	POINT *pmin_star;
-	POINT *plast_star;
+	DPOINT *star_array; // JMS: Changed from POINT to DPOINT
+	DPOINT *pmin_star;  // JMS: Changed from POINT to DPOINT
+	DPOINT *plast_star; // JMS: Changed from POINT to DPOINT
 } STAR_BLOCK;
 
 STAR_BLOCK StarBlock[NUM_STAR_PLANES] =
@@ -87,7 +90,7 @@ SortStarBlock (STAR_BLOCK *pStarBlock)
 		{
 			if (pStarBlock->star_array[i].y > pStarBlock->star_array[j].y)
 			{
-				POINT temp;
+				DPOINT temp; // JMS: Changed from POINT to DPOINT
 
 				temp = pStarBlock->star_array[i];
 				pStarBlock->star_array[i] = pStarBlock->star_array[j];
@@ -102,12 +105,13 @@ SortStarBlock (STAR_BLOCK *pStarBlock)
 			&pStarBlock->star_array[pStarBlock->num_stars - 1];
 }
 
+// JMS: Changed dx, dy from SIZE to SDWORD
 static void
-WrapStarBlock (SIZE plane, SIZE dx, SIZE dy)
+WrapStarBlock (SIZE plane, SDWORD dx, SDWORD dy)
 {
 	COUNT i;
-	POINT *ppt;
-	SIZE offs_y;
+	DPOINT *ppt; // JMS: Changed from POINT to DPOINT
+	SDWORD offs_y; // JMS: Changed from SIZE to SDWORD
 	COUNT num_stars;
 	STAR_BLOCK *pStarBlock;
 
@@ -237,7 +241,7 @@ void
 InitGalaxy (void)
 {
 	COUNT i, factor;
-	POINT *ppt;
+	DPOINT *ppt; // JMS: Changed POINT to DPOINT
 	PRIM_LINKS Links;
 
 	log_add (log_Debug, "InitGalaxy(): transition_width = %d, "
@@ -254,16 +258,22 @@ InitGalaxy (void)
 
 		if (i == BIG_STAR_COUNT || i == BIG_STAR_COUNT + MED_STAR_COUNT)
 			++factor;
-
-		ppt->x = (COORD)((UWORD)TFB_Random () % SPACE_WIDTH) << factor;
-		ppt->y = (COORD)((UWORD)TFB_Random () % SPACE_HEIGHT) << factor;
+		
+		// JMS Changed COORDS to SDWORDS
+		ppt->x = (SDWORD)((UWORD)TFB_Random () % SPACE_WIDTH) << factor;
+		ppt->y = (SDWORD)((UWORD)TFB_Random () % SPACE_HEIGHT) << factor;
 
 		if (i < BIG_STAR_COUNT + MED_STAR_COUNT)
 		{
 			SetPrimType (&DisplayArray[p], STAMP_PRIM);
 			SetPrimColor (&DisplayArray[p],
 					BUILD_COLOR (MAKE_RGB15 (0x0B, 0x0B, 0x1F), 0x09));
-			DisplayArray[p].Object.Stamp.frame = stars_in_space;
+			
+			// JMS_GFX: This was originally only "DisplayArray[p].Object.Stamp.frame = stars_in_space;"
+			if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				DisplayArray[p].Object.Stamp.frame = stars_in_space;
+			else
+				DisplayArray[p].Object.Stamp.frame = stars_in_quasispace;
 		}
 		else
 		{
@@ -287,9 +297,9 @@ InitGalaxy (void)
 	SortStarBlock (&StarBlock[2]);
 }
 
+// JMS: Changed POINT *pt2 to DPOINT *pt2 and dx, dy from SIZE to SDWORD
 static BOOLEAN
-CmpMovePoints (const POINT *pt1, const POINT *pt2, SIZE dx, SIZE dy,
-			   SIZE reduction)
+CmpMovePoints (const POINT *pt1, const DPOINT *pt2, SDWORD dx, SDWORD dy, SIZE reduction)
 {
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{
@@ -303,8 +313,9 @@ CmpMovePoints (const POINT *pt1, const P
 	}
 }
 
+// JMS: Changed dx, dy from SIZE to SDWORD
 void
-MoveGalaxy (VIEW_STATE view_state, SIZE dx, SIZE dy)
+MoveGalaxy (VIEW_STATE view_state, SDWORD dx, SDWORD dy)
 {
 	PRIMITIVE *pprim;
 	static const COUNT star_counts[] =
@@ -320,10 +331,17 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 		COUNT reduction;
 		COUNT i;
 		COUNT iss;
-		POINT *ppt;
+		DPOINT *ppt;
+		FRAME tempframe;
 		int wrap_around;
 
 		reduction = zoom_out;
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+			tempframe = stars_in_space;
+		else
+			tempframe = stars_in_quasispace;
 
 		if (view_state == VIEW_CHANGE)
 		{
@@ -333,8 +351,9 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 				{
 					for (i = star_counts[iss]; i > 0; --i, ++pprim)
 					{
+						// JMS_GFX: Replaced stars_in_space with tempframe.
 						pprim->Object.Stamp.frame =	SetAbsFrameIndex (
-								stars_in_space,
+								tempframe,
 									(COUNT)(TFB_Random () & 31)
 									+ star_frame_ofs[iss]);
 					}
@@ -343,7 +362,7 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 			else
 			{
 				GRAPHICS_PRIM star_object[2];
-				FRAME star_frame[2];
+				FRAME star_frame[9]; // JMS_GFX: was 2. Added extra frames for more star .pngs.
 
 				star_frame[0] = IncFrameIndex (stars_in_space);
 				star_frame[1] = stars_in_space;
@@ -363,23 +382,69 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 				}
 				else
 				{	/* on 3DO, the closest stars are pixels when zoomed out */
+					/* In 320x240 mode. */
 					star_object[1] = POINT_PRIM;
 					if (reduction > (1 << ZOOM_SHIFT))
 					{
-						star_object[0] = POINT_PRIM;
+						// JMS_GFX: In hi-res modes, Closest stars are images when zoomed out.
+						if (RESOLUTION_FACTOR == 0)
+							star_object[0] = POINT_PRIM;
+						else
+						{
+							star_object[0] = STAMP_PRIM;
+							star_object[1] = STAMP_PRIM;
+							star_frame[0] = stars_in_space;
+							star_frame[1] = IncFrameIndex (stars_in_space);
+							
+						}
 					}
 					else
 					{
 						star_object[0] = STAMP_PRIM;
+						star_object[1] = STAMP_PRIM;
 					}
 				}
 
-				for (iss = 0, pprim = DisplayArray; iss < 2; ++iss)
+				// Normal handling of stars in 320x240.
+				if (RESOLUTION_FACTOR == 0)
 				{
-					for (i = star_counts[iss]; i > 0; --i, ++pprim)
+					for (iss = 0, pprim = DisplayArray; iss < 2; ++iss)
+					{
+						for (i = star_counts[iss]; i > 0; --i, ++pprim)
+						{
+							SetPrimType (pprim, star_object[iss]);
+							pprim->Object.Stamp.frame = star_frame[iss];
+						}
+					}
+				}
+				
+				// JMS_GFX: Advanced handling of stars in hi-res modes.
+				// Basically, draw a BIG star .png when zoomed close in
+				// medium-sized when at med distance and a small .png when far away.
+				else
+				{
+					COUNT zoomlevel;
+					COUNT med_sml_zoom_limit = optMeleeScale == TFB_SCALE_STEP ? 0 : (1 << (ZOOM_SHIFT + 1));
+					
+					if (reduction == MAX_ZOOM_OUT)
+						zoomlevel = 0;
+					else if (reduction <= med_sml_zoom_limit)
+						zoomlevel = 6;
+					else
+						zoomlevel = 3;
+					
+					for (i = 3; i < 9; i++)
+					{
+						star_frame[i] = SetAbsFrameIndex (stars_in_space, i);
+					}
+				
+					for (iss = 0, pprim = DisplayArray; iss < 2; ++iss)
 					{
-						SetPrimType (pprim, star_object[iss]);
-						pprim->Object.Stamp.frame = star_frame[iss];
+						for (i = star_counts[iss]; i > 0; --i, ++pprim)
+						{
+							SetPrimType (pprim, star_object[iss]);
+							pprim->Object.Stamp.frame = star_frame[iss + zoomlevel];
+						}
 					}
 				}
 			}
@@ -417,10 +482,11 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 		}
 		else
 		{
-			dx = (COORD)(LOG_SPACE_WIDTH >> 1)
+			// JMS: Changed COORDs to SDWORDs
+			dx = (SDWORD)(LOG_SPACE_WIDTH >> 1)
 					- (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1)
 					- MAX_VIS_REDUCTION));
-			dy = (COORD)(LOG_SPACE_HEIGHT >> 1)
+			dy = (SDWORD)(LOG_SPACE_HEIGHT >> 1)
 					- (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1)
 					- MAX_VIS_REDUCTION));
 			if (optMeleeScale == TFB_SCALE_STEP)
diff -ruNp ./src.orig/uqm/gameev.c ./src/uqm/gameev.c
--- ./src.orig/uqm/gameev.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/gameev.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,7 @@
  */
 
 #include "gameev.h"
+#include "options.h" // JMS: For cheat mode.
 
 #include "build.h"
 #include "clock.h"
@@ -40,9 +41,11 @@ static void mycon_mission (void);
 
 void
 AddInitialGameEvents (void) {
+	COUNT kohrah_winning_years = optCheatMode ? YEARS_TO_KOHRAH_VICTORY + 25 : YEARS_TO_KOHRAH_VICTORY;
+
 	AddEvent (RELATIVE_EVENT, 0, 1, 0, HYPERSPACE_ENCOUNTER_EVENT);
 	AddEvent (ABSOLUTE_EVENT, 3, 17, START_YEAR, ARILOU_ENTRANCE_EVENT);
-	AddEvent (RELATIVE_EVENT, 0, 0, YEARS_TO_KOHRAH_VICTORY,
+	AddEvent (RELATIVE_EVENT, 0, 0, kohrah_winning_years,
 			KOHR_AH_VICTORIOUS_EVENT);
 	AddEvent (RELATIVE_EVENT, 0, 0, 0, SLYLANDRO_RAMP_UP);
 }
@@ -387,6 +390,10 @@ black_urquan_genocide (void)
 			speed = 1;
 		else if (speed > 255)
 			speed = 255;
+			
+		// JMS: Cheat mode: The Kohr-Ah don't move at all!
+		if (optCheatMode)
+			speed = 0;
 
 		SET_GAME_STATE (KOHR_AH_FRENZY, 1);
 		SET_GAME_STATE (KOHR_AH_VISITS, 0);
diff -ruNp ./src.orig/uqm/gameopt.c ./src/uqm/gameopt.c
--- ./src.orig/uqm/gameopt.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/gameopt.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "gameopt.h"
 
 #include "build.h"
@@ -35,14 +37,17 @@
 #include "sounds.h"
 #include "util.h"
 #include "libs/graphics/gfx_common.h"
+#include "libs/log.h"
+
+#include "process.h" // JMS
 
 #include <ctype.h>
 
 extern FRAME PlayFrame;
 
 #define MAX_SAVED_GAMES 50
-#define SUMMARY_X_OFFS 14
-#define SUMMARY_SIDE_OFFS 7
+#define SUMMARY_X_OFFS (14 << RESOLUTION_FACTOR) // JMS_GFX
+#define SUMMARY_SIDE_OFFS (7 << RESOLUTION_FACTOR) // JMS_GFX
 #define SAVES_PER_PAGE 5
 
 #define MAX_NAME_SIZE  SIS_NAME_SIZE
@@ -61,7 +66,7 @@ ConfirmSaveLoad (STAMP *MsgStamp)
 	GetContextClipRect (&clip_r);
 
 	t.baseline.x = clip_r.extent.width >> 1;
-	t.baseline.y = (clip_r.extent.height >> 1) + 3;
+	t.baseline.y = (clip_r.extent.height >> 1) + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	if (MsgStamp)
@@ -71,20 +76,32 @@ ConfirmSaveLoad (STAMP *MsgStamp)
 		t.pStr = GAME_STRING (SAVEGAME_STRING_BASE + 1);
 				// "Loading . . ."
 	TextRect (&t, &r, NULL);
-	r.corner.x -= 4;
-	r.corner.y -= 4;
-	r.extent.width += 8;
-	r.extent.height += 8;
+	r.corner.x -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.width += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height += 8 << RESOLUTION_FACTOR; // JMS_GFX
 	if (MsgStamp)
 	{
 		*MsgStamp = SaveContextFrame (&r);
 	}
-	DrawStarConBox (&r, 2,
-			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
-			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
-			TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		DrawStarConBox (&r, 2,
+						BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
+						BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
+						TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+	}
+	else
+	{
+		DrawStarConBox (&r, 2,
+						PCMENU_TOP_LEFT_BORDER_COLOR,
+						PCMENU_BOTTOM_RIGHT_BORDER_COLOR,
+						TRUE, PCMENU_BACKGROUND_COLOR);
+		SetContextForeGroundColor (PCMENU_SELECTION_TEXT_COLOR);
+	}
+	
 	font_DrawText (&t);
 }
 
@@ -189,18 +206,18 @@ DrawNameString (bool nameCaptain, UNICOD
 	LockMutex (GraphicsLock);
 
 	{
-		r.corner.x = 2;
-		r.extent.width = SHIP_NAME_WIDTH;
 		r.extent.height = SHIP_NAME_HEIGHT;
 
 		SetContext (StatusContext);
 		if (nameCaptain)
 		{	// Naming the captain
 			Font = TinyFont;
-			r.corner.y = 10;
-			++r.corner.x;
-			r.extent.width -= 2;
-			lf.baseline.x = r.corner.x + (r.extent.width >> 1) - 1;
+			r.corner.x = RES_STAT_SCALE(3) - RES_CASE(0,3,5); // JMS_GFX
+			r.corner.y = RES_CASE(10,20,32); // JMS_GFX
+			r.extent.width = SHIP_NAME_WIDTH - RES_CASE(2,1,0);		// JMS_GFX
+			r.extent.height += RESOLUTION_FACTOR; // JMS_GFX
+			lf.baseline.x = (STATUS_WIDTH >> 1) - RES_CASE(1,0,-1);
+			lf.baseline.y = r.corner.y + r.extent.height - RES_CASE(1,4,3);
 
 			BackGround = BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09);
 			ForeGround = BUILD_COLOR (MAKE_RGB15 (0x0A, 0x1F, 0x1F), 0x0B);
@@ -208,14 +225,17 @@ DrawNameString (bool nameCaptain, UNICOD
 		else
 		{	// Naming the flagship
 			Font = StarConFont;
-			r.corner.y = 20;
+			r.corner.x = RES_CASE(2,3,5); // JMS_GFX
+			r.corner.y = RES_CASE(20,40,63); // JMS_GFX
+			r.extent.width = SHIP_NAME_WIDTH;
+			r.extent.height += RES_CASE(0,0,1); // JMS_GFX
 			lf.baseline.x = r.corner.x + (r.extent.width >> 1);
+			lf.baseline.y = r.corner.y + r.extent.height - RES_CASE(1,4,3); // JMS_GFX
 
 			BackGround = BUILD_COLOR (MAKE_RGB15 (0x0F, 0x00, 0x00), 0x2D);
 			ForeGround = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x0A, 0x00), 0x7D);
 		}
 
-		lf.baseline.y = r.corner.y + r.extent.height - 1;
 		lf.align = ALIGN_CENTER;
 	}
 
@@ -302,22 +322,77 @@ OnNameChange (TEXTENTRY_STATE *pTES)
 	return DrawNameString (nameCaptain, pTES->BaseStr, pTES->CursorPos, hl);
 }
 
+// JMS: Added the 'gamestart' parameter.
 static void
-NameCaptainOrShip (bool nameCaptain)
+NameCaptainOrShip (bool nameCaptain, bool gamestart)
 {
 	UNICODE buf[MAX_NAME_SIZE] = "";
 	TEXTENTRY_STATE tes;
 	UNICODE *Setting;
-
+	COUNT CursPos = 0; // JMS
+	RECT r; // JMS
+	
 	LockMutex (GraphicsLock);
+	
+	// JMS: This should only be invoked when starting a new game.
+	// It prints a prompt window to the center of the screen, urging
+	// the player to name his captain and ship.
+	if (gamestart)
+	{
+		RECT clip_r;
+		TEXT t;
+		
+		SetContext (ScreenContext);
+		SetContextFont (StarConFont);
+		GetContextClipRect (&clip_r);
+		
+		t.baseline.x = clip_r.extent.width >> 1;
+		t.baseline.y = (clip_r.extent.height >> 1) + (3 << RESOLUTION_FACTOR); // JMS_GFX
+		t.align = ALIGN_CENTER;
+		t.CharCount = (COUNT)~0;
+		
+		if (nameCaptain)
+		{
+			// "Captain, what is your name?"
+			t.pStr = GAME_STRING (NAMING_STRING_BASE + 4);
+			strcpy (buf,  GAME_STRING (NAMING_STRING_BASE + 3)); // "Zelnick"
+			CursPos = strlen(GAME_STRING (NAMING_STRING_BASE + 3));
+		}
+		else
+		{
+			// "What is the name of your flagship?"
+			t.pStr = GAME_STRING (NAMING_STRING_BASE + 5);
+			strcpy (buf, GAME_STRING (NAMING_STRING_BASE + 2)); // "Vindicator"
+			CursPos = strlen(GAME_STRING (NAMING_STRING_BASE + 2));
+		}
+		
+		TextRect (&t, &r, NULL);
+		r.corner.x -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.y -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.width += 8 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height += 8 << RESOLUTION_FACTOR; // JMS_GFX
+		
+		DrawStarConBox (&r, 2,
+						BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
+						BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
+						TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+		SetContextForeGroundColor (
+								   BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+		font_DrawText (&t);
+	}
+
+	
 	SetFlashRect (NULL);
 	UnlockMutex (GraphicsLock);
 
-	DrawNameString (nameCaptain, buf, 0, DDSHS_EDIT);
+	DrawNameString (nameCaptain, buf, CursPos, DDSHS_EDIT);
 
-	LockMutex (GraphicsLock);
-	DrawStatusMessage (GAME_STRING (NAMING_STRING_BASE + 0));
-	UnlockMutex (GraphicsLock);
+	if (!gamestart)
+	{
+		LockMutex (GraphicsLock);
+		DrawStatusMessage (GAME_STRING (NAMING_STRING_BASE + 0));
+		UnlockMutex (GraphicsLock);
+	}
 
 	if (nameCaptain)
 	{
@@ -333,7 +408,7 @@ NameCaptainOrShip (bool nameCaptain)
 	// text entry setup
 	tes.Initialized = FALSE;
 	tes.BaseStr = buf;
-	tes.CursorPos = 0;
+	tes.CursorPos = CursPos;
 	tes.CbParam = (void*) nameCaptain;
 	tes.ChangeCallback = OnNameChange;
 	tes.FrameCallback = 0;
@@ -347,12 +422,231 @@ NameCaptainOrShip (bool nameCaptain)
 	SetFlashRect (SFR_MENU_3DO);
 	UnlockMutex (GraphicsLock);
 	
-	DrawNameString (nameCaptain, buf, 0, DDSHS_NORMAL);
+	DrawNameString (nameCaptain, buf, CursPos, DDSHS_NORMAL);
+
+	if (namingCB)
+		namingCB ();
+	
+	// JMS: This clears the captain or ship naming prompt.
+	if (gamestart)
+	{
+		LockMutex (GraphicsLock);
+		SetContext (ScreenContext);
+		DrawStarConBox (&r, 2,
+			BLACK_COLOR, BLACK_COLOR, TRUE, BLACK_COLOR);
+		UnlockMutex (GraphicsLock);
+	}
+
+	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+}
+
+// JMS
+static BOOLEAN
+DrawSaveNameString (UNICODE *Str, COUNT CursorPos, COUNT state, COUNT gameIndex)
+{
+	RECT r;
+	TEXT lf;
+	Color BackGround, ForeGround;
+	FONT Font;
+	
+	LockMutex (GraphicsLock);
+	
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33));
+	r.extent.width = 15 << RESOLUTION_FACTOR; // JMS_GFX
+	if (MAX_SAVED_GAMES > 99)
+		r.extent.width += 5 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = 11 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.x = 8 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = (160 + ((gameIndex % SAVES_PER_PAGE) * 13)) << RESOLUTION_FACTOR; // JMS_GFX
+	DrawRectangle (&r);
+	
+	r.extent.width = (204 - SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.x = (30 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
+	DrawRectangle (&r);
+		
+	Font = TinyFont;
+	lf.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR); // JMS_GFX
+	lf.baseline.y = r.corner.y + RES_CASE(8,14,29); // JMS_GFX
+			
+	BackGround = BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33);
+	ForeGround = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01);
+		
+	lf.align = ALIGN_LEFT;
+	
+	SetContextFont (Font);
+	lf.pStr = Str;
+	lf.CharCount = (COUNT)~0;
+	
+	if (!(state & DDSHS_EDIT))
+	{	
+		//RECT r;
+		TEXT t;
+		
+		SetContextForeGroundColor (BLACK_COLOR);
+		DrawFilledRectangle (&r);
+		
+		t.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR);
+		t.baseline.y = r.corner.y + (8 << RESOLUTION_FACTOR); // JMS_GFX
+		t.align = ALIGN_LEFT;
+		t.pStr = Global_save_name;
+		t.CharCount = (COUNT)~0;
+		SetContextForeGroundColor (CAPTAIN_NAME_TEXT_COLOR);
+		font_DrawText (&t);
+	}
+	else
+	{	// editing state
+		COUNT i;
+		RECT text_r;
+		BYTE char_deltas[SAVE_NAME_SIZE];
+		BYTE *pchar_deltas;
+		
+		TextRect (&lf, &text_r, char_deltas);
+		if ((text_r.extent.width + 2) >= r.extent.width)
+		{	// the text does not fit the input box size and so
+			// will not fit when displayed later
+			UnlockMutex (GraphicsLock);
+			// disallow the change
+			return (FALSE);
+		}
+		
+		SetContextForeGroundColor (BackGround);
+		DrawFilledRectangle (&r);
+		
+		pchar_deltas = char_deltas;
+		
+		for (i = CursorPos; i > 0; --i)
+			text_r.corner.x += *pchar_deltas++;
+		if (CursorPos < lf.CharCount) /* end of line */
+			--text_r.corner.x;
+		
+		if (state & DDSHS_BLOCKCUR)
+		{	// Use block cursor for keyboardless systems
+			if (CursorPos == lf.CharCount)
+			{	// cursor at end-line -- use insertion point
+				text_r.extent.width = 1;
+			}
+			else if (CursorPos + 1 == lf.CharCount)
+			{	// extra pixel for last char margin
+				text_r.extent.width = (SIZE)*pchar_deltas + 2;
+			}
+			else
+			{	// normal mid-line char
+				text_r.extent.width = (SIZE)*pchar_deltas + 1;
+			}
+		}
+		else
+		{	// Insertion point cursor
+			text_r.extent.width = 1;
+		}
+		
+		text_r.corner.y = r.corner.y;
+		text_r.extent.height = r.extent.height;
+		SetContextForeGroundColor (BLACK_COLOR);
+		DrawFilledRectangle (&text_r);
+		
+		SetContextForeGroundColor (ForeGround);
+		font_DrawText (&lf);
+		
+		SetFlashRect (&r);
+	}
+	
+	UnlockMutex (GraphicsLock);
+	return (TRUE);
+}
+
+// JMS
+static BOOLEAN
+OnSaveNameChange (TEXTENTRY_STATE *pTES)
+{
+	COUNT hl = DDSHS_EDIT;
+	COUNT *gameIndex = pTES->CbParam;
+	
+	if (pTES->JoystickMode)
+		hl |= DDSHS_BLOCKCUR;
+	
+	return DrawSaveNameString (pTES->BaseStr, pTES->CursorPos, hl, *gameIndex);
+}
+
+// JMS
+static BOOLEAN
+NameSaveGame (SUMMARY_DESC *desc, COUNT gameIndex)
+{
+	UNICODE buf[SAVE_NAME_SIZE] = "";
+	TEXTENTRY_STATE tes;
+	UNICODE *Setting;
+	COUNT CursPos = 0; // JMS
+	COUNT *gIndex = HMalloc (sizeof (COUNT));
+	
+	*gIndex = gameIndex;
+	
+	if (!(strncmp(desc->SaveNameChecker, SAVE_NAME_CHECKER, SAVE_CHECKER_SIZE)))
+	{
+		strncpy (buf, desc->SaveName, SAVE_NAME_SIZE);
+		CursPos = strlen(desc->SaveName);
+	}
+	
+	DrawSaveNameString (buf, CursPos, DDSHS_EDIT, gameIndex);
+	
+	Setting = Global_save_name;
+	tes.MaxSize = SAVE_NAME_SIZE;
+	
+	// text entry setup
+	tes.Initialized = FALSE;
+	tes.BaseStr = buf;
+	tes.CursorPos = CursPos;
+	tes.CbParam = gIndex;
+	tes.ChangeCallback = OnSaveNameChange;
+	tes.FrameCallback = 0;
+	
+	if (DoTextEntrySavename (&tes))
+		utf8StringCopy (Setting, tes.MaxSize, buf);
+	else
+		utf8StringCopy (buf, sizeof (buf), Setting);
+	
+	DrawSaveNameString (buf, CursPos, DDSHS_NORMAL, gameIndex);
 
 	if (namingCB)
 		namingCB ();
+	
+	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+	
+	HFree (gIndex);
+	
+	LockMutex (GraphicsLock);
+	SetFlashRect (NULL);
+	UnlockMutex (GraphicsLock);
+	
+	if (tes.Success)
+		return (TRUE);
+	else
+		return (FALSE);
+}
 
+// JMS: This is for naming captain and ship at game start.
+void
+AskNameForCaptainAndShip()
+{
+	// Give sounds for arrows and enter.
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+
+	// Erase the intro graphics (that are still hidden in the black fade).
+	LockMutex (GraphicsLock);
+	SetContext (ScreenContext);
+	SetContextBackGroundColor (BLACK_COLOR);
+	ClearDrawable ();
+
+	// Enable graphics so the prompt for captain naming will be visible.
+	FadeScreen (FadeAllToColor, ONE_SECOND / 2);
+	UnlockMutex (GraphicsLock);
+	
+	// Name the captain and the ship.
+	NameCaptainOrShip (true, true);
+	NameCaptainOrShip (false, true);
+	
+	// Re-fade to black before loading the first IP graphics.
+	LockMutex (GraphicsLock);
+	FadeScreen (FadeAllToBlack, ONE_SECOND / 2);
+	UnlockMutex (GraphicsLock);
 }
 
 void
@@ -395,7 +689,7 @@ DoSettings (MENU_STATE *pMS)
 				break;
 			case CHANGE_CAPTAIN_SETTING:
 			case CHANGE_SHIP_SETTING:
-				NameCaptainOrShip (pMS->CurState == CHANGE_CAPTAIN_SETTING);
+				NameCaptainOrShip (pMS->CurState == CHANGE_CAPTAIN_SETTING, false);
 				break;
 			default:
 				if (cur_speed++ < NUM_COMBAT_SPEEDS - 1)
@@ -455,7 +749,7 @@ DrawBlankSavegameDisplay (PICK_GAME_STAT
 {
 	STAMP s;
 
-	s.origin.x = 0;
+	s.origin.x = 0 - (RESOLUTION_FACTOR >> 1); // JMS_GFX
 	s.origin.y = 0;
 	s.frame = SetAbsFrameIndex (pickState->SummaryFrame,
 			GetFrameCount (pickState->SummaryFrame) - 1);
@@ -495,9 +789,9 @@ DrawSavegameCargo (SIS_STATE *sisState)
 		BUILD_COLOR (MAKE_RGB15_INIT (0x14, 0x00, 0x14), 0x05),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x19), 0x00),
 	};
-#define ELEMENT_ORG_Y      17
-#define ELEMENT_SPACING_Y  12
-#define ELEMENT_SPACING_X  36
+#define ELEMENT_ORG_Y      (17 << RESOLUTION_FACTOR) // JMS_GFX
+#define ELEMENT_SPACING_Y  (12 << RESOLUTION_FACTOR) // JMS_GFX
+#define ELEMENT_SPACING_X  (36 << RESOLUTION_FACTOR) // JMS_GFX
 
 	SetContext (SpaceContext);
 	BatchGraphics ();
@@ -506,11 +800,11 @@ DrawSavegameCargo (SIS_STATE *sisState)
 	// setup element icons
 	s.frame = SetAbsFrameIndex (MiscDataFrame,
 			(NUM_SCANDOT_TRANSITIONS << 1) + 3);
-	s.origin.x = 7 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 3;
+	s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + (10 << RESOLUTION_FACTOR); // JMS_GFX
 	s.origin.y = ELEMENT_ORG_Y;
 	// setup element amounts
-	t.baseline.x = 33 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 3;
-	t.baseline.y = ELEMENT_ORG_Y + 3;
+	t.baseline.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + ELEMENT_SPACING_X;
+	t.baseline.y = ELEMENT_ORG_Y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 
@@ -522,7 +816,7 @@ DrawSavegameCargo (SIS_STATE *sisState)
 			s.origin.x += ELEMENT_SPACING_X;
 			s.origin.y = ELEMENT_ORG_Y;
 			t.baseline.x += ELEMENT_SPACING_X;
-			t.baseline.y = ELEMENT_ORG_Y + 3;
+			t.baseline.y = ELEMENT_ORG_Y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 		}
 		// draw element icon
 		DrawStamp (&s);
@@ -537,13 +831,13 @@ DrawSavegameCargo (SIS_STATE *sisState)
 	}
 
 	// draw Bio icon
-	s.origin.x = 24 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS;
-	s.origin.y = 68;
+	s.origin.x = (24 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS; // JMS_GFX
+	s.origin.y = 68 << RESOLUTION_FACTOR; // JMS_GFX
 	s.frame = SetAbsFrameIndex (s.frame, 68);
 	DrawStamp (&s);
 	// print Bio amount
-	t.baseline.x = 50 + SUMMARY_X_OFFS;
-	t.baseline.y = s.origin.y + 3;
+	t.baseline.x = (50 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS; // JMS_GFX
+	t.baseline.y = s.origin.y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	SetContextForeGroundColor (cargo_color[i]);
 	snprintf (buf, sizeof buf, "%u", sisState->TotalBioMass);
 	t.CharCount = (COUNT)~0;
@@ -590,10 +884,9 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		// Hack StatusContext so we can use standard SIS display funcs
 		GetContextClipRect (&OldRect);
 		r.corner.x = SIS_ORG_X + ((SIS_SCREEN_WIDTH - STATUS_WIDTH) >> 1) +
-				SAFE_X - 16 + SUMMARY_X_OFFS;
-//		r.corner.x = SIS_ORG_X + ((SIS_SCREEN_WIDTH - STATUS_WIDTH) >> 1);
-		r.corner.y = SIS_ORG_Y;
-		r.extent.width = STATUS_WIDTH;
+			SAFE_X - (16 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + RES_CASE(0,0,6); // JMS_GFX
+		r.corner.y = SIS_ORG_Y; // JMS_GFX
+		r.extent.width = STATUS_WIDTH + 2 * RESOLUTION_FACTOR; // JMS_GFX
 		r.extent.height = STATUS_HEIGHT;
 		SetContextClipRect (&r);
 
@@ -613,12 +906,13 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		
 		SetContext (SpaceContext);
 		// draw devices
-		s.origin.y = 13;
+		s.origin.y = 13 << RESOLUTION_FACTOR; // JMS_GFX
 		for (i = 0; i < 4; ++i)
 		{
 			COUNT j;
 
-			s.origin.x = 140 + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS;
+			s.origin.x = (140 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS + RES_CASE(0,10,110); // JMS_GFX
+			
 			for (j = 0; j < 4; ++j)
 			{
 				COUNT devIndex = (i * 4) + j;
@@ -628,20 +922,22 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 							+ pSD->DeviceList[devIndex]);
 					DrawStamp (&s);
 				}
-				s.origin.x += 18;
+				s.origin.x += 18 << RESOLUTION_FACTOR; // JMS_GFX
 			}
-			s.origin.y += 18;
+			s.origin.y += 18 << RESOLUTION_FACTOR; // JMS_GFX
 		}
 
+		// Placement of the RU and bio-credit amounts.
 		SetContextFont (StarConFont);
-		t.baseline.x = 173 + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS;
+		t.baseline.x = (173 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS + RES_CASE(0,15,110); // JMS_GFX
+		
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
 		if (pSD->Flags & AFTER_BOMB_INSTALLED)
 		{
 			// draw the bomb and the escape pod
-			s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 6;
+			s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + (6 << RESOLUTION_FACTOR); // JMS_GFX
 			s.origin.y = 0;
 			s.frame = SetRelFrameIndex (pickState->SummaryFrame, 0);
 			DrawStamp (&s);
@@ -657,8 +953,8 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			SetContext (RadarContext);
 			// Hack RadarContext so we can use standard Lander display funcs
 			GetContextClipRect (&OldRect);
-			r.corner.x = SIS_ORG_X + 10 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS;
-			r.corner.y = SIS_ORG_Y + 84;
+			r.corner.x = SIS_ORG_X + RES_CASE(10,20,70) + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS; // JMS_GFX
+			r.corner.y = SIS_ORG_Y + (84 << RESOLUTION_FACTOR); // JMS_GFX
 			r.extent = OldRect.extent;
 			SetContextClipRect (&r);
 			UnlockMutex (GraphicsLock);
@@ -669,13 +965,12 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			SetContext (SpaceContext);
 
 			snprintf (buf, sizeof buf, "%u", pSD->SS.ResUnits);
-			t.baseline.y = 102;
-			SetContextForeGroundColor (
-					BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
+			t.baseline.y = 102 << RESOLUTION_FACTOR; // JMS_GFX
+			SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
 			font_DrawText (&t);
 			t.CharCount = (COUNT)~0;
 		}
-		t.baseline.y = 126;
+		t.baseline.y = 126 << RESOLUTION_FACTOR; // JMS_GFX
 		snprintf (buf, sizeof buf, "%u",
 				MAKE_WORD (pSD->MCreditLo, pSD->MCreditHi));
 		SetContextForeGroundColor (
@@ -683,8 +978,8 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		font_DrawText (&t);
 		
 		// print the location
-		t.baseline.x = 6;
-		t.baseline.y = 139 + 6;
+		t.baseline.x = 6 << RESOLUTION_FACTOR; // JMS_GFX
+		t.baseline.y = ((139 + 6) << RESOLUTION_FACTOR) + RES_CASE(0,3,0); // JMS_GFX;
 		t.align = ALIGN_LEFT;
 		t.pStr = buf;
 		starPt.x = LOGX_TO_UNIVERSE (pSD->SS.log_x);
@@ -729,8 +1024,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
 		t.align = ALIGN_CENTER;
-		t.baseline.x = SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - 4
-				+ (SIS_TITLE_WIDTH >> 1);
+		t.baseline.x = SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - (4 << RESOLUTION_FACTOR) + (SIS_TITLE_WIDTH >> 1); // JMS_GFX
 		switch (pSD->Activity)
 		{
 			case IN_STARBASE:
@@ -751,7 +1045,12 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		}
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-
+		
+		// JMS: This can be used to warn the user about bogus savegames.
+		/*if (strncmp(pSD->SaveNameChecker, SAVE_NAME_CHECKER, SAVE_CHECKER_SIZE)
+			&& !(pickState->saving))
+			LoadProblemMessage ();*/
+		
 		SetContext (OldContext);
 
 		// Restore the states because we hacked them
@@ -771,16 +1070,17 @@ DrawGameSelection (PICK_GAME_STATE *pick
 	COUNT curSlot;
 	UNICODE buf[256];
 	UNICODE buf2[80];
+	UNICODE *SaveName; // JMS
 	
 	BatchGraphics ();
 
 	SetContextFont (TinyFont);
 	
 	// Erase the selection menu
-	r.extent.width = 240;
-	r.extent.height = 65;
-	r.corner.x = 1;
-	r.corner.y = 160;
+	r.extent.width = 240 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = 65 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.x = 1 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	SetContextForeGroundColor (BLACK_COLOR);
 	DrawFilledRectangle (&r);
 
@@ -795,28 +1095,31 @@ DrawGameSelection (PICK_GAME_STATE *pick
 	{
 		SUMMARY_DESC *desc = &pickState->summary[curSlot];
 
+		// JMS_GFX: In hi-res modes, the dark blue is brighter because otherwise
+		// the thinner lines/text would be hard to see.
 		SetContextForeGroundColor ((curSlot == selSlot) ?
-				(BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33)):
-				(BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01)));
-		r.extent.width = 15;
+				(BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33)): 
+				( RESOLUTION_FACTOR == 0 ?
+				(BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01)) : (BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x19), 0x01))));
+		r.extent.width = 15 << RESOLUTION_FACTOR; // JMS_GFX
 		if (MAX_SAVED_GAMES > 99)
-			r.extent.width += 5;
-		r.extent.height = 11;
-		r.corner.x = 8;
-		r.corner.y = 160 + (i * 13);
+			r.extent.width += 5 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 11 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.x = 8 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.y = (160 + (i * 13)) << RESOLUTION_FACTOR; // JMS_GFX
 		DrawRectangle (&r);
 
-		t.baseline.x = r.corner.x + 3;
-		t.baseline.y = r.corner.y + 8;
+		t.baseline.x = r.corner.x + RES_CASE(3,8,18); // JMS_GFX
+		t.baseline.y = r.corner.y + RES_CASE(8,14,29); // JMS_GFX
 		snprintf (buf, sizeof buf, (MAX_SAVED_GAMES > 99) ? "%03u" : "%02u",
 				curSlot);
 		font_DrawText (&t);
 
-		r.extent.width = 204 - SAFE_X;
-		r.corner.x = 30 + SAFE_X;
+		r.extent.width = (204 - SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.x = (30 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 		DrawRectangle (&r);
 
-		t.baseline.x = r.corner.x + 3;
+		t.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR); // JMS_GFX
 		if (desc->year_index == 0)
 		{
 			utf8StringCopy (buf, sizeof buf,
@@ -824,11 +1127,21 @@ DrawGameSelection (PICK_GAME_STATE *pick
 		}
 		else
 		{
+			// JMS: If a savegamename identifier is found, this save
+			// has an user-given name and we can use it.
+			// Otherwise we'll use the default "unnamed save" for this
+			// savegame (it's most probably a save from an older version,
+			// which didn't feature user-given names for saves.)
+			if (!(strncmp(desc->SaveNameChecker, SAVE_NAME_CHECKER, SAVE_CHECKER_SIZE)))
+				SaveName = desc->SaveName;
+			else if (RESOLUTION_FACTOR == 0)
+				SaveName = GAME_STRING (SAVEGAME_STRING_BASE + 5); // "Unnamed save"
+			else
+				SaveName = GAME_STRING (SAVEGAME_STRING_BASE + 6); // "Unnamed save"
+			
 			DateToString (buf2, sizeof buf2, desc->month_index,
 					desc->day_index, desc->year_index);
-			snprintf (buf, sizeof buf, "%s %s",
-					GAME_STRING (SAVEGAME_STRING_BASE + 4), buf2);
-						// "Saved Game - Date:"
+			snprintf (buf, sizeof buf, "%s: %s", buf2, SaveName); // JMS
 		}
 		font_DrawText (&t);
 	}
@@ -853,7 +1166,7 @@ LoadGameDescriptions (SUMMARY_DESC *pSD)
 
 	for (i = 0; i < MAX_SAVED_GAMES; ++i, ++pSD)
 	{
-		if (!LoadGame (i, pSD))
+		if (!LoadGame (i, pSD, FALSE))
 			pSD->year_index = 0;
 	}
 }
@@ -939,7 +1252,7 @@ DoPickGame (MENU_STATE *pMS)
 }
 
 static BOOLEAN
-SaveLoadGame (PICK_GAME_STATE *pickState, COUNT gameIndex)
+SaveLoadGame (PICK_GAME_STATE *pickState, COUNT gameIndex, BOOLEAN *canceled_by_user)
 {
 	SUMMARY_DESC *desc = pickState->summary + gameIndex;
 	STAMP saveStamp;
@@ -947,16 +1260,29 @@ SaveLoadGame (PICK_GAME_STATE *pickState
 
 	saveStamp.frame = NULL;
 
-	// TODO: fix ConfirmSaveLoad() interface so it does not rely on
-	//   MsgStamp != NULL parameter.
-	LockMutex (GraphicsLock);
-	ConfirmSaveLoad (pickState->saving ? &saveStamp : NULL);
-	UnlockMutex (GraphicsLock);
-
 	if (pickState->saving)
-		success = SaveGame (gameIndex, desc);
+	{
+		if (NameSaveGame (desc, gameIndex))
+		{
+			PlayMenuSound (MENU_SOUND_SUCCESS);
+			LockMutex (GraphicsLock);
+			ConfirmSaveLoad (pickState->saving ? &saveStamp : NULL);
+			UnlockMutex (GraphicsLock);
+			success = SaveGame (gameIndex, desc);
+		}
+		else
+		{
+			success = FALSE;
+			*canceled_by_user = TRUE;
+		}
+	}
 	else
-		success = LoadGame (gameIndex, NULL);
+	{
+		LockMutex (GraphicsLock);
+		ConfirmSaveLoad (pickState->saving ? &saveStamp : NULL);
+		UnlockMutex (GraphicsLock);
+		success = LoadGame (gameIndex, NULL, FALSE);
+	}
 
 	// TODO: the same should be done for both save and load if we also
 	//   display a load problem message
@@ -1036,13 +1362,14 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 	}
 	UnlockMutex (GraphicsLock);
 
-	SetMenuSounds (MENU_SOUND_ARROWS | MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN,
-			0);
+	SetMenuSounds (MENU_SOUND_ARROWS | MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN, 0);
 	MenuState.InputFunc = DoPickGame;
 	
 	// Save/load retry loop
 	while (1)
 	{
+		BOOLEAN canceled_by_user = FALSE;
+		
 		pickState.success = FALSE;
 		DoInput (&MenuState, TRUE);
 		if (!pickState.success)
@@ -1050,11 +1377,11 @@ PickGame (BOOLEAN saving, BOOLEAN fromMa
 
 		lastUsedSlot = MenuState.CurState;
 
-		if (SaveLoadGame (&pickState, MenuState.CurState))
+		if (SaveLoadGame (&pickState, MenuState.CurState, &canceled_by_user))
 			break; // all good
 
 		// something broke
-		if (saving)
+		if (saving && !canceled_by_user)
 			SaveProblem ();
 		// TODO: Shouldn't we have a Problem() equivalent for Load too?
 
diff -ruNp ./src.orig/uqm/gameopt.h ./src/uqm/gameopt.h
--- ./src.orig/uqm/gameopt.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/gameopt.h	2017-10-23 11:41:34 -0700
@@ -25,5 +25,8 @@ extern BOOLEAN GameOptions (void);
 typedef void (NamingCallback) (void);
 extern void SetNamingCallback (NamingCallback *);
 
+// JMS: For naming captain and ship at game start.
+extern void AskNameForCaptainAndShip(void);
+
 #endif  /* _GAMEOPT_H */
 
diff -ruNp ./src.orig/uqm/gamestr.h ./src/uqm/gamestr.h
--- ./src.orig/uqm/gamestr.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/gamestr.h	2017-10-23 11:41:34 -0700
@@ -25,21 +25,21 @@
 
 #include "libs/strlib.h"
 
-#define STAR_STRING_COUNT       133
+#define STAR_STRING_COUNT       149 // JMS: Was 133. Added 15 QS portals+Arilouhome
 #define DEVICE_STRING_COUNT      29
 #define CARGO_STRING_COUNT       10
-#define ELEMENTS_STRING_COUNT   133
+#define ELEMENTS_STRING_COUNT   134 // JMS: Was 133. Added "Biodata".
 #define SCAN_STRING_COUNT        56
 #define STAR_NUMBER_COUNT        14
 #define PLANET_NUMBER_COUNT      33
 #define MONTHS_STRING_COUNT      12
-#define FEEDBACK_STRING_COUNT     2
+#define FEEDBACK_STRING_COUNT     5 // JMS: Was 2. Added 3 starmap titles.
 #define STARBASE_STRING_COUNT     5
 #define ENCOUNTER_STRING_COUNT    8
 #define NAVIGATION_STRING_COUNT   6
-#define NAMING_STRING_COUNT       4
+#define NAMING_STRING_COUNT       6 // JMS: Was 4. The newgame name queries.
 #define MELEE_STRING_COUNT        9
-#define SAVEGAME_STRING_COUNT     5
+#define SAVEGAME_STRING_COUNT     9 // JMS: Was 5. Added unnamed save stuff.
 #define OPTION_STRING_COUNT       5
 #define QUITMENU_STRING_COUNT     3
 #define STATUS_STRING_COUNT       6
diff -ruNp ./src.orig/uqm/gendef.c ./src/uqm/gendef.c
--- ./src.orig/uqm/gendef.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/gendef.c	2017-10-23 11:41:34 -0700
@@ -51,6 +51,8 @@ extern GenerateFunctions generateWreckFu
 extern GenerateFunctions generateYehatFunctions;
 extern GenerateFunctions generateZoqFotPikFunctions;
 extern GenerateFunctions generateZoqFotPikScoutFunctions;
+extern GenerateFunctions generateZoqFotPikColony0Functions;
+extern GenerateFunctions generateZoqFotPikColony1Functions;
 
 
 const GenerateFunctions *
@@ -121,6 +123,10 @@ getGenerateFunctions (BYTE Index)
 			return &generateZoqFotPikFunctions;
 		case ZOQ_SCOUT_DEFINED:
 			return &generateZoqFotPikScoutFunctions;
+		case ZOQ_COLONY0_DEFINED:
+			return &generateZoqFotPikColony0Functions;
+		case ZOQ_COLONY1_DEFINED:
+			return &generateZoqFotPikColony1Functions;
 		case YEHAT_DEFINED:
 			return &generateYehatFunctions;
 		case PKUNK_DEFINED:
diff -ruNp ./src.orig/uqm/getchar.c ./src/uqm/getchar.c
--- ./src.orig/uqm/getchar.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/getchar.c	2017-10-23 11:41:34 -0700
@@ -440,3 +440,346 @@ DoTextEntry (TEXTENTRY_STATE *pTES)
 	return TRUE;
 }
 
+BOOLEAN
+DoTextEntrySavename (TEXTENTRY_STATE *pTES)
+{
+	UniChar ch;
+	UNICODE *pStr;
+	UNICODE *CacheInsPt;
+	int CacheCursorPos;
+	int len;
+	BOOLEAN changed = FALSE;
+	static BOOLEAN giving_first_char = TRUE;
+
+	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
+	{
+		giving_first_char = TRUE;
+		return (FALSE);
+	}
+
+	if (!pTES->Initialized)
+	{	// init basic vars
+		int lwlen;
+
+		pTES->InputFunc = DoTextEntrySavename;
+		pTES->Success = FALSE;
+		pTES->Initialized = TRUE;
+		pTES->JoystickMode = FALSE;
+		pTES->UpperRegister = TRUE;
+	
+		// init insertion point
+		if ((size_t)pTES->CursorPos > utf8StringCount (pTES->BaseStr))
+			pTES->CursorPos = utf8StringCount (pTES->BaseStr);
+		pTES->InsPt = skipUTF8Chars (pTES->BaseStr, pTES->CursorPos);
+
+		// load joystick alphabet
+		pTES->JoyAlphaString = CaptureStringTable (
+				LoadStringTable (JOYSTICK_ALPHA_STRTAB));
+		pTES->JoyAlpha = LoadJoystickAlpha (
+				SetAbsStringTableIndex (pTES->JoyAlphaString, 0),
+				&pTES->JoyAlphaLength);
+		pTES->JoyUpper = LoadJoystickAlpha (
+				SetAbsStringTableIndex (pTES->JoyAlphaString, 1),
+				&pTES->JoyRegLength);
+		pTES->JoyLower = LoadJoystickAlpha (
+				SetAbsStringTableIndex (pTES->JoyAlphaString, 2),
+				&lwlen);
+		if (lwlen != pTES->JoyRegLength)
+		{
+			if (lwlen < pTES->JoyRegLength)
+				pTES->JoyRegLength = lwlen;
+			log_add (log_Warning, "Warning: Joystick upper-lower registers"
+					" size mismatch; using the smallest subset (%d)",
+					pTES->JoyRegLength);
+		}
+
+		pTES->CacheStr = HMalloc (pTES->MaxSize * sizeof (*pTES->CacheStr));
+
+		EnterCharacterMode ();
+		DoInput (pTES, TRUE);
+		ExitCharacterMode ();
+
+		if (pTES->CacheStr)
+			HFree (pTES->CacheStr);
+		if (pTES->JoyLower)
+			HFree (pTES->JoyLower);
+		if (pTES->JoyUpper)
+			HFree (pTES->JoyUpper);
+		if (pTES->JoyAlpha)
+			HFree (pTES->JoyAlpha);
+		DestroyStringTable ( ReleaseStringTable (pTES->JoyAlphaString));
+
+		giving_first_char = TRUE;
+		return pTES->Success;
+	}
+
+	pStr = pTES->InsPt;
+	len = strlen (pStr);
+	// save a copy of string
+	CacheInsPt = pTES->InsPt;
+	CacheCursorPos = pTES->CursorPos;
+	memcpy (pTES->CacheStr, pTES->BaseStr, pTES->MaxSize);
+
+	// process the pending character buffer
+	ch = GetNextCharacter ();
+	if (!ch && PulsedInputState.menu[KEY_MENU_ANY])
+	{	// keyboard repeat, but only when buffer empty
+		ch = GetLastCharacter ();
+	}
+	while (ch)
+	{
+		UNICODE chbuf[8];
+		int chsize;
+
+		pTES->JoystickMode = FALSE;
+
+		chsize = getStringFromChar (chbuf, sizeof (chbuf), ch);
+		if (UniChar_isPrint (ch) && chsize > 0)
+		{
+			if (pStr + len - pTES->BaseStr + chsize < pTES->MaxSize)
+			{	// insert character, when fits
+				memmove (pStr + chsize, pStr, len + 1);
+				memcpy (pStr, chbuf, chsize);
+				pStr += chsize;
+				++pTES->CursorPos;
+				changed = TRUE;
+			}
+			else
+			{	// does not fit
+				PlayMenuSound (MENU_SOUND_FAILURE);
+			}
+			
+			giving_first_char = FALSE;
+		}
+		ch = GetNextCharacter ();
+	}
+
+	if (PulsedInputState.menu[KEY_MENU_DELETE])
+	{
+		if (len)
+		{
+			joy_char_t ch;
+			
+			ReadOneChar (&ch, pStr);
+			memmove (pStr, pStr + ch.len, len - ch.len + 1);
+			len -= ch.len;
+			changed = TRUE;
+		}
+	}
+	else if (PulsedInputState.menu[KEY_MENU_BACKSPACE]&& !giving_first_char)
+	{
+		if (pStr > pTES->BaseStr)
+		{
+			UNICODE *prev = skipUTF8Chars (pTES->BaseStr,
+					pTES->CursorPos - 1);
+			
+			memmove (prev, pStr, len + 1);
+			pStr = prev;
+			--pTES->CursorPos;
+			changed = TRUE;
+		}
+	}
+	else if (PulsedInputState.menu[KEY_MENU_BACKSPACE] && giving_first_char)
+	{
+		while (pStr > pTES->BaseStr)
+		{
+			UNICODE *prev = skipUTF8Chars (pTES->BaseStr,
+					pTES->CursorPos - 1);
+			
+			memmove (prev, pStr, len + 1);
+			pStr = prev;
+			--pTES->CursorPos;
+			changed = TRUE;
+		}
+		giving_first_char = FALSE;
+	}
+	else if (PulsedInputState.menu[KEY_MENU_LEFT])
+	{
+		if (pStr > pTES->BaseStr)
+		{
+			UNICODE *prev = skipUTF8Chars (pTES->BaseStr,
+					pTES->CursorPos - 1);
+
+			pStr = prev;
+			len += (prev - pStr);
+			--pTES->CursorPos;
+			changed = TRUE;
+		}
+		giving_first_char = FALSE;
+	}
+	else if (PulsedInputState.menu[KEY_MENU_RIGHT])
+	{
+		if (len > 0)
+		{
+			joy_char_t ch;
+			
+			ReadOneChar (&ch, pStr);
+			pStr += ch.len;
+			len -= ch.len;
+			++pTES->CursorPos;
+			changed = TRUE;
+		}
+		giving_first_char = FALSE;
+	}
+	else if (PulsedInputState.menu[KEY_MENU_HOME])
+	{
+		if (pStr > pTES->BaseStr)
+		{
+			pStr = pTES->BaseStr;
+			len = strlen (pStr);
+			pTES->CursorPos = 0;
+			changed = TRUE;
+		}
+		giving_first_char = FALSE;
+	}
+	else if (PulsedInputState.menu[KEY_MENU_END])
+	{
+		if (len > 0)
+		{
+			pTES->CursorPos += utf8StringCount (pStr);
+			pStr += len;
+			len = 0;
+			changed = TRUE;
+		}
+		giving_first_char = FALSE;
+	}
+	
+	if (pTES->JoyAlpha && (
+			PulsedInputState.menu[KEY_MENU_UP] ||
+			PulsedInputState.menu[KEY_MENU_DOWN] ||
+			PulsedInputState.menu[KEY_MENU_PAGE_UP] ||
+			PulsedInputState.menu[KEY_MENU_PAGE_DOWN]) )
+	{	// do joystick text
+		joy_char_t ch;
+		joy_char_t newch;
+		joy_char_t cmpch;
+		int i;
+		BOOLEAN curCharUpper;
+
+		pTES->JoystickMode = TRUE;
+
+		if (len)
+		{	// changing an existing character
+			ReadOneChar (&ch, pStr);
+			curCharUpper = !JoyCharIsLower (&ch, pTES);
+		}
+		else
+		{	// adding a new character
+			ch = pTES->JoyAlpha[0];
+			// new characters will have case determined by the
+			// currently selected register
+			curCharUpper = pTES->UpperRegister;
+		}
+		
+		newch = ch;
+		JoyCharToUpper (&cmpch, &ch, pTES);
+
+		// find current char in the alphabet
+		i = JoyCharFindIn (&cmpch, pTES->JoyAlpha, pTES->JoyAlphaLength);
+
+		if (PulsedInputState.menu[KEY_MENU_UP])
+		{
+			--i;
+			if (i < 0)
+				i = pTES->JoyAlphaLength - 1;
+			newch = pTES->JoyAlpha[i];
+		}
+		else if (PulsedInputState.menu[KEY_MENU_DOWN])
+		{
+			++i;
+			if (i >= pTES->JoyAlphaLength)
+				i = 0;
+			newch = pTES->JoyAlpha[i];
+		}
+
+		if (PulsedInputState.menu[KEY_MENU_PAGE_UP] ||
+				PulsedInputState.menu[KEY_MENU_PAGE_DOWN])
+		{
+			if (len)
+			{	// single char change
+				if (!curCharUpper)
+					JoyCharToUpper (&newch, &newch, pTES);
+				else
+					JoyCharToLower (&newch, &newch, pTES);
+			}
+			else
+			{	// register change
+				pTES->UpperRegister = !pTES->UpperRegister;
+			}
+		}
+		else
+		{	// check register
+			if (curCharUpper)
+				JoyCharToUpper (&newch, &newch, pTES);
+			else
+				JoyCharToLower (&newch, &newch, pTES);
+		}
+
+		if (strcmp (newch.enc, ch.enc) != 0)
+		{	// new char is different, put it in
+			if (len)
+			{	// change current -- this is messy with utf8
+				int l = len - ch.len;
+				if (pStr + l - pTES->BaseStr + newch.len < pTES->MaxSize)
+				{
+					// adjust other chars if necessary
+					if (newch.len != ch.len)
+						memmove (pStr + newch.len, pStr + ch.len, l + 1);
+
+					memcpy (pStr, newch.enc, newch.len);
+					len = l + newch.len;
+					changed = TRUE;
+				}
+			}
+			else
+			{	// append
+				if (pStr + len - pTES->BaseStr + newch.len < pTES->MaxSize)
+				{
+					memcpy (pStr, newch.enc, newch.len);
+					pStr[newch.len] = '\0';
+					len += newch.len;
+					changed = TRUE;
+				}
+				else
+				{	// does not fit
+					PlayMenuSound (MENU_SOUND_FAILURE);
+				}
+			}
+		}
+		giving_first_char = FALSE;
+	}
+	
+	if (PulsedInputState.menu[KEY_MENU_SELECT])
+	{	// done entering
+		pTES->Success = TRUE;
+		giving_first_char = TRUE;
+		return FALSE;
+	}
+	else if (PulsedInputState.menu[KEY_MENU_EDIT_CANCEL])
+	{	// canceled entering
+		pTES->Success = FALSE;
+		giving_first_char = TRUE;
+		return FALSE;
+	}
+
+	pTES->InsPt = pStr;
+
+	if (changed && pTES->ChangeCallback)
+	{
+		if (!pTES->ChangeCallback (pTES))
+		{	// changes not accepted - revert
+			memcpy (pTES->BaseStr, pTES->CacheStr, pTES->MaxSize);
+			pTES->InsPt = CacheInsPt;
+			pTES->CursorPos = CacheCursorPos;
+
+			PlayMenuSound (MENU_SOUND_FAILURE);
+		}
+	}
+		
+	if (pTES->FrameCallback)
+		return pTES->FrameCallback (pTES);
+	else
+		SleepThread (ONE_SECOND / 30);
+
+	return TRUE;
+}
\ No newline at end of file
diff -ruNp ./src.orig/uqm/globdata.c ./src/uqm/globdata.c
--- ./src.orig/uqm/globdata.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/globdata.c	2017-10-23 11:41:34 -0700
@@ -32,9 +32,7 @@
 #include "gamestr.h"
 
 #include <stdlib.h>
-#ifdef STATE_DEBUG
-#	include "libs/log.h"
-#endif
+#include "libs/log.h"
 
 
 static void CreateRadar (void);
@@ -43,6 +41,7 @@ CONTEXT RadarContext;
 FRAME PlayFrame;
 
 GLOBDATA GlobData;
+UNICODE Global_save_name[SAVE_NAME_SIZE]; // JMS
 
 static BOOLEAN initedGameStructs = FALSE;
 
@@ -318,7 +317,7 @@ InitGameStructures (void)
 
 	GLOBAL_SIS (ResUnits) = 0;
 	GLOBAL (CrewCost) = 3;
-	GLOBAL (FuelCost) = 20;
+	GLOBAL (FuelCost) = FUEL_COST_RU; // JMS: Was 20
 	GLOBAL (ModuleCost[PLANET_LANDER]) = 500 / MODULE_COST_SCALE;
 	GLOBAL (ModuleCost[FUSION_THRUSTER]) = 500 / MODULE_COST_SCALE;
 	GLOBAL (ModuleCost[TURNING_JETS]) = 500 / MODULE_COST_SCALE;
@@ -344,6 +343,10 @@ InitGameStructures (void)
 	CurStarDescPtr = 0;
 	GLOBAL (autopilot.x) = ~0;
 	GLOBAL (autopilot.y) = ~0;
+	
+	// JMS
+	for (i = 0; i < SAVE_NAME_SIZE ; i++)
+		Global_save_name[i] = 0;
 
 	/* In case the program is exited before the full game is terminated,
 	 * make sure that the temporary files are deleted.
diff -ruNp ./src.orig/uqm/globdata.h ./src/uqm/globdata.h
--- ./src.orig/uqm/globdata.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/globdata.h	2017-10-23 11:41:34 -0700
@@ -27,7 +27,6 @@
 #include "velocity.h"
 #include "commanim.h"
 
-
 // general numbers-speech generator info
 // should accomodate most common base-10 languages
 // many languages require various plural forms
@@ -88,8 +87,40 @@ typedef DWORD LDAS_FLAGS;
 #define LDASF_NONE           ((LDAS_FLAGS)      0 )
 #define LDASF_USE_ALTERNATE  ((LDAS_FLAGS)(1 << 0))
 
+// BW: had to move that from commglue.h to here because now LOCDATA features it
+typedef enum {
+	ARILOU_CONVERSATION,
+	CHMMR_CONVERSATION,
+	COMMANDER_CONVERSATION,
+	ORZ_CONVERSATION,
+	PKUNK_CONVERSATION,
+	SHOFIXTI_CONVERSATION,
+	SPATHI_CONVERSATION,
+	SUPOX_CONVERSATION,
+	THRADD_CONVERSATION,
+	UTWIG_CONVERSATION,
+	VUX_CONVERSATION,
+	YEHAT_CONVERSATION,
+	MELNORME_CONVERSATION,
+	DRUUGE_CONVERSATION,
+	ILWRATH_CONVERSATION,
+	MYCON_CONVERSATION,
+	SLYLANDRO_CONVERSATION,
+	UMGAH_CONVERSATION,
+	URQUAN_CONVERSATION,
+	ZOQFOTPIK_CONVERSATION,
+	SYREEN_CONVERSATION,
+	BLACKURQ_CONVERSATION,
+	TALKING_PET_CONVERSATION,
+	SLYLANDRO_HOME_CONVERSATION,
+	URQUAN_DRONE_CONVERSATION,
+	YEHAT_REBEL_CONVERSATION,
+	INVALID_CONVERSATION,
+} CONVERSATION;
+
 typedef struct
 {
+	CONVERSATION AlienConv;
 	void (*init_encounter_func) (void);
 			/* Called when entering communications */
 	void (*post_encounter_func) (void);
@@ -872,8 +903,104 @@ START_GAME_STATE
 
 	ADD_GAME_STATE (ORZ_STACK0, 1)
 	ADD_GAME_STATE (ORZ_STACK1, 1)
+
+	// JMS: It is allowed for the autopilot to engage
+	ADD_GAME_STATE (AUTOPILOT_OK, 1)
+
+	// JMS: Quasispace portal name flags
+	ADD_GAME_STATE (KNOW_QS_PORTAL_0, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_1, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_2, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_3, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_4, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_5, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_6, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_7, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_8, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_9, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_10, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_11, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_12, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_13, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_14, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_15, 1)
 END_GAME_STATE
 
+// JMS: For making array of Quasispace portal name flags
+#define QS_PORTALS_KNOWN \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_0)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_1)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_2)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_3)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_4)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_5)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_6)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_7)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_8)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_9)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_10)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_11)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_12)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_13)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_14)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_15)),
+
+// JMS: For making array of Quasispace portal name flags
+#define SET_QS_PORTAL_KNOWN(val) \
+	switch (val)	\
+	{				\
+	case 0:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_0, 1);\
+		break; \
+	case 1:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_1, 1);\
+		break; \
+	case 2:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_2, 1);\
+		break; \
+	case 3:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_3, 1);\
+		break; \
+	case 4:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_4, 1);\
+		break; \
+	case 5:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_5, 1);\
+		break; \
+	case 6:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_6, 1);\
+		break; \
+	case 7:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_7, 1);\
+		break; \
+	case 8:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_8, 1);\
+		break; \
+	case 9:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_9, 1);\
+		break; \
+	case 10:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_10, 1);\
+		break; \
+	case 11:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_11, 1);\
+		break; \
+	case 12:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_12, 1);\
+		break; \
+	case 13:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_13, 1);\
+		break; \
+	case 14:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_14, 1);\
+		break; \
+	case 15:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_15, 1);\
+		break; \
+	default: \
+	break;\
+	}
+
 // Values for GAME_STATE.glob_flags:
 #define COMBAT_SPEED_SHIFT 6
 #define COMBAT_SPEED_MASK (((1 << 2) - 1) << COMBAT_SPEED_SHIFT)
@@ -958,6 +1085,7 @@ typedef struct
 } GLOBDATA;
 
 extern GLOBDATA GlobData;
+extern UNICODE Global_save_name[SAVE_NAME_SIZE]; // JMS
 #define GLOBAL(f) GlobData.Game_state.f
 #define GLOBAL_SIS(f) GlobData.SIS_state.f
 
diff -ruNp ./src.orig/uqm/gravity.c ./src/uqm/gravity.c
--- ./src.orig/uqm/gravity.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/gravity.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "collide.h"
 #include "races.h"
 #include "units.h"
@@ -96,7 +98,7 @@ CalculateGravity (ELEMENT *ElementPtr)
 #ifdef NEVER
 					COUNT magnitude;
 
-#define DIFUSE_GRAVITY 175
+#define DIFUSE_GRAVITY (175 << RESOLUTION_FACTOR) // JMS_GFX: Because of the ifdef NEVER this is actually never run. Well, changed it for consistency
 					dist_squared += (DWORD)abs_dx * (DIFUSE_GRAVITY << 1)
 							+ (DWORD)abs_dy * (DIFUSE_GRAVITY << 1)
 							+ ((DWORD)(DIFUSE_GRAVITY * DIFUSE_GRAVITY) << 1);
@@ -104,7 +106,7 @@ CalculateGravity (ELEMENT *ElementPtr)
 							* GRAVITY_THRESHOLD) / dist_squared)) == 0)
 						magnitude = 1;
 
-#define MAX_MAGNITUDE 6
+#define MAX_MAGNITUDE (6 << RESOLUTION_FACTOR) // JMS_GFX: Because of the ifdef NEVER this is actually never run. Well, changed it for consistency
 					else if (magnitude > MAX_MAGNITUDE)
 						magnitude = MAX_MAGNITUDE;
 					log_add (log_Debug, "magnitude = %u", magnitude);
@@ -126,8 +128,8 @@ CalculateGravity (ELEMENT *ElementPtr)
 
 						angle = ARCTAN (dx, dy);
 						DeltaVelocityComponents (&TestElementPtr->velocity,
-								COSINE (angle, WORLD_TO_VELOCITY (1)),
-								SINE (angle, WORLD_TO_VELOCITY (1)));
+								COSINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR)),
+								SINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR))); // JMS_GFX
 						if (TestElementPtr->state_flags & PLAYER_SHIP)
 						{
 							STARSHIP *StarShipPtr;
diff -ruNp ./src.orig/uqm/grpinfo.c ./src/uqm/grpinfo.c
--- ./src.orig/uqm/grpinfo.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/grpinfo.c	2017-10-23 11:41:34 -0700
@@ -307,8 +307,8 @@ BuildGroups (void)
 		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
 		hNextFleet = _GetSuccLink (FleetPtr);
 
-		if ((encounter_radius = FleetPtr->actual_strength)
-				&& (i = EncounterPercent[Index]))
+		if (((encounter_radius = FleetPtr->actual_strength)
+				&& (i = EncounterPercent[Index])))
 		{
 			SIZE dx, dy;
 			DWORD d_squared;
@@ -367,7 +367,12 @@ BuildGroups (void)
 						i = 4;
 					}
 
-					BestPercent = i;
+					// JMS: No Ur-Quan or Kohr-Ah at Zoqfot home system.
+					if (!(CurStarDescPtr->Index == ZOQFOT_DEFINED
+						  && (FleetPtr->SpeciesID == UR_QUAN_ID
+							  || FleetPtr->SpeciesID == KOHR_AH_ID)))
+						BestPercent = i;
+					
 					BestIndex = Index;
 				}
 			}
diff -ruNp ./src.orig/uqm/grpinfo.h ./src/uqm/grpinfo.h
--- ./src.orig/uqm/grpinfo.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/grpinfo.h	2017-10-23 11:41:34 -0700
@@ -53,6 +53,10 @@ typedef struct
 	POINT loc;
 
 	FRAME melee_icon;
+	
+	// JMS: direction memory prevents jittering of battle group icons when they change direction they're flying to.
+	BYTE lastDirection;
+	
 } IP_GROUP;
 
 enum
diff -ruNp ./src.orig/uqm/hyper.c ./src/uqm/hyper.c
--- ./src.orig/uqm/hyper.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/hyper.c	2017-10-23 11:41:34 -0700
@@ -40,12 +40,15 @@
 #include "options.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
+#include "libs/log.h"
 
 
 #define XOFFS ((RADAR_SCAN_WIDTH + (UNIT_SCREEN_WIDTH << 2)) >> 1)
 #define YOFFS ((RADAR_SCAN_HEIGHT + (UNIT_SCREEN_HEIGHT << 2)) >> 1)
 
-static FRAME hyperstars[3];
+static FRAME npcbubble;			// BW: animated bubble
+static FRAME hyperholes[3];		// BW: One for each flavour of space
+static FRAME hyperstars[4];
 static COLORMAP hypercmaps[2];
 static BYTE fuel_ticks;
 static COUNT hyper_dx, hyper_dy, hyper_extra;
@@ -62,12 +65,11 @@ enum HyperMenuItems
 	NAVIGATION,
 };
 
-
 void
-MoveSIS (SIZE *pdx, SIZE *pdy)
+MoveSIS (SDWORD *pdx, SDWORD *pdy)
 {
-	SIZE new_dx, new_dy;
-
+	SDWORD new_dx, new_dy;
+	
 	new_dx = *pdx;
 	GLOBAL_SIS (log_x) -= new_dx;
 	if (GLOBAL_SIS (log_x) < 0)
@@ -80,7 +82,7 @@ MoveSIS (SIZE *pdx, SIZE *pdy)
 		new_dx += (SIZE)(GLOBAL_SIS (log_x) - MAX_X_LOGICAL);
 		GLOBAL_SIS (log_x) = MAX_X_LOGICAL;
 	}
-
+	
 	new_dy = *pdy;
 	GLOBAL_SIS (log_y) -= new_dy;
 	if (GLOBAL_SIS (log_y) < 0)
@@ -93,21 +95,21 @@ MoveSIS (SIZE *pdx, SIZE *pdy)
 		new_dy += (SIZE)(GLOBAL_SIS (log_y) - MAX_Y_LOGICAL);
 		GLOBAL_SIS (log_y) = MAX_Y_LOGICAL;
 	}
-
+	
 	if (new_dx != *pdx || new_dy != *pdy)
 	{
 		HELEMENT hElement, hNextElement;
-
+		
 		*pdx = new_dx;
 		*pdy = new_dy;
-
+		
 		for (hElement = GetTailElement ();
-				hElement != 0; hElement = hNextElement)
+			 hElement != 0; hElement = hNextElement)
 		{
 			ELEMENT *ElementPtr;
-
+			
 			LockElement (hElement, &ElementPtr);
-
+			
 			if (!(ElementPtr->state_flags & PLAYER_SHIP))
 				hNextElement = GetPredElement (ElementPtr);
 			else
@@ -116,32 +118,32 @@ MoveSIS (SIZE *pdx, SIZE *pdy)
 				ElementPtr->next.location.y = (LOG_SPACE_HEIGHT >> 1) - new_dy;
 				hNextElement = 0;
 			}
-
+			
 			UnlockElement (hElement);
 		}
 	}
-
+	
 	if (GLOBAL_SIS (FuelOnBoard) && GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 	{
 		COUNT cur_fuel_ticks;
 		COUNT hyper_dist;
 		DWORD adj_dx, adj_dy;
-
+		
 		if (new_dx < 0)
 			new_dx = -new_dx;
 		hyper_dx += new_dx;
 		if (new_dy < 0)
 			new_dy = -new_dy;
 		hyper_dy += new_dy;
-
+		
 		/* These macros are also used in the fuel estimate on the starmap. */
 		adj_dx = LOGX_TO_UNIVERSE(16 * hyper_dx);
 		adj_dy = MAX_Y_UNIVERSE - LOGY_TO_UNIVERSE(16 * hyper_dy);
-
+		
 		hyper_dist = square_root (adj_dx * adj_dx + adj_dy * adj_dy) 
-					+ hyper_extra;
+		+ hyper_extra;
 		cur_fuel_ticks = hyper_dist >> 4;
-
+		
 		if (cur_fuel_ticks > (COUNT)fuel_ticks)
 		{
 #ifndef TESTING
@@ -154,7 +156,7 @@ MoveSIS (SIZE *pdx, SIZE *pdy)
 				hyper_dy = 0;
 				cur_fuel_ticks = 0;
 			}
-
+			
 			fuel_ticks = (BYTE)cur_fuel_ticks;
 		}
 	}
@@ -284,12 +286,27 @@ check_hyperspace_encounter (void)
 void
 FreeHyperData (void)
 {
+	if (RESOLUTION_FACTOR > 0)
+	{
+		DestroyDrawable (ReleaseDrawable (hyperholes[1]));
+		hyperholes[1] = 0;
+		DestroyDrawable (ReleaseDrawable (hyperholes[2]));
+		hyperholes[2] = 0;
+		// BW: TODO left out for demo
+		// DestroyDrawable (ReleaseDrawable (hyperspacesuns));
+		// hyperspacesuns = 0;
+		DestroyDrawable (ReleaseDrawable (npcbubble));
+		npcbubble = 0;
+	}
+	
 	DestroyDrawable (ReleaseDrawable (hyperstars[0]));
 	hyperstars[0] = 0;
 	DestroyDrawable (ReleaseDrawable (hyperstars[1]));
 	hyperstars[1] = 0;
 	DestroyDrawable (ReleaseDrawable (hyperstars[2]));
 	hyperstars[2] = 0;
+	DestroyDrawable (ReleaseDrawable (hyperstars[3]));
+	hyperstars[3] = 0;
 
 	DestroyColorMap (ReleaseColorMap (hypercmaps[0]));
 	hypercmaps[0] = 0;
@@ -300,16 +317,30 @@ FreeHyperData (void)
 static void
 LoadHyperData (void)
 {
+	if (RESOLUTION_FACTOR > 0)
+	{
+		if (hyperholes[1] == 0)
+		{
+			hyperholes[1] = CaptureDrawable (
+				LoadGraphic (HYPERHOLES_MASK_PMAP_ANIM));
+			hyperholes[2] = CaptureDrawable (
+				LoadGraphic (ARIHOLES_MASK_PMAP_ANIM));
+			hyperstars[3] = CaptureDrawable (
+				LoadGraphic (ARI_AMBIENT_MASK_PMAP_ANIM));
+		}
+		npcbubble = CaptureDrawable (LoadGraphic (NPCBUBBLE_MASK_PMAP_ANIM));
+	}
+	
 	if (hyperstars[0] == 0)
 	{
 		hyperstars[0] = CaptureDrawable (
 				LoadGraphic (AMBIENT_MASK_PMAP_ANIM));
 		hyperstars[1] = CaptureDrawable (
 				LoadGraphic (HYPERSTARS_MASK_PMAP_ANIM));
-		hypercmaps[0] = CaptureColorMap (LoadColorMap (HYPER_COLOR_TAB));
-
 		hyperstars[2] = CaptureDrawable (
 				LoadGraphic (ARISPACE_MASK_PMAP_ANIM));
+
+		hypercmaps[0] = CaptureColorMap (LoadColorMap (HYPER_COLOR_TAB));		
 		hypercmaps[1] = CaptureColorMap (LoadColorMap (ARISPACE_COLOR_TAB));
 	}
 }
@@ -327,11 +358,18 @@ LoadHyperspace (void)
 
 	LoadHyperData ();
 	{
-		FRAME F;
+		FRAME F, FQ;
 		
 		F = hyperstars[0];
 		hyperstars[0] = stars_in_space;
 		stars_in_space = F;
+		
+		if (RESOLUTION_FACTOR > 0)
+		{
+			FQ = hyperstars[3];
+			hyperstars[3] = stars_in_quasispace;
+			stars_in_quasispace = FQ;
+		}
 	}
 
 	if (!(LastActivity & CHECK_LOAD))
@@ -380,11 +418,18 @@ BOOLEAN
 FreeHyperspace (void)
 {
 	{
-		FRAME F;
+		FRAME F, FQ;
 		
 		F = hyperstars[0];
 		hyperstars[0] = stars_in_space;
 		stars_in_space = F;
+		
+		if (RESOLUTION_FACTOR > 0)
+		{
+			FQ = hyperstars[3];
+			hyperstars[3] = stars_in_quasispace;
+			stars_in_quasispace = FQ;
+		}
 	}
 //    FreeHyperData ();
 
@@ -465,12 +510,25 @@ InterplanetaryTransition (ELEMENT *Eleme
 		GLOBAL (autopilot.y) = ~0;
 
 		ElementToUniverse (ElementPtr, &pt);
-		CurStarDescPtr = FindStar (NULL, &pt, 5, 5);
+		CurStarDescPtr = FindStar (NULL, &pt, 5,5);
+
+		// JMS: Debugging helpers
+		/*{
+			STAR_DESC *SDPtr, *SDPtr2;
+			SDPtr = CurStarDescPtr;
+			SDPtr2 = FindStar (NULL, &pt, 500, 500);
+			log_add(log_Debug, "SDPtr.x %d, SDPtr.y %d SDPtr2.x %d, SDPtr2.y %d, pt.x %d pt.y %d", 
+				SDPtr->star_pt.x, SDPtr->star_pt.y, SDPtr2->star_pt.x, SDPtr2->star_pt.y, pt.x, pt.y);
+		}*/
+			
 		if (CurStarDescPtr->star_pt.x == ARILOU_HOME_X
 				&& CurStarDescPtr->star_pt.y == ARILOU_HOME_Y)
 		{
 			// Meet the Arilou.
 			GLOBAL (CurrentActivity) |= START_ENCOUNTER;
+			
+			// JMS: The arilou homeworld name can now be shown on QS map.
+			SET_GAME_STATE (KNOW_QS_PORTAL_15, 1);
 		}
 		else
 		{
@@ -478,11 +536,15 @@ InterplanetaryTransition (ELEMENT *Eleme
 			// one of the permanent portals.
 			COUNT index;
 			const POINT portal_pt[] = QUASISPACE_PORTALS_HYPERSPACE_ENDPOINTS;
-
+			
 			index = CurStarDescPtr - &star_array[NUM_SOLAR_SYSTEMS + 1];
 			GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (portal_pt[index].x);
 			GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (portal_pt[index].y);
 
+			// JMS: This QS portal's HS coordinates are revealed on QS map
+			// the next time the player visits QS.
+			SET_QS_PORTAL_KNOWN(index);
+			
 			SET_GAME_STATE (ARILOU_SPACE_SIDE, 0);
 		}
 	}
@@ -589,7 +651,7 @@ init_transition (ELEMENT *ElementPtr0, E
 			- StarShipPtr->ShipFacing);
 	if (num_turns == 0)
 		num_turns = 1;
-
+	
 	SetVelocityComponents (&ElementPtr1->velocity,
 			dx / num_turns, dy / num_turns);
 }
@@ -625,6 +687,26 @@ hyper_transition (ELEMENT *ElementPtr)
 	{
 		COUNT frame_index;
 
+		// JMS: If leaving interplanetary on autopilot, always arrive HS with
+		// the ship's nose pointed into correct direction.
+		if ((GLOBAL (autopilot)).x != ~0 && (GLOBAL (autopilot)).y != ~0)
+		{
+			STARSHIP *StarShipPtr;
+			POINT universe;
+			SIZE facing;
+			SDWORD udx = 0, udy = 0;
+			
+			GetElementStarShip (ElementPtr, &StarShipPtr);
+			universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+			universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+			udx = (GLOBAL (autopilot)).x - universe.x;
+			udy = -((GLOBAL (autopilot)).y - universe.y);
+			
+			facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (udx, udy)));
+			StarShipPtr->ShipFacing = facing;
+			SetElementStarShip(ElementPtr, StarShipPtr);
+		}
+
 		frame_index = GetFrameIndex (ElementPtr->current.image.frame);
 		if (frame_index-- <= ANGLE_TO_FACING (FULL_CIRCLE))
 		{
@@ -674,9 +756,8 @@ hyper_collision (ELEMENT *ElementPtr0, P
 		STARSHIP *StarShipPtr;
 
 		ElementToUniverse (ElementPtr0, &pt);
-
 		SDPtr = FindStar (NULL, &pt, 5, 5);
-
+		
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
 		GetCurrentVelocityComponents (&ElementPtr1->velocity, &dx, &dy);
 		if (SDPtr == CurStarDescPtr
@@ -695,7 +776,7 @@ hyper_collision (ELEMENT *ElementPtr0, P
 		{
 			CurStarDescPtr = SDPtr;
 			ElementPtr0->state_flags |= COLLISION;
-
+			
 			init_transition (ElementPtr0, ElementPtr1,
 					INTERPLANETARY_TRANSITION);
 		}
@@ -810,32 +891,49 @@ AddAmbientElement (void)
 
 		LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
 		HyperSpaceElementPtr->playerNr = NEUTRAL_PLAYER_NUM;
-		HyperSpaceElementPtr->state_flags =
-				APPEARING | FINITE_LIFE | NONSOLID;
-		SetPrimType (&DisplayArray[HyperSpaceElementPtr->PrimIndex],
-				STAMP_PRIM);
+		HyperSpaceElementPtr->state_flags = APPEARING | FINITE_LIFE | NONSOLID;
+		SetPrimType (&DisplayArray[HyperSpaceElementPtr->PrimIndex], STAMP_PRIM);
 		HyperSpaceElementPtr->preprocess_func = animation_preprocess;
 
 		rand_val = TFB_Random ();
 		dy = LOWORD (rand_val);
-		dx = (SIZE)(LOBYTE (dy) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
-		dy = (SIZE)(HIBYTE (dy) % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
-		HyperSpaceElementPtr->current.location.x = (LOG_SPACE_WIDTH >> 1)
-				+ DISPLAY_TO_WORLD (dx);
-		HyperSpaceElementPtr->current.location.y = (LOG_SPACE_HEIGHT >> 1)
-				+ DISPLAY_TO_WORLD (dy);
-		HyperSpaceElementPtr->current.image.farray = &stars_in_space;
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0)
+		{
+			dx = (SIZE)(LOBYTE (dy) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
+			dy = (SIZE)(HIBYTE (dy) % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
+			HyperSpaceElementPtr->current.image.farray = &stars_in_space;
+		}
+		else
+		{
+			dx = (SIZE)((HIWORD (rand_val)) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
+			dy = (SIZE)(dy % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
+			
+			if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				HyperSpaceElementPtr->current.image.farray = &stars_in_space;
+			else
+				HyperSpaceElementPtr->current.image.farray = &stars_in_quasispace;
+		}
+		
+		HyperSpaceElementPtr->current.location.x = (LOG_SPACE_WIDTH >> 1) + DISPLAY_TO_WORLD (dx);
+		HyperSpaceElementPtr->current.location.y = (LOG_SPACE_HEIGHT >> 1) + DISPLAY_TO_WORLD (dy);
 
 		if (HIWORD (rand_val) & 7)
 		{
 			HyperSpaceElementPtr->life_span = 14;
-			HyperSpaceElementPtr->current.image.frame = stars_in_space;
+			if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				HyperSpaceElementPtr->current.image.frame = stars_in_space;
+			else
+				HyperSpaceElementPtr->current.image.frame = stars_in_quasispace;
 		}
 		else
 		{
 			HyperSpaceElementPtr->life_span = 12;
-			HyperSpaceElementPtr->current.image.frame =
-					SetAbsFrameIndex (stars_in_space, 14);
+			if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (stars_in_space, 14);
+			else
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (stars_in_quasispace, 14);
 		}
 
 		UnlockElement (hHyperSpaceElement);
@@ -871,7 +969,17 @@ encounter_transition (ELEMENT *ElementPt
 			if (f != ElementPtr->current.image.farray[0])
 				ElementPtr->next.image.frame = f;
 			else
+			{
 				ElementPtr->death_func = NULL;
+				// BW: the bubble has reached full size so we start animation
+				if (RESOLUTION_FACTOR > 0)
+				{
+					ElementPtr->current.image.farray = &npcbubble;
+					ElementPtr->next.image.farray = &npcbubble;
+					ElementPtr->current.image.frame = SetAbsFrameIndex(npcbubble, 0);
+					ElementPtr->next.image.frame = SetAbsFrameIndex(npcbubble, 0);
+				}
+			}
 		}
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
@@ -1068,8 +1176,17 @@ AddEncounterElement (ENCOUNTER *Encounte
 		}
 		else
 		{
-			ElementPtr->current.image.frame =
-					DecFrameIndex (ElementPtr->current.image.farray[0]);
+			if (RESOLUTION_FACTOR > 0)
+			{
+				ElementPtr->current.image.farray = &npcbubble;
+				ElementPtr->next.image.farray = &npcbubble;
+				ElementPtr->current.image.frame = SetAbsFrameIndex(npcbubble, 0);
+				ElementPtr->next.image.frame = SetAbsFrameIndex(npcbubble, 0);
+			}
+			else
+			{
+				ElementPtr->current.image.frame = DecFrameIndex (ElementPtr->current.image.farray[0]);
+			}
 		}
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
@@ -1146,7 +1263,7 @@ DrawHyperGrid (COORD ux, COORD uy, COORD
 	}
 }
 
-// Returns false iff the encounter is to be removed.
+// Returns false if the encounter is to be removed.
 static bool
 ProcessEncounter (ENCOUNTER *EncounterPtr, POINT *puniverse,
 		COORD ox, COORD oy, STAMP *stamp)
@@ -1236,6 +1353,10 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 		EncounterPtr->SD.star_pt.x = LOGX_TO_UNIVERSE (EncounterPtr->log_x);
 		EncounterPtr->SD.star_pt.y = LOGY_TO_UNIVERSE (EncounterPtr->log_y);
 
+		// BW: Animate the NPC bubble in hi-res modes.
+		if (RESOLUTION_FACTOR > 0)
+			ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+		
 		encounter_radius = EncounterPtr->radius + (GRID_OFFSET >> 1);
 		delta_x = EncounterPtr->SD.star_pt.x - EncounterPtr->origin.x;
 		if (delta_x < 0)
@@ -1295,8 +1416,10 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 	else
 	{
 		ElementPtr->state_flags |= NONSOLID;
-		if (ex - puniverse->x < -XOFFS || ex - puniverse->x > XOFFS
-				|| ey - puniverse->y < -YOFFS || ey - puniverse->y > YOFFS)
+		if (ex - puniverse->x < -XOFFS 
+				|| ex - puniverse->x > XOFFS
+				|| ey - puniverse->y < -YOFFS 
+				|| ey - puniverse->y > YOFFS)
 		{
 			ElementPtr->life_span = 0;
 			ElementPtr->death_func = NULL;
@@ -1310,8 +1433,7 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 	UnlockElement (EncounterPtr->hElement);
 		
 	stamp->origin.x = (COORD)((long)ex * RADAR_WIDTH / RADAR_SCAN_WIDTH) - ox;
-	stamp->origin.y = (COORD)((long)(MAX_Y_UNIVERSE - ey) * RADAR_HEIGHT
-			/ RADAR_SCAN_HEIGHT) - oy;
+	stamp->origin.y = (COORD)((long)(MAX_Y_UNIVERSE - ey) * RADAR_HEIGHT / RADAR_SCAN_HEIGHT) - oy;
 	DrawStamp (stamp);
 
 	return true;
@@ -1344,6 +1466,9 @@ ProcessEncounters (POINT *puniverse, COO
 	}
 }
 
+#define NUM_HOLES_FRAMES 32 // BW
+#define NUM_SUNS_FRAMES 32 // BW
+
 void
 SeedUniverse (void)
 {
@@ -1356,6 +1481,9 @@ SeedUniverse (void)
 	STAR_DESC *SDPtr;
 	HELEMENT hHyperSpaceElement;
 	ELEMENT *HyperSpaceElementPtr;
+	static COUNT frameCounter; // BW
+	
+	frameCounter++; // BW
 
 	universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
 	universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
@@ -1516,7 +1644,8 @@ SeedUniverse (void)
 		while ((SDPtr = FindStar (SDPtr, &universe, XOFFS, YOFFS)))
 		{
 			BYTE star_type;
-
+			int which_spaces_star_gfx;
+			
 			ex = SDPtr->star_pt.x - universe.x;
 			if (ex < 0)
 				ex = -ex;
@@ -1524,39 +1653,152 @@ SeedUniverse (void)
 			if (ey < 0)
 				ey = -ey;
 			if (ex > (XOFFS / NUM_RADAR_SCREENS)
-					|| ey > (YOFFS / NUM_RADAR_SCREENS))
-				continue;
-
-			hHyperSpaceElement = AllocHyperElement (SDPtr);
-			if (hHyperSpaceElement == 0)
+				|| ey > (YOFFS / NUM_RADAR_SCREENS))
 				continue;
-
+			
 			star_type = SDPtr->Type;
-
-			LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
-			HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
-					hyperstars[1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1)],
+			
+			if (RESOLUTION_FACTOR == 0)
+			{
+				hHyperSpaceElement = AllocHyperElement (SDPtr);
+				if (hHyperSpaceElement == 0)
+					continue;
+				
+				LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+				which_spaces_star_gfx = 1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1);
+				
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+					hyperstars[which_spaces_star_gfx],
 					STAR_TYPE (star_type) * NUM_STAR_COLORS
-					+ STAR_COLOR (star_type));
-			HyperSpaceElementPtr->preprocess_func = NULL;
-			HyperSpaceElementPtr->postprocess_func = NULL;
-			HyperSpaceElementPtr->collision_func = hyper_collision;
-
-			SetUpElement (HyperSpaceElementPtr);
-
-			if (SDPtr == CurStarDescPtr
-					&& GET_GAME_STATE (PORTAL_COUNTER) == 0)
-				HyperSpaceElementPtr->death_func = hyper_death;
+					 + STAR_COLOR (star_type));
+				
+				HyperSpaceElementPtr->preprocess_func = NULL;
+				HyperSpaceElementPtr->postprocess_func = NULL;
+				HyperSpaceElementPtr->collision_func = hyper_collision;
+				
+				SetUpElement (HyperSpaceElementPtr);
+				
+				if (SDPtr == CurStarDescPtr
+				    && GET_GAME_STATE (PORTAL_COUNTER) == 0)
+					HyperSpaceElementPtr->death_func = hyper_death;
+				else
+				{
+					HyperSpaceElementPtr->death_func = NULL;
+					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
+					DecFrameIndex (stars_in_space);
+				}
+				UnlockElement (hHyperSpaceElement);
+				
+				InsertElement (hHyperSpaceElement, GetHeadElement ());
+			}
 			else
 			{
-				HyperSpaceElementPtr->death_func = NULL;
-				HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
-						DecFrameIndex (stars_in_space);
+				// BW: first the actual star
+				if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1 
+					|| ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY))
+				{
+					hHyperSpaceElement = AllocHyperElement (SDPtr);
+					if (hHyperSpaceElement == 0)
+					continue;
+				
+					LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+				
+					// JMS_GFX: Draw stars in hyperspace.
+					if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+					{
+						// The color, then the size and finally
+						// the frame offset for the actual animation
+						HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+						hyperspacesuns, STAR_COLOR (star_type) * NUM_STAR_TYPES * NUM_SUNS_FRAMES
+						+ STAR_TYPE (star_type) * NUM_SUNS_FRAMES
+						+ frameCounter % NUM_SUNS_FRAMES);
+					
+						HyperSpaceElementPtr->current.image.farray = &hyperspacesuns;
+						HyperSpaceElementPtr->death_func = NULL;
+					}
+					// JMS_GFX: Draw Arilou homeworld in quasispace.
+					else if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY)
+					{
+						HyperSpaceElementPtr->current.image.frame = 
+						SetAbsFrameIndex (hyperstars[2], 5);
+					
+						HyperSpaceElementPtr->current.image.farray = &hyperstars[2];
+						HyperSpaceElementPtr->death_func = hyper_death;
+					}
+				
+					HyperSpaceElementPtr->preprocess_func = NULL;
+					HyperSpaceElementPtr->postprocess_func = NULL;
+					HyperSpaceElementPtr->collision_func = hyper_collision;
+				
+					SetUpElement (HyperSpaceElementPtr);
+				
+					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame = DecFrameIndex (stars_in_space);
+				
+					UnlockElement (hHyperSpaceElement);
+				
+					InsertElement (hHyperSpaceElement, GetHeadElement ());
+				
+					// JMS_GFX: Don't draw hole for arilou homeworld - it already has a nice planet gfx.
+					if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY)
+						continue;
+				
+				}
+				
+				// BW: and then the animated hyperspace portal
+				hHyperSpaceElement = AllocHyperElement (SDPtr);
+				if (hHyperSpaceElement == 0)
+					continue;
+				
+				LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+				which_spaces_star_gfx = 1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1);
+				
+				// Most holes go 100, 150, 200 or 150, 200, 250
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+					hyperholes[which_spaces_star_gfx],
+					STAR_TYPE (star_type) * NUM_HOLES_FRAMES);
+				
+				// Green, orange and yellow need bigger holes
+				if (STAR_COLOR (star_type) == GREEN_BODY 
+					|| STAR_COLOR (star_type) == ORANGE_BODY 
+					|| STAR_COLOR (star_type) == YELLOW_BODY)
+					HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+						HyperSpaceElementPtr->current.image.frame,
+						NUM_HOLES_FRAMES);
+				
+				// Super giant blue needs a bigger hole
+				if (STAR_COLOR (star_type) == BLUE_BODY 
+					&& STAR_TYPE (star_type) == SUPER_GIANT_STAR)
+					HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+						HyperSpaceElementPtr->current.image.frame,
+						NUM_HOLES_FRAMES);
+				
+				// The actual animation
+				HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+					HyperSpaceElementPtr->current.image.frame,
+					frameCounter % NUM_HOLES_FRAMES);
+				
+				HyperSpaceElementPtr->current.image.farray = &hyperholes[which_spaces_star_gfx];
+				HyperSpaceElementPtr->preprocess_func = NULL;
+				HyperSpaceElementPtr->postprocess_func = NULL;
+				HyperSpaceElementPtr->collision_func = hyper_collision;
+				
+				SetUpElement (HyperSpaceElementPtr);
+				
+				if (SDPtr == CurStarDescPtr
+					&& GET_GAME_STATE (PORTAL_COUNTER) == 0)
+					HyperSpaceElementPtr->death_func = hyper_death;
+				else
+				{
+					HyperSpaceElementPtr->death_func = NULL;
+					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
+					DecFrameIndex (stars_in_space);
+				}
+				UnlockElement (hHyperSpaceElement);
+				
+				InsertElement (hHyperSpaceElement, GetHeadElement ());				
 			}
-			UnlockElement (hHyperSpaceElement);
-
-			InsertElement (hHyperSpaceElement, GetHeadElement ());
 		}
+		
 		ProcessEncounters (&universe, ox, oy);
 	}
 
@@ -1608,8 +1850,7 @@ SeedUniverse (void)
 	if (!(LOWORD (TFB_Random ()) & 7))
 		AddAmbientElement ();
 
-	if (universe.x != GLOBAL (ShipStamp.origin.x)
-			|| universe.y != GLOBAL (ShipStamp.origin.y))
+	if (universe.x != GLOBAL (ShipStamp.origin.x) || universe.y != GLOBAL (ShipStamp.origin.y))
 	{
 		GLOBAL (ShipStamp.origin) = universe;
 		DrawHyperCoords (universe);
diff -ruNp ./src.orig/uqm/hyper.h ./src/uqm/hyper.h
--- ./src.orig/uqm/hyper.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/hyper.h	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef _HYPER_H
 #define _HYPER_H
 
@@ -25,8 +27,8 @@
 
 #define NUM_RADAR_SCREENS 12
 
-#define RADAR_SCAN_WIDTH (UNIT_SCREEN_WIDTH * NUM_RADAR_SCREENS)
-#define RADAR_SCAN_HEIGHT (UNIT_SCREEN_HEIGHT * NUM_RADAR_SCREENS)
+#define RADAR_SCAN_WIDTH ((UNIT_SCREEN_WIDTH * NUM_RADAR_SCREENS) >> RESOLUTION_FACTOR)
+#define RADAR_SCAN_HEIGHT ((UNIT_SCREEN_HEIGHT * NUM_RADAR_SCREENS) >> RESOLUTION_FACTOR)
 
 // Hyperspace coordinates of the naturally occuring portal into QuasiSpace
 #define ARILOU_SPACE_X   438
@@ -37,8 +39,8 @@
 #define QUASI_SPACE_Y  5000
 
 // QuasiSpace coordinates of the Arilou home world
-#define ARILOU_HOME_X  (QUASI_SPACE_X + ((RADAR_SCAN_WIDTH >> 1) * 3))
-#define ARILOU_HOME_Y  (QUASI_SPACE_Y + ((RADAR_SCAN_HEIGHT >> 1) * 3))
+#define ARILOU_HOME_X  6134
+#define ARILOU_HOME_Y  5900
 
 // HyperSpace coordinates of the locations where the QuasiSpace portals
 // take you.
@@ -70,7 +72,7 @@
 extern BOOLEAN LoadHyperspace (void);
 extern BOOLEAN FreeHyperspace (void);
 extern void SeedUniverse (void);
-extern void MoveSIS (SIZE *pdx, SIZE *pdy);
+extern void MoveSIS (SDWORD *pdx, SDWORD *pdy);
 
 extern void FreeHyperData (void);
 extern void check_hyperspace_encounter (void);
diff -ruNp ./src.orig/uqm/ifontres.h ./src/uqm/ifontres.h
--- ./src.orig/uqm/ifontres.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/ifontres.h	2017-10-23 11:41:34 -0700
@@ -2,11 +2,19 @@
    should not be edited directly.  Modify the master resource list
    instead and regenerate. */
 
+#define FALLBACK_TO1X_FONT "font.fallbackto1x"
+#define FALLBACK_TO2X_FONT "font.fallbackto2x"
+#define FALLBACK_TO4X_FONT "font.fallbackto4x"
 #define LANDER_FONT "font.lander"
 #define MICRO_FONT "font.micro"
+#define NANO_FONT "font.nano"
 #define PLAYER_FONT "font.player"
 #define PT13AA_FONT "credits.font.pt13"
 #define PT17AA_FONT "credits.font.pt17"
 #define PT45AA_FONT "credits.font.pt45"
 #define STARCON_FONT "font.starcon"
 #define TINY_FONT "font.tiny"
+#define TINY_FALLBACK_TO1X_FONT "font.tinyfallbackto1x"
+#define TINY_FALLBACK_TO2X_FONT "font.tinyfallbackto2x"
+#define TINY_FALLBACK_TO4X_FONT "font.tinyfallbackto4x"
+#define COMPUTER_FONT "comm.computer.font"
diff -ruNp ./src.orig/uqm/igfxres.h ./src/uqm/igfxres.h
--- ./src.orig/uqm/igfxres.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/igfxres.h	2017-10-23 11:41:34 -0700
@@ -5,6 +5,8 @@
 #define ACTIVITY_ANIM "graphics.activity"
 #define AMBIENT_MASK_PMAP_ANIM "graphics.ambient"
 #define AQUA_MASK_PMAP_ANIM "graphics.aquahelix"
+#define ARI_AMBIENT_MASK_PMAP_ANIM "graphics.ambientquasispace"
+#define ARIHOLES_MASK_PMAP_ANIM "graphics.quasiholes"
 #define ARISPACE_MASK_PMAP_ANIM "graphics.quasispace"
 #define ASTEROID_BIG_MASK_PMAP_ANIM "graphics.asteroid.large"
 #define ASTEROID_MED_MASK_PMAP_ANIM "graphics.asteroid.medium"
@@ -17,14 +19,38 @@
 #define BOOM_MED_MASK_PMAP_ANIM "graphics.boom.medium"
 #define BOOM_SML_MASK_PMAP_ANIM "graphics.boom.small"
 #define BURV_BCS_MASK_PMAP_ANIM "graphics.burvixcaster"
+#define CALLISTO_MASK_ANIM "graphics.callistomask"
+#define CONSTELLATIONS_MASK_PMAP_ANIM "graphics.constellations"
 #define CANNISTER_MASK_PMAP_ANIM "graphics.lifecan"
 #define CREDITS_BACK_ANIM "credits.background"
 #define EARTH_MASK_ANIM "graphics.earthmask"
 #define EGG_CASE_MASK_PMAP_ANIM "graphics.eggcase"
+#define EUROPA_MASK_ANIM "graphics.europamask"
 #define FLAGSTAT_MASK_PMAP_ANIM "graphics.flagshipstatus"
 #define FONTGRAD_PMAP_ANIM "graphics.fontgradient"
+#define GANYMEDE_MASK_ANIM "graphics.ganymedemask"
+#define HYPERHOLES_MASK_PMAP_ANIM "graphics.hyperholes"
 #define HYPERSTARS_MASK_PMAP_ANIM "graphics.hyperstars"
+#define HYPERSUNS_MASK_PMAP_ANIM "graphics.hypersuns"
+#define IO_MASK_ANIM "graphics.iomask"
 #define IPBKGND_MASK_PMAP_ANIM "graphics.orbitbackground"
+#define IP_CALLISTO_MASK_ANIM "graphics.ipcallistomask"
+#define IP_EARTH_MASK_ANIM "graphics.ipearthmask"
+#define IP_EUROPA_MASK_ANIM "graphics.ipeuropamask"
+#define IP_GANYMEDE_MASK_ANIM "graphics.ipganymedemask"
+#define IP_IO_MASK_ANIM "graphics.ipiomask"
+#define IP_JUPITER_MASK_ANIM "graphics.ipjupitermask"
+#define IP_LUNA_MASK_ANIM "graphics.iplunamask"
+#define IP_MARS_MASK_ANIM "graphics.ipmarsmask"
+#define IP_MERCURY_MASK_ANIM "graphics.ipmercurymask"
+#define IP_NEPTUNE_MASK_ANIM "graphics.ipneptunemask"
+#define IP_PLUTO_MASK_ANIM "graphics.ipplutomask"
+#define IP_SATURN_MASK_ANIM "graphics.ipsaturnmask"
+#define IP_TITAN_MASK_ANIM "graphics.iptitanmask"
+#define IP_TRITON_MASK_ANIM "graphics.iptritonmask"
+#define IP_URANUS_MASK_ANIM "graphics.ipuranusmask"
+#define IP_VENUS_MASK_ANIM "graphics.ipvenusmask"
+#define JUPITER_MASK_ANIM "graphics.jupitermask"
 #define LANDER_FONTEFF_PMAP_ANIM "graphics.landerfonteffect"
 #define LANDER_LAUNCH_MASK_PMAP_ANIM "graphics.landerlaunch"
 #define LANDER_MASK_PMAP_ANIM "graphics.lander"
@@ -58,13 +84,21 @@
 #define LIFE24_MASK_PMAP_ANIM "graphics.life.24"
 #define LIFE25_MASK_PMAP_ANIM "graphics.life.25"
 #define LIGHTNING_MASK_ANIM "graphics.lightning"
+#define LUNA_MASK_ANIM "graphics.lunamask"
 #define MAIDENS_MASK_PMAP_ANIM "graphics.maidens"
+#define MARS_MASK_ANIM "graphics.marsmask"
 #define MELEE_PICK_MASK_PMAP_ANIM "graphics.meleepickship"
 #define MELEE_SCREEN_PMAP_ANIM "graphics.meleemenu"
 #define MENUBKG_PMAP_ANIM "graphics.setupmenu"
+#define MENUBKG_PMAP_ANIM2X "graphics.setupmenu2x"
+#define MENUBKG_PMAP_ANIM4X "graphics.setupmenu4x"
+#define MERCURY_MASK_ANIM "graphics.mercurymask"
 #define MISCDATA_MASK_PMAP_ANIM "graphics.miscdata"
 #define MODULES_PMAP_ANIM "graphics.modulesmenu"
 #define MOONBASE_MASK_PMAP_ANIM "graphics.moonbase"
+#define NEBULAE_PMAP_ANIM "graphics.nebulae"
+#define NEPTUNE_MASK_ANIM "graphics.neptunemask"
+#define NPCBUBBLE_MASK_PMAP_ANIM "graphics.npcbubble"
 #define ORBENTER_PMAP_ANIM "graphics.orbitenter"
 #define ORBIT_VIEW_ANIM "graphics.orbview"
 #define ORBPLAN_MASK_PMAP_ANIM "graphics.planets"
@@ -247,10 +281,14 @@
 #define PLANET58_MED_MASK_PMAP_ANIM "planet.yellowgas.medium"
 #define PLANET58_SML_MASK_PMAP_ANIM "planet.yellowgas.small"
 #define PLAYMENU_ANIM "graphics.playmenu"
+#define PLUTO_MASK_ANIM "graphics.plutomask"
 #define QUAKE_MASK_PMAP_ANIM "graphics.quake"
 #define RESTART_PMAP_ANIM "graphics.newgame"
+#define RESTART_PMAP_ANIM2x "graphics.newgame2x"
+#define RESTART_PMAP_ANIM4x "graphics.newgame4x"
 #define RUINS_MASK_PMAP_ANIM "graphics.ruins"
 #define SAMATRA_BIG_MASK_PMAP_ANIM "planet.samatra.large"
+#define SATURN_MASK_ANIM "graphics.saturnmask"
 #define SC2_PICK_PMAP_ANIM "graphics.pickship"
 #define SEGUE_PMAP_ANIM "graphics.segue"
 #define SHIELDED_BIG_MASK_PMAP_ANIM "planet.slaveshield.large"
@@ -265,10 +303,25 @@
 #define STARBASE_ANIM "graphics.starbase"
 #define STAR_MASK_PMAP_ANIM "graphics.stars"
 #define STATUS_MASK_PMAP_ANIM "graphics.status"
+#define SUBMENUMINERALS_MASK_PMAP_ANIM "graphics.submenu.minerals"
+#define SUBMENUSTARMAPKEYS_MASK_PMAP_ANIM "graphics.submenu.starmapkeys"
+#define SUNBLUE_MASK_PMAP_ANIM "graphics.truespacesunblue"
+#define SUNGREEN_MASK_PMAP_ANIM "graphics.truespacesungreen"
+#define SUNORANGE_MASK_PMAP_ANIM "graphics.truespacesunorange"
+#define SUNRED_MASK_PMAP_ANIM "graphics.truespacesunred"
+#define SUNWHITE_MASK_PMAP_ANIM "graphics.truespacesunwhite"
+#define SUNYELLOW_MASK_PMAP_ANIM "graphics.truespacesunyellow"
 #define SUN_DEVICE_MASK_PMAP_ANIM "graphics.sundevice"
 #define SUN_MASK_PMAP_ANIM "graphics.truespacesun"
 #define TAALO_DEVICE_MASK_PMAP_ANIM "graphics.taalodevice"
+#define TITAN_MASK_ANIM "graphics.titanmask"
 #define TITLE_ANIM "graphics.title"
+#define TITLE_2X "graphics.title2x"
+#define TITLE_4X "graphics.title4x"
+#define TRITON_MASK_ANIM "graphics.tritonmask"
+#define NEBULA  "graphics.nebula"
 #define UMGAH_BCS_MASK_PMAP_ANIM "graphics.umgahcaster"
+#define URANUS_MASK_ANIM "graphics.uranusmask"
 #define VAULT_MASK_PMAP_ANIM "graphics.syreenvault"
+#define VENUS_MASK_ANIM "graphics.venusmask"
 #define WRECK_MASK_PMAP_ANIM "graphics.urquanwreck"
diff -ruNp ./src.orig/uqm/init.c ./src/uqm/init.c
--- ./src.orig/uqm/init.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/init.c	2017-10-23 11:41:34 -0700
@@ -37,6 +37,7 @@
 
 
 FRAME stars_in_space;
+FRAME stars_in_quasispace; // JMS_GFX
 FRAME asteroid[NUM_VIEWS];
 FRAME blast[NUM_VIEWS];
 FRAME explosion[NUM_VIEWS];
diff -ruNp ./src.orig/uqm/init.h ./src/uqm/init.h
--- ./src.orig/uqm/init.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/init.h	2017-10-23 11:41:34 -0700
@@ -24,6 +24,7 @@
 #define NUM_SIDES 2
 
 extern FRAME stars_in_space;
+extern FRAME stars_in_quasispace; // JMS_GFX
 
 extern BOOLEAN InitSpace (void);
 extern void UninitSpace (void);
diff -ruNp ./src.orig/uqm/intel.h ./src/uqm/intel.h
--- ./src.orig/uqm/intel.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/intel.h	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+ // JMS_GFX: Added definitions for hi-res modes.
+
 #ifndef _INTEL_H
 #define _INTEL_H
 
@@ -35,6 +37,29 @@
 #define MEDIUM_SHIP 45
 #define SLOW_SHIP 25
 
+// JMS_GFX
+#define CLOSE_RANGE_WEAPON_2XRES DISPLAY_TO_WORLD (100)
+#define LONG_RANGE_WEAPON_2XRES DISPLAY_TO_WORLD (2000)
+
+// JMS_GFX: Multiplied by 2*2=4 because of the way the ManeuverabilityIndex
+// is calculated in InitCyborg () (cyborg.c).
+#define FAST_SHIP_2XRES 600
+#define MEDIUM_SHIP_2XRES 180
+#define SLOW_SHIP_2XRES 100
+
+// JMS_GFX
+#define CLOSE_RANGE_WEAPON_4XRES DISPLAY_TO_WORLD (200)
+#define LONG_RANGE_WEAPON_4XRES DISPLAY_TO_WORLD (4000)
+
+// JMS_GFX: Multiplied by 4*4=16 because of the way the ManeuverabilityIndex
+// is calculated in InitCyborg () (cyborg.c).
+#define FAST_SHIP_4XRES 2400
+#define MEDIUM_SHIP_4XRES 720
+#define SLOW_SHIP_4XRES 400
+
+// JMS_GFX
+#define RESOLUTION_COMPENSATED(speed) ((speed << RESOLUTION_FACTOR) << RESOLUTION_FACTOR)
+
 enum
 {
 	ENEMY_SHIP_INDEX = 0,
diff -ruNp ./src.orig/uqm/intro.c ./src/uqm/intro.c
--- ./src.orig/uqm/intro.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/intro.c	2017-10-23 11:41:34 -0700
@@ -181,10 +181,12 @@ Present_UnbatchGraphics (PRESENTATION_IN
 static void
 Present_GenerateSIS (PRESENTATION_INPUT_STATE* pPIS)
 {
-#define MODULE_YOFS_P  (-79)
+#define MODULE_YOFS_P  (((-79) << RESOLUTION_FACTOR) + RES_CASE(0,-34,-94)) // JMS_GFX
 #define DRIVE_TOP_Y_P  (DRIVE_TOP_Y + MODULE_YOFS_P)
 #define JET_TOP_Y_P    (JET_TOP_Y + MODULE_YOFS_P)
 #define MODULE_TOP_Y_P (MODULE_TOP_Y + MODULE_YOFS_P)
+#define MODULE_TOP_X_P (MODULE_TOP_X + RES_CASE(0,18,0))
+#define JET_DRIVE_EXTRA_X RES_CASE(0,5,-3)
 	CONTEXT	OldContext;
 	FRAME SisFrame;
 	FRAME ModuleFrame;
@@ -223,7 +225,7 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 		piece = GLOBAL_SIS (DriveSlots[slot]);
 		if (piece < EMPTY_SLOT)
 		{
-			s.origin.x = DRIVE_TOP_X;
+			s.origin.x = DRIVE_TOP_X + JET_DRIVE_EXTRA_X;
 			s.origin.y = DRIVE_TOP_Y_P;
 			s.origin.x += slot * SHIP_PIECE_OFFSET;
 			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
@@ -235,7 +237,7 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 		piece = GLOBAL_SIS (JetSlots[slot]);
 		if (piece < EMPTY_SLOT)
 		{
-			s.origin.x = JET_TOP_X;
+			s.origin.x = JET_TOP_X + JET_DRIVE_EXTRA_X;
 			s.origin.y = JET_TOP_Y_P;
 			s.origin.x += slot * SHIP_PIECE_OFFSET;
 			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
@@ -247,7 +249,7 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 		piece = GLOBAL_SIS (ModuleSlots[slot]);
 		if (piece < EMPTY_SLOT)
 		{
-			s.origin.x = MODULE_TOP_X;
+			s.origin.x = MODULE_TOP_X_P;
 			s.origin.y = MODULE_TOP_Y_P;
 			s.origin.x += slot * SHIP_PIECE_OFFSET;
 			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
@@ -357,6 +359,9 @@ DoPresentation (void *pIS)
 			int w, h;
 			if (2 == sscanf (pStr, "%d %d", &w, &h))
 			{
+				w <<= RESOLUTION_FACTOR; // JMS_GFX
+				h <<= RESOLUTION_FACTOR; // JMS_GFX
+				
 				pPIS->clip_r.extent.width = w;
 				pPIS->clip_r.extent.height = h;
 				/* center on screen */
@@ -396,6 +401,93 @@ DoPresentation (void *pIS)
 			if (!pPIS->Batched)
 				UnlockMutex (GraphicsLock);
 		}
+		else if (strcmp (Opcode, "FONT1X") == 0 && RESOLUTION_FACTOR == 0)
+		{	/* set and/or load a font */
+			int index;
+			FONT *pFont;
+			
+			assert (sizeof (pPIS->Buffer) >= 256);
+			
+			pPIS->Buffer[0] = '\0';
+			if (1 > sscanf (pStr, "%d %255[^\n]", &index, pPIS->Buffer) ||
+				index < 0 || index >= MAX_FONTS)
+			{
+				log_add (log_Warning, "Bad FONT command '%s'", pStr);
+				continue;
+			}
+			pFont = &pPIS->Fonts[index];
+			
+			if (pPIS->Buffer[0])
+			{	/* asked to load a font */
+				if (*pFont)
+					DestroyFont (*pFont);
+				*pFont = LoadFontFile (pPIS->Buffer);
+			}
+			
+			if (!pPIS->Batched)
+				LockMutex (GraphicsLock);
+			SetContextFont (*pFont);
+			if (!pPIS->Batched)
+				UnlockMutex (GraphicsLock);
+		}
+		else if (strcmp (Opcode, "FONT2X") == 0 && RESOLUTION_FACTOR == 1)
+		{	/* set and/or load a font */
+			int index;
+			FONT *pFont;
+			
+			assert (sizeof (pPIS->Buffer) >= 256);
+			
+			pPIS->Buffer[0] = '\0';
+			if (1 > sscanf (pStr, "%d %255[^\n]", &index, pPIS->Buffer) ||
+				index < 0 || index >= MAX_FONTS)
+			{
+				log_add (log_Warning, "Bad FONT command '%s'", pStr);
+				continue;
+			}
+			pFont = &pPIS->Fonts[index];
+			
+			if (pPIS->Buffer[0])
+			{	/* asked to load a font */
+				if (*pFont)
+					DestroyFont (*pFont);
+				*pFont = LoadFontFile (pPIS->Buffer);
+			}
+			
+			if (!pPIS->Batched)
+				LockMutex (GraphicsLock);
+			SetContextFont (*pFont);
+			if (!pPIS->Batched)
+				UnlockMutex (GraphicsLock);
+		}
+		else if (strcmp (Opcode, "FONT4X") == 0 && RESOLUTION_FACTOR == 2)
+		{	/* set and/or load a font */
+			int index;
+			FONT *pFont;
+			
+			assert (sizeof (pPIS->Buffer) >= 256);
+			
+			pPIS->Buffer[0] = '\0';
+			if (1 > sscanf (pStr, "%d %255[^\n]", &index, pPIS->Buffer) ||
+				index < 0 || index >= MAX_FONTS)
+			{
+				log_add (log_Warning, "Bad FONT command '%s'", pStr);
+				continue;
+			}
+			pFont = &pPIS->Fonts[index];
+			
+			if (pPIS->Buffer[0])
+			{	/* asked to load a font */
+				if (*pFont)
+					DestroyFont (*pFont);
+				*pFont = LoadFontFile (pPIS->Buffer);
+			}
+			
+			if (!pPIS->Batched)
+				LockMutex (GraphicsLock);
+			SetContextFont (*pFont);
+			if (!pPIS->Batched)
+				UnlockMutex (GraphicsLock);
+		}
 		else if (strcmp (Opcode, "ANI") == 0)
 		{	/* set ani */
 			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
@@ -403,6 +495,27 @@ DoPresentation (void *pIS)
 				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
 			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
 		}
+		else if (strcmp (Opcode, "ANI1X") == 0 && RESOLUTION_FACTOR == 0)
+		{	/* set ani */
+			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
+			if (pPIS->Frame)
+				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
+			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
+		}
+		else if (strcmp (Opcode, "ANI2X") == 0 && RESOLUTION_FACTOR == 1)
+		{	/* set ani */
+			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
+			if (pPIS->Frame)
+				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
+			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
+		}
+		else if (strcmp (Opcode, "ANI4X") == 0 && RESOLUTION_FACTOR == 2)
+		{	/* set ani */
+			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
+			if (pPIS->Frame)
+				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
+			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
+		}
 		else if (strcmp (Opcode, "MUSIC") == 0)
 		{	/* set music */
 			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
@@ -484,6 +597,9 @@ DoPresentation (void *pIS)
 			if (3 == sscanf (pStr, "%d %d %255[^\n]", &x, &y, pPIS->Buffer))
 			{
 				TEXT t;
+				
+				x <<= RESOLUTION_FACTOR; // JMS_GFX
+				y <<= RESOLUTION_FACTOR; // JMS_GFX
 
 				t.align = ALIGN_CENTER;
 				t.pStr = pPIS->Buffer;
@@ -624,6 +740,9 @@ DoPresentation (void *pIS)
 				x = 0;
 				y = 0;
 			}
+			
+			x <<= RESOLUTION_FACTOR; // JMS_GFX
+			y <<= RESOLUTION_FACTOR; // JMS_GFX
 
 			s.frame = NULL;
 			if (draw_what == PRES_DRAW_INDEX)
@@ -706,6 +825,11 @@ DoPresentation (void *pIS)
 			if (4 == sscanf (pStr, "%d %d %d %d", &x1, &y1, &x2, &y2))
 			{
 				LINE l;
+				
+				x1 <<= RESOLUTION_FACTOR; // JMS_GFX
+				y1 <<= RESOLUTION_FACTOR; // JMS_GFX
+				x2 <<= RESOLUTION_FACTOR; // JMS_GFX
+				y2 <<= RESOLUTION_FACTOR; // JMS_GFX
 
 				l.first.x = x1;
 				l.first.y = y1;
diff -ruNp ./src.orig/uqm/ipdisp.c ./src/uqm/ipdisp.c
--- ./src.orig/uqm/ipdisp.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/ipdisp.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "ipdisp.h"
 
 #include "collide.h"
@@ -237,12 +239,15 @@ ip_group_preprocess (ELEMENT *ElementPtr
 	if (task <= ON_STATION)
 #endif /* NEVER */
 	{
-		BOOLEAN Transition;
+		BOOLEAN Transition, isOrbiting;
 		SIZE dx, dy;
 		SIZE delta_x, delta_y;
 		COUNT angle;
+		FRAME suggestedFrame; // JMS
 
 		Transition = FALSE;
+		isOrbiting = FALSE;
+		
 		if (task == FLEE)
 		{
 			dest_pt.x = GroupPtr->loc.x << 1;
@@ -257,11 +262,14 @@ ip_group_preprocess (ELEMENT *ElementPtr
 		{
 			if (GroupPtr->dest_loc == IPNL_INTERCEPT_PLAYER)
 				dest_pt = GLOBAL (ip_location);
+			
+			// ship is circling around a planet.
 			else
 			{
 				COUNT orbit_dist;
 				POINT org;
 
+				isOrbiting = TRUE;
 				if (task != ON_STATION)
 				{
 					orbit_dist = ORBIT_RADIUS;
@@ -448,6 +456,22 @@ CheckGetAway:
 				}
 			}
 		}
+		
+		//BW : make IP ships face the direction they're going into
+		suggestedFrame = SetAbsFrameIndex(ElementPtr->next.image.farray[0], 1 + NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))));
+		
+		// JMS: Direction memory prevents jittering of battle group icons when they are orbiting a planet (and not chasing the player ship).		
+		if (isOrbiting)
+		{
+			// This works because ships always orbit planets clockwise.
+			if (GroupPtr->lastDirection < NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)))
+				|| GroupPtr->lastDirection == 15)
+				ElementPtr->next.image.frame = suggestedFrame;
+		}
+		else
+			ElementPtr->next.image.frame = suggestedFrame;
+		
+		GroupPtr->lastDirection = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)));
 	}
 
 	radius = zoomRadiusForLocation (group_loc);
diff -ruNp ./src.orig/uqm/istrtab.h ./src/uqm/istrtab.h
--- ./src.orig/uqm/istrtab.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/istrtab.h	2017-10-23 11:41:34 -0700
@@ -19,6 +19,7 @@
 #define BOMB_STRTAB "text.utwigbomb"
 #define BURV_BCS_STRTAB "text.burvixcaster"
 #define BURV_RUINS_STRTAB "text.burvixeseruins"
+#define CALLISTO_COLOR_TAB "planet.callisto.colortable"
 #define CARBIDE_COLOR_TAB "planet.carbide.colortable"
 #define CARBIDE_XLAT_TAB "planet.carbide.translatetable"
 #define CHLORINE_COLOR_TAB "planet.chlorine.colortable"
@@ -37,15 +38,18 @@
 #define CYANIC_XLAT_TAB "planet.cyanic.translatetable"
 #define CYA_GAS_COLOR_TAB "planet.cyangas.colortable"
 #define CYA_GAS_XLAT_TAB "planet.cyangas.translatetable"
+#define DEIMOS_COLOR_TAB "planet.deimos.colortable"
 #define DRUUGE_RUINS_STRTAB "text.sphere"
 #define DUST_COLOR_TAB "planet.dust.colortable"
 #define DUST_XLAT_TAB "planet.dust.translatetable"
 #define EGG_CASE_STRTAB "text.eggcase"
 #define EMERALD_COLOR_TAB "planet.emerald.colortable"
 #define EMERALD_XLAT_TAB "planet.emerald.translatetable"
+#define EUROPA_COLOR_TAB "planet.europa.colortable"
 #define FINALPRES_STRTAB "slides.ending"
 #define FLUORESCENT_COLOR_TAB "planet.fluorescent.colortable"
 #define FLUORESCENT_XLAT_TAB "planet.fluorescent.translatetable"
+#define GANYMEDE_COLOR_TAB "planet.ganymede.colortable"
 #define GREEN_COLOR_TAB "planet.green.colortable"
 #define GREEN_XLAT_TAB "planet.green.translatetable"
 #define GRN_GAS_COLOR_TAB "planet.greengas.colortable"
@@ -61,22 +65,28 @@
 #define INFRARED_COLOR_TAB "planet.infrared.colortable"
 #define INFRARED_XLAT_TAB "planet.infrared.translatetable"
 #define INTROPRES_STRTAB "slides.intro"
+#define IO_COLOR_TAB "planet.io.colortable"
 #define IODINE_COLOR_TAB "planet.iodine.colortable"
 #define IODINE_XLAT_TAB "planet.iodine.translatetable"
 #define IPSUN_COLOR_MAP "colortable.truespace"
 #define JOYSTICK_ALPHA_STRTAB "text.joyalpha"
+#define JUPITER_COLOR_TAB "planet.jupiter.colortable"
 #define LANTHANIDE_COLOR_TAB "planet.lanthanide.colortable"
 #define LANTHANIDE_XLAT_TAB "planet.lanthanide.translatetable"
+#define LUNA_COLOR_TAB "planet.luna.colortable"
 #define MAGMA_COLOR_TAB "planet.magma.colortable"
 #define MAGMA_XLAT_TAB "planet.magma.translatetable"
+#define MARS_COLOR_TAB "planet.mars.colortable"
 #define MAGNETIC_COLOR_TAB "planet.magnetic.colortable"
 #define MAGNETIC_XLAT_TAB "planet.magnetic.translatetable"
 #define MAIDENS_STRTAB "text.maidens"
 #define MAROON_COLOR_TAB "planet.maroon.colortable"
 #define MAROON_XLAT_TAB "planet.maroon.translatetable"
+#define MERCURY_COLOR_TAB "planet.mercury.colortable"
 #define METAL_COLOR_TAB "planet.metal.colortable"
 #define METAL_XLAT_TAB "planet.metal.translatetable"
 #define MOONBASE_STRTAB "text.moonbase"
+#define NEPTUNE_COLOR_TAB "planet.neptune.colortable"
 #define NOBLE_COLOR_TAB "planet.noble.colortable"
 #define NOBLE_XLAT_TAB "planet.noble.translatetable"
 #define OOLITE_COLOR_TAB "planet.oolite.colortable"
@@ -90,7 +100,9 @@
 #define ORGANIC_XLAT_TAB "planet.organic.translatetable"
 #define PELLUCID_COLOR_TAB "planet.pellucid.colortable"
 #define PELLUCID_XLAT_TAB "planet.pellucid.translatetable"
+#define PHOBOS_COLOR_TAB "planet.phobos.colortable"
 #define PKUNK_RUINS_STRTAB "text.spindle"
+#define PLUTO_COLOR_TAB "planet.pluto.colortable"
 #define PLUTONIC_COLOR_TAB "planet.plutonic.colortable"
 #define PLUTONIC_XLAT_TAB "planet.plutonic.translatetable"
 #define PRIMORDIAL_COLOR_TAB "planet.primordial.colortable"
@@ -114,11 +126,13 @@
 #define RUINS_STRTAB "text.ruins"
 #define SAPPHIRE_COLOR_TAB "planet.sapphire.colortable"
 #define SAPPHIRE_XLAT_TAB "planet.sapphire.translatetable"
+#define SATURN_COLOR_TAB "planet.saturn.colortable"
 #define SELENIC_COLOR_TAB "planet.selenic.colortable"
 #define SELENIC_XLAT_TAB "planet.selenic.translatetable"
 #define SETUP_MENU_STRTAB "text.setupmenu"
 #define SHATTERED_COLOR_TAB "planet.shattered.colortable"
 #define SHATTERED_XLAT_TAB "planet.shattered.translatetable"
+#define SPECIAL_CMAP_XLAT_TAB "planet.specialcolormap.translatetable"
 #define SPAPLUTO_STRTAB "text.fwiffo"
 #define STARCON_COLOR_MAP "colortable.main"
 #define STARCON_GAME_STRINGS "text.starcon"
@@ -127,18 +141,22 @@
 #define SUPER_DENSE_XLAT_TAB "planet.superdense.translatetable"
 #define SUPOX_RUINS_STRTAB "text.ultron"
 #define TAALO_DEVICE_STRTAB "text.taalodevice"
+#define TITAN_COLOR_TAB "planet.titan.colortable"
 #define TELLURIC_COLOR_TAB "planet.telluric.colortable"
 #define TELLURIC_XLAT_TAB "planet.telluric.translatetable"
 #define TREASURE_COLOR_TAB "planet.treasure.colortable"
 #define TREASURE_XLAT_TAB "planet.treasure.translatetable"
+#define TRITON_COLOR_TAB "planet.triton.colortable"
 #define ULTRAMARINE_COLOR_TAB "planet.ultramarine.colortable"
 #define ULTRAMARINE_XLAT_TAB "planet.ultramarine.translatetable"
 #define ULTRAVIOLET_COLOR_TAB "planet.ultraviolet.colortable"
 #define ULTRAVIOLET_XLAT_TAB "planet.ultraviolet.translatetable"
+#define URANUS_COLOR_TAB "planet.uranus.colortable"
 #define UMGAH_BCS_STRTAB "text.umgahcaster"
 #define UREA_COLOR_TAB "planet.urea.colortable"
 #define UREA_XLAT_TAB "planet.urea.translatetable"
 #define VAULT_STRTAB "text.syreenvault"
+#define VENUS_COLOR_TAB "planet.venus.colortable"
 #define VINYLOGOUS_COLOR_TAB "planet.vinylogous.colortable"
 #define VINYLOGOUS_XLAT_TAB "planet.vinylogous.translatetable"
 #define VIO_GAS_COLOR_TAB "planet.violetgas.colortable"
@@ -152,3 +170,5 @@
 #define YEL_GAS_XLAT_TAB "planet.yellowgas.translatetable"
 #define YTTRIC_COLOR_TAB "planet.yttric.colortable"
 #define YTTRIC_XLAT_TAB "planet.yttric.translatetable"
+#define ZOQCOLONY_RUINS1_STRTAB "text.zoqfotcolonyruins1"
+#define ZOQCOLONY_RUINS2_STRTAB "text.zoqfotcolonyruins2"
diff -ruNp ./src.orig/uqm/load.c ./src/uqm/load.c
--- ./src.orig/uqm/load.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/load.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2011: - Added loading res_factor to summary_desc. It'll help making saves between different resolutions compatible.
+
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include <assert.h>
 
 #include "load.h"
@@ -35,6 +39,10 @@
 #include "libs/log.h"
 #include "libs/misc.h"
 
+#include "util.h"
+
+#include "gamestr.h" // JMS: For GAME_STRING
+
 //#define DEBUG_LOAD
 
 ACTIVITY NextActivity;
@@ -240,9 +248,8 @@ static void
 LoadRaceQueue (DECODE_REF fh, QUEUE *pQueue)
 {
 	COUNT num_links;
-
 	cread_16 (fh, &num_links);
-
+	
 	while (num_links--)
 	{
 		HFLEETINFO hStarShip;
@@ -369,6 +376,10 @@ LoadEncounter (ENCOUNTER *EncounterPtr,
 	// Load the stuff after the BRIEF_SHIP_INFO array
 	cread_32s (fh, &EncounterPtr->log_x);
 	cread_32s (fh, &EncounterPtr->log_y);
+	
+	// JMS: Let's make savegames work even between different resolution modes.
+	EncounterPtr->log_x <<= RESOLUTION_FACTOR;
+	EncounterPtr->log_y <<= RESOLUTION_FACTOR;
 }
 
 static void
@@ -422,20 +433,39 @@ LoadClockState (CLOCK_STATE *ClockPtr, D
 	DummyLoadQueue (&ClockPtr->event_q, fh);
 }
 
-static void
-LoadGameState (GAME_STATE *GSPtr, DECODE_REF fh)
+static BOOLEAN
+LoadGameState (GAME_STATE *GSPtr, DECODE_REF fh, BOOLEAN vanilla)
 {
 	BYTE dummy8;
+	BYTE res_scale; // JMS
 
 	cread_8   (fh, &dummy8); /* obsolete */
 	cread_8   (fh, &GSPtr->glob_flags);
 	cread_8   (fh, &GSPtr->CrewCost);
 	cread_8   (fh, &GSPtr->FuelCost);
+	
+	// JMS: Now that we have read the fuelcost, we can compare it
+	// to the correct value. Fuel cost is always FUEL_COST_RU, and if
+	// the savefile tells otherwise, we have read it with the wrong method
+	// (The savegame is from vanilla UQM and we've been reading it as if it
+	// were UQM-HD save.)
+	//
+	// At this point we must then cease reading the savefile, close it
+	// and re-open it again, this time using the vanilla-reading method.
+	if (GSPtr->FuelCost != FUEL_COST_RU)
+		return FALSE;
+	
 	cread_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
 	cread_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
 	cread_ptr (fh); /* not loading ptr; PRIMITIVE *DisplayArray */
 	cread_16  (fh, &GSPtr->CurrentActivity);
 	
+	// JMS
+	if (LOBYTE (GSPtr->CurrentActivity) != IN_INTERPLANETARY)
+		res_scale = RESOLUTION_FACTOR;
+	else
+		res_scale = 0;
+	
 	cread_16  (fh, NULL); /* CLOCK_STATE alignment padding */
 	LoadClockState (&GSPtr->GameClock, fh);
 
@@ -449,6 +479,9 @@ LoadGameState (GAME_STATE *GSPtr, DECODE
 	cread_16  (fh, &GSPtr->ShipFacing);
 	cread_8   (fh, &GSPtr->ip_planet);
 	cread_8   (fh, &GSPtr->in_orbit);
+	
+	GSPtr->ShipStamp.origin.x <<= RESOLUTION_FACTOR; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->ShipStamp.origin.y <<= RESOLUTION_FACTOR; // JMS: Let's make savegames work even between different resolution modes.
 
 	/* VELOCITY_DESC velocity */
 	cread_16  (fh, &GSPtr->velocity.TravelAngle);
@@ -461,6 +494,15 @@ LoadGameState (GAME_STATE *GSPtr, DECODE
 	cread_16s (fh, &GSPtr->velocity.incr.width);
 	cread_16s (fh, &GSPtr->velocity.incr.height);
 	cread_16  (fh, NULL); /* VELOCITY_DESC padding */
+	
+	GSPtr->velocity.vector.width  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.vector.height <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.fract.width	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.fract.height  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.error.width	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.error.height  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.incr.width	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.incr.height	  <<= res_scale; // JMS: Let's make savegames work even between different resolution modes.
 
 	cread_32  (fh, &GSPtr->BattleGroupRef);
 	
@@ -470,10 +512,17 @@ LoadGameState (GAME_STATE *GSPtr, DECODE
 	DummyLoadQueue (&GSPtr->encounter_q, fh);
 	DummyLoadQueue (&GSPtr->built_ship_q, fh);
 
-	cread_a8  (fh, GSPtr->GameState, sizeof (GSPtr->GameState));
+	// JMS: Let's not read the 'autopilot ok' and QS portal
+	// coord bits for vanilla UQM saves.
+	if (vanilla)
+		cread_a8  (fh, GSPtr->GameState, (sizeof (GSPtr->GameState) - 2));
+	else
+		cread_a8  (fh, GSPtr->GameState, sizeof (GSPtr->GameState));
 
-	assert (sizeof (GSPtr->GameState) % 4 == 3);
+	//assert (sizeof (GSPtr->GameState) % 4 == 1);
 	cread_8  (fh, NULL); /* GAME_STATE alignment padding */
+	
+	return TRUE;
 }
 
 static BOOLEAN
@@ -501,15 +550,143 @@ LoadSisState (SIS_STATE *SSPtr, void *fp
 		)
 		return FALSE;
 	else
+	{
+		// JMS: Let's make savegames work even between different resolution modes.
+		SSPtr->log_x <<= RESOLUTION_FACTOR;
+		SSPtr->log_y <<= RESOLUTION_FACTOR;
 		return TRUE;
+	}
+}
+
+void
+LoadProblemMessage ()
+{
+#define MAX_MSG_LINES 2
+	COUNT i;
+	RECT r;
+	TEXT t;
+	UNICODE *ppStr[MAX_MSG_LINES];
+	ppStr[0] = GAME_STRING (SAVEGAME_STRING_BASE + 7);
+	ppStr[1] = GAME_STRING (SAVEGAME_STRING_BASE + 8);
+	
+	SetContextFont (StarConFont);
+	
+	t.baseline.x = t.baseline.y = 0;
+	t.align = ALIGN_CENTER;
+	
+	for (i = 0; i < MAX_MSG_LINES; ++i)
+	{
+		RECT tr;
+
+		t.pStr = ppStr[i];
+		if (*t.pStr == '\0')
+			break;
+		t.CharCount = (COUNT)~0;
+		TextRect (&t, &tr, NULL);
+		if (i == 0)
+			r = tr;
+		else
+			BoxUnion (&tr, &r, &r);
+		t.baseline.y += (11 << RESOLUTION_FACTOR);
+	}
+		
+	t.baseline.x = ((SIS_SCREEN_WIDTH >> 1) - (r.extent.width >> 1))
+		- r.corner.x;
+	t.baseline.y = ((SIS_SCREEN_HEIGHT >> 1) - (r.extent.height >> 1))
+		- r.corner.y;
+	
+	r.corner.x += t.baseline.x - (4 << RESOLUTION_FACTOR);
+	r.corner.y += t.baseline.y - (4 << RESOLUTION_FACTOR);
+	r.extent.width += (8 << RESOLUTION_FACTOR);
+	r.extent.height += (8 << RESOLUTION_FACTOR);
+	
+	BatchGraphics ();
+	DrawStarConBox (&r, 2,
+					BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
+					BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
+					TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+	SetContextForeGroundColor (
+		BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+	
+	for (i = 0; i < MAX_MSG_LINES; ++i)
+	{
+		t.pStr = ppStr[i];
+		if (*t.pStr == '\0')
+			break;
+		t.CharCount = (COUNT)~0;
+		font_DrawText (&t);
+		t.baseline.y += (11 << RESOLUTION_FACTOR);
+	}
+	
+	UnbatchGraphics ();
 }
 
 static BOOLEAN
-LoadSummary (SUMMARY_DESC *SummPtr, void *fp)
+LoadSummary (SUMMARY_DESC *SummPtr, void *fp, BOOLEAN try_vanilla)
 {
+	// JMS: New variables required for compatibility between
+	// old, unnamed saves and the new, named ones.
+	SDWORD  temp_log_x = 0;
+	SDWORD  temp_log_y = 0;
+	DWORD   temp_ru    = 0;
+	DWORD   temp_fuel  = 0;
+	BOOLEAN no_savename = FALSE;
+	
+	// First we check if there is a savegamename identifier.
+	// The identifier tells us whether the name exists at all.
+	read_str (fp, SummPtr->SaveNameChecker, SAVE_CHECKER_SIZE);
+		
+	// If the name doesn't exist (because this most probably
+	// is a savegame from an older version), we have to rewind the
+	// savefile to be able to read the saved variables into their
+	// correct places.
+	if (strncmp(SummPtr->SaveNameChecker, SAVE_NAME_CHECKER, SAVE_CHECKER_SIZE))
+	{
+		COUNT i;
+			
+		// Apparently the bytes read to SummPtr->SaveNameChecker with
+		// read_str are destroyed from fp, so we must copy these bytes
+		// to temp variables at this point to preserve them.
+		no_savename = TRUE;
+		memcpy(&temp_log_x, SummPtr->SaveNameChecker, sizeof(SDWORD));
+		memcpy(&temp_log_y, &(SummPtr->SaveNameChecker[sizeof(SDWORD)]), sizeof(SDWORD));
+		memcpy(&temp_ru, &(SummPtr->SaveNameChecker[2 * sizeof(SDWORD)]), sizeof(DWORD));
+		memcpy(&temp_fuel, &(SummPtr->SaveNameChecker[2 * sizeof(SDWORD)+ sizeof(DWORD)]), sizeof(DWORD));
+			
+		// Rewind the position in savefile.
+		for (i = 0; i < SAVE_CHECKER_SIZE; i++)
+			uio_backtrack (1, (uio_Stream *) fp);
+			
+		// Zero the bogus savenamechecker.
+		for (i = 0; i < SAVE_CHECKER_SIZE; i++)
+			SummPtr->SaveNameChecker[i] = 0;
+			
+		// Make sure the save's name is empty.
+		for (i = 0; i < SAVE_NAME_SIZE; i++)
+			SummPtr->SaveName[i] = 0;
+		}
+	else
+	{
+		// If the name identifier exists, let's also read
+		// the savegame's actual name, which is situated right
+		// after the identifier.
+		read_str (fp, SummPtr->SaveName, SAVE_NAME_SIZE);
+	}
+		
+	//log_add (log_Debug, "fp: %d Check:%s Name:%s", fp, SummPtr->SaveNameChecker, SummPtr->SaveName);
+	
 	if (!LoadSisState (&SummPtr->SS, fp))
 		return FALSE;
-
+		
+	// JMS: Now we'll put those temp variables into action.
+	if (no_savename)
+	{
+		SummPtr->SS.log_x = temp_log_x;
+		SummPtr->SS.log_y = temp_log_y;
+		SummPtr->SS.ResUnits = temp_ru;
+		SummPtr->SS.FuelOnBoard = temp_fuel;
+	}
+	
 	if (
 			read_8  (fp, &SummPtr->Activity) != 1 ||
 			read_8  (fp, &SummPtr->Flags) != 1 ||
@@ -522,12 +699,20 @@ LoadSummary (SUMMARY_DESC *SummPtr, void
 			read_8  (fp, &SummPtr->NumDevices) != 1 ||
 			read_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
 			read_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
-
-			read_16  (fp, NULL) != 1 /* padding */
+			read_8  (fp, &SummPtr->res_factor) != 1 || // JMS: This'll help making saves between different resolutions compatible.
+		
+			read_8  (fp, NULL) != 1 /* padding */
 		)
 		return FALSE;
 	else
+	{
+		// JMS: UQM-HD saves have an extra piece of padding to compensate for the
+		// added res_factor in SummPtr.
+		if (!try_vanilla)
+			read_8 (fp, NULL); /* padding */
+	
 		return TRUE;
+	}
 }
 
 static void
@@ -542,7 +727,7 @@ LoadStarDesc (STAR_DESC *SDPtr, DECODE_R
 }
 
 BOOLEAN
-LoadGame (COUNT which_game, SUMMARY_DESC *SummPtr)
+LoadGame (COUNT which_game, SUMMARY_DESC *SummPtr, BOOLEAN try_vanilla)
 {
 	uio_Stream *in_fp;
 	char file[PATH_MAX];
@@ -559,7 +744,7 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 	if (!in_fp)
 		return FALSE;
 
-	if (!LoadSummary (&loc_sd, in_fp))
+	if (!LoadSummary (&loc_sd, in_fp, try_vanilla))
 	{
 		log_add (log_Error, "Warning: Savegame is corrupt");
 		res_CloseResFile (in_fp);
@@ -608,7 +793,24 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 
 	memset (&GLOBAL (GameState[0]), 0, sizeof (GLOBAL (GameState)));
 	Activity = GLOBAL (CurrentActivity);
-	LoadGameState (&GlobData.Game_state, fh);
+	
+	// JMS: We can decide whether the current savefile is vanilla UQM or UQM-HD
+	// only at this point, when reading the game states. If this turns out to be a 
+	// vanilla UQM save, we must close the file and re-open it for reading
+	// with the vanilla method.
+	if (!(LoadGameState (&GlobData.Game_state, fh, try_vanilla)))
+	{
+		res_CloseResFile (in_fp);
+		
+		if (!try_vanilla)
+		{
+			LoadGame (which_game, NULL, TRUE);
+			return TRUE;
+		}
+		else
+			return FALSE;
+	}
+	
 	NextActivity = GLOBAL (CurrentActivity);
 	GLOBAL (CurrentActivity) = Activity;
 
diff -ruNp ./src.orig/uqm/load.h ./src/uqm/load.h
--- ./src.orig/uqm/load.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/load.h	2017-10-23 11:41:34 -0700
@@ -24,7 +24,8 @@
 
 extern ACTIVITY NextActivity;
 
-extern BOOLEAN LoadGame (COUNT which_game, SUMMARY_DESC *summary_desc);
+extern BOOLEAN LoadGame (COUNT which_game, SUMMARY_DESC *summary_desc, BOOLEAN try_vanilla);
+extern void LoadProblemMessage ();
 
 
 #endif  /* _LOAD_H */
diff -ruNp ./src.orig/uqm/menu.c ./src/uqm/menu.c
--- ./src.orig/uqm/menu.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/menu.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "menustat.h"
 
 #include "colors.h"
@@ -79,7 +81,7 @@ static UNICODE pm_fuel_str[128];
 static void
 DrawPCMenu (BYTE beg_index, BYTE end_index, BYTE NewState, BYTE hilite, RECT *r)
 {
-#define PC_MENU_HEIGHT 8
+#define PC_MENU_HEIGHT (RES_STAT_SCALE(8)) // JMS_GFX
 	BYTE pos;
 	COUNT i;
 	int num_items;
@@ -101,7 +103,7 @@ DrawPCMenu (BYTE beg_index, BYTE end_ind
 	OldFont = SetContextFont (StarConFont);
 	t.align = ALIGN_LEFT;
 	t.baseline.x = r->corner.x + 2;
-	t.baseline.y = r->corner.y + PC_MENU_HEIGHT -1;
+	t.baseline.y = r->corner.y + PC_MENU_HEIGHT - (1 << RESOLUTION_FACTOR);// - RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	r->corner.x++;
@@ -118,7 +120,7 @@ DrawPCMenu (BYTE beg_index, BYTE end_ind
 			
 			// Draw the background of the selection.
 			SetContextForeGroundColor (PCMENU_SELECTION_BACKGROUND_COLOR);
-			r->corner.y = t.baseline.y - PC_MENU_HEIGHT + 2;
+			r->corner.y = t.baseline.y - PC_MENU_HEIGHT + RES_STAT_SCALE(2);// + RESOLUTION_FACTOR; // JMS_GFX
 			r->extent.height = PC_MENU_HEIGHT - 1;
 			DrawFilledRectangle (r);
 
@@ -506,7 +508,7 @@ DrawMenuStateStrings (BYTE beg_index, SW
 	s.origin.x = RADAR_X - r.corner.x;
 	s.origin.y = RADAR_Y - r.corner.y;
 	r.corner.x = s.origin.x - 1;
-	r.corner.y = s.origin.y - 11;
+	r.corner.y = s.origin.y - (11 << RESOLUTION_FACTOR); // JMS_GFX
 	r.extent.width = RADAR_WIDTH + 2;
 	BatchGraphics ();
 	SetContextForeGroundColor (
@@ -551,7 +553,16 @@ DrawMenuStateStrings (BYTE beg_index, SW
 					break;
 			}
 		}
-		r.extent.height = RADAR_HEIGHT + 11;
+		r.extent.height = RADAR_HEIGHT + (11 << RESOLUTION_FACTOR); // JMS_GFX
+		
+		// JMS_GFX: This is to fix the two-line high outfit module texts.
+		// They weren't completely erased in 640x480 when exiting module selection.
+		if (RESOLUTION_FACTOR == 1)
+		{
+			r.corner.y -= 7;
+			r.extent.height += 7;
+		}
+		
 		DrawPCMenu (beg_index, end_index, (BYTE)NewState, hilite, &r);
 		s.frame = 0;
 	}
@@ -561,10 +572,11 @@ DrawMenuStateStrings (BYTE beg_index, SW
 		{
 			r.corner.x -= 1;
 			r.extent.width += 1;
-			r.extent.height = RADAR_HEIGHT + 11;
+			r.extent.height = RADAR_HEIGHT + (11 << RESOLUTION_FACTOR); // JMS_GFX
 		}
 		else
-			r.extent.height = 11;
+			r.extent.height = 11 << RESOLUTION_FACTOR;
+			
 		DrawFilledRectangle (&r);
 	}
 	if (s.frame)
diff -ruNp ./src.orig/uqm/misc.c ./src/uqm/misc.c
--- ./src.orig/uqm/misc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/misc.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "element.h"
 #include "init.h"
 #include "races.h"
@@ -26,6 +28,8 @@
 #include "weapon.h"
 #include "libs/mathlib.h"
 
+#include "uqmdebug.h" // JMS: For debug invincibility
+
 
 void
 spawn_planet (void)
@@ -86,8 +90,13 @@ spawn_rubble (ELEMENT *AsteroidElementPt
 		RubbleElementPtr->turn_wait = RubbleElementPtr->next_turn = 0;
 		SetPrimType (&DisplayArray[RubbleElementPtr->PrimIndex], STAMP_PRIM);
 		RubbleElementPtr->current.image.farray = asteroid;
-		RubbleElementPtr->current.image.frame =
-				SetAbsFrameIndex (asteroid[0], ANGLE_TO_FACING (FULL_CIRCLE));
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0)
+			RubbleElementPtr->current.image.frame = SetAbsFrameIndex (asteroid[0], ANGLE_TO_FACING (FULL_CIRCLE));
+		else
+			RubbleElementPtr->current.image.frame = SetAbsFrameIndex (asteroid[0], 29);
+		
 		RubbleElementPtr->current.location = AsteroidElementPtr->current.location;
 		RubbleElementPtr->preprocess_func = animation_preprocess;
 		RubbleElementPtr->death_func = spawn_asteroid;
@@ -109,11 +118,14 @@ asteroid_preprocess (ELEMENT *ElementPtr
 			--frame_index;
 		else
 			++frame_index;
-		ElementPtr->next.image.frame =
-				SetAbsFrameIndex (ElementPtr->current.image.frame,
-				NORMALIZE_FACING (frame_index));
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0)
+			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, NORMALIZE_FACING (frame_index));
+		else
+			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, frame_index % 30);
+		
 		ElementPtr->state_flags |= CHANGING;
-
 		ElementPtr->turn_wait = (unsigned char)(ElementPtr->thrust_wait & ((1 << 7) - 1));
 	}
 }
@@ -194,6 +206,13 @@ spawn_asteroid (ELEMENT *ElementPtr)
 void
 do_damage (ELEMENT *ElementPtr, SIZE damage)
 {
+#ifdef DEBUG
+	// JMS: Let's help out our testing crew.
+	// Punching debug key now toggles invincibility on/off
+	if (invincibility && ElementPtr->playerNr == 0)
+		damage = 0; 
+#endif
+
 	if (ElementPtr->state_flags & PLAYER_SHIP)
 	{
 		if (!DeltaCrew (ElementPtr, -damage))
@@ -251,7 +270,7 @@ crew_preprocess (ELEMENT *ElementPtr)
 
 	if (hTarget)
 	{
-#define CREW_DELTA SCALED_ONE
+#define CREW_DELTA (SCALED_ONE << RESOLUTION_FACTOR)
 		SIZE delta;
 		ELEMENT *ShipPtr;
 
diff -ruNp ./src.orig/uqm/oscill.c ./src/uqm/oscill.c
--- ./src.orig/uqm/oscill.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/oscill.c	2017-10-23 11:41:34 -0700
@@ -24,6 +24,7 @@
 #include "libs/graphics/drawable.h"
 #include "libs/sound/sound.h"
 #include "libs/sound/trackplayer.h"
+#include "libs/log.h"
 
 
 static FRAME scope_frame;
@@ -71,13 +72,20 @@ void
 DrawOscilloscope (void)
 {
 	STAMP s;
-	BYTE scope_data[128];
+	BYTE scope_data[192]; // JMS_GFX: was 128... FIXME:This is a hack: GraphForeGroundStream would really require this to be
+							// less than 256. This "fix" messes up how the oscilloscope looks, but it works for now
+							// (doesn't get caught in asserts). We need to fix this later.
 
+	// BW: fixed. With narrow status panel at 4x, scope width (and data) are never more than 192.
 	if (oscillDisabled)
 		return;
 
-	assert ((size_t)scopeSize.width <= sizeof scope_data);
-	assert (scopeSize.height < 256);
+	//log_add(log_Debug, "(size_t)scopeSize.width %lu, sizeof(scope_data) %lu", (size_t)scopeSize.width, sizeof(scope_data));
+	
+	assert ((size_t)scopeSize.width <= sizeof(scope_data));
+	assert (scopeSize.height < 256); // JMS_GFX: Was 256. FIXME:This is a hack: GraphForeGroundStream would really require this to be
+	// less than 256. This "fix" messes up how the oscilloscope looks, but it works for now
+	// (doesn't get caught in asserts). We need to fix this later.
 
 	if (GraphForegroundStream (scope_data, scopeSize.width, scopeSize.height))
 	{
diff -ruNp ./src.orig/uqm/outfit.c ./src/uqm/outfit.c
--- ./src.orig/uqm/outfit.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/outfit.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "options.h"
 #include "colors.h"
 #include "controls.h"
@@ -34,6 +36,8 @@
 		// for xxx_DISASTER
 #include "libs/graphics/gfx_common.h"
 
+// How manyeth .png in the module.ani file is the first lander shield.
+#define SHIELD_LOCATION_IN_MODULE_ANI (RES_CASE(5,9,9))
 
 enum
 {
@@ -55,11 +59,11 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 	OldContext = SetContext (StatusContext);
 	GetContextClipRect (&r);
 	s.origin.x = RADAR_X - r.corner.x;
-	s.origin.y = RADAR_Y - r.corner.y;
+	s.origin.y = RADAR_Y - r.corner.y - 19 * RESOLUTION_FACTOR; // JMS_GFX;
 	r.corner.x = s.origin.x - 1;
 	r.corner.y = s.origin.y - 11;
 	r.extent.width = RADAR_WIDTH + 2;
-	r.extent.height = 11;
+	r.extent.height = 11 + 20 * RESOLUTION_FACTOR; // JMS_GFX;
 	BatchGraphics ();
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
@@ -67,6 +71,7 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 	if (NewModule >= EMPTY_SLOT)
 	{
 		r.corner = s.origin;
+		r.corner.y += 19 * RESOLUTION_FACTOR; // JMS_GFX
 		r.extent.width = RADAR_WIDTH;
 		r.extent.height = RADAR_HEIGHT;
 		SetContextForeGroundColor (
@@ -80,15 +85,27 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 
 		s.frame = SetAbsFrameIndex (pMS->CurFrame, NewModule);
 		DrawStamp (&s);
-		t.baseline.x = s.origin.x + RADAR_WIDTH - 2;
-		t.baseline.y = s.origin.y + RADAR_HEIGHT - 2;
+		t.baseline.x = s.origin.x + RADAR_WIDTH - RES_STAT_SCALE(2) - RESOLUTION_FACTOR;
+		t.baseline.y = s.origin.y + RADAR_HEIGHT - RES_STAT_SCALE(2) + 14 * RESOLUTION_FACTOR; // JMS_GFX;
 		t.align = ALIGN_RIGHT;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
 		sprintf (buf, "%u", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
+
+		if ((GLOBAL_SIS (ResUnits)) > (DWORD)((GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE)))
+		{
+			sprintf (buf, "%u", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
+			SetContextForeGroundColor (
+					BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
+		}
+		else /* We don't have enough RUs to purchase this module, draw the price in red */
+		{
+			sprintf (buf, "(%u)", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
+			SetContextForeGroundColor (
+					BUILD_COLOR (MAKE_RGB15 (0x1F, 0x00, 0x00), 0x02));
+		}
+
 		SetContextFont (TinyFont);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
 		font_DrawText (&t);
 	}
 	UnbatchGraphics ();
@@ -109,7 +126,7 @@ RedistributeFuel (void)
 	GLOBAL_SIS (FuelOnBoard) = 0;
 	m = FUEL_VOLUME_PER_ROW;
 
-	r.extent.width = 3;
+	r.extent.width = (3 << RESOLUTION_FACTOR) + RES_CASE(0,2,6); // JMS_GFX
 	r.extent.height = 1;
 	while (FuelVolume -= m)
 	{
@@ -127,9 +144,8 @@ RedistributeFuel (void)
 
 	FuelVolume = GLOBAL_SIS (FuelOnBoard) + m;
 
-	r.extent.width = 5;
-	while ((GLOBAL_SIS (FuelOnBoard) += FUEL_VOLUME_PER_ROW) <
-			GetFTankCapacity (&r.corner))
+	r.extent.width = 5 << RESOLUTION_FACTOR; // JMS_GFX
+	while ((GLOBAL_SIS (FuelOnBoard) += FUEL_VOLUME_PER_ROW) < GetFTankCapacity (&r.corner))
 	{
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
@@ -139,9 +155,9 @@ RedistributeFuel (void)
 	GLOBAL_SIS (FuelOnBoard) = FuelVolume;
 }
 
-#define LANDER_X 24
-#define LANDER_Y 67
-#define LANDER_WIDTH 15
+#define LANDER_X ((24 << RESOLUTION_FACTOR) + RES_CASE(0,2,0)) // JMS_GFX
+#define LANDER_Y (67 << RESOLUTION_FACTOR) // JMS_GFX
+#define LANDER_WIDTH ((15 << RESOLUTION_FACTOR) - RES_CASE(0,2,0)) // JMS_GFX
 
 static void
 DisplayLanders (MENU_STATE *pMS)
@@ -152,7 +168,9 @@ DisplayLanders (MENU_STATE *pMS)
 	if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 3)
 	{
 		s.origin.x = s.origin.y = 0;
-		s.frame = DecFrameIndex (s.frame);
+		//s.frame = DecFrameIndex (s.frame);
+		s.frame = SetAbsFrameIndex (pMS->ModuleFrame,
+			GetFrameCount (pMS->ModuleFrame) - SHIELD_LOCATION_IN_MODULE_ANI + 4);
 		DrawStamp (&s);
 	}
 	else
@@ -485,6 +503,12 @@ DoInstallModule (MENU_STATE *pMS)
 					w = LANDER_WIDTH;
 				else
 					w = SHIP_PIECE_OFFSET;
+				
+				// JMS_GFX
+				if (NewState != PLANET_LANDER && NewState != FUSION_THRUSTER 
+					&& NewState != TURNING_JETS && NewState != EMPTY_SLOT + 0
+					 && NewState != EMPTY_SLOT + 1 && NewState != EMPTY_SLOT + 3)
+					w += RES_CASE(0,1,1);
 
 				w *= (NewItem - pMS->delta_item);
 				pMS->flash_rect0.corner.x += w;
@@ -499,35 +523,36 @@ InitFlash:
 				{
 					case PLANET_LANDER:
 					case EMPTY_SLOT + 3:
-						pMS->flash_rect0.corner.x = LANDER_X - 1;
-						pMS->flash_rect0.corner.y = LANDER_Y - 1;
-						pMS->flash_rect0.extent.width = 11 + 2;
-						pMS->flash_rect0.extent.height = 13 + 2;
+						pMS->flash_rect0.corner.x = LANDER_X - 1 + RES_CASE(0,50,114); // JMS_GFX
+						pMS->flash_rect0.corner.y = LANDER_Y - 1 + RES_CASE(0,24,65); // JMS_GFX
+						pMS->flash_rect0.extent.width = (11 + 2) << RESOLUTION_FACTOR; // JMS_GFX
+						pMS->flash_rect0.extent.height = (13 + 2) << RESOLUTION_FACTOR; // JMS_GFX;
 
 						w = LANDER_WIDTH;
 						break;
 					case FUSION_THRUSTER:
 					case EMPTY_SLOT + 0:
-						pMS->flash_rect0.corner.x = DRIVE_TOP_X - 1;
-						pMS->flash_rect0.corner.y = DRIVE_TOP_Y - 1;
-						pMS->flash_rect0.extent.width = 8;
-						pMS->flash_rect0.extent.height = 6;
+						pMS->flash_rect0.corner.x = DRIVE_TOP_X - 1 - RES_CASE(0,4,5);
+						pMS->flash_rect0.corner.y = DRIVE_TOP_Y - 1 + RES_CASE(0,69,146);
+						pMS->flash_rect0.extent.width = 8 << RESOLUTION_FACTOR; // JMS_GFX;
+						pMS->flash_rect0.extent.height = (6 << RESOLUTION_FACTOR) - RES_CASE(0,0,2); // JMS_GFX;
 
 						break;
 					case TURNING_JETS:
 					case EMPTY_SLOT + 1:
-						pMS->flash_rect0.corner.x = JET_TOP_X - 1;
-						pMS->flash_rect0.corner.y = JET_TOP_Y - 1;
-						pMS->flash_rect0.extent.width = 9;
-						pMS->flash_rect0.extent.height = 10;
-
+						pMS->flash_rect0.corner.x = JET_TOP_X - 1 - RES_CASE(0,3,3);
+						pMS->flash_rect0.corner.y = JET_TOP_Y - 1 + RES_CASE(0,90,185);
+						pMS->flash_rect0.extent.width = 9 << RESOLUTION_FACTOR; // JMS_GFX;
+						pMS->flash_rect0.extent.height = (10 << RESOLUTION_FACTOR) + RES_CASE(0,0,4); // JMS_GFX;
+						
 						break;
 					default:
-						pMS->flash_rect0.corner.x = MODULE_TOP_X - 1;
+						pMS->flash_rect0.corner.x = MODULE_TOP_X - 1 + RES_CASE(0,0,2);
 						pMS->flash_rect0.corner.y = MODULE_TOP_Y - 1;
-						pMS->flash_rect0.extent.width = SHIP_PIECE_OFFSET + 2;
-						pMS->flash_rect0.extent.height = 34;
-
+						pMS->flash_rect0.extent.width = SHIP_PIECE_OFFSET + 2 - RES_CASE(0,1,1);
+						pMS->flash_rect0.extent.height = (34 << RESOLUTION_FACTOR) + RES_CASE(0,0,9); // JMS_GFX;
+						w += RES_CASE(0,1,1);
+						
 						break;
 				}
 
@@ -564,7 +589,7 @@ ChangeFuelQuantity (void)
 		{
 			if (GLOBAL_SIS (FuelOnBoard) >= FUEL_RESERVE)
 			{
-				r.extent.width = 3;
+				r.extent.width = (3 << RESOLUTION_FACTOR) + RES_CASE(0,2,6); // JMS_GFX
 				DrawPoint (&r.corner);
 				r.corner.x += r.extent.width + 1;
 				DrawPoint (&r.corner);
@@ -591,14 +616,23 @@ ChangeFuelQuantity (void)
 		if (GLOBAL_SIS (FuelOnBoard))
 		{
 			DeltaSISGauges (0, -FUEL_TANK_SCALE, GLOBAL (FuelCost));
-			if (GLOBAL_SIS (FuelOnBoard) % FUEL_VOLUME_PER_ROW == 0 &&
+			
+			if ((((GLOBAL_SIS (FuelOnBoard) % FUEL_VOLUME_PER_ROW == 0) && RESOLUTION_FACTOR == 0)
+				  || (RESOLUTION_FACTOR > 0)) 
+					&&
 					GLOBAL_SIS (FuelOnBoard) >= FUEL_RESERVE)
 			{
 				GetFTankCapacity (&r.corner);
-				SetContextForeGroundColor (
-						BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
-				r.extent.width = 5;
+				SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
+				r.extent.width = (5 << RESOLUTION_FACTOR);// JMS_GFX
 				DrawFilledRectangle (&r);
+				
+				// JMS_GFX: Crude fix to remove intermittent residual fuel lines left hanging mid-tank.
+				if (RESOLUTION_FACTOR == 2)
+				{
+					r.corner.y -= 1;
+					DrawFilledRectangle (&r);
+				}
 			}
 		}
 		else
@@ -619,7 +653,7 @@ onNamingDone (void)
 	LockMutex (GraphicsLock);
 	DrawFlagshipName (FALSE);
 	UnlockMutex (GraphicsLock);
-}
+} 
 
 BOOLEAN
 DoOutfit (MENU_STATE *pMS)
@@ -696,7 +730,7 @@ DoOutfit (MENU_STATE *pMS)
 				ShieldFlags = GET_GAME_STATE (LANDER_SHIELDS);
 
 				s.frame = SetAbsFrameIndex (pMS->ModuleFrame,
-						GetFrameCount (pMS->ModuleFrame) - 5);
+						GetFrameCount (pMS->ModuleFrame) - SHIELD_LOCATION_IN_MODULE_ANI);
 				if (ShieldFlags & (1 << EARTHQUAKE_DISASTER))
 					DrawStamp (&s);
 				s.frame = IncFrameIndex (s.frame);
diff -ruNp ./src.orig/uqm/pickship.c ./src/uqm/pickship.c
--- ./src.orig/uqm/pickship.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/pickship.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "pickship.h"
 
 #include "build.h"
@@ -37,13 +39,13 @@
 #define NUM_PICK_SHIP_ROWS 2
 #define NUM_PICK_SHIP_COLUMNS 6
 
-#define ICON_WIDTH 16
-#define ICON_HEIGHT 16
+#define ICON_WIDTH (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define ICON_HEIGHT (16 << RESOLUTION_FACTOR) // JMS_GFX
 
-#define FLAGSHIP_X_OFFS 65
-#define FLAGSHIP_Y_OFFS 4
-#define FLAGSHIP_WIDTH 22
-#define FLAGSHIP_HEIGHT 48
+#define FLAGSHIP_X_OFFS (65 << RESOLUTION_FACTOR) // JMS_GFX
+#define FLAGSHIP_Y_OFFS (4 << RESOLUTION_FACTOR) // JMS_GFX
+#define FLAGSHIP_WIDTH (22 << RESOLUTION_FACTOR) // JMS_GFX
+#define FLAGSHIP_HEIGHT (48 << RESOLUTION_FACTOR) // JMS_GFX
 
 static BOOLEAN
 DoPickBattleShip (MENU_STATE *pMS)
@@ -120,9 +122,9 @@ ChangeSelection:
 			if (pMS->first_item.x == (NUM_PICK_SHIP_COLUMNS >> 1))
 			{
 				pMS->flash_rect0.corner.x =
-						pMS->flash_rect1.corner.x - 2 + FLAGSHIP_X_OFFS;
+					pMS->flash_rect1.corner.x - 2 + FLAGSHIP_X_OFFS;
 				pMS->flash_rect0.corner.y =
-						pMS->flash_rect1.corner.y - 2 + FLAGSHIP_Y_OFFS;
+					pMS->flash_rect1.corner.y - 2 + FLAGSHIP_Y_OFFS;
 				pMS->flash_rect0.extent.width = FLAGSHIP_WIDTH + 4;
 				pMS->flash_rect0.extent.height = FLAGSHIP_HEIGHT + 4;
 
@@ -131,15 +133,15 @@ ChangeSelection:
 			else
 			{
 				new_col = pMS->first_item.x;
-				pMS->flash_rect0.corner.x = 5 + pMS->flash_rect1.corner.x - 2
-						+ ((ICON_WIDTH + 4) * new_col);
+				pMS->flash_rect0.corner.x = (5 << RESOLUTION_FACTOR) + pMS->flash_rect1.corner.x - 2
+					+ ((ICON_WIDTH + (4 << RESOLUTION_FACTOR)) * new_col); // JMS_GFX
 				if (new_col > (NUM_PICK_SHIP_COLUMNS >> 1))
 				{
 					--new_col;
 					pMS->flash_rect0.corner.x += FLAGSHIP_WIDTH - ICON_WIDTH;
 				}
-				pMS->flash_rect0.corner.y = 16 + pMS->flash_rect1.corner.y - 2
-						+ ((ICON_HEIGHT + 4) * pMS->first_item.y);
+				pMS->flash_rect0.corner.y = (16 << RESOLUTION_FACTOR) + pMS->flash_rect1.corner.y - 2
+					+ ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR)) * pMS->first_item.y); // JMS_GFX
 				pMS->flash_rect0.extent.width = ICON_WIDTH + 4;
 				pMS->flash_rect0.extent.height = ICON_HEIGHT + 4;
 
@@ -169,10 +171,10 @@ ChangeSelection:
 			pMS->CurFrame = (FRAME)hBattleShip;
 
 			SetContextForeGroundColor (BLACK_COLOR);
-			r.corner.x = pMS->flash_rect1.corner.x + 6;
-			r.corner.y = pMS->flash_rect1.corner.y + 5;
-			r.extent.width = ((ICON_WIDTH + 4) * 3) - 4;
-			r.extent.height = 7;
+			r.corner.x = pMS->flash_rect1.corner.x + (6 << RESOLUTION_FACTOR) - 2*RESOLUTION_FACTOR; // JMS_GFX
+			r.corner.y = pMS->flash_rect1.corner.y + (5 << RESOLUTION_FACTOR) - 2*RESOLUTION_FACTOR; // JMS_GFX
+			r.extent.width = ((ICON_WIDTH + (4 << RESOLUTION_FACTOR)) * 3) - (4 << RESOLUTION_FACTOR) + 2*RESOLUTION_FACTOR;  // JMS_GFX
+			r.extent.height = 7 << RESOLUTION_FACTOR; // JMS_GFX
 			DrawFilledRectangle (&r);
 
 			if (hBattleShip == 0)
@@ -186,7 +188,7 @@ ChangeSelection:
 				SetContextFont (TinyFont);
 
 				t.baseline.x = r.corner.x + (r.extent.width >> 1);
-				t.baseline.y = r.corner.y + (r.extent.height - 1);
+				t.baseline.y = r.corner.y + (r.extent.height - (1 << RESOLUTION_FACTOR)) - 2*RESOLUTION_FACTOR; // JMS_GFX
 				t.align = ALIGN_CENTER;
 
 				StarShipPtr = LockStarShip (&race_q[0], hBattleShip);
@@ -217,9 +219,10 @@ ChangeSelection:
 				SetContextForeGroundColor (BLACK_COLOR);
 			}
 
-			r.corner.x += (ICON_WIDTH + 4)
-					* ((NUM_PICK_SHIP_COLUMNS >> 1) + 1)
-					+ FLAGSHIP_WIDTH - ICON_WIDTH;
+			r.extent.width -= 2*RESOLUTION_FACTOR; // JMS_GFX
+			r.corner.x += (ICON_WIDTH + (4 << RESOLUTION_FACTOR))
+				* ((NUM_PICK_SHIP_COLUMNS >> 1) + 1)
+					+ FLAGSHIP_WIDTH - ICON_WIDTH; // JMS_GFX
 			DrawFilledRectangle (&r);
 
 			if (crew_level)
@@ -393,7 +396,7 @@ GetEncounterStarShip (STARSHIP *LastStar
 void
 DrawArmadaPickShip (BOOLEAN draw_salvage_frame, RECT *pPickRect)
 {
-#define PICK_NAME_HEIGHT 6
+#define PICK_NAME_HEIGHT (6 << RESOLUTION_FACTOR); // JMS_GFX
 	//COUNT i;
 	HSTARSHIP hBattleShip, hNextShip;
 	STARSHIP *StarShipPtr;
@@ -438,7 +441,8 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 	DrawStamp (&s);
 
 	t.baseline.x = pick_r.corner.x + (pick_r.extent.width >> 1);
-	t.baseline.y = pick_r.corner.y + pick_r.extent.height - 5;
+	t.baseline.y = pick_r.corner.y + pick_r.extent.height - (5 << RESOLUTION_FACTOR) - 2 * RESOLUTION_FACTOR; // JMS_GFX
+	
 	t.align = ALIGN_CENTER;
 	t.pStr = GLOBAL_SIS (ShipName);
 	t.CharCount = (COUNT)~0;
@@ -461,14 +465,14 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 			ship_index = StarShipPtr->index;
 
 			s.origin.x = pick_r.corner.x
-					+ (5 + ((ICON_WIDTH + 4)
-					* (ship_index % NUM_PICK_SHIP_COLUMNS)));
+				+ ((5 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (4 << RESOLUTION_FACTOR))
+				       * (ship_index % NUM_PICK_SHIP_COLUMNS))); // JMS_GFX
 			if ((ship_index % NUM_PICK_SHIP_COLUMNS) >=
 					(NUM_PICK_SHIP_COLUMNS >> 1))
-				s.origin.x += FLAGSHIP_WIDTH + 4;
+				s.origin.x += FLAGSHIP_WIDTH + (4 << RESOLUTION_FACTOR); // JMS_GFX
 			s.origin.y = pick_r.corner.y
-					+ (16 + ((ICON_HEIGHT + 4)
-					* (ship_index / NUM_PICK_SHIP_COLUMNS)));
+				+ ((16 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR))
+					* (ship_index / NUM_PICK_SHIP_COLUMNS))); // JMS_GFX
 			s.frame = StarShipPtr->icons;
 			r.corner = s.origin;
 			SetContextForeGroundColor (BLACK_COLOR);
@@ -479,7 +483,12 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 				if (StarShipPtr->SpeciesID == NO_ID)
 				{
 					/* Dead ship - mark with an X. */
-					s.origin.x -= 1;
+					s.origin.x -= (1 << RESOLUTION_FACTOR); // JMS_GFX
+					
+					// JMS_GFX
+					if (RESOLUTION_FACTOR > 0)
+						s.origin.y -= (1 << RESOLUTION_FACTOR);
+					
 					s.frame = SetAbsFrameIndex (StatusFrame, 3);
 					DrawStamp (&s);
 				}
diff -ruNp ./src.orig/uqm/plandata.c ./src/uqm/plandata.c
--- ./src.orig/uqm/plandata.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/plandata.c	2017-10-23 11:41:34 -0700
@@ -18,6 +18,7 @@
 
 // XXX: for XXX_DEFINED constants
 #include "encount.h"
+#include "hyper.h" // JMS: For ARILOU_HOME_X and Y
 #include "resinst.h"
 #include "planets/planets.h"
 #include "planets/elemdata.h"
@@ -306,7 +307,7 @@ STAR_DESC starmap_array[] =
 	{{9062, 5083}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 3, 67},
 	{{7416, 5083}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), RAINBOW_DEFINED, 3, 68},
 	{{5155, 5122}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 2, 11},
-	{{3875, 5145}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 4, 17},
+	{{3875, 5145}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), ZOQ_COLONY0_DEFINED, 4, 17},
 	{{4937, 5145}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 1, 11},
 	{{2979, 5166}, MAKE_STAR (GIANT_STAR, ORANGE_BODY, -1), 0, 1, 15},
 	{{3035, 5178}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 15},
@@ -325,7 +326,7 @@ STAR_DESC starmap_array[] =
 	{{3416, 5437}, MAKE_STAR (DWARF_STAR, BLUE_BODY, -1), 0, 2, 16},
 	{{4000, 5437}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ZOQFOT_DEFINED, 1, 18},
 	{{6270, 5479}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 2, 102},
-	{{3583, 5479}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), 0, 3, 16},
+	{{3583, 5479}, MAKE_STAR (DWARF_STAR, GREEN_BODY, -1), ZOQ_COLONY1_DEFINED, 3, 16},
 	{{4083, 5513}, MAKE_STAR (DWARF_STAR, RED_BODY, -1), 0, 3, 18},
 	{{2159, 5614}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 6, 55},
 	{{3937, 5625}, MAKE_STAR (DWARF_STAR, ORANGE_BODY, -1), 0, 2, 18},
@@ -538,37 +539,37 @@ STAR_DESC starmap_array[] =
 	// QuasiSpace locations
 #define VORTEX_SCALE 20
 	{{(-12* VORTEX_SCALE) + 5000, (-21 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 133},
 	{{( 1 * VORTEX_SCALE) + 5000, (-20 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 134},
 	{{(-16 * VORTEX_SCALE) + 5000, (-18 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 135},
 	{{( 8 * VORTEX_SCALE) + 5000, (-17 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 136},
 	{{( 3 * VORTEX_SCALE) + 5000, (-13 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 137},
 	{{(-21 * VORTEX_SCALE) + 5000, (-4 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 138},
 	{{(-4 * VORTEX_SCALE) + 5000, (-4 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 139},
 	{{(-12 * VORTEX_SCALE) + 5000, (-2 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 140},
 	{{(-26 * VORTEX_SCALE) + 5000, (2 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 141},
 	{{(-17 * VORTEX_SCALE) + 5000, (7 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 142},
 	{{(10 * VORTEX_SCALE) + 5000, (7 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 143},
 	{{(15 * VORTEX_SCALE) + 5000, (14 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 144},
 	{{(22 * VORTEX_SCALE) + 5000, (16 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 145},
 	{{(-6 * VORTEX_SCALE) + 5000, (19 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 146},
 	{{(10 * VORTEX_SCALE) + 5000, (20 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 147},
 
-	{{6134, 5900}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 0, 132},
+	{{ARILOU_HOME_X, ARILOU_HOME_Y}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 0, 148},
 
 	{{MAX_X_UNIVERSE << 1, MAX_Y_UNIVERSE << 1}, 0, 0, 0, 0},
 };
@@ -1179,6 +1180,25 @@ const PlanetFrame planet_array[NUMBER_OF
 		DUST_XLAT_TAB,
 		250, 2, 80, 200,
 	},
+	// 	{ /* EARTH_WORLD */
+	// 	MAKE_BYTE (LARGE_ROCKY_WORLD + CRATERED_ALGO,
+	// 			BLUE_BODY), /* Color and type/size of planet */
+	// 	LOW_TECTONICS, /* Tectonics - Scaled with Earth at 82    */
+	// 	MAKE_BYTE (NORMAL_DENSITY, MEDIUM), /* Atmosphere and density */
+	// 	{
+	// 		{IRON, LIGHT_USEFUL},
+	// 		{ALUMINUM, LIGHT_USEFUL},
+	// 		{TIN, LIGHT_USEFUL},
+	// 		{LEAD, LIGHT_USEFUL},
+	// 		{URANIUM, TRACE_USEFUL},
+	// 		{MOLYBDENUM, TRACE_USEFUL},
+	// 		{NOTHING, NO_DEPOSIT},
+	// 		{NOTHING, NO_DEPOSIT},
+	// 	},
+	// 	WATER_COLOR_TAB,
+	// 	WATER_XLAT_TAB,
+	// 	500, 1, 0, 190,
+	// },	
 	{ /* CRIMSON_WORLD */
 		MAKE_BYTE (SMALL_ROCKY_WORLD + CRATERED_ALGO,
 				RED_BODY), /* Color and type/size of planet */
diff -ruNp ./src.orig/uqm/planets/calc.c ./src/uqm/planets/calc.c
--- ./src.orig/uqm/planets/calc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/calc.c	2017-10-23 11:41:34 -0700
@@ -201,14 +201,19 @@ CalcTemp (SYSTEM_INFO *SysInfoPtr, SIZE
 }
 
 static COUNT
-CalcRotation (PLANET_INFO *PlanetInfoPtr)
+CalcRotation (PLANET_INFO *PlanetInfoPtr, PLANET_DESC *planet)
 {
+	COUNT period;
 	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT)
-		return ((COUNT)CalcFromBase (80, 80));
+		period = ((COUNT)CalcFromBase (80, 80));
 	else if (((BYTE)TFB_Random () % 10) == 0)
-		return ((COUNT)CalcFromBase ((UWORD)50 * 240, (UWORD)200 * 240));
+		period = ((COUNT)CalcFromBase ((UWORD)50 * 240, (UWORD)200 * 240));
 	else
-		return ((COUNT)CalcFromBase (150, 150));
+		period = ((COUNT)CalcFromBase (150, 150));
+	// BW 2011: Research shows that most major moons have a synchronous rotation
+	if (planet->pPrevDesc != pSolarSysState->SunDesc)
+		period = ((COUNT)(FULL_CIRCLE * 240 / planet->orb_speed));
+	return period;
 }
 
 static SIZE
@@ -324,7 +329,7 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 				break;
 		}
 
-		SysInfoPtr->PlanetInfo.RotationPeriod = CalcRotation (&SysInfoPtr->PlanetInfo);
+		SysInfoPtr->PlanetInfo.RotationPeriod = CalcRotation (&SysInfoPtr->PlanetInfo, pPlanetDesc);
 		SysInfoPtr->PlanetInfo.SurfaceGravity =
 				CalcGravity (SysInfoPtr->PlanetInfo.PlanetDensity,
 				SysInfoPtr->PlanetInfo.PlanetRadius);
diff -ruNp ./src.orig/uqm/planets/cargo.c ./src/uqm/planets/cargo.c
--- ./src.orig/uqm/planets/cargo.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/cargo.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "../colors.h"
 #include "../controls.h"
 #include "../gamestr.h"
@@ -30,20 +32,20 @@
 		// for GetFrameBounds()
 
 
-#define ELEMENT_ORG_Y      35
+#define ELEMENT_ORG_Y      RES_STAT_SCALE(35) // JMS_GFX
 #define FREE_ORG_Y         (ELEMENT_ORG_Y + (NUM_ELEMENT_CATEGORIES \
 							* ELEMENT_SPACING_Y))
-#define BIO_ORG_Y          119
-#define ELEMENT_SPACING_Y  9
+#define BIO_ORG_Y          RES_STAT_SCALE(119) // JMS_GFX
+#define ELEMENT_SPACING_Y  RES_STAT_SCALE(9) // JMS_GFX
 
-#define ELEMENT_COL_0      7
-#define ELEMENT_COL_1      32
-#define ELEMENT_COL_2      58
+#define ELEMENT_COL_0      RES_STAT_SCALE(7) // JMS_GFX
+#define ELEMENT_COL_1      RES_STAT_SCALE(32) // JMS_GFX
+#define ELEMENT_COL_2      RES_STAT_SCALE(58) // JMS_GFX
 
-#define ELEMENT_SEL_ORG_X  (ELEMENT_COL_0 + 7 + 5)
-#define ELEMENT_SEL_WIDTH  (ELEMENT_COL_2 - ELEMENT_SEL_ORG_X + 1)
+#define ELEMENT_SEL_ORG_X  (ELEMENT_COL_0 + RES_STAT_SCALE(7 + 5)) // JMS_GFX
+#define ELEMENT_SEL_WIDTH  (ELEMENT_COL_2 - ELEMENT_SEL_ORG_X + RES_STAT_SCALE(1)) // JMS_GFX
 
-#define TEXT_BASELINE      6
+#define TEXT_BASELINE      RES_STAT_SCALE(6) // JMS_GFX
 
 
 void
@@ -57,19 +59,19 @@ ShowRemainingCapacity (void)
 	OldContext = SetContext (StatusContext);
 	SetContextFont (TinyFont);
 
-	r.corner.x = 40;
+	r.corner.x = RES_STAT_SCALE(40); // JMS_GFX
 	r.corner.y = FREE_ORG_Y;
 
 	snprintf (buf, sizeof buf, "%u",
 			GetStorageBayCapacity () - GLOBAL_SIS (TotalElementMass));
-	t.baseline.x = ELEMENT_COL_2 + 1;
+	t.baseline.x = ELEMENT_COL_2 + RES_STAT_SCALE(1); // JMS_GFX
 	t.baseline.y = r.corner.y + TEXT_BASELINE;
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
-	r.extent.width = t.baseline.x - r.corner.x + 1;
-	r.extent.height = ELEMENT_SPACING_Y - 2;
+	r.extent.width = t.baseline.x - r.corner.x + RES_STAT_SCALE(1); // JMS_GFX
+	r.extent.height = ELEMENT_SPACING_Y - RES_STAT_SCALE(2); // JMS_GFX
 
 	BatchGraphics ();
 	// erase previous free amount
@@ -92,7 +94,7 @@ DrawElementAmount (COUNT element, bool s
 
 	r.corner.x = ELEMENT_SEL_ORG_X;
 	r.extent.width = ELEMENT_SEL_WIDTH;
-	r.extent.height = ELEMENT_SPACING_Y - 2;
+	r.extent.height = ELEMENT_SPACING_Y - RES_STAT_SCALE(2); // JMS_GFX
 
 	if (element == NUM_ELEMENT_CATEGORIES)
 		r.corner.y = BIO_ORG_Y;
@@ -142,20 +144,20 @@ DrawCargoDisplay (void)
 	COORD cy;
 	COUNT i;
 
-	r.corner.x = 2;
-	r.extent.width = FIELD_WIDTH + 1;
-	r.corner.y = 20;
+	r.corner.x = RES_CASE(2,2,3); // JMS_GFX
+	r.corner.y = RES_STAT_SCALE(20) - RES_CASE(0,1,0); // JMS_GFX
+	r.extent.width = FIELD_WIDTH + 1; // JMS_GFX
 	// XXX: Shouldn't the height be 1 less? This draws the bottom border
 	//   1 pixel too low. Or if not, why do we need another box anyway?
-	r.extent.height = 129 - r.corner.y;
+	r.extent.height = RES_STAT_SCALE(129) - r.corner.y + RES_CASE(0,6,19); // JMS_GFX
 	DrawStarConBox (&r, 1,
 			SHADOWBOX_MEDIUM_COLOR, SHADOWBOX_DARK_COLOR,
 			TRUE, CARGO_BACK_COLOR);
 
 	// draw the "CARGO" title
 	SetContextFont (StarConFont);
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = 27;
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_STAT_SCALE(1); // JMS_GFX
+	t.baseline.y = RES_STAT_SCALE(27); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GAME_STRING (CARGO_STRING_BASE);
 	t.CharCount = (COUNT)~0;
@@ -166,15 +168,20 @@ DrawCargoDisplay (void)
 
 	s.frame = SetAbsFrameIndex (MiscDataFrame,
 			(NUM_SCANDOT_TRANSITIONS * 2) + 3);
+	if (RESOLUTION_FACTOR == 2)
+		s.frame = SetRelFrameIndex (s.frame, -1); // JMS_GFX
+	
 	r.corner.x = ELEMENT_COL_0;
 	r.extent = GetFrameBounds (s.frame);
-	s.origin.x = r.corner.x + (r.extent.width >> 1);
+	r.extent.width -= RES_CASE(0,5,7); // JMS_GFX
+	r.extent.height -= RES_CASE(0,5,8); // JMS_GFX
+	s.origin.x = r.corner.x + (r.extent.width >> 1) - RES_CASE(0,1,4); // JMS_GFX
 
 	cy = ELEMENT_ORG_Y;
 
 	// print element column headings
 	t.align = ALIGN_RIGHT;
-	t.baseline.y = cy - 1;
+	t.baseline.y = cy - RES_STAT_SCALE(1); // JMS_GFX
 	t.CharCount = (COUNT)~0;
 
 	SetContextForeGroundColor (CARGO_WORTH_COLOR);
@@ -195,7 +202,7 @@ DrawCargoDisplay (void)
 		DrawFilledRectangle (&r);
 
 		// draw an element icon
-		s.origin.y = r.corner.y + (r.extent.height >> 1);
+		s.origin.y = r.corner.y + (r.extent.height >> 1) - RES_CASE(0,1,5);
 		DrawStamp (&s);
 		s.frame = SetRelFrameIndex (s.frame, 5);
 
@@ -216,15 +223,15 @@ DrawCargoDisplay (void)
 	DrawElementAmount (NUM_ELEMENT_CATEGORIES, false);
 
 	// draw the line over the Bio amount
-	r.corner.x = 4;
-	r.corner.y = BIO_ORG_Y - 2;
-	r.extent.width = FIELD_WIDTH - 3;
+	r.corner.x = RES_STAT_SCALE(4); // JMS_GFX
+	r.corner.y = BIO_ORG_Y - RES_STAT_SCALE(2); // JMS_GFX
+	r.extent.width = FIELD_WIDTH - RES_CASE(3,10,17); // JMS_GFX
 	r.extent.height = 1;
 	SetContextForeGroundColor (CARGO_SELECTED_BACK_COLOR);
 	DrawFilledRectangle (&r);
 
 	// print "Free"
-	t.baseline.x = 5;
+	t.baseline.x = RES_STAT_SCALE(5); // JMS_GFX
 	t.baseline.y = FREE_ORG_Y + TEXT_BASELINE;
 	t.align = ALIGN_LEFT;
 	t.pStr = GAME_STRING (CARGO_STRING_BASE + 1);
diff -ruNp ./src.orig/uqm/planets/devices.c ./src/uqm/planets/devices.c
--- ./src.orig/uqm/planets/devices.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/devices.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "../build.h"
 #include "../colors.h"
 #include "../encount.h"
@@ -36,31 +38,32 @@
 #include "planets.h"
 		// for SaveSolarSysLocation() and tests
 #include "libs/strlib.h"
-
+#include "libs/graphics/gfx_common.h"
+                // for scaling down devices in 4x
 
 // If DEBUG_DEVICES is defined, the device list shown in the game will
 // include the pictures of all devices defined, regardless of which
 // devices the player actually possesses.
 //#define DEBUG_DEVICES
 
-#define DEVICE_ICON_WIDTH  16
-#define DEVICE_ICON_HEIGHT 16
+#define DEVICE_ICON_WIDTH  RES_STAT_SCALE(16) // JMS_GFX
+#define DEVICE_ICON_HEIGHT RES_STAT_SCALE(16) // JMS_GFX
 
-#define DEVICE_ORG_Y       33
-#define DEVICE_SPACING_Y   (DEVICE_ICON_HEIGHT + 2)
+#define DEVICE_ORG_Y       RES_STAT_SCALE(33) // JMS_GFX
+#define DEVICE_SPACING_Y   (DEVICE_ICON_HEIGHT + RES_STAT_SCALE(2)) // JMS_GFX
 
-#define DEVICE_COL_0       4
-#define DEVICE_COL_1       40
+#define DEVICE_COL_0       RES_STAT_SCALE(4) // JMS_GFX
+#define DEVICE_COL_1       RES_STAT_SCALE(40) // JMS_GFX
 
 #define DEVICE_SEL_ORG_X  (DEVICE_COL_0 + DEVICE_ICON_WIDTH)
-#define DEVICE_SEL_WIDTH  (FIELD_WIDTH + 1 - DEVICE_SEL_ORG_X + 1)
+#define DEVICE_SEL_WIDTH  (FIELD_WIDTH + RES_CASE(2,0,6) - DEVICE_SEL_ORG_X) // JMS_GFX
 
-#define ICON_OFS_Y         1
-#define NAME_OFS_Y         2
-#define TEXT_BASELINE      6
-#define TEXT_SPACING_Y     7
+#define ICON_OFS_Y         RES_CASE(1,4,11) // JMS_GFX
+#define NAME_OFS_Y         RES_STAT_SCALE(2) // JMS_GFX
+#define TEXT_BASELINE      RES_STAT_SCALE(6) // JMS_GFX
+#define TEXT_SPACING_Y     RES_STAT_SCALE(7) // JMS_GFX
 
-#define MAX_VIS_DEVICES    ((129 - DEVICE_ORG_Y) / DEVICE_SPACING_Y)
+#define MAX_VIS_DEVICES    ((RES_STAT_SCALE(129) - DEVICE_ORG_Y) / DEVICE_SPACING_Y) // JMS_GFX
 
 
 typedef enum
@@ -87,8 +90,8 @@ EraseDevicesBackground (void)
 {
 	RECT r;
 
-	r.corner.x = 2 + 1;
-	r.extent.width = FIELD_WIDTH + 1 - 2;
+	r.corner.x = RES_STAT_SCALE(2 + 1); // JMS_GFX
+	r.extent.width = FIELD_WIDTH - RES_STAT_SCALE(1); // JMS_GFX
 	r.corner.y = DEVICE_ORG_Y;
 	r.extent.height = MAX_VIS_DEVICES * DEVICE_SPACING_Y;
 	SetContextForeGroundColor (DEVICES_BACK_COLOR);
@@ -106,8 +109,8 @@ DrawDevice (COUNT device, COUNT pos, boo
 	t.baseline.x = DEVICE_COL_1;
 
 	r.extent.width = DEVICE_SEL_WIDTH;
-	r.extent.height = TEXT_SPACING_Y * 2;
-	r.corner.x = DEVICE_SEL_ORG_X;
+	r.extent.height = (TEXT_SPACING_Y * 2) + RES_CASE(0,4,0);
+	r.corner.x = DEVICE_SEL_ORG_X - RES_CASE(0,0,8);
 
 	// draw line background
 	r.corner.y = DEVICE_ORG_Y + pos * DEVICE_SPACING_Y + NAME_OFS_Y;
@@ -139,20 +142,20 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 	COORD cy;
 	COUNT i;
 
-	r.corner.x = 2;
-	r.corner.y = 20;
-	r.extent.width = FIELD_WIDTH + 1;
+	r.corner.x = RES_CASE(2,2,3); // JMS_GFX
+	r.corner.y = RES_STAT_SCALE(20) - RES_CASE(0,1,0); // JMS_GFX
+	r.extent.width = FIELD_WIDTH + 1; // JMS_GFX
 	// XXX: Shouldn't the height be 1 less? This draws the bottom border
 	//   1 pixel too low. Or if not, why do we need another box anyway?
-	r.extent.height = 129 - r.corner.y;
+	r.extent.height = RES_STAT_SCALE(129) - r.corner.y + RES_CASE(0,6,19); // JMS_GFX
 	DrawStarConBox (&r, 1,
 			SHADOWBOX_MEDIUM_COLOR, SHADOWBOX_DARK_COLOR,
 			TRUE, DEVICES_BACK_COLOR);
 
 	// print the "DEVICES" title
 	SetContextFont (StarConFont);
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = r.corner.y + 7;
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_STAT_SCALE(1); // JMS_GFX
+	t.baseline.y = r.corner.y + RES_STAT_SCALE(7); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GAME_STRING (DEVICE_STRING_BASE);
 	t.CharCount = (COUNT)~0;
@@ -174,8 +177,20 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 		s.origin.y = cy + ICON_OFS_Y;
 		s.frame = SetAbsFrameIndex (MiscDataFrame,
 				77 + devState->list[devIndex]);
-		DrawStamp (&s);
-
+		if (RESOLUTION_FACTOR < 2)
+		{
+			DrawStamp (&s);			
+		}
+		else
+		{
+			int oldMode, oldScale;
+			oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
+			oldScale = SetGraphicScale ((int)(GSCALE_IDENTITY / 2));
+			DrawStamp (&s);
+			SetGraphicScale (oldScale);
+			SetGraphicScaleMode (oldMode);
+		}
+		
 		DrawDevice (devState->list[devIndex], i, false);
 	}
 }
diff -ruNp ./src.orig/uqm/planets/generate/Makeinfo ./src/uqm/planets/generate/Makeinfo
--- ./src.orig/uqm/planets/generate/Makeinfo	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/Makeinfo	2017-10-23 11:41:34 -0700
@@ -2,4 +2,4 @@ uqm_CFILES="gendefault.c genand.c genbur
 		genilw.c genmel.c genmyc.c genorz.c genpet.c genpku.c genrain.c
 		gensam.c genshof.c gensly.c gensol.c genspa.c gensup.c gensyr.c
 		genthrad.c gentrap.c genutw.c genvault.c genvux.c genwreck.c
-		genyeh.c genzfpscout.c genzoq.c"
+		genyeh.c genzfpscout.c genzoq.c genzoqcolony.c"
diff -ruNp ./src.orig/uqm/planets/generate/genand.c ./src/uqm/planets/generate/genand.c
--- ./src.orig/uqm/planets/generate/genand.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genand.c	2017-10-23 11:41:34 -0700
@@ -68,6 +68,7 @@ GenerateAndrosynth_generatePlanets (SOLA
 			COSINE (angle, solarSys->PlanetDesc[1].radius);
 	solarSys->PlanetDesc[1].location.y =
 			SINE (angle, solarSys->PlanetDesc[1].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[1], FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/genburv.c ./src/uqm/planets/generate/genburv.c
--- ./src.orig/uqm/planets/generate/genburv.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genburv.c	2017-10-23 11:41:34 -0700
@@ -69,6 +69,7 @@ GenerateBurvixese_generatePlanets (SOLAR
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	return true;
 }
 
@@ -91,6 +92,7 @@ GenerateBurvixese_generateMoons (SOLARSY
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/genchmmr.c ./src/uqm/planets/generate/genchmmr.c
--- ./src.orig/uqm/planets/generate/genchmmr.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genchmmr.c	2017-10-23 11:41:34 -0700
@@ -83,6 +83,7 @@ GenerateChmmr_generateMoons (SOLARSYS_ST
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp ./src.orig/uqm/planets/generate/gencol.c ./src/uqm/planets/generate/gencol.c
--- ./src.orig/uqm/planets/generate/gencol.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/gencol.c	2017-10-23 11:41:34 -0700
@@ -97,6 +97,8 @@ GenerateColony_generatePlanets (SOLARSYS
 	pMinPlanet->location.x = COSINE (angle, pMinPlanet->radius);
 	pMinPlanet->location.y = SINE (angle, pMinPlanet->radius);
 	pMinPlanet->data_index = WATER_WORLD | PLANET_SHIELDED;
+	pMinPlanet->alternate_colormap = NULL;
+	ComputeSpeed(pMinPlanet, FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/gendru.c ./src/uqm/planets/generate/gendru.c
--- ./src.orig/uqm/planets/generate/gendru.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/gendru.c	2017-10-23 11:41:34 -0700
@@ -69,6 +69,7 @@ GenerateDruuge_generatePlanets (SOLARSYS
 	++solarSys->SunDesc[0].NumPlanets;
 
 	solarSys->PlanetDesc[0].data_index = DUST_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 50L / 100;
 	solarSys->PlanetDesc[0].NumPlanets = 0;
 	angle = HALF_CIRCLE - OCTANT;
@@ -79,6 +80,7 @@ GenerateDruuge_generatePlanets (SOLARSYS
 	solarSys->PlanetDesc[0].rand_seed = MAKE_DWORD (
 			solarSys->PlanetDesc[0].location.x,
 			solarSys->PlanetDesc[0].location.y);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/genilw.c ./src/uqm/planets/generate/genilw.c
--- ./src.orig/uqm/planets/generate/genilw.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genilw.c	2017-10-23 11:41:34 -0700
@@ -69,6 +69,7 @@ GenerateIlwrath_generatePlanets (SOLARSY
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/genmyc.c ./src/uqm/planets/generate/genmyc.c
--- ./src.orig/uqm/planets/generate/genmyc.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genmyc.c	2017-10-23 11:41:34 -0700
@@ -77,6 +77,7 @@ GenerateMycon_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/genorz.c ./src/uqm/planets/generate/genorz.c
--- ./src.orig/uqm/planets/generate/genorz.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genorz.c	2017-10-23 11:41:34 -0700
@@ -66,6 +66,7 @@ GenerateOrz_generatePlanets (SOLARSYS_ST
 	if (CurStarDescPtr->Index == ORZ_DEFINED)
 	{
 		solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 156L / 100;
 		solarSys->PlanetDesc[0].NumPlanets = 0;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -74,6 +75,7 @@ GenerateOrz_generatePlanets (SOLARSYS_ST
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 
 	return true;
diff -ruNp ./src.orig/uqm/planets/generate/genpet.c ./src/uqm/planets/generate/genpet.c
--- ./src.orig/uqm/planets/generate/genpet.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genpet.c	2017-10-23 11:41:34 -0700
@@ -72,6 +72,7 @@ GenerateTalkingPet_generatePlanets (SOLA
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/genpku.c ./src/uqm/planets/generate/genpku.c
--- ./src.orig/uqm/planets/generate/genpku.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genpku.c	2017-10-23 11:41:34 -0700
@@ -62,6 +62,7 @@ GeneratePkunk_generatePlanets (SOLARSYS_
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 104L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -70,6 +71,7 @@ GeneratePkunk_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/genrain.c ./src/uqm/planets/generate/genrain.c
--- ./src.orig/uqm/planets/generate/genrain.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genrain.c	2017-10-23 11:41:34 -0700
@@ -53,6 +53,7 @@ GenerateRainbowWorld_generatePlanets (SO
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = RAINBOW_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 0;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 50L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -65,6 +66,7 @@ GenerateRainbowWorld_generatePlanets (SO
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/gensam.c ./src/uqm/planets/generate/gensam.c
--- ./src.orig/uqm/planets/generate/gensam.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/gensam.c	2017-10-23 11:41:34 -0700
@@ -156,6 +156,7 @@ GenerateSaMatra_generateMoons (SOLARSYS_
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp ./src.orig/uqm/planets/generate/gensly.c ./src/uqm/planets/generate/gensly.c
--- ./src.orig/uqm/planets/generate/gensly.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/gensly.c	2017-10-23 11:41:34 -0700
@@ -49,6 +49,7 @@ GenerateSlylandro_generatePlanets (SOLAR
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[3].data_index = RED_GAS_GIANT;
+	solarSys->PlanetDesc[3].alternate_colormap = NULL;
 	solarSys->PlanetDesc[3].NumPlanets = 1;
 
 	return true;
diff -ruNp ./src.orig/uqm/planets/generate/gensol.c ./src/uqm/planets/generate/gensol.c
--- ./src.orig/uqm/planets/generate/gensol.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/gensol.c	2017-10-23 11:41:34 -0700
@@ -29,6 +29,7 @@
 #include "../../state.h"
 #include "libs/mathlib.h"
 
+#include <math.h>
 
 static bool GenerateSol_initNpcs (SOLARSYS_STATE *solarSys);
 static bool GenerateSol_reinitNpcs (SOLARSYS_STATE *solarSys);
@@ -113,68 +114,77 @@ GenerateSol_generatePlanets (SOLARSYS_ST
 	solarSys->SunDesc[0].NumPlanets = 9;
 	for (planetI = 0; planetI < 9; ++planetI)
 	{
-		COUNT angle;
 		DWORD rand_val;
 		UWORD word_val;
 		PLANET_DESC *pCurDesc = &solarSys->PlanetDesc[planetI];
 
 		pCurDesc->rand_seed = rand_val = TFB_Random ();
 		word_val = LOWORD (rand_val);
-		angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
+		pCurDesc->angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
 
 		switch (planetI)
 		{
 			case 0: /* MERCURY */
 				pCurDesc->data_index = METAL_WORLD;
+				pCurDesc->alternate_colormap = MERCURY_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 39L / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 1: /* VENUS */
 				pCurDesc->data_index = PRIMORDIAL_WORLD;
+				pCurDesc->alternate_colormap = VENUS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 72L / 100;
 				pCurDesc->NumPlanets = 0;
-				angle = NORMALIZE_ANGLE (FULL_CIRCLE - angle);
+				pCurDesc->angle = NORMALIZE_ANGLE (FULL_CIRCLE - pCurDesc->angle);
 				break;
 			case 2: /* EARTH */
-				pCurDesc->data_index = WATER_WORLD | PLANET_SHIELDED;
+				pCurDesc->data_index = WATER_WORLD | PLANET_SHIELDED; // EARTH_WORLD
+				pCurDesc->alternate_colormap = NULL;
 				pCurDesc->radius = EARTH_RADIUS;
 				pCurDesc->NumPlanets = 2;
 				break;
 			case 3: /* MARS */
 				pCurDesc->data_index = DUST_WORLD;
+				pCurDesc->alternate_colormap = MARS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 152L / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 4: /* JUPITER */
 				pCurDesc->data_index = RED_GAS_GIANT;
+				pCurDesc->alternate_colormap = JUPITER_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 500L /* 520L */ / 100;
 				pCurDesc->NumPlanets = 4;
 				break;
 			case 5: /* SATURN */
 				pCurDesc->data_index = ORA_GAS_GIANT;
+				pCurDesc->alternate_colormap = SATURN_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 750L /* 952L */ / 100;
 				pCurDesc->NumPlanets = 1;
 				break;
 			case 6: /* URANUS */
 				pCurDesc->data_index = GRN_GAS_GIANT;
+				pCurDesc->alternate_colormap = URANUS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1000L /* 1916L */ / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 7: /* NEPTUNE */
 				pCurDesc->data_index = BLU_GAS_GIANT;
+				pCurDesc->alternate_colormap = NEPTUNE_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1250L /* 2999L */ / 100;
 				pCurDesc->NumPlanets = 1;
 				break;
 			case 8: /* PLUTO */
 				pCurDesc->data_index = PELLUCID_WORLD;
+				pCurDesc->alternate_colormap = PLUTO_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1550L /* 3937L */ / 100;
 				pCurDesc->NumPlanets = 0;
-				angle = FULL_CIRCLE - OCTANT;
+				pCurDesc->angle = FULL_CIRCLE - OCTANT;
 				break;
 		}
 
-		pCurDesc->location.x = COSINE (angle, pCurDesc->radius);
-		pCurDesc->location.y = SINE (angle, pCurDesc->radius);
+		pCurDesc->orb_speed = FULL_CIRCLE / (365.25 * pow((float)pCurDesc->radius / EARTH_RADIUS, 1.5));
+		pCurDesc->location.x = COSINE (pCurDesc->angle, pCurDesc->radius);
+		pCurDesc->location.y = SINE (pCurDesc->angle, pCurDesc->radius);
 	}
 
 	return true;
@@ -203,9 +213,11 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 					COSINE (angle, solarSys->MoonDesc[0].radius);
 			solarSys->MoonDesc[0].location.y =
 					SINE (angle, solarSys->MoonDesc[0].radius);
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 11.46;
 
 			/* Luna: */
 			solarSys->MoonDesc[1].data_index = SELENIC_WORLD;
+			solarSys->MoonDesc[1].alternate_colormap = LUNA_COLOR_TAB;
 			solarSys->MoonDesc[1].radius = MIN_MOON_RADIUS
 					+ (MAX_MOONS - 1) * MOON_DELTA;
 			rand_val = TFB_Random ();
@@ -214,24 +226,39 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 					COSINE (angle, solarSys->MoonDesc[1].radius);
 			solarSys->MoonDesc[1].location.y =
 					SINE (angle, solarSys->MoonDesc[1].radius);
+			solarSys->MoonDesc[1].orb_speed = FULL_CIRCLE / 29;
 			break;
 		}
 		case 4: /* moons of JUPITER */
 			solarSys->MoonDesc[0].data_index = RADIOACTIVE_WORLD;
+			solarSys->MoonDesc[0].alternate_colormap = IO_COLOR_TAB;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 1.77;
 					/* Io */
 			solarSys->MoonDesc[1].data_index = HALIDE_WORLD;
+			solarSys->MoonDesc[1].alternate_colormap = EUROPA_COLOR_TAB;
+			solarSys->MoonDesc[1].orb_speed = FULL_CIRCLE / 3.55;
 					/* Europa */
 			solarSys->MoonDesc[2].data_index = CYANIC_WORLD;
+			solarSys->MoonDesc[2].alternate_colormap = GANYMEDE_COLOR_TAB;
+			solarSys->MoonDesc[2].orb_speed = FULL_CIRCLE / 7.16;
 					/* Ganymede */
 			solarSys->MoonDesc[3].data_index = PELLUCID_WORLD;
+			solarSys->MoonDesc[3].alternate_colormap = CALLISTO_COLOR_TAB;
+			solarSys->MoonDesc[3].orb_speed = FULL_CIRCLE / 16.69;
 					/* Callisto */
 			break;
 		case 5: /* moons of SATURN */
 			solarSys->MoonDesc[0].data_index = ALKALI_WORLD;
+			solarSys->MoonDesc[0].alternate_colormap = TITAN_COLOR_TAB;
+			solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS
+					+ (MAX_MOONS - 1) * MOON_DELTA;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 15.95;
 					/* Titan */
 			break;
 		case 7: /* moons of NEPTUNE */
 			solarSys->MoonDesc[0].data_index = VINYLOGOUS_WORLD;
+			solarSys->MoonDesc[0].alternate_colormap = TRITON_COLOR_TAB;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / -5.88;
 					/* Triton */
 			break;
 	}
@@ -407,8 +434,40 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
 				CalcGravity (solarSys->SysInfo.PlanetInfo.PlanetDensity,
 				solarSys->SysInfo.PlanetInfo.PlanetRadius);
-		LoadPlanet (planetNr == 2 ?
-				CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)) : NULL);
+
+		switch (planetNr)
+			{
+			case 0: /* MERCURY */
+				LoadPlanet (CaptureDrawable (LoadGraphic (MERCURY_MASK_ANIM)));
+				break;
+			case 1: /* VENUS */
+				LoadPlanet (CaptureDrawable (LoadGraphic (VENUS_MASK_ANIM)));
+				break;
+			case 2: /* EARTH */
+				LoadPlanet (CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)));
+				break;
+			case 3: /* MARS */
+				LoadPlanet (CaptureDrawable (LoadGraphic (MARS_MASK_ANIM)));
+				break;
+			case 4: /* JUPITER*/
+				LoadPlanet (CaptureDrawable (LoadGraphic (JUPITER_MASK_ANIM)));
+				break;
+			case 5: /* SATURN*/
+				LoadPlanet (CaptureDrawable (LoadGraphic (SATURN_MASK_ANIM)));
+				break;
+			case 6: /* URANUS */
+				LoadPlanet (CaptureDrawable (LoadGraphic (URANUS_MASK_ANIM)));
+				break;
+			case 7: /* NEPTUNE */
+				LoadPlanet (CaptureDrawable (LoadGraphic (NEPTUNE_MASK_ANIM)));
+				break;
+			case 8: /* PLUTO */
+				LoadPlanet (CaptureDrawable (LoadGraphic (PLUTO_MASK_ANIM)));
+				break;
+			default:
+				LoadPlanet (NULL);
+				break;
+			}
 	}
 	else
 	{
@@ -507,7 +566,40 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
 				CalcGravity (solarSys->SysInfo.PlanetInfo.PlanetDensity,
 				solarSys->SysInfo.PlanetInfo.PlanetRadius);
-		LoadPlanet (NULL);
+		
+		switch (planetNr)
+			{
+			case 2: /* moons of EARTH */
+				if (moonNr == 1)
+					LoadPlanet (CaptureDrawable (LoadGraphic (LUNA_MASK_ANIM)));
+				else
+					LoadPlanet (NULL);
+				break;
+			case 4: /* moons of JUPITER */
+				switch (moonNr)
+				{
+					case 0: /* Io */
+						LoadPlanet (CaptureDrawable (LoadGraphic (IO_MASK_ANIM)));
+						break;
+					case 1: /* Europa */
+						LoadPlanet (CaptureDrawable (LoadGraphic (EUROPA_MASK_ANIM)));
+						break;
+					case 2: /* Ganymede */
+						LoadPlanet (CaptureDrawable (LoadGraphic (GANYMEDE_MASK_ANIM)));
+						break;
+					case 3: /* Callisto */
+						LoadPlanet (CaptureDrawable (LoadGraphic (CALLISTO_MASK_ANIM)));
+						break;
+				}
+				break;
+			case 5: /* moon of Saturn: Titan */
+				LoadPlanet (CaptureDrawable (LoadGraphic (TITAN_MASK_ANIM)));
+				break;
+			case 7: /* moon of NEPTUNE: Triton */
+			default:
+				LoadPlanet (CaptureDrawable (LoadGraphic (TRITON_MASK_ANIM)));
+				break;
+			}
 	}
 
 	return true;
@@ -527,8 +619,8 @@ GenerateSol_generateEnergy (SOLARSYS_STA
 			return 0;
 		}
 
-		solarSys->SysInfo.PlanetInfo.CurPt.x = 20;
-		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT - 8;
+		solarSys->SysInfo.PlanetInfo.CurPt.x = (20 << RESOLUTION_FACTOR); // JMS_GFX
+		solarSys->SysInfo.PlanetInfo.CurPt.y = MAP_HEIGHT - (8 << RESOLUTION_FACTOR); // JMS_GFX
 
 		return 1; // only matters when count is requested
 	}
diff -ruNp ./src.orig/uqm/planets/generate/genspa.c ./src/uqm/planets/generate/genspa.c
--- ./src.orig/uqm/planets/generate/genspa.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genspa.c	2017-10-23 11:41:34 -0700
@@ -78,10 +78,11 @@ GenerateSpathi_generatePlanets (SOLARSYS
 	pMinPlanet->location.x = COSINE (angle, pMinPlanet->radius);
 	pMinPlanet->location.y = SINE (angle, pMinPlanet->radius);
 	pMinPlanet->data_index = WATER_WORLD;
+	pMinPlanet->alternate_colormap = NULL;
 	if (GET_GAME_STATE (SPATHI_SHIELDED_SELVES))
 		pMinPlanet->data_index |= PLANET_SHIELDED;
 	pMinPlanet->NumPlanets = 1;
-
+	ComputeSpeed(pMinPlanet, FALSE, 1);
 	return true;
 }
 
@@ -101,12 +102,14 @@ GenerateSpathi_generateMoons (SOLARSYS_S
 #endif /* NOTYET */
 
 		solarSys->MoonDesc[0].data_index = PELLUCID_WORLD;
+		solarSys->MoonDesc[0].alternate_colormap = NULL;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS + MOON_DELTA;
 		angle = NORMALIZE_ANGLE (LOWORD (TFB_Random ()));
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp ./src.orig/uqm/planets/generate/gensup.c ./src/uqm/planets/generate/gensup.c
--- ./src.orig/uqm/planets/generate/gensup.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/gensup.c	2017-10-23 11:41:34 -0700
@@ -62,6 +62,7 @@ GenerateSupox_generatePlanets (SOLARSYS_
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 2;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 152L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -70,6 +71,7 @@ GenerateSupox_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/gensyr.c ./src/uqm/planets/generate/gensyr.c
--- ./src.orig/uqm/planets/generate/gensyr.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/gensyr.c	2017-10-23 11:41:34 -0700
@@ -50,6 +50,7 @@ GenerateSyreen_generatePlanets (SOLARSYS
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = WATER_WORLD | PLANET_SHIELDED;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 
 	return true;
@@ -63,11 +64,13 @@ GenerateSyreen_generateMoons (SOLARSYS_S
 	if (matchWorld (solarSys, planet, 0, MATCH_PLANET))
 	{
 		solarSys->MoonDesc[0].data_index = HIERARCHY_STARBASE;
+		solarSys->MoonDesc[0].alternate_colormap = NULL;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS;
 		solarSys->MoonDesc[0].location.x =
 				COSINE (QUADRANT, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (QUADRANT, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp ./src.orig/uqm/planets/generate/genthrad.c ./src/uqm/planets/generate/genthrad.c
--- ./src.orig/uqm/planets/generate/genthrad.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genthrad.c	2017-10-23 11:41:34 -0700
@@ -66,6 +66,7 @@ GenerateThraddash_generatePlanets (SOLAR
 	if (CurStarDescPtr->Index == AQUA_HELIX_DEFINED)
 	{
 		solarSys->PlanetDesc[0].data_index = PRIMORDIAL_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 65L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
 				solarSys->PlanetDesc[0].location.y);
@@ -73,10 +74,12 @@ GenerateThraddash_generatePlanets (SOLAR
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	else  /* CurStarDescPtr->Index == THRADD_DEFINED */
 	{
 		solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].NumPlanets = 0;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 98L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -85,6 +88,7 @@ GenerateThraddash_generatePlanets (SOLAR
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/gentrap.c ./src/uqm/planets/generate/gentrap.c
--- ./src.orig/uqm/planets/generate/gentrap.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/gentrap.c	2017-10-23 11:41:34 -0700
@@ -50,6 +50,7 @@ GenerateTrap_generatePlanets (SOLARSYS_S
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = TELLURIC_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 203L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -58,6 +59,7 @@ GenerateTrap_generatePlanets (SOLARSYS_S
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/genutw.c ./src/uqm/planets/generate/genutw.c
--- ./src.orig/uqm/planets/generate/genutw.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genutw.c	2017-10-23 11:41:34 -0700
@@ -84,6 +84,7 @@ GenerateUtwig_generatePlanets (SOLARSYS_
 	if (CurStarDescPtr->Index == UTWIG_DEFINED)
 	{
 		solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].NumPlanets = 1;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 174L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -92,6 +93,7 @@ GenerateUtwig_generatePlanets (SOLARSYS_
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 
 	return true;
diff -ruNp ./src.orig/uqm/planets/generate/genvux.c ./src/uqm/planets/generate/genvux.c
--- ./src.orig/uqm/planets/generate/genvux.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genvux.c	2017-10-23 11:41:34 -0700
@@ -76,6 +76,7 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 				// called. Is it safe to remove one, or does this change
 				// the RNG so that the outcome is different?
 		solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 212L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
 				solarSys->PlanetDesc[0].location.y);
@@ -83,15 +84,18 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	else
 	{
 		if (CurStarDescPtr->Index == VUX_DEFINED)
 		{
 			solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
+			solarSys->PlanetDesc[0].alternate_colormap = NULL;
 			solarSys->PlanetDesc[0].NumPlanets = 1;
 			solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 42L / 100;
 			angle = HALF_CIRCLE + OCTANT;
+			ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 		}
 		else /* if (CurStarDescPtr->Index == VUX_BEAST_DEFINED) */
 		{
@@ -102,8 +106,10 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 
 			angle = HALF_CIRCLE - OCTANT;
 			solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+			solarSys->PlanetDesc[0].alternate_colormap = NULL;
 			solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 110L / 100;
 			solarSys->PlanetDesc[0].NumPlanets = 0;
+			ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 		}
 
 		solarSys->PlanetDesc[0].location.x =
diff -ruNp ./src.orig/uqm/planets/generate/genyeh.c ./src/uqm/planets/generate/genyeh.c
--- ./src.orig/uqm/planets/generate/genyeh.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genyeh.c	2017-10-23 11:41:34 -0700
@@ -68,6 +68,7 @@ GenerateYehat_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/genzoq.c ./src/uqm/planets/generate/genzoq.c
--- ./src.orig/uqm/planets/generate/genzoq.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/generate/genzoq.c	2017-10-23 11:41:34 -0700
@@ -70,6 +70,7 @@ GenerateZoqFotPik_generatePlanets (SOLAR
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 138L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -78,6 +79,7 @@ GenerateZoqFotPik_generatePlanets (SOLAR
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp ./src.orig/uqm/planets/generate/genzoqcolony.c ./src/uqm/planets/generate/genzoqcolony.c
--- ./src.orig/uqm/planets/generate/genzoqcolony.c	1969-12-31 16:00:00 -0800
+++ ./src/uqm/planets/generate/genzoqcolony.c	2017-10-23 11:41:34 -0700
@@ -0,0 +1,190 @@
+//Copyright Paul Reiche, Fred Ford. 1992-2002
+
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "genall.h"
+#include "../planets.h"
+#include "../../build.h"
+#include "../../comm.h"
+#include "../../globdata.h"
+#include "../../nameref.h"
+#include "../../state.h"
+#include "libs/mathlib.h"
+
+static bool GenerateZoqColony0_generatePlanets (SOLARSYS_STATE *solarSys);
+static bool GenerateZoqColony0_generateOrbital (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world);
+static bool GenerateZoqColony1_generateOrbital (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world);
+static COUNT GenerateZoqColony0_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT whichNode);
+static COUNT GenerateZoqColony1_generateEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateZoqColony0_pickupEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT whichNode);
+static bool GenerateZoqColony1_pickupEnergy (SOLARSYS_STATE *solarSys,
+		PLANET_DESC *world, COUNT whichNode);
+
+
+const GenerateFunctions generateZoqFotPikColony0Functions = {
+	/* .initNpcs         = */ GenerateDefault_initNpcs,
+	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
+	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
+	/* .generatePlanets  = */ GenerateZoqColony0_generatePlanets,
+	/* .generateMoons    = */ GenerateDefault_generateMoons,
+	/* .generateName     = */ GenerateDefault_generateName,
+	/* .generateOrbital  = */ GenerateZoqColony0_generateOrbital,
+	/* .generateMinerals = */ GenerateDefault_generateMinerals,
+	/* .generateEnergy   = */ GenerateZoqColony0_generateEnergy,
+	/* .generateLife     = */ GenerateDefault_generateLife,
+	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
+	/* .pickupEnergy     = */ GenerateZoqColony0_pickupEnergy,
+	/* .pickupLife       = */ GenerateDefault_pickupLife,
+};
+
+const GenerateFunctions generateZoqFotPikColony1Functions = {
+	/* .initNpcs         = */ GenerateDefault_initNpcs,
+	/* .reinitNpcs       = */ GenerateDefault_reinitNpcs,
+	/* .uninitNpcs       = */ GenerateDefault_uninitNpcs,
+	/* .generatePlanets  = */ GenerateDefault_generatePlanets,
+	/* .generateMoons    = */ GenerateDefault_generateMoons,
+	/* .generateName     = */ GenerateDefault_generateName,
+	/* .generateOrbital  = */ GenerateZoqColony1_generateOrbital,
+	/* .generateMinerals = */ GenerateDefault_generateMinerals,
+	/* .generateEnergy   = */ GenerateZoqColony1_generateEnergy,
+	/* .generateLife     = */ GenerateDefault_generateLife,
+	/* .pickupMinerals   = */ GenerateDefault_pickupMinerals,
+	/* .pickupEnergy     = */ GenerateZoqColony1_pickupEnergy,
+	/* .pickupLife       = */ GenerateDefault_pickupLife,
+};
+
+static bool
+GenerateZoqColony0_generatePlanets (SOLARSYS_STATE *solarSys)
+{
+	COUNT angle;
+
+	GenerateDefault_generatePlanets (solarSys);
+
+	solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
+	solarSys->PlanetDesc[0].NumPlanets = 0;
+	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 125L / 100;
+	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
+			solarSys->PlanetDesc[0].location.y);
+	solarSys->PlanetDesc[0].location.x =
+			COSINE (angle, solarSys->PlanetDesc[0].radius);
+	solarSys->PlanetDesc[0].location.y =
+			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
+
+	return true;
+}
+
+static bool
+GenerateZoqColony0_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
+{
+	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
+	{
+		LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
+		solarSys->PlanetSideFrame[1] =
+				CaptureDrawable (LoadGraphic (RUINS_MASK_PMAP_ANIM));
+		
+		if ((GET_GAME_STATE(MET_ZOQFOT)) == 1)
+			solarSys->SysInfo.PlanetInfo.DiscoveryString =
+				CaptureStringTable (LoadStringTable (ZOQCOLONY_RUINS2_STRTAB));
+		else
+			solarSys->SysInfo.PlanetInfo.DiscoveryString =
+				CaptureStringTable (LoadStringTable (ZOQCOLONY_RUINS1_STRTAB));
+	}
+
+	GenerateDefault_generateOrbital (solarSys, world);
+	return true;
+}
+
+static bool
+GenerateZoqColony1_generateOrbital (SOLARSYS_STATE *solarSys, PLANET_DESC *world)
+{
+	if (matchWorld (solarSys, world, 0, 1))
+	{
+		LoadStdLanderFont (&solarSys->SysInfo.PlanetInfo);
+		solarSys->PlanetSideFrame[1] =
+			CaptureDrawable (LoadGraphic (RUINS_MASK_PMAP_ANIM));
+		
+		if ((GET_GAME_STATE(MET_ZOQFOT)) == 1)
+			solarSys->SysInfo.PlanetInfo.DiscoveryString =
+			CaptureStringTable (LoadStringTable (ZOQCOLONY_RUINS2_STRTAB));
+		else
+			solarSys->SysInfo.PlanetInfo.DiscoveryString =
+			CaptureStringTable (LoadStringTable (ZOQCOLONY_RUINS1_STRTAB));
+	}
+	
+	GenerateDefault_generateOrbital (solarSys, world);
+	return true;
+}
+
+static COUNT
+GenerateZoqColony0_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+		COUNT whichNode)
+{
+	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
+	{
+		return GenerateDefault_generateRuins (solarSys, whichNode);
+	}
+
+	return 0;
+}
+
+static COUNT
+GenerateZoqColony1_generateEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+								   COUNT whichNode)
+{
+	if (matchWorld (solarSys, world, 0, 1))
+	{
+		return GenerateDefault_generateRuins (solarSys, whichNode);
+	}
+	
+	return 0;
+}
+
+static bool
+GenerateZoqColony0_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+		COUNT whichNode)
+{
+	if (matchWorld (solarSys, world, 0, MATCH_PLANET))
+	{
+		// Standard ruins report
+		GenerateDefault_landerReportCycle (solarSys);
+		return false;
+	}
+
+	(void) whichNode;
+	return false;
+}
+
+static bool
+GenerateZoqColony1_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
+								 COUNT whichNode)
+{
+	if (matchWorld (solarSys, world, 0, 1))
+	{
+		// Standard ruins report
+		GenerateDefault_landerReportCycle (solarSys);
+		return false;
+	}
+	
+	(void) whichNode;
+	return false;
+}
diff -ruNp ./src.orig/uqm/planets/gentopo.c ./src/uqm/planets/gentopo.c
--- ./src.orig/uqm/planets/gentopo.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/gentopo.c	2017-10-23 11:41:34 -0700
@@ -18,6 +18,8 @@
 
 // See doc/devel/planettopo for details.
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "libs/gfxlib.h"
 #include "libs/mathlib.h"
 #include "planets.h"
@@ -49,8 +51,15 @@ DeltaTopography (COUNT num_iterations, S
 		w1 = LOWORD (rand_val);
 		w2 = HIWORD (rand_val);
 
-		LineDDA0.x_top = LOBYTE (w1) % width;
-		LineDDA0.x_bot = HIBYTE (w1) % width;
+		LineDDA0.x_top = (LOBYTE (w1) % ORIGINAL_MAP_WIDTH) * width / ORIGINAL_MAP_WIDTH;
+		LineDDA0.x_bot = (HIBYTE (w1) % ORIGINAL_MAP_WIDTH) * width / ORIGINAL_MAP_WIDTH;
+		
+		//LineDDA0.x_top = w1 % width; // JMS_GFX: Replaced previous lines with these: BYTE is too small for 640x480 sized maps.
+		//LineDDA0.x_bot = w2 % width; // Using w1 and w2 to get difference between top and bottom.
+		// BW: reinstate previous method and adapt it for higher res.
+		// Overusing w1 and w2 was hampering randomness.
+		// Now planets will look the same no matter what the res is.
+		
 		LineDDA0.delta_x = (LineDDA0.x_bot - LineDDA0.x_top) << 1;
 		if (LineDDA0.delta_x >= 0)
 			LineDDA0.x_incr = 1;
@@ -64,8 +73,14 @@ DeltaTopography (COUNT num_iterations, S
 		else
 			LineDDA0.error_term = -(delta_y >> 1);
 
-		LineDDA1.x_top = (LOBYTE (w2) % (width - 1)) + LineDDA0.x_top + 1;
-		LineDDA1.x_bot = (HIBYTE (w2) % (width - 1)) + LineDDA0.x_bot + 1;
+		LineDDA1.x_top = (LOBYTE (w2) % (ORIGINAL_MAP_WIDTH - 1)) * width / ORIGINAL_MAP_WIDTH + LineDDA0.x_top + 1;
+		LineDDA1.x_bot = (HIBYTE (w2) % (ORIGINAL_MAP_WIDTH - 1)) * width / ORIGINAL_MAP_WIDTH + LineDDA0.x_bot + 1;
+		
+		// JMS_GFX: Replaced previous lines with these: BYTE is too small for 640x480 sized maps.
+		// LineDDA1.x_top = (w2 % (width - 1)) + LineDDA0.x_top + 1;
+		// LineDDA1.x_bot = (w1 % (width - 1)) + LineDDA0.x_bot + 1;
+		// BW: the same as above
+		
 		LineDDA1.delta_x = (LineDDA1.x_bot - LineDDA1.x_top) << 1;
 		if (LineDDA1.delta_x >= 0)
 			LineDDA1.x_incr = 1;
@@ -85,6 +100,8 @@ DeltaTopography (COUNT num_iterations, S
 		{
 			COUNT w;
 
+			// Add depth_delta between DDA0.x_top and DDA1.x_top
+			// wrapping around if needed
 			w1 = LineDDA1.x_top - LineDDA0.x_top;
 			w2 = width - w1;
 
@@ -124,6 +141,8 @@ DeltaTopography (COUNT num_iterations, S
 				} while (--w1);
 			}
 
+			// Substract depth_delta between DDA0.x_top and
+			//  DDA1.x_top wrapping around if needed
 			if ((int)(LineDDA0.x_top + w2) > (int)width)
 				w = width - LineDDA0.x_top;
 			else
@@ -160,6 +179,8 @@ DeltaTopography (COUNT num_iterations, S
 				} while (--w2);
 			}
 
+			// Prepare next line
+			// slowly shifting to x_bot values
 			lpDst += pRect->extent.width;
 
 			if (delta_y >= LineDDA0.delta_x)
diff -ruNp ./src.orig/uqm/planets/lander.c ./src/uqm/planets/lander.c
--- ./src.orig/uqm/planets/lander.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/lander.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "lander.h"
 
 #include "lifeform.h"
@@ -33,6 +35,7 @@
 #include "../setup.h"
 #include "../sounds.h"
 #include "../element.h"
+#include "options.h" // JMS: For optMineralSubmenu
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
@@ -63,6 +66,8 @@ struct LanderInputState {
 };
 
 FRAME LanderFrame[8];
+FRAME SubmenuMineralsFrame; // JMS
+
 static SOUND LanderSounds;
 MUSIC_REF LanderMusic;
 #define NUM_ORBIT_THEMES 5
@@ -119,7 +124,7 @@ const LIFEFORM_DESC CreatureData[] =
 
 	{SPEED_MOTIONLESS | DANGER_MONSTROUS, MAKE_BYTE (1, 1)},
 			// Evil One
-	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (0, 1)},
+	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (1, 1)},
 			// Brainbox Bulldozers
 	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_FAST | DANGER_MONSTROUS, MAKE_BYTE (15, 15)},
 			// Zex's Beauty
@@ -151,7 +156,7 @@ extern PRIM_LINKS DisplayLinks;
 #define ADD_AT_END (1 << 4)
 #define REPAIR_COUNT (0xf)
 
-#define LANDER_SPEED_DENOM 10
+#define LANDER_SPEED_DENOM (10) // JMS_GFX
 
 static BYTE lander_flags;
 static POINT curLanderLoc;
@@ -265,17 +270,20 @@ object_animation (ELEMENT *ElementPtr)
 			else if (ElementPtr->mass_points == EARTHQUAKE_DISASTER)
 			{
 				SIZE s;
+				SIZE frame_amount; // JMS_GFX
 
-				if (frame_index >= 13)
+				frame_amount = 14;
+				
+				if (frame_index >= (frame_amount-1))
 					s = 0;
 				else
-					s = (14 - frame_index) >> 1;
+					s = (frame_amount - frame_index) >> 1;
 				// XXX: Was 0x8000 the background flag on 3DO?
 				//SetPrimColor (pPrim, BUILD_COLOR (0x8000 | MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
 				SetPrimColor (pPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
-				if (frame_index == 13)
+				if (frame_index == (frame_amount - 1))
 					PlaySound (SetAbsSoundIndex (LanderSounds, EARTHQUAKE_DISASTER),
-							NotPositional (), NULL, GAME_SOUND_PRIORITY);
+							   NotPositional (), NULL, GAME_SOUND_PRIORITY);
 			}
 			
 			if (ElementPtr->mass_points == LAVASPOT_DISASTER
@@ -293,8 +301,8 @@ object_animation (ELEMENT *ElementPtr)
 					angle = FACING_TO_ANGLE (ElementPtr->facing);
 					LockElement (hLavaElement, &LavaElementPtr);
 					LavaElementPtr->next.location = ElementPtr->next.location;
-					LavaElementPtr->next.location.x += COSINE (angle, 4);
-					LavaElementPtr->next.location.y += SINE (angle, 4);
+					LavaElementPtr->next.location.x += COSINE (angle, 4 << RESOLUTION_FACTOR); // JMS_GFX
+					LavaElementPtr->next.location.y += SINE (angle, 4 << RESOLUTION_FACTOR); // JMS_GFX
 					if (LavaElementPtr->next.location.y < 0)
 						LavaElementPtr->next.location.y = 0;
 					else if (LavaElementPtr->next.location.y >= (MAP_HEIGHT << MAG_SHIFT))
@@ -414,6 +422,7 @@ object_animation (ELEMENT *ElementPtr)
 						speed = WORLD_TO_VELOCITY (2 * 1) * 9 / 10;
 						break;
 				}
+				speed = speed << RESOLUTION_FACTOR; // JMS_GFX
 
 				SetVelocityComponents (&ElementPtr->velocity,
 						COSINE (angle, speed), SINE (angle, speed));
@@ -468,8 +477,21 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 				NotPositional (), NULL, GAME_SOUND_PRIORITY);
 	}
 
-	s.origin.x = 11 + (6 * (crew_delta % NUM_CREW_COLS));
-	s.origin.y = 35 - (6 * (crew_delta / NUM_CREW_COLS));
+	if (RESOLUTION_FACTOR == 0)
+	{
+		s.origin.x = ((11 + ((6 << RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)))); // JMS_GFX
+		s.origin.y = (35 - (6 * (crew_delta / NUM_CREW_COLS))) << RESOLUTION_FACTOR; // JMS_GFX
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		s.origin.x = ((23 + ((6 << RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)))); // JMS_GFX
+		s.origin.y = 1 + ((35 - (6 * (crew_delta / NUM_CREW_COLS))) << RESOLUTION_FACTOR); // JMS_GFX
+	}
+	else
+	{
+		s.origin.x = 32 + ((9 * RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)); // JMS_GFX
+		s.origin.y = (52 * RESOLUTION_FACTOR - (9 * RESOLUTION_FACTOR * (crew_delta / NUM_CREW_COLS))); // JMS_GFX
+	}
 
 	OldContext = SetContext (RadarContext);
 	DrawStamp (&s);
@@ -482,6 +504,8 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 	COUNT start_count;
 	STAMP s;
 	CONTEXT OldContext;
+	SIZE  rounding_error_startcount = 0; // JMS_GFX
+	SIZE  rounding_error_numretrieved = 0; // JMS_GFX
 
 	PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_PICKUP),
 			NotPositional (), NULL, GAME_SOUND_PRIORITY);
@@ -498,21 +522,48 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 	{
 		start_count = pPSD->ElementLevel;
 		pPSD->ElementLevel += NumRetrieved;
+		
+		rounding_error_startcount = (start_count % 2);
+		rounding_error_numretrieved = (pPSD->ElementLevel % 2);
+		
 		if (GET_GAME_STATE (IMPROVED_LANDER_CARGO))
-		{
-			start_count >>= 1;
-			NumRetrieved = (pPSD->ElementLevel >> 1) - start_count;
-		}
+			NumRetrieved = (pPSD->ElementLevel >> 1) - (start_count >> 1);
 
 		s.frame = SetAbsFrameIndex (LanderFrame[0], 43);
 	}
+	
+	//log_add(log_Warning, "sc %d, ellevel %d, numr %d, ", start_count, scan == BIOLOGICAL_SCAN ? pPSD->BiologicalLevel : pPSD->ElementLevel, NumRetrieved);
 
+	start_count *= RES_STAT_SCALE(1); // JMS_GFX
+	
+	if (scan == MINERAL_SCAN && GET_GAME_STATE (IMPROVED_LANDER_CARGO))
+	{
+		start_count >>= 1;
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 1)
+			start_count += rounding_error_startcount;
+	}
+	
 	s.origin.x = 0;
-	s.origin.y = -(int)start_count;
+	s.origin.y =  -(int)start_count + RESOLUTION_FACTOR; // JMS_GFX
 	if (!(start_count & 1))
 		s.frame = IncFrameIndex (s.frame);
 
 	OldContext = SetContext (RadarContext);
+	
+	// JMS_GFX
+	if (scan == MINERAL_SCAN && GET_GAME_STATE (IMPROVED_LANDER_CARGO) && RESOLUTION_FACTOR > 0)
+	{
+		NumRetrieved *= RES_STAT_SCALE(1);
+		NumRetrieved >>= 1;
+		
+		if (RESOLUTION_FACTOR == 1)
+			NumRetrieved += rounding_error_numretrieved;
+	}
+		
+	//log_add(log_Warning, "SCALED: sc %d, ellevel %d, numr %d, ", start_count, scan == BIOLOGICAL_SCAN ? pPSD->BiologicalLevel : pPSD->ElementLevel, NumRetrieved);
+	
 	while (NumRetrieved--)
 	{
 		if (start_count++ & 1)
@@ -520,7 +571,7 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 		else
 			s.frame = DecFrameIndex (s.frame);
 		DrawStamp (&s);
-		--s.origin.y;
+		s.origin.y -= RES_STAT_SCALE(1); // JMS_GFX
 	}
 	SetContext (OldContext);
 }
@@ -534,6 +585,9 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 	BYTE EType;
 	UNICODE ch;
 	UNICODE *pStr;
+	
+	// JMS: The rest of partially scavenged minerals stay on the surface.
+	bool partialPickup = false;
 
 	if (pPSD->ElementLevel >= pPSD->MaxElementLevel)
 	{
@@ -545,8 +599,48 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 
 	if (pPSD->ElementLevel + NumRetrieved > pPSD->MaxElementLevel)
 	{
+		SIZE which_node;
+		COUNT oldsize = ElementPtr->mass_points;
+		
 		// Deposit could only be picked up partially.
 		NumRetrieved = (COUNT)(pPSD->MaxElementLevel - pPSD->ElementLevel);
+		
+		// JMS: Subtract the scavenged kilotons from the mineral deposit.
+		// The rest will stay on the surface.
+		ElementPtr->mass_points -= NumRetrieved;
+		
+		// JMS: This makes the mineral deposit subtraction keep  
+		// in effect even after leaving & re-entering the planet.
+		which_node = HIBYTE (ElementPtr->scan_node) - 1;
+		pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[MINERAL_SCAN][which_node] = NumRetrieved;
+		
+		// JMS: If the deposit was large and its amount now equates to a smaller
+		// deposit, change its graphics.
+		if ((oldsize > 22 && ElementPtr->mass_points <= 22)
+			|| (oldsize > 15 && ElementPtr->mass_points <= 15))
+		{
+			PRIMITIVE *pPrim = &DisplayArray[ElementPtr->PrimIndex];
+			BYTE gfx_index_change = 0;
+			
+			if (oldsize > 22 && ElementPtr->mass_points <= 15)
+				gfx_index_change = 2;
+			else
+				gfx_index_change = 1;
+			
+			// Change the scan screen gfx.
+			ElementPtr->current.image.frame = SetRelFrameIndex (
+				ElementPtr->current.image.frame, (2 - gfx_index_change));
+			ElementPtr->next.image.frame = ElementPtr->current.image.frame;
+
+			// Notify the engine that the scan screen gfx should be updated.
+			ElementPtr->state_flags |= CHANGING;
+			SET_GAME_STATE (PLANETARY_CHANGE, 1);
+			
+			// Change the surface screen gfx.
+			pPrim->Object.Stamp.frame = SetRelFrameIndex (pPrim->Object.Stamp.frame, -gfx_index_change);
+		}
+		
+		partialPickup = true;
 	}
 
 	FillLanderHold (pPSD, MINERAL_SCAN, NumRetrieved);
@@ -559,9 +653,9 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 	pStr = GAME_STRING (EType + ELEMENTS_STRING_BASE);
 
 	pPSD->MineralText[0].baseline.x = (SURFACE_WIDTH >> 1)
-			+ (ElementControl->EndPoint.x - LanderControl->EndPoint.x);
+			+ ((ElementControl->EndPoint.x - LanderControl->EndPoint.x) << RESOLUTION_FACTOR); // JMS_GFX
 	pPSD->MineralText[0].baseline.y = (SURFACE_HEIGHT >> 1)
-			+ (ElementControl->EndPoint.y - LanderControl->EndPoint.y);
+			+ ((ElementControl->EndPoint.y - LanderControl->EndPoint.y) << RESOLUTION_FACTOR); // JMS_GFX
 	pPSD->MineralText[0].CharCount = (COUNT)~0;
 	pPSD->MineralText[1].pStr = pStr;
 
@@ -582,12 +676,20 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 		pPSD->MineralText[2].CharCount = (COUNT)~0;
 	}
 
-	return true;
+	// JMS
+	if (partialPickup)
+		return false;
+	else
+		return true;
 }
 
 static bool
-pickupBioNode (PLANETSIDE_DESC *pPSD, COUNT NumRetrieved)
+pickupBioNode (PLANETSIDE_DESC *pPSD, COUNT NumRetrieved,
+	const INTERSECT_CONTROL *LanderControl, const INTERSECT_CONTROL *ElementControl)
 {
+	UNICODE *pStr; // JMS
+	UNICODE ch; // JMS
+	
 	if (pPSD->BiologicalLevel >= MAX_SCROUNGED)
 	{
 		// Lander is full.
@@ -601,6 +703,34 @@ pickupBioNode (PLANETSIDE_DESC *pPSD, CO
 		// Node could only be picked up partially.
 		NumRetrieved = (COUNT)(MAX_SCROUNGED - pPSD->BiologicalLevel);
 	}
+	
+	// JMS: Print biodata amount.
+	pPSD->NumFrames = NUM_TEXT_FRAMES;
+	sprintf (pPSD->AmountBuf, "%u", NumRetrieved);
+	pStr = GAME_STRING (ELEMENTS_STRING_BASE + ELEMENTS_STRING_COUNT - 1);
+	pPSD->MineralText[0].baseline.x = (SURFACE_WIDTH >> 1)
+		+ ((ElementControl->EndPoint.x - LanderControl->EndPoint.x) << RESOLUTION_FACTOR); // JMS_GFX
+	pPSD->MineralText[0].baseline.y = (SURFACE_HEIGHT >> 1)
+		+ ((ElementControl->EndPoint.y - LanderControl->EndPoint.y) << RESOLUTION_FACTOR); // JMS_GFX
+	pPSD->MineralText[0].CharCount = (COUNT)~0;
+	pPSD->MineralText[1].pStr = pStr;
+	
+	while ((ch = *pStr++) && ch != ' ')
+		;
+	if (ch == '\0')
+	{
+		pPSD->MineralText[1].CharCount = (COUNT)~0;
+		pPSD->MineralText[2].CharCount = 0;
+	}
+	else  /* ch == ' ' */
+	{
+		// Name contains a space. Print over
+		// two lines.
+		pPSD->MineralText[1].CharCount = utf8StringCountN(
+			pPSD->MineralText[1].pStr, pStr - 1);
+		pPSD->MineralText[2].pStr = pStr;
+		pPSD->MineralText[2].CharCount = (COUNT)~0;
+	}
 
 	FillLanderHold (pPSD, BIOLOGICAL_SCAN, NumRetrieved);
 
@@ -608,6 +738,52 @@ pickupBioNode (PLANETSIDE_DESC *pPSD, CO
 }
 
 static void
+ExplodeCritter (ELEMENT *ElementPtr)
+{
+	HELEMENT hExplosionElement;
+	SIZE temp_which_node;
+				
+	hExplosionElement = AllocElement ();
+	if (hExplosionElement)
+	{
+		ELEMENT *ExplosionElementPtr;
+		LockElement (hExplosionElement, &ExplosionElementPtr);
+					
+		ExplosionElementPtr->mass_points = DEATH_EXPLOSION;
+		ExplosionElementPtr->state_flags = FINITE_LIFE;
+		ExplosionElementPtr->playerNr = PS_NON_PLAYER;
+		ExplosionElementPtr->next.location = ElementPtr->next.location;
+		ExplosionElementPtr->preprocess_func = object_animation;
+		ExplosionElementPtr->turn_wait = MAKE_BYTE (2, 2);
+		ExplosionElementPtr->life_span = EXPLOSION_LIFE * (LONIBBLE (ExplosionElementPtr->turn_wait));
+					
+		SetPrimType (&DisplayArray[ExplosionElementPtr->PrimIndex], STAMP_PRIM);
+		DisplayArray[ExplosionElementPtr->PrimIndex].Object.Stamp.frame = SetAbsFrameIndex (LanderFrame[0], 46);
+
+		// JMS: This keeps track of the explosion frames. Normally explosion occurs only once (lander explodes).
+		// If we don't zero this variable here, the explosion anim can run only once properly and would
+		// get stuck in the last frame after that on all the subsequent explosions.
+		explosion_index = 0;
+					
+		UnlockElement (hExplosionElement);
+		InsertElement (hExplosionElement, GetHeadElement ());
+					
+		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_DESTROYED), NotPositional (), NULL, GAME_SOUND_PRIORITY + 1);
+					
+		ElementPtr->state_flags |= DISAPPEARING; // JMS: Delete the critter frame
+		ElementPtr->mass_points = 0;			 // JMS: Make sure critter/explosion doesn't give biodata.
+					
+		// JMS: This marks the exploded critter "collected". (even though there was no biodata to collect).
+		// This ensures the critter isn't resurrected when visiting the planet next time.
+		temp_which_node = HIBYTE (ElementPtr->scan_node) - 1;
+		pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] |= (1L << temp_which_node); // Mark this bio blip's state as "collected".
+		//pSolarSysState->CurNode = (COUNT)~0; // GenerateLifeForms will update the states of ALL bio-blips when run.
+		//callGenerateForScanType (pSolarSysState, pSolarSysState->pOrbitalDesc, &pSolarSysState->CurNode, BIOLOGICAL_SCAN); // Re-run GenerateLifeForms so the changed state takes effect
+		SET_GAME_STATE (PLANETARY_CHANGE, 1); // Save the changes to the file containing the states of all lifeforms.
+	}
+}
+
+static void
 shotCreature (ELEMENT *ElementPtr, BYTE value,
 		INTERSECT_CONTROL *LanderControl, PRIMITIVE *pPrim)
 {
@@ -620,10 +796,18 @@ shotCreature (ELEMENT *ElementPtr, BYTE
 	--ElementPtr->hit_points;
 	if (ElementPtr->hit_points == 0)
 	{
-		// Can creature.
-		ElementPtr->mass_points = value;
-		DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
-				pSolarSysState->PlanetSideFrame[0];
+		// Brainbox bulldozers (Tractors at moon) explode.
+		if ((ElementPtr->mass_points & ~CREATURE_AWARE) == 24)
+		{
+			ExplodeCritter (ElementPtr);
+		}
+		// Can other creatures.
+		else
+		{
+			ElementPtr->mass_points = value;
+			DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
+			pSolarSysState->PlanetSideFrame[0];
+		}
 	}
 	else if (CreatureData[ElementPtr->mass_points & ~CREATURE_AWARE]
 			.Attributes & SPEED_MASK)
@@ -734,7 +918,11 @@ CheckObjectCollision (COUNT index)
 						{
 							case EARTHQUAKE_DISASTER:
 							case LAVASPOT_DISASTER:
-								if (TFB_Random () % 100 < 25)
+								if (scan == LAVASPOT_DISASTER 
+									&& RESOLUTION_FACTOR == 2 
+									&& TFB_Random () % 100 < 9)
+									DeltaLanderCrew (-1, scan);
+								else if (TFB_Random () % 100 < 25)
 									DeltaLanderCrew (-1, scan);
 								break;
 						}
@@ -818,7 +1006,8 @@ CheckObjectCollision (COUNT index)
 								continue;
 							break;
 						case BIOLOGICAL_SCAN:
-							if (!pickupBioNode (pPSD, NumRetrieved))
+							if (!pickupBioNode (pPSD, NumRetrieved, &LanderControl,
+									&ElementControl))
 								continue;
 							break;
 					}
@@ -861,18 +1050,29 @@ lightning_process (ELEMENT *ElementPtr)
 		}
 		else
 		{
+			static const Color color_tab[] =
+			{
+				BUILD_COLOR (MAKE_RGB15_INIT (0x11, 0x11, 0x11), 0x18),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x13, 0x13, 0x13), 0x17),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x15, 0x15, 0x15), 0x15),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x17, 0x17, 0x17), 0x14),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x19, 0x19, 0x19), 0x13),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x1B, 0x1B, 0x1B), 0x12),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x1D, 0x1D, 0x1D), 0x10),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x1F, 0x1F), 0x0f),
+			};
+			
 			SIZE s;
 			
-			// XXX: Color cycling is largely unused, because the color
-			//   never actually changes RGB values (see MAKE_RGB15 below).
-			//   This did, however, work in DOS SC2 version (fade effect).
 			s = 7 - ((SIZE)ElementPtr->cycle - (SIZE)ElementPtr->life_span);
 			if (s < 0)
 				s = 0;
+			
 			// XXX: Was 0x8000 the background flag on 3DO?
 			//SetPrimColor (pPrim, BUILD_COLOR (0x8000 | MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
-			SetPrimColor (pPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
-
+			//SetPrimColor (pPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
+			SetPrimColor (pPrim, color_tab[s]);
+			
 			if (ElementPtr->mass_points == LIGHTNING_DISASTER)
 			{
 				/* This one always strikes the lander and can hurt */
@@ -918,14 +1118,29 @@ AddLightning (void)
 
 		rand_val = TFB_Random ();
 		LightningElementPtr->life_span = 10 + (HIWORD (rand_val) % 10) + 1;
-		LightningElementPtr->next.location.x = (curLanderLoc.x
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			LightningElementPtr->next.location.x = (curLanderLoc.x
 				+ ((MAP_WIDTH << MAG_SHIFT) - ((SURFACE_WIDTH >> 1) - 6))
 				+ (LOBYTE (rand_val) % (SURFACE_WIDTH - 12))
 				) % (MAP_WIDTH << MAG_SHIFT);
-		LightningElementPtr->next.location.y = (curLanderLoc.y
+			LightningElementPtr->next.location.y = (curLanderLoc.y
 				+ ((MAP_HEIGHT << MAG_SHIFT) - ((SURFACE_HEIGHT >> 1) - 6))
 				+ (HIBYTE (rand_val) % (SURFACE_HEIGHT - 12))
 				) % (MAP_HEIGHT << MAG_SHIFT);
+		}
+		else
+		{
+			LightningElementPtr->next.location.x = (curLanderLoc.x
+				+ ((MAP_WIDTH << MAG_SHIFT) - ((SURFACE_WIDTH >> 1) - 6))
+				+ (rand_val % (SURFACE_WIDTH - (12 << RESOLUTION_FACTOR)))
+				) % (MAP_WIDTH << MAG_SHIFT);
+			LightningElementPtr->next.location.y = (curLanderLoc.y
+				+ ((MAP_HEIGHT << MAG_SHIFT) - ((SURFACE_HEIGHT >> 1) - 6))
+				+ (rand_val % (SURFACE_HEIGHT - (12 << RESOLUTION_FACTOR)))
+				) % (MAP_HEIGHT << MAG_SHIFT);
+		}
 
 		LightningElementPtr->cycle = LightningElementPtr->life_span;
 		
@@ -976,7 +1191,7 @@ AddGroundDisaster (COUNT which_disaster)
 
 		if (which_disaster == EARTHQUAKE_DISASTER)
 		{
-			SetPrimType (pPrim, STAMPFILL_PRIM);
+			SetPrimType (pPrim, STAMP_PRIM); // JMS: was STAMPFILL_PRIM (this rendered it totally white).
 			pPrim->Object.Stamp.frame = LanderFrame[1];
 			GroundDisasterElementPtr->turn_wait = MAKE_BYTE (2, 2);
 		}
@@ -991,7 +1206,7 @@ AddGroundDisaster (COUNT which_disaster)
 		GroundDisasterElementPtr->life_span =
 				GetFrameCount (pPrim->Object.Stamp.frame)
 				* (LONIBBLE (GroundDisasterElementPtr->turn_wait) + 1) - 1;
-
+		
 		UnlockElement (hGroundDisasterElement);
 
 		PutElement (hGroundDisasterElement);
@@ -1233,15 +1448,11 @@ ScrollPlanetSide (SIZE dx, SIZE dy, int
 			pPSD->MineralText[0].baseline.x -= dx;
 			pPSD->MineralText[0].baseline.y -= dy;
 			font_DrawText (&pPSD->MineralText[0]);
-			pPSD->MineralText[1].baseline.x =
-					pPSD->MineralText[0].baseline.x;
-			pPSD->MineralText[1].baseline.y =
-					pPSD->MineralText[0].baseline.y + 7;
+			pPSD->MineralText[1].baseline.x = pPSD->MineralText[0].baseline.x;
+			pPSD->MineralText[1].baseline.y = pPSD->MineralText[0].baseline.y + (7 << RESOLUTION_FACTOR); // JMS_GFX
 			font_DrawText (&pPSD->MineralText[1]);
-			pPSD->MineralText[2].baseline.x =
-					pPSD->MineralText[1].baseline.x;
-			pPSD->MineralText[2].baseline.y =
-					pPSD->MineralText[1].baseline.y + 7;
+			pPSD->MineralText[2].baseline.x = pPSD->MineralText[1].baseline.x;
+			pPSD->MineralText[2].baseline.y = pPSD->MineralText[1].baseline.y + (7 << RESOLUTION_FACTOR); // JMS_GFX
 			font_DrawText (&pPSD->MineralText[2]);
 		}
 	}
@@ -1258,6 +1469,27 @@ ScrollPlanetSide (SIZE dx, SIZE dy, int
 }
 
 static void
+DrawSubmenuMineralValues (bool menu_visible)
+{
+	STAMP s;
+	CONTEXT OldContext;
+	
+	OldContext = SetContext (ScreenContext);
+
+	s.origin.x = 0;
+	s.origin.y = 0;
+		
+	if (menu_visible)
+		s.frame = SetAbsFrameIndex (SubmenuMineralsFrame, 1);
+	else
+		s.frame = SetAbsFrameIndex (SubmenuMineralsFrame, 0);
+
+	DrawStamp (&s);
+	
+	SetContext (OldContext);
+}
+
+static void
 animationInterframe (TimeCount *TimeIn, COUNT periods)
 {
 #define ANIM_FRAME_RATE  (ONE_SECOND / 30)
@@ -1274,7 +1506,7 @@ animationInterframe (TimeCount *TimeIn,
 }
 
 static void
-AnimateLaunch (FRAME farray)
+AnimateLaunch (FRAME farray, BOOLEAN landing)
 {
 	RECT r;
 	STAMP s;
@@ -1296,7 +1528,7 @@ AnimateLaunch (FRAME farray)
 		NextTime = GetTimeCounter () + (ONE_SECOND / 22);
 
 		BatchGraphics ();
-		RepairBackRect (&r);
+		RepairBackRect (&r, TRUE);
 #ifdef SPIN_ON_LAUNCH
 		RotatePlanetSphere (FALSE);
 #else
@@ -1314,7 +1546,10 @@ AnimateLaunch (FRAME farray)
 		LockMutex (GraphicsLock);
 	}
 
-	RepairBackRect (&r);
+	// This clears the last lander return / launch) anim frame from the planet window.
+	if (RESOLUTION_FACTOR == 0 || !landing)
+		RepairBackRect (&r, FALSE);
+	
 	UnlockMutex (GraphicsLock);
 }
 
@@ -1403,7 +1638,7 @@ static void
 InitPlanetSide (POINT pt)
 {
 	// Adjust landing location by a random jitter.
-#define RANDOM_MISS 64
+#define RANDOM_MISS (64 << RESOLUTION_FACTOR) // JMS_GFX
 	// Jitter the X landing point.
 	pt.x -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
 	if (pt.x < 0)
@@ -1497,9 +1732,9 @@ LanderFire (SIZE facing)
 
 	angle = FACING_TO_ANGLE (facing);
 	SetVelocityComponents (
-			&WeaponElementPtr->velocity,
-			COSINE (angle, WORLD_TO_VELOCITY (2 * 3)) + wdx,
-			SINE (angle, WORLD_TO_VELOCITY (2 * 3)) + wdy);
+		&WeaponElementPtr->velocity,
+		COSINE (angle, WORLD_TO_VELOCITY ((2 * 3) << RESOLUTION_FACTOR)) + wdx,
+		SINE (angle, WORLD_TO_VELOCITY ((2 * 3) << RESOLUTION_FACTOR)) + wdy); // JMS_GFX
 
 	UnlockElement (hWeaponElement);
 
@@ -1568,11 +1803,11 @@ DoPlanetSide (LanderInputState *pMS)
 
 		angle = FACING_TO_ANGLE (GetFrameIndex (LanderFrame[0]));
 		landerSpeedNumer = GET_GAME_STATE (IMPROVED_LANDER_SPEED) ?
-				WORLD_TO_VELOCITY (2 * 14) :
-				WORLD_TO_VELOCITY (2 * 8);
-
+			WORLD_TO_VELOCITY (2 * (14 << RESOLUTION_FACTOR)) :
+			WORLD_TO_VELOCITY (2 * (8 << RESOLUTION_FACTOR));
+		
 #ifdef FAST_FAST
-landerSpeedNumer = WORLD_TO_VELOCITY (48);
+landerSpeedNumer = WORLD_TO_VELOCITY (48 << RESOLUTION_FACTOR); // JMS
 #endif
 
 		SetVelocityComponents (&GLOBAL (velocity),
@@ -1635,11 +1870,11 @@ landerSpeedNumer = WORLD_TO_VELOCITY (48
 
 				angle = FACING_TO_ANGLE (index);
 				landerSpeedNumer = GET_GAME_STATE (IMPROVED_LANDER_SPEED) ?
-						WORLD_TO_VELOCITY (2 * 14) :
-						WORLD_TO_VELOCITY (2 * 8);
+						WORLD_TO_VELOCITY ((2 * 14) << RESOLUTION_FACTOR) :
+						WORLD_TO_VELOCITY ((2 * 8) << RESOLUTION_FACTOR);
 
 #ifdef FAST_FAST
-landerSpeedNumer = WORLD_TO_VELOCITY (48);
+landerSpeedNumer = WORLD_TO_VELOCITY (48 << RESOLUTION_FACTOR);
 #endif
 
 				SetVelocityComponents (&GLOBAL (velocity),
@@ -1736,6 +1971,9 @@ LoadLanderData (void)
 		for (i = 0; i < NUM_ORBIT_THEMES; ++i)
 			OrbitMusic[i] = load_orbit_theme (i);
 	}
+	
+	// JMS: This is a table of mineral values that will be shown on the status bar.
+	SubmenuMineralsFrame = CaptureDrawable (LoadGraphic (SUBMENUMINERALS_MASK_PMAP_ANIM));
 }
 
 void
@@ -1756,6 +1994,11 @@ ReturnToOrbit (void)
 
 	SetTransitionSource (&r);
 	BatchGraphics ();
+	
+	// JMS: This will hide the table of mineral values on the status bar.
+	if (optMineralSubmenu)
+		DrawSubmenuMineralValues (FALSE);
+		
 	DrawStarBackGround ();
 	DrawPlanetSurfaceBorder ();
 	RedrawSurfaceScan (NULL);
@@ -1775,7 +2018,7 @@ IdlePlanetSide (LanderInputState *inputS
 	while (GetTimeCounter () < TimeOut)
 	{
 		// 10 to clear the lander off of the screen
-		ScrollPlanetSide (0, 0, -(SURFACE_HEIGHT / 2 + 10));
+		ScrollPlanetSide (0, 0, -(SURFACE_HEIGHT / 2 + (10 << RESOLUTION_FACTOR))); // JMS_GFX
 		SleepThreadUntil (inputState->NextTime);
 		inputState->NextTime += PLANET_SIDE_RATE;
 	}
@@ -1785,21 +2028,35 @@ static void
 LandingTakeoffSequence (LanderInputState *inputState, BOOLEAN landing)
 {
 // We cannot solve a quadratic equation in a macro, so use a sensible max
-#define MAX_OFFSETS  20
-// 10 to clear the lander off of the screen
-#define DISTANCE_COVERED  (SURFACE_HEIGHT / 2 + 10)
+#define MAX_OFFSETS 20
+#define MAX_OFFSETS_4X 400 // JMS_GFX
+// 10 << RESOLUTION_FACTOR to clear the lander off of the screen
+#define DISTANCE_COVERED  (SURFACE_HEIGHT / 2 + (10 << RESOLUTION_FACTOR))
 	int landingOfs[MAX_OFFSETS];
 	int start;
 	int end;
 	int delta;
 	int index;
-
+	int max_offsets; // JMS_GFX
+	int landingOfs4x[MAX_OFFSETS_4X]; // JMS_GFX
+	
 	// Produce smooth acceleration deltas from a simple 1..x progression
 	delta = 0;
-	for (index = 0; index < MAX_OFFSETS && delta < DISTANCE_COVERED; ++index)
+	
+	// JMS_GFX: At 4x resolution we run out of default offsets. -> Use larger offset value.
+	max_offsets = MAX_OFFSETS;
+	if (RESOLUTION_FACTOR == 2) 
+		max_offsets = MAX_OFFSETS_4X;
+	
+	for (index = 0; index < max_offsets && delta < DISTANCE_COVERED; ++index)
 	{
 		delta += index + 1;
-		landingOfs[index] = -delta;
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 2)
+			landingOfs4x[index] = -delta;
+		else
+			landingOfs[index] = -delta;
 	}
 	assert (delta >= DISTANCE_COVERED && "Increase MAX_OFFSETS!");
 
@@ -1822,7 +2079,12 @@ LandingTakeoffSequence (LanderInputState
 	// Draw the landing/takeoff lander positions
 	for (index = start; index != end; index += delta)
 	{
-		ScrollPlanetSide (0, 0, landingOfs[index]);
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 2)
+			ScrollPlanetSide (0, 0, landingOfs4x[index]);
+		else
+			ScrollPlanetSide (0, 0, landingOfs[index]);
+		
 		SleepThreadUntil (inputState->NextTime);
 		inputState->NextTime += PLANET_SIDE_RATE;
 	}
@@ -1931,7 +2193,16 @@ PlanetSide (POINT planetLoc)
 	explosion_index = 0;
 
 	AnimateLanderWarmup ();
-	AnimateLaunch (LanderFrame[5]);
+	AnimateLaunch (LanderFrame[5], TRUE);
+
+	// JMS: This will show the table of mineral values on the status bar.
+	if (optMineralSubmenu)
+	{
+		LockMutex (GraphicsLock);
+		DrawSubmenuMineralValues (TRUE);
+		UnlockMutex (GraphicsLock);
+	}
+	
 	InitPlanetSide (planetLoc);
 
 	landerInputState.NextTime = GetTimeCounter () + PLANET_SIDE_RATE;
@@ -1962,7 +2233,7 @@ PlanetSide (POINT planetLoc)
 
 			LandingTakeoffSequence (&landerInputState, FALSE);
 			ReturnToOrbit ();
-			AnimateLaunch (LanderFrame[6]);
+			AnimateLaunch (LanderFrame[6], FALSE);
 			
 			LockMutex (GraphicsLock);
 			DeltaSISGauges (crew_left, 0, 0);
@@ -2086,9 +2357,8 @@ InitLander (BYTE LanderFlags)
 		if ((int)free_space < (int)(MAX_SCROUNGED << capacity_shift))
 		{
 			r.corner.x = 1;
-			r.extent.width = 4;
-			r.extent.height = MAX_SCROUNGED
-					- (free_space >> capacity_shift) + 1;
+			r.extent.width = RES_STAT_SCALE(4) + RESOLUTION_FACTOR; // JMS_GFX
+			r.extent.height = RES_STAT_SCALE(MAX_SCROUNGED - (free_space >> capacity_shift) + 1);
 			SetContextForeGroundColor (BLACK_COLOR);
 			DrawFilledRectangle (&r);
 		}
diff -ruNp ./src.orig/uqm/planets/orbits.c ./src/uqm/planets/orbits.c
--- ./src.orig/uqm/planets/orbits.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/orbits.c	2017-10-23 11:41:34 -0700
@@ -16,13 +16,16 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "planets.h"
 // XXX: for CurStarDescPtr
 #include "../encount.h"
+#include "../clock.h"
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
-
+#include <math.h>
 
 //#define DEBUG_ORBITS
 
@@ -462,7 +465,7 @@ YellowDistribution (BYTE which_world)
 }
 
 #define DWARF_ROCK_DIST MIN_PLANET_RADIUS
-#define DWARF_GASG_DIST SCALE_RADIUS (12)
+#define DWARF_GASG_DIST SCALE_RADIUS (12) 
 
 #define GIANT_ROCK_DIST SCALE_RADIUS (8)
 #define GIANT_GASG_DIST SCALE_RADIUS (13)
@@ -470,6 +473,24 @@ YellowDistribution (BYTE which_world)
 #define SUPERGIANT_ROCK_DIST SCALE_RADIUS (16)
 #define SUPERGIANT_GASG_DIST SCALE_RADIUS (33)
 
+void ComputeSpeed(PLANET_DESC *planet, BOOLEAN GeneratingMoons, UWORD rand_val)
+{
+	//BW : empiric values, which would give roughly correct
+	// rotation periods for most moons in the solar system
+	if (GeneratingMoons)
+		{
+			planet->orb_speed = FULL_CIRCLE / (29 * pow((double)planet->radius / (MIN_MOON_RADIUS + (MAX_MOONS - 1) * MOON_DELTA), 1.5));
+			if ((planet->pPrevDesc->data_index & ~PLANET_SHIELDED) >= FIRST_GAS_GIANT)
+				planet->orb_speed *= 2;
+			if (!(rand_val % 7))
+				planet->orb_speed = - planet->orb_speed;
+		}
+		else
+		{
+			planet->orb_speed = FULL_CIRCLE / (ONE_YEAR * pow((double)planet->radius / EARTH_RADIUS, 1.5));
+		}
+}
+
 void
 FillOrbits (SOLARSYS_STATE *system, BYTE NumPlanets,
 		PLANET_DESC *pBaseDesc, BOOLEAN TypesDefined)
@@ -522,7 +543,7 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 	{
 		BYTE chance;
 		DWORD rand_val;
-		COUNT min_radius, angle;
+		DWORD min_radius; //, angle; // JMS_GFX: Was COUNT. Changed to avoid overflows in 1280x960.
 		SIZE delta_r;
 		PLANET_DESC *pLocPD;
 
@@ -535,6 +556,9 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 				pPD->data_index =
 						(BYTE)(HIBYTE (LOWORD (rand_val)) % MaxPlanet);
 
+			// JMS: This exists for special colormaps of Sol system planets.
+			pPD->alternate_colormap = NULL;
+
 			chance = PLANET_NEVER;
 			switch (StarColor)
 			{
@@ -593,10 +617,25 @@ RelocatePlanet:
 		}
 
 		rand_val = TFB_Random ();
-		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
-		pPD->location.x = COSINE (angle, pPD->radius);
-		pPD->location.y = SINE (angle, pPD->radius);
-		pPD->rand_seed = MAKE_DWORD (pPD->location.x, pPD->location.y);
+		// Initial angle & coordinates as in Vanilla UQM
+		// Still used to compute rand_seed and the position
+		// of the planet at the start of the game
+		pPD->angle = NORMALIZE_ANGLE (LOWORD (rand_val));
+		pPD->location.x = COSINE (pPD->angle, pPD->radius);
+		pPD->location.y = SINE (pPD->angle, pPD->radius);
+		if (GeneratingMoons)
+		{
+		pPD->rand_seed = MAKE_DWORD (
+		     COSINE (pPD->angle, pPD->radius >> RESOLUTION_FACTOR),
+		     SINE (pPD->angle, pPD->radius >> RESOLUTION_FACTOR));
+		}
+		else
+		{
+			pPD->rand_seed = MAKE_DWORD (pPD->location.x, pPD->location.y);
+		}
+		// Angle is kept for reference but location will be adjusted
+		// to take orbiting into account
+		ComputeSpeed(pPD, GeneratingMoons, HIWORD (rand_val));
 
 		++pPD;
 	}
diff -ruNp ./src.orig/uqm/planets/pl_stuff.c ./src/uqm/planets/pl_stuff.c
--- ./src.orig/uqm/planets/pl_stuff.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/pl_stuff.c	2017-10-23 11:41:34 -0700
@@ -24,6 +24,7 @@
 #include "libs/mathlib.h"
 #include "scan.h"
 #include "options.h"
+#include "libs/log.h"
 
 #include <math.h>
 
@@ -38,6 +39,9 @@ static int rotDirection;
 static bool throbShield;
 static int rotPointIndex;
 
+static int rotwidth;
+static int rotheight;
+
 // Draw the planet sphere and any extra graphic (like a shield) if present
 void
 DrawPlanetSphere (int x, int y)
@@ -70,10 +74,13 @@ DrawDefaultPlanetSphere (void)
 }
 
 void
-InitSphereRotation (int direction, BOOLEAN shielded)
+InitSphereRotation (int direction, BOOLEAN shielded, COUNT width, COUNT height)
 {
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 
+	rotwidth = width;
+	rotheight = height;
+	
 	rotDirection = direction;
 	rotPointIndex = 0;
 	throbShield = shielded && optWhichShield == OPT_3DO;
@@ -122,13 +129,13 @@ PrepareNextRotationFrame (void)
 	// Go to next point, taking care of wraparounds
 	rotPointIndex += rotDirection;
 	if (rotPointIndex < 0)
-		rotPointIndex = MAP_WIDTH - 1;
-	else if (rotPointIndex >= MAP_WIDTH)
+		rotPointIndex = rotwidth - 1;
+	else if (rotPointIndex >= rotwidth)
 		rotPointIndex = 0;
 
 	// prepare the next sphere frame
 	Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, rotFrameIndex);
-	RenderPlanetSphere (Orbit->SphereFrame, rotPointIndex, throbShield);
+	RenderPlanetSphere (Orbit, Orbit->SphereFrame, rotPointIndex, pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED, throbShield, rotwidth, rotheight, (rotheight >> 1) - RESOLUTION_FACTOR); // RADIUS
 	
 	if (throbShield)
 	{	// prepare the next shield throb frame
@@ -139,6 +146,65 @@ PrepareNextRotationFrame (void)
 	}
 }
 
+void
+PrepareNextRotationFrameForIP (PLANET_DESC *pPlanetDesc, SIZE frameCounter)
+{
+	PLANET_ORBIT *Orbit = &pPlanetDesc->orbit;
+	COUNT framerate;
+	int oldPointIndex = pPlanetDesc->rotPointIndex;
+	// Go to next point, taking care of wraparounds
+
+	// No need to rotate planets that are off screen
+	if (pPlanetDesc->radius > 4 * pSolarSysState->SunDesc[0].radius)
+		return;
+
+	// Optimization : the smallest worlds are rotated only once in a while
+	// The framerate is fine-tuned so that the planet is updated
+	// when the landscape has moved 1 pixel approximately
+	switch (pPlanetDesc->size)
+	{
+	case 3: framerate = 15;
+		break;
+	case 4: framerate = 10;
+		break;
+	case 7: framerate = 4;
+		break;
+	case 11: framerate = 2;
+		break;
+	default: framerate = 1;
+		break;
+	}
+	if ((frameCounter % framerate) != 0)
+		return;
+
+	// BW: account for rotation period
+	pPlanetDesc->rotPointIndex = (int)(fmod(pPlanetDesc->rot_speed * daysElapsed(), pPlanetDesc->rotwidth));
+	if (pPlanetDesc->rotPointIndex < 0)
+		pPlanetDesc->rotPointIndex += pPlanetDesc->rotwidth;
+
+	// Nothing to do if there has been no visible rotation
+	if (pPlanetDesc->rotPointIndex == oldPointIndex)
+		return;
+
+	// Generate the next rotation frame
+	// We alternate between the frames because we do not call FlushGraphics()
+	// The frame we just drew may not have made it to the screen yet
+	pPlanetDesc->rotFrameIndex ^= 1;
+
+	// pPlanetDesc->rotPointIndex += pPlanetDesc->rotDirection;
+	// if (pPlanetDesc->rotPointIndex < 0)
+	//	pPlanetDesc->rotPointIndex = pPlanetDesc->rotwidth - 1;
+	// else if (pPlanetDesc->rotPointIndex >= pPlanetDesc->rotwidth)
+	//	pPlanetDesc->rotPointIndex = 0;
+
+	// prepare the next sphere frame
+	Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, pPlanetDesc->rotFrameIndex);
+	RenderPlanetSphere (Orbit, Orbit->SphereFrame, pPlanetDesc->rotPointIndex, pPlanetDesc->data_index & PLANET_SHIELDED, FALSE, pPlanetDesc->rotwidth, pPlanetDesc->rotheight, (pPlanetDesc->rotheight >> 1) - RESOLUTION_FACTOR); // RADIUS
+	Orbit->SphereFrame->image->dirty = TRUE;
+	// BW: slightly hacky but, in DrawTexturedBody, the call
+	// to DrawStamp won't re-blit the frame unless scale has changed.
+}
+
 #define ZOOM_RATE  24
 #define ZOOM_TIME  (ONE_SECOND * 6 / 5)
 
@@ -197,7 +263,7 @@ ZoomInPlanetSphere (void)
 
 		BatchGraphics ();
 		if (i > 0)
-			RepairBackRect (&repairRect);
+			RepairBackRect (&repairRect, FALSE);
 
 		oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
 		oldScale = SetGraphicScale ((int)(base * scale + 0.5));
diff -ruNp ./src.orig/uqm/planets/plandata.h ./src/uqm/planets/plandata.h
--- ./src.orig/uqm/planets/plandata.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/plandata.h	2017-10-23 11:41:34 -0700
@@ -137,6 +137,7 @@ enum
 	SUPER_DENSE_WORLD,
 	PELLUCID_WORLD,
 	DUST_WORLD,
+	//	EARTH_WORLD,
 	CRIMSON_WORLD,
 	CIMMERIAN_WORLD,
 	INFRARED_WORLD,
@@ -276,6 +277,16 @@ typedef struct
 	DWORD ScanSeed[NUM_SCAN_TYPES];
 	DWORD ScanRetrieveMask[NUM_SCAN_TYPES];
 
+	// JMS: This stores the amount of partially scavenged minerals.
+	//
+	// How it works: When the mineral deposits are generated in scan.c, first the deposit
+	// is given its normal kiloton-size (decided by pseudo-random number). Then, the value
+	// stored in this list is subtracted from the initial value.
+	// There can be max DWORD = 32 mineral deposits on the planet, thus the 32.
+	//
+	// This can be later made to support also partially scavenged biodata.
+	BYTE  PartiallyScavengedList[NUM_SCAN_TYPES][32];
+	
 	// The CurPt, CurDensity and CurType fields are filled in
 	// when a GENERATE_MINERAL, GENERATE_ENERGY, or GENERATE_LIFE
 	// call is made.
@@ -318,6 +329,17 @@ enum
 #define COLD_THRESHOLD -40
 #define HOT_THRESHOLD 100
 
+#define SOL_COLOR_TABS \
+	MERCURY_COLOR_TAB, \
+	VENUS_COLOR_TAB, \
+	EARTH_COLOR_TAB, \
+	MARS_COLOR_TAB, \
+	JUPITER_COLOR_TAB, \
+	SATURN_COLOR_TAB, \
+	URANUS_COLOR_TAB, \
+	NEPTUNE_COLOR_TAB, \
+	PLUTO_COLOR_TAB,
+
 /*------------------------------ Global Data ------------------------------ */
 
 #define NO_TECTONICS 0
diff -ruNp ./src.orig/uqm/planets/planets.c ./src/uqm/planets/planets.c
--- ./src.orig/uqm/planets/planets.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/planets.c	2017-10-23 11:41:34 -0700
@@ -34,7 +34,6 @@
 #include "options.h"
 #include "libs/graphics/gfx_common.h"
 
-
 // PlanetOrbitMenu() items
 enum PlanetMenuItems
 {
@@ -236,7 +235,11 @@ DrawOrbitalDisplay (DRAW_ORBITAL_MODE Mo
 	UnbatchGraphics ();
 
 	// for later RepairBackRect()
-	LoadIntoExtraScreen (&r);
+	// JMS_GFX
+	if (RESOLUTION_FACTOR == 0)
+		LoadIntoExtraScreen (&r);
+	else
+		LoadIntoExtraScreen_Fs (&r);
 }
 
 // Initialise the surface graphics, and start the planet music.
@@ -296,7 +299,7 @@ LoadPlanet (FRAME SurfDefFrame)
 void
 FreePlanet (void)
 {
-	COUNT i;
+	COUNT i, j;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 
 	UninitSphereRotation ();
@@ -340,6 +343,19 @@ FreePlanet (void)
 	Orbit->TopoColors = NULL;
 	HFree (Orbit->ScratchArray);
 	Orbit->ScratchArray = NULL;
+	if (Orbit->map_rotate && Orbit->light_diff)
+	{
+		for (j=0 ; j < MAP_HEIGHT+1 ; j++)
+		{
+			HFree (Orbit->map_rotate[j]);
+			HFree (Orbit->light_diff[j]);
+		}
+	}
+
+	HFree (Orbit->map_rotate);
+	Orbit->map_rotate = NULL;
+	HFree (Orbit->light_diff);
+	Orbit->light_diff = NULL;
 
 	DestroyStringTable (ReleaseStringTable (
 			pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
diff -ruNp ./src.orig/uqm/planets/planets.h ./src/uqm/planets/planets.h
--- ./src.orig/uqm/planets/planets.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/planets.h	2017-10-23 11:41:34 -0700
@@ -16,11 +16,22 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef _PLANETS_H
 #define _PLANETS_H
 
 #define END_INTERPLANETARY START_INTERPLANETARY
 
+#define ORBITING_PLANETS TRUE
+#define ROTATING_PLANETS optRotatingIpPlanets
+#define TEXTURED_PLANETS (optTexturedIpPlanets || ROTATING_PLANETS)
+// TEXTURED_PLANETS should always be defined TRUE if ROTATING_PLANETS is.
+#define ONE_YEAR 365.25
+#ifndef M_PI
+#define M_PI 3.141592653589
+#endif
+
 enum PlanetScanTypes
 {
 	MINERAL_SCAN = 0,
@@ -31,7 +42,9 @@ enum PlanetScanTypes
 };
 
 #define MAP_WIDTH SIS_SCREEN_WIDTH
-#define MAP_HEIGHT (75 - SAFE_Y)
+#define MAP_HEIGHT RES_CASE(75,150,330) // JMS_GFX
+#define ORIGINAL_MAP_WIDTH 242			// JMS_GFX
+#define ORIGINAL_MAP_HEIGHT 75			// JMS_GFX
 
 enum
 {
@@ -67,18 +80,18 @@ enum
 
 #define NUM_SCANDOT_TRANSITIONS 4
 
-#define MIN_MOON_RADIUS 35
-#define MOON_DELTA 20
+#define MIN_MOON_RADIUS (35 << RESOLUTION_FACTOR) // JMS_GFX
+#define MOON_DELTA (20 << RESOLUTION_FACTOR) // JMS_GFX
 
 #define MAX_SUNS 1
 #define MAX_PLANETS 16
 #define MAX_MOONS 4
 
-#define MAP_BORDER_HEIGHT  5
+#define MAP_BORDER_HEIGHT  RES_CASE(5,10,10) // JMS_GFX
 #define SCAN_SCREEN_HEIGHT (SIS_SCREEN_HEIGHT - MAP_HEIGHT - MAP_BORDER_HEIGHT)
 
 #define PLANET_ROTATION_TIME (ONE_SECOND * 12)
-#define PLANET_ROTATION_RATE (PLANET_ROTATION_TIME / MAP_WIDTH)
+#define PLANET_ROTATION_RATE (PLANET_ROTATION_TIME / ORIGINAL_MAP_WIDTH) // JMS_GFX
 // XXX: -9 to match the original, but why? I have no idea
 #define PLANET_ORG_Y ((SCAN_SCREEN_HEIGHT - 9) / 2)
 
@@ -99,6 +112,40 @@ typedef struct solarsys_state SOLARSYS_S
 #include "plandata.h"
 #include "sundata.h"
 
+typedef struct 
+{
+	POINT p[4];
+	DWORD m[4];
+} MAP3D_POINT;
+
+struct planet_orbit
+{
+	FRAME TopoZoomFrame;
+			// 4x scaled topo image for planet-side
+	SBYTE  *lpTopoData;
+			// normal topo data; expressed in elevation levels
+			// data is signed for planets other than gas giants
+			// transformed to light variance map for 3d planet
+	FRAME SphereFrame;
+			// rotating 3d planet frames (current and next)
+	FRAME ObjectFrame;
+			// any extra planetary object (shield, atmo, rings)
+			// automatically drawn if present
+	FRAME TintFrame;
+			// tinted topo images for current scan type (dynamic)
+	Color TintColor;
+			// the color of the last used tint
+	Color *TopoColors;
+			// RGBA version of topo image; for 3d planet
+	Color *ScratchArray;
+			// temp RGBA data for whatever transforms (nuked often)
+	FRAME WorkFrame;
+			// any extra frame workspace (for dynamic objects)
+	// BW: extra stuff for animated IP
+	DWORD **light_diff;
+	MAP3D_POINT **map_rotate;
+	// doubly dynamically allocated depending on map size
+};
 
 struct planet_desc
 {
@@ -107,7 +154,10 @@ struct planet_desc
 	BYTE data_index;
 	BYTE NumPlanets;
 	SIZE radius;
+	COUNT angle;
 	POINT location;
+	double orb_speed;
+	double rot_speed;
 
 	Color temp_color;
 	COUNT NextIndex;
@@ -115,6 +165,12 @@ struct planet_desc
 
 	PLANET_DESC *pPrevDesc;
 			// The Sun or planet that this world is orbiting around.
+	// BW : new stuff for animated solar systems
+	PLANET_ORBIT orbit;
+	COUNT size;
+	int rotFrameIndex, rotPointIndex, rotDirection, rotwidth, rotheight;
+	
+	RESOURCE alternate_colormap; // JMS: Special color maps for Sol system planets
 };
 
 struct star_desc
@@ -128,31 +184,6 @@ struct star_desc
 
 typedef void (*PLAN_GEN_FUNC) (BYTE control);
 
-struct planet_orbit
-{
-	FRAME TopoZoomFrame;
-			// 4x scaled topo image for planet-side
-	SBYTE  *lpTopoData;
-			// normal topo data; expressed in elevation levels
-			// data is signed for planets other than gas giants
-			// transformed to light variance map for 3d planet
-	FRAME SphereFrame;
-			// rotating 3d planet frames (current and next)
-	FRAME ObjectFrame;
-			// any extra planetary object (shield, atmo, rings)
-			// automatically drawn if present
-	FRAME TintFrame;
-			// tinted topo images for current scan type (dynamic)
-	Color TintColor;
-			// the color of the last used tint
-	Color *TopoColors;
-			// RGBA version of topo image; for 3d planet
-	Color *ScratchArray;
-			// temp RGBA data for whatever transforms (nuked often)
-	FRAME WorkFrame;
-			// any extra frame workspace (for dynamic objects)
-};
-
 // See doc/devel/generate for information on how this structure is
 // filled.
 struct solarsys_state
@@ -257,16 +288,18 @@ extern void XFormIPLoc (POINT *pIn, POIN
 extern PLAN_GEN_FUNC GenerateIP (BYTE Index);
 extern void DrawOval (RECT *pRect, BYTE num_off_pixels);
 extern void DrawFilledOval (RECT *pRect);
+extern void ComputeSpeed(PLANET_DESC *planet, BOOLEAN GeneratingMoons, UWORD rand_val);
 extern void FillOrbits (SOLARSYS_STATE *system, BYTE NumPlanets,
 		PLANET_DESC *pBaseDesc, BOOLEAN TypesDefined);
 extern void InitLander (BYTE LanderFlags);
 
-extern void InitSphereRotation (int direction, BOOLEAN shielded);
+extern void InitSphereRotation (int direction, BOOLEAN shielded, COUNT width, COUNT height);
 extern void UninitSphereRotation (void);
 extern void PrepareNextRotationFrame (void);
+extern void PrepareNextRotationFrameForIP (PLANET_DESC *pPlanetDesc, SIZE frameCounter);
 extern void DrawPlanetSphere (int x, int y);
 extern void DrawDefaultPlanetSphere (void);
-extern void RenderPlanetSphere (FRAME Frame, int offset, BOOLEAN doThrob);
+extern void RenderPlanetSphere (PLANET_ORBIT *Orbit, FRAME Frame, int offset, BOOLEAN shielded, BOOLEAN doThrob, COUNT width, COUNT height, COUNT radius);
 extern void SetShieldThrobEffect (FRAME FromFrame, int offset, FRAME ToFrame);
 
 extern void ZoomInPlanetSphere (void);
@@ -275,6 +308,8 @@ extern void RotatePlanetSphere (BOOLEAN
 extern void DrawScannedObjects (BOOLEAN Reversed);
 extern void GeneratePlanetSurface (PLANET_DESC *pPlanetDesc,
 		FRAME SurfDefFrame);
+extern void GeneratePlanetSurfaceForIP (PLANET_DESC *pPlanetDesc,
+		FRAME SurfDefFrame, COUNT width, COUNT height);
 extern void DeltaTopography (COUNT num_iterations, SBYTE *DepthArray,
 		RECT *pRect, SIZE depth_delta);
 
diff -ruNp ./src.orig/uqm/planets/plangen.c ./src/uqm/planets/plangen.c
--- ./src.orig/uqm/planets/plangen.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/plangen.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// BW 2011: fixed using pixmaps to define planet surfaces so it actually works
+// on planets you can land on. The second frame of planetmask.ani has to be a
+// (Black & White) indexed pic with 128 colors top. Lesser indices (black)
+// will correspond to lower altitudes.
+
 #include "planets.h"
 #include "scan.h"
 #include "../nameref.h"
@@ -30,7 +35,6 @@
 #include <math.h>
 #include <time.h>
 
-
 #undef PROFILE_ROTATION
 
 // define USE_ALPHA_SHIELD to use an aloha overlay instead of
@@ -41,7 +45,7 @@
 #define SHIELD_REFLECT_COMP 100
 
 #define NUM_BATCH_POINTS 64
-#define RADIUS 37
+#define RADIUS RES_CASE(37,74,163) // JMS_GFX
 //2*RADIUS
 #define TWORADIUS (RADIUS << 1)
 //RADIUS^2
@@ -72,77 +76,84 @@
 #define M_DEG2RAD (M_TWOPI / 360.0)
 #endif
 
-DWORD light_diff[DIAMETER][DIAMETER];
-
-typedef struct 
-{
-	POINT p[4];
-	DWORD m[4];
-} MAP3D_POINT;
-
-MAP3D_POINT map_rotate[DIAMETER][DIAMETER];
+// BW: dynamically allocated in the orbit structure
+// JMS_GFX: Changed initialization to constant numbers since DIAMETER is now variably defined
+// The value 330 is the value that's reached at the biggest resolution, 4x.
+// DWORD light_diff[330][330]; //DWORD light_diff[DIAMETER][DIAMETER];
+
+// BW: Moved to planets.h
+// typedef struct 
+// {
+// 	POINT p[4];
+// 	DWORD m[4];
+// } MAP3D_POINT;
+
+// BW: dynamically allocated in the orbit structure
+// JMS_GFX: Changed initialization to constant numbers since DIAMETER is now variably defined
+// The value 330 is the value that's reached at the biggest resolution, 4x.
+// MAP3D_POINT map_rotate[330][330];//MAP3D_POINT map_rotate[DIAMETER][DIAMETER];
 
 typedef struct
 {
 	double x, y, z;
 } POINT3;
 
+// BW : changed rendering method to direct SDL routines like in
+// RenderPlanetSphere to improve performance at 4x
 static void
-RenderTopography (FRAME DstFrame, SBYTE *pTopoData, int w, int h)
+RenderTopography (FRAME DstFrame, SBYTE *pTopoData, int w, int h, BOOLEAN SurfDef)
 {
-	FRAME OldFrame;
-
-	OldFrame = SetContextFGFrame (DstFrame);
-
 	if (pSolarSysState->XlatRef == 0)
 	{
 		// There is currently nothing we can do w/o an xlat table
 		// This is still called for Earth for 4x scaled topo, but we
 		// do not need it because we cannot land on Earth.
+		log_add(log_Warning, "No xlat table -- could not generate surface.\n");
 	}
 	else
 	{
-		COUNT i;
 		BYTE AlgoType;
 		SIZE base, d;
 		const XLAT_DESC *xlatDesc;
 		POINT pt;
 		const PlanetFrame *PlanDataPtr;
-		PRIMITIVE BatchArray[NUM_BATCH_POINTS];
-		PRIMITIVE *pBatch;
 		SBYTE *pSrc;
 		const BYTE *xlat_tab;
 		BYTE *cbase;
-		POINT oldOrigin;
-		RECT ClipRect;
+		Color *pix;
+		Color *map;
+		BYTE ColorShift; // JMS
 
-		oldOrigin = SetContextOrigin (MAKE_POINT (0, 0));
-		GetContextClipRect (&ClipRect);
-		SetContextClipRect (NULL);
-
-		pBatch = &BatchArray[0];
-		for (i = 0; i < NUM_BATCH_POINTS; ++i, ++pBatch)
-		{
-			SetPrimNextLink (pBatch, i + 1);
-			SetPrimType (pBatch, POINT_PRIM);
-		}
-		SetPrimNextLink (&pBatch[-1], END_OF_LIST);
+		map = HMalloc (sizeof (Color) * w * h);
+		pix = map;
 
 		PlanDataPtr = &PlanData[
 				pSolarSysState->pOrbitalDesc->data_index & ~PLANET_SHIELDED
 				];
 		AlgoType = PLANALGO (PlanDataPtr->Type);
-		base = PlanDataPtr->base_elevation;
+		if (SurfDef)
+			{
+				// Planets given by a pixmap have elevations between -128 and +128
+				base = 256;
+			}
+		else
+			{
+				base = PlanDataPtr->base_elevation;
+			}
 		xlatDesc = (const XLAT_DESC *) pSolarSysState->XlatPtr;
 		xlat_tab = (const BYTE *) xlatDesc->xlat_tab;
 		cbase = GetColorMapAddress (pSolarSysState->OrbitalCMap);
 
-		i = NUM_BATCH_POINTS;
-		pBatch = &BatchArray[i];
+		// JMS: This is for using 8-bits per color channel .ct files for e.g. Mars.
+		if (SurfDef)
+			ColorShift = 3;
+		else
+			ColorShift = 1;
+
 		pSrc = pTopoData;
 		for (pt.y = 0; pt.y < h; ++pt.y)
 		{
-			for (pt.x = 0; pt.x < w; ++pt.x, ++pSrc)
+			for (pt.x = 0; pt.x < w; ++pt.x, ++pSrc, ++pix)
 			{
 				BYTE *ctab;
 
@@ -160,37 +171,19 @@ RenderTopography (FRAME DstFrame, SBYTE
 						d = 255;
 				}
 
-				--pBatch;
-				pBatch->Object.Point.x = pt.x;
-				pBatch->Object.Point.y = pt.y;
-
 				d = xlat_tab[d] - cbase[0];
 				ctab = (cbase + 2) + d * 3;
 
 				// fixed planet surfaces being too dark
 				// ctab shifts were previously >> 3 .. -Mika
-				SetPrimColor (pBatch, BUILD_COLOR (MAKE_RGB15 (ctab[0] >> 1,
-								ctab[1] >> 1, ctab[2] >> 1), d));
-				
-				if (--i == 0)
-				{	// flush the batch and start the next one
-					DrawBatch (BatchArray, 0, 0);
-					i = NUM_BATCH_POINTS;
-					pBatch = &BatchArray[i];
-				}
+				*pix = BUILD_COLOR (MAKE_RGB15 (ctab[0] >> ColorShift, 
+					ctab[1] >> ColorShift, ctab[2] >> ColorShift), d);				
 			}
 		}
 
-		if (i < NUM_BATCH_POINTS)
-		{
-			DrawBatch (BatchArray, i, 0);
-		}
-
-		SetContextClipRect (&ClipRect);
-		SetContextOrigin (oldOrigin);
+		WriteFramePixelColors (DstFrame, map, w, h);
+		HFree(map);
 	}
-
-	SetContextFGFrame (OldFrame);
 }
 
 static inline void
@@ -225,13 +218,16 @@ P3norm (POINT3 *res, POINT3 *vec)
 // GenerateSphereMask builds a shadow map for the rotating planet
 //  loc indicates the planet's position relative to the sun
 static void
-GenerateSphereMask (POINT loc)
+GenerateSphereMask (POINT loc, COUNT radius)
 {
 	POINT pt;
 	POINT3 light;
 	double lrad;
 	const DWORD step = 1 << DIFFUSE_BITS;
 	int y, x;
+	COUNT tworadius = radius << 1;
+	COUNT radius_thres = (radius + 1) * (radius + 1);
+	COUNT radius_2 = radius * radius;
 
 #define AMBIENT_LIGHT 0.1
 #define LIGHT_Z       1.2
@@ -244,11 +240,11 @@ GenerateSphereMask (POINT loc)
 	light.z = LIGHT_Z * lrad;
 	P3norm (&light, &light);
 	
-	for (pt.y = 0, y = -RADIUS; pt.y <= TWORADIUS; ++pt.y, y++)
+	for (pt.y = 0, y = -radius; pt.y <= tworadius; ++pt.y, y++)
 	{
 		DWORD y_2 = y * y;
 
-		for (pt.x = 0, x = -RADIUS; pt.x <= TWORADIUS; ++pt.x, x++)
+		for (pt.x = 0, x = -radius; pt.x <= tworadius; ++pt.x, x++)
 		{
 			DWORD x_2 = x * x;
 			DWORD rad_2 = x_2 + y_2;
@@ -256,13 +252,13 @@ GenerateSphereMask (POINT loc)
 			POINT3 norm;
 			double diff;
 			
-			if (rad_2 < RADIUS_THRES) 
+			if (rad_2 < radius_thres) 
 			{
 				// norm is the sphere's surface normal.
 				norm.x = (double)x;
 				norm.y = (double)y;
-				norm.z = (sqrt (RADIUS_2 - x_2) * sqrt (RADIUS_2 - y_2)) /
-						RADIUS;
+				norm.z = (sqrt (radius_2 - x_2) * sqrt (radius_2 - y_2)) /
+						radius;
 				P3norm (&norm, &norm);
 				// diffuse component is norm dot light
 				diff = P3dot (&norm, &light);
@@ -305,9 +301,9 @@ GenerateSphereMask (POINT loc)
 				if (diff < AMBIENT_LIGHT)
 					diff = AMBIENT_LIGHT;
 				// Now we antialias the edge of the spere to look nice
-				if (rad_2 > RADIUS_2) 
+				if (rad_2 > radius_2) 
 				{
-					diff *= 1 - (sqrt(rad_2) - RADIUS);
+					diff *= 1 - (sqrt(rad_2) - radius);
 					if (diff < 0) 
 						diff = 0;
 				}
@@ -316,7 +312,7 @@ GenerateSphereMask (POINT loc)
 				diff_int = (DWORD)(diff * step);
 			}
 
-			light_diff[pt.y][pt.x] = diff_int;
+			pSolarSysState->Orbit.light_diff[pt.y][pt.x] = diff_int;
 		}
 	}
 }
@@ -326,21 +322,22 @@ GenerateSphereMask (POINT loc)
 //  the concept is to compute the weight based on the
 //  distance from the integer location points to the ideal point
 static void
-create_aa_points (MAP3D_POINT *ppt, double x, double y)
+create_aa_points (MAP3D_POINT *ppt, double x, double y, COUNT height)
 {
 	double deltax, deltay, inv_deltax, inv_deltay;
 	COORD nextx, nexty;
 	COUNT i;
 	double d1, d2, d3, d4, m[4];
+	COUNT spherespanx = height;
 
 	if (x < 0)
 		x = 0;
-	else if (x >= SPHERE_SPAN_X)
-		x = SPHERE_SPAN_X - 1;
+	else if (x >= spherespanx)
+		x = spherespanx - 1;
 	if (y < 0)
 		y = 0;
-	else if (y >= MAP_HEIGHT)
-		y = MAP_HEIGHT - 1;
+	else if (y >= height)
+		y = height - 1;
 
 	// get  the integer value of this point
 	ppt->p[0].x = (COORD)x;
@@ -437,30 +434,32 @@ get_avg_channel (Color p[4], DWORD mult[
 // CreateSphereTiltMap creates 'map_rotate' to map the topo data
 //  for a tilted planet.  It also does the sphere->plane mapping
 static void
-CreateSphereTiltMap (int angle)
+CreateSphereTiltMap (int angle, COUNT height, COUNT radius)
 {
 	int x, y;
-	const double multx = ((double)SPHERE_SPAN_X / M_PI);
-	const double multy = ((double)MAP_HEIGHT / M_PI);
-	const double xadj = ((double)SPHERE_SPAN_X / 2.0);
+	COUNT spherespanx = height;
+	COUNT radius_thres = (radius + 1) * (radius + 1);
+	const double multx = ((double)spherespanx / M_PI);
+	const double multy = ((double)height / M_PI);
+	const double xadj = ((double)spherespanx / 2.0);
 
-	for (y = -RADIUS; y <= RADIUS; y++)
+	for (y = -radius; y <= radius; y++)
 	{
 		int y_2 = y * y;
 
-		for (x = -RADIUS; x <= RADIUS; x++)
+		for (x = -radius; x <= radius; x++)
 		{
 			double dx, dy, newx, newy;
 			double da, rad, rad_2;
 			double xa, ya;
-			MAP3D_POINT *ppt = &map_rotate[y + RADIUS][x + RADIUS];
+			MAP3D_POINT *ppt = &pSolarSysState->Orbit.map_rotate[y + radius][x + radius];
 			
 			rad_2 = x * x + y_2;
 
-			if (rad_2 >= RADIUS_THRES)
+			if (rad_2 >= radius_thres)
 			{	// pixel won't be present
-				ppt->p[0].x = x + RADIUS;
-				ppt->p[0].y = y + RADIUS;
+				ppt->p[0].x = x + radius;
+				ppt->p[0].y = y + radius;
 				ppt->m[0] = 0;
 
 				continue;
@@ -468,8 +467,8 @@ CreateSphereTiltMap (int angle)
 			
 			rad = sqrt (rad_2);
 			// antialiasing goes beyond the actual radius
-			if (rad >= RADIUS)
-				rad = (double)RADIUS - 0.1;
+			if (rad >= radius)
+				rad = (double)radius - 0.1;
 			
 			da = atan2 ((double)y, (double)x);
 			// compute the planet-tilt
@@ -478,8 +477,8 @@ CreateSphereTiltMap (int angle)
 			dy = rad * sin (da);
 
 			// Map the sphere onto a plane
-			xa = acos (-dx / RADIUS);
-			ya = acos (-dy / RADIUS);
+			xa = acos (-dx / radius);
+			ya = acos (-dy / radius);
 			newx = multx * xa;
 			newy = multy * ya;
 			// Adjust for vertical curvature
@@ -488,7 +487,7 @@ CreateSphereTiltMap (int angle)
 			else
 				newx = xadj + ((newx - xadj) / sin (ya));
 
-			create_aa_points (ppt, newx, newy);
+			create_aa_points (ppt, newx, newy, height);
 		}
 	}
 }
@@ -501,34 +500,38 @@ CreateSphereTiltMap (int angle)
 // this routine, but a filter can be applied if desired too.
 
 // HALO rim size
-#define SHIELD_HALO          7
+#define SHIELD_HALO          (7 << RESOLUTION_FACTOR) // JMS_GFX
 #define SHIELD_RADIUS        (RADIUS + SHIELD_HALO)
 #define SHIELD_DIAM          ((SHIELD_RADIUS << 1) + 1)
 #define SHIELD_RADIUS_2      (SHIELD_RADIUS * SHIELD_RADIUS)
-#define SHIELD_RADIUS_THRES  ((SHIELD_RADIUS + 1) * (SHIELD_RADIUS + 1))
+#define SHIELD_RADIUS_THRES  ((SHIELD_RADIUS + (1 << RESOLUTION_FACTOR)) * (SHIELD_RADIUS + (1 << RESOLUTION_FACTOR))) // JMS_GFX
 #define SHIELD_HALO_GLOW     (SHIELD_GLOW_COMP + SHIELD_REFLECT_COMP)
 #define SHIELD_HALO_GLOW_MIN (SHIELD_HALO_GLOW >> 2)
 
 static FRAME
-CreateShieldMask (void)
+CreateShieldMask (COUNT radius)
 {
 	Color clear;
 	Color *pix;
 	int x, y;
 	FRAME ShieldFrame;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-
+	COUNT shieldradius = SHIELD_RADIUS * radius / RADIUS;
+	COUNT shielddiam = (shieldradius << 1) + 1;
+	COUNT radius_2 = radius * radius;
+	COUNT shieldradius_thres = (shieldradius + 1) * (shieldradius + 1);
+	
 	ShieldFrame = CaptureDrawable (
 			CreateDrawable (WANT_PIXMAP | WANT_ALPHA,
-				SHIELD_DIAM, SHIELD_DIAM, 1));
+				shielddiam, shielddiam, 1));
 
 	pix = Orbit->ScratchArray;
 	//  This is 100% transparent.
 	clear = BUILD_COLOR_RGBA (0, 0, 0, 0);
 
-	for (y = -SHIELD_RADIUS; y <= SHIELD_RADIUS; y++)
+	for (y = -shieldradius; y <= shieldradius; y++)
 	{
-		for (x = -SHIELD_RADIUS; x <= SHIELD_RADIUS; ++x, ++pix)
+		for (x = -shieldradius; x <= shieldradius; ++x, ++pix)
 		{
 			int rad_2 = x * x + y * y;
 			// This is a non-transparent red for the halo
@@ -536,13 +539,13 @@ CreateShieldMask (void)
 			int alpha = 255;
 			double rad;
 			
-			if (rad_2 >= SHIELD_RADIUS_THRES)
+			if (rad_2 >= shieldradius_thres)
 			{	// outside all bounds
 				*pix = clear;
 				continue;
 			}
 			// Inside the halo
-			if (rad_2 <= RADIUS_2)
+			if (rad_2 <= radius_2)
 			{	// planet's pixels, ours transparent
 				*pix = clear;
 				continue;
@@ -551,16 +554,16 @@ CreateShieldMask (void)
 			// The halo itself
 			rad = sqrt (rad_2);
 
-			if (rad <= RADIUS + 0.8)
+			if (rad <= radius + 0.8)
 			{	// pixels common between the shield and planet
 				// do antialiasing using alpha
-				alpha = (int) (red * (rad - RADIUS));
+				alpha = (int) (red * (rad - radius));
 				red = 255;
 			}
 			else
 			{	// shield pixels
-				red -= (int) ((red - SHIELD_HALO_GLOW_MIN) * (rad - RADIUS)
-						/ SHIELD_HALO);
+				red -= (int) ((red - SHIELD_HALO_GLOW_MIN) * (rad - radius)
+					      / (SHIELD_HALO * radius / RADIUS));
 				if (red < 0)
 					red = 0;
 			}
@@ -570,9 +573,9 @@ CreateShieldMask (void)
 	}
 	
 	WriteFramePixelColors (ShieldFrame, Orbit->ScratchArray,
-			SHIELD_DIAM, SHIELD_DIAM);
-	SetFrameHot (ShieldFrame, MAKE_HOT_SPOT (SHIELD_RADIUS + 1,
-				SHIELD_RADIUS + 1));
+			shielddiam, shielddiam);
+	SetFrameHot (ShieldFrame, MAKE_HOT_SPOT (shieldradius + 1,
+				shieldradius + 1));
 	
 	return ShieldFrame;
 }
@@ -589,13 +592,15 @@ CreateShieldMask (void)
 #define THROB_D_LEVEL   (THROB_MAX_LEVEL - THROB_MIN_LEVEL)
 
 static inline int
-shield_level (int offset)
+shield_level (int offset, int width)
 {
 	int level;
-
-	offset = (offset << 8) % THROB_CYCLE;
-	level = abs (offset - THROB_HALF_CYCLE);
-	level = THROB_MIN_LEVEL + level * THROB_D_LEVEL / THROB_HALF_CYCLE;
+	int throb_cycle = ((width << 8) / SHIELD_THROBS);
+	int throb_half_cycle = throb_cycle >> 1;
+	
+	offset = (offset << 8) % throb_cycle;
+	level = abs (offset - throb_half_cycle);
+	level = THROB_MIN_LEVEL + level * THROB_D_LEVEL / throb_half_cycle;
 
 	return level;
 }
@@ -611,10 +616,11 @@ SetShieldThrobEffect (FRAME ShieldFrame,
 	Color *pix;
 	int level;
 
-	level = shield_level (offset);
-
 	width = GetFrameWidth (ShieldFrame);
 	height = GetFrameHeight (ShieldFrame);
+
+	level = shield_level (offset, width);
+
 	ReadFramePixelColors (ShieldFrame, Orbit->ScratchArray, width, height);
 	
 	for (i = 0, pix = Orbit->ScratchArray; i < width * height; ++i, ++pix)
@@ -685,24 +691,25 @@ calc_map_light (UBYTE val, DWORD dif, in
 }
 
 static inline Color
-get_map_pixel (Color *pixels, int x, int y)
+get_map_pixel (Color *pixels, int x, int y, COUNT width, COUNT spherespanx)
 {
-	return pixels[y * (MAP_WIDTH + SPHERE_SPAN_X) + x];
+	/*if (y * (width + spherespanx) + x > 463000)
+		log_add(log_Warning,"x:%u, y:%u, width:%u, spherespanx:%u, slot:%u. Max:%u", x, y, width, spherespanx, y * (width + spherespanx) + x, (MAP_HEIGHT+1) * (MAP_WIDTH + spherespanx));*/
+	return pixels[y * (width + spherespanx) + x];
 }
 
 static inline int
-get_map_elev (SBYTE *elevs, int x, int y, int offset)
+get_map_elev (SBYTE *elevs, int x, int y, int offset, COUNT width)
 {
-	return elevs[y * MAP_WIDTH + (offset + x) % MAP_WIDTH];
+	return elevs[y * width + (offset + x) % width];
 }
 
 // RenderPlanetSphere builds a frame for the rotating planet view
 // offset is effectively the angle of rotation around the planet's axis
 // We use the SDL routines to directly write to the SDL_Surface to improve performance
 void
-RenderPlanetSphere (FRAME MaskFrame, int offset, BOOLEAN doThrob)
+RenderPlanetSphere (PLANET_ORBIT *Orbit, FRAME MaskFrame, int offset, BOOLEAN shielded, BOOLEAN doThrob, COUNT width, COUNT height, COUNT radius)
 {
-	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 	POINT pt;
 	Color *pix;
 	Color clear;
@@ -710,7 +717,10 @@ RenderPlanetSphere (FRAME MaskFrame, int
 	Color *pixels;
 	SBYTE *elevs;
 	int shLevel;
-
+	COUNT spherespanx = height;
+	COUNT tworadius = radius << 1;
+	COUNT diameter = tworadius + 1;
+	
 #if PROFILE_ROTATION
 	static clock_t t = 0;
 	static int frames_done = 1;
@@ -719,21 +729,21 @@ RenderPlanetSphere (FRAME MaskFrame, int
 #endif
 
 
-	shLevel = shield_level (offset);
+	shLevel = shield_level (offset, width);
 
 	pix = Orbit->ScratchArray;
 	clear = BUILD_COLOR_RGBA (0, 0, 0, 0);
 	pixels = Orbit->TopoColors + offset;
 	elevs = Orbit->lpTopoData;
 	
-	for (pt.y = 0, y = -RADIUS; pt.y <= TWORADIUS; ++pt.y, ++y)
+	for (pt.y = 0, y = -radius; pt.y <= tworadius; ++pt.y, ++y)
 	{
-		for (pt.x = 0, x = -RADIUS; pt.x <= TWORADIUS; ++pt.x, ++x, ++pix)
+		for (pt.x = 0, x = -radius; pt.x <= tworadius; ++pt.x, ++x, ++pix)
 		{
 			Color c;
-			DWORD diffus = light_diff[pt.y][pt.x];
+			DWORD diffus = Orbit->light_diff[pt.y][pt.x];
 			int i;
-			MAP3D_POINT *ppt = &map_rotate[pt.y][pt.x];
+			MAP3D_POINT *ppt = &Orbit->map_rotate[pt.y][pt.x];
 			int lvf; // light variance factor
 	
 			if (diffus == 0)
@@ -745,8 +755,8 @@ RenderPlanetSphere (FRAME MaskFrame, int
 			// get pixel from topo map and factor from light variance map
 			if (ppt->m[0] == 0) 
 			{	// exact pixel from the topo map
-				c = get_map_pixel (pixels, ppt->p[0].x, ppt->p[0].y);
-				lvf = get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y, offset);
+				c = get_map_pixel (pixels, ppt->p[0].x, ppt->p[0].y, width, spherespanx);
+				lvf = get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y, offset, width);
 			}
 			else
 			{	// fractional pixel -- blend from 4
@@ -755,7 +765,7 @@ RenderPlanetSphere (FRAME MaskFrame, int
 
 				// compute 'ideal' pixel
 				for (i = 0; i < 4; i++)
-					p[i] = get_map_pixel (pixels, ppt->p[i].x, ppt->p[i].y);
+					p[i] = get_map_pixel (pixels, ppt->p[i].x, ppt->p[i].y, width, spherespanx);
 				
 				c.r = get_avg_channel (p, ppt->m, 0);
 				c.g = get_avg_channel (p, ppt->m, 1);
@@ -764,13 +774,13 @@ RenderPlanetSphere (FRAME MaskFrame, int
 				// compute 'ideal' light variance
 				for (i = 0, lvsum = 0; i < 4; i++)
 					lvsum += get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y,
-							offset) * ppt->m[i];
+							       offset, width) * ppt->m[i];
 				lvf = lvsum >> AA_WEIGHT_BITS;
 			}
 		
 			// Apply the lighting model.  This also bounds the sphere
 			// to make it circular.
-			if (pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED)
+			if (shielded)
 			{
 				int r;
 				
@@ -808,12 +818,12 @@ RenderPlanetSphere (FRAME MaskFrame, int
 		}
 	}
 	
-	WriteFramePixelColors (MaskFrame, Orbit->ScratchArray, DIAMETER, DIAMETER);
-	SetFrameHot (MaskFrame, MAKE_HOT_SPOT (RADIUS + 1, RADIUS + 1));
+	WriteFramePixelColors (MaskFrame, Orbit->ScratchArray, diameter, diameter);
+	SetFrameHot (MaskFrame, MAKE_HOT_SPOT (radius + 1, radius + 1));
 
 #if PROFILE_ROTATION
 	t += clock() - t1;
-	if (frames_done == MAP_WIDTH)
+	if (frames_done == width)
 	{
 		log_add (log_Debug, "Rotation frames/sec: %d/%ld(msec)=%f",
 				frames_done,
@@ -831,14 +841,14 @@ RenderPlanetSphere (FRAME MaskFrame, int
 #define RANGE_SHIFT 6
 
 static void
-DitherMap (SBYTE *DepthArray)
+DitherMap (SBYTE *DepthArray, COUNT width, COUNT height)
 {
 #define DITHER_VARIANCE  (1 << (RANGE_SHIFT - 3))
-	COUNT i;
+	DWORD i;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
 	SBYTE *elev;
 	DWORD rand_val = 0;
 
-	for (i = 0, elev = DepthArray; i < MAP_WIDTH * MAP_HEIGHT; ++i, ++elev)
+	for (i = 0, elev = DepthArray; i < (DWORD)(width * height); ++i, ++elev)
 	{
 		// Use up the random value byte by byte
 		if ((i & 3) == 0)
@@ -853,14 +863,13 @@ DitherMap (SBYTE *DepthArray)
 
 static void
 MakeCrater (RECT *pRect, SBYTE *DepthArray, SIZE rim_delta, SIZE
-		crater_delta, BOOLEAN SetDepth)
+	    crater_delta, BOOLEAN SetDepth, COUNT width)
 {
 	COORD x, y, lf_x, rt_x;
 	SIZE A, B;
-	long Asquared, TwoAsquared,
-				Bsquared, TwoBsquared;
-	long d, dx, dy;
-	COUNT TopIndex, BotIndex, rim_pixels;
+	SDWORD Asquared, TwoAsquared, Bsquared, TwoBsquared;	// JMS_GFX: Was 'long' - type changed to conform to UQM's own types
+	SDWORD d, dx, dy;									// JMS_GFX: Was 'long' - type changed to conform to UQM's own types
+	DWORD TopIndex, BotIndex, rim_pixels;				// JMS_GFX: Was COUNT - type changed because of overflow at 4x
 
 	A = pRect->extent.width >> 1;
 	B = pRect->extent.height >> 1;
@@ -879,8 +888,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 
 	A += pRect->corner.x;
 	B += pRect->corner.y;
-	TopIndex = (B - y) * MAP_WIDTH;
-	BotIndex = (B + y) * MAP_WIDTH;
+	TopIndex = (B - y) * width;
+	BotIndex = (B + y) * width;
 	rim_pixels = 1;
 	while (dx < dy)
 	{
@@ -932,8 +941,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 			}
 		
 			--y;
-			TopIndex += MAP_WIDTH;
-			BotIndex -= MAP_WIDTH;
+			TopIndex += width;
+			BotIndex -= width;
 			dy -= TwoAsquared;
 			d -= dy;
 		}
@@ -1001,8 +1010,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 
 		rim_pixels = 1;
 		--y;
-		TopIndex += MAP_WIDTH;
-		BotIndex -= MAP_WIDTH;
+		TopIndex += width;
+		BotIndex -= width;
 		dy -= TwoAsquared;
 		d += Asquared - dy;
 	}
@@ -1044,9 +1053,9 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 #define NUM_BAND_COLORS 4
 
 static void
-MakeStorms (COUNT storm_count, SBYTE *DepthArray)
+MakeStorms (COUNT storm_count, SBYTE *DepthArray, COUNT width, COUNT height)
 {
-#define MAX_STORMS 8
+#define MAX_STORMS 12 // JMS_GFX: was 8
 	COUNT i;
 	RECT storm_r[MAX_STORMS];
 	RECT *pstorm_r;
@@ -1072,22 +1081,16 @@ MakeStorms (COUNT storm_count, SBYTE *De
 			switch (HIBYTE (hiword) & 31)
 			{
 				case 0:
-					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 2))
-							+ (MAP_HEIGHT >> 2);
+					pstorm_r->extent.height = (LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 2)) + (ORIGINAL_MAP_HEIGHT >> 2);
 					break;
 				case 1:
 				case 2:
 				case 3:
 				case 4:
-					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 3))
-							+ (MAP_HEIGHT >> 3);
+					pstorm_r->extent.height = (LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 3)) + (ORIGINAL_MAP_HEIGHT >> 3);
 					break;
 				default:
-					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 4))
-							+ 4;
+					pstorm_r->extent.height = (LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 4)) + 4;
 					break;
 			}
 
@@ -1098,14 +1101,16 @@ MakeStorms (COUNT storm_count, SBYTE *De
 			loword = LOWORD (rand_val);
 			hiword = HIWORD (rand_val);
 
-			pstorm_r->extent.width = pstorm_r->extent.height
-					+ (LOBYTE (loword) % pstorm_r->extent.height);
+			pstorm_r->extent.width = pstorm_r->extent.height + (LOBYTE (loword) % pstorm_r->extent.height);
 
-			pstorm_r->corner.x = HIBYTE (loword)
-					% (MAP_WIDTH - pstorm_r->extent.width);
-			pstorm_r->corner.y = LOBYTE (loword)
-					% (MAP_HEIGHT - pstorm_r->extent.height);
+			pstorm_r->corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - pstorm_r->extent.width);			
+			pstorm_r->corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - pstorm_r->extent.height);
 
+			pstorm_r->corner.x = pstorm_r->corner.x * width / ORIGINAL_MAP_WIDTH;
+			pstorm_r->extent.width = pstorm_r->extent.width * width / ORIGINAL_MAP_WIDTH;
+			pstorm_r->corner.y = pstorm_r->corner.y * height / ORIGINAL_MAP_HEIGHT;
+			pstorm_r->extent.height = pstorm_r->extent.height * height / ORIGINAL_MAP_HEIGHT;
+			
 			for (j = i + 1; j < storm_count; ++j)
 			{
 				COORD x, y;
@@ -1124,7 +1129,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 
 		} while (intersect);
 
-		MakeCrater (pstorm_r, DepthArray, 6, 6, FALSE);
+		MakeCrater (pstorm_r, DepthArray, 6, 6, FALSE, width);
 		++pstorm_r->corner.x;
 		++pstorm_r->corner.y;
 		pstorm_r->extent.width -= 2;
@@ -1132,8 +1137,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 
 		band_delta = HIBYTE (loword) & ((3 << RANGE_SHIFT) + 20);
 
-		MakeCrater (pstorm_r, DepthArray,
-				band_delta, band_delta, TRUE);
+		MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 		++pstorm_r->corner.x;
 		++pstorm_r->corner.y;
 		pstorm_r->extent.width -= 2;
@@ -1142,8 +1146,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		band_delta += 2;
 		if (pstorm_r->extent.width > 2 && pstorm_r->extent.height > 2)
 		{
-			MakeCrater (pstorm_r, DepthArray,
-					band_delta, band_delta, TRUE);
+			MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 			++pstorm_r->corner.x;
 			++pstorm_r->corner.y;
 			pstorm_r->extent.width -= 2;
@@ -1153,8 +1156,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		band_delta += 2;
 		if (pstorm_r->extent.width > 2 && pstorm_r->extent.height > 2)
 		{
-			MakeCrater (pstorm_r, DepthArray,
-					band_delta, band_delta, TRUE);
+			MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 			++pstorm_r->corner.x;
 			++pstorm_r->corner.y;
 			pstorm_r->extent.width -= 2;
@@ -1162,8 +1164,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		}
 
 		band_delta += 4;
-		MakeCrater (pstorm_r, DepthArray,
-				band_delta, band_delta, TRUE);
+		MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 	}
 }
 
@@ -1178,14 +1179,14 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 	UWORD loword, hiword;
 	DWORD rand_val;
 
-	band_height = pRect->extent.height / num_bands;
-	band_bump = pRect->extent.height % num_bands;
+	// band_height = pRect->extent.height / num_bands;
+	band_height = ORIGINAL_MAP_HEIGHT / num_bands;
+	// band_bump = pRect->extent.height % num_bands;
+	band_bump = ORIGINAL_MAP_HEIGHT % num_bands;
 	band_error = num_bands >> 1;
 	lpDst = DepthArray;
 
-	band_delta = ((LOWORD (TFB_Random ())
-			& (NUM_BAND_COLORS - 1)) << RANGE_SHIFT)
-			+ (1 << (RANGE_SHIFT - 1));
+	band_delta = ((LOWORD (TFB_Random ()) & (NUM_BAND_COLORS - 1)) << RANGE_SHIFT) + (1 << (RANGE_SHIFT - 1));
 	last_y = next_y = 0;
 	for (i = num_bands; i > 0; --i)
 	{
@@ -1202,19 +1203,19 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 			band_error += num_bands;
 		}
 		if (i == 1)
-			cur_y = pRect->extent.height;
+		        cur_y = pRect->extent.height;
 		else
 		{
 			RECT r;
 
-			cur_y = next_y
-					+ ((band_height - 2) >> 1)
-					- ((LOBYTE (hiword) % (band_height - 2)) + 1);
+			cur_y = next_y + ((band_height - 2) >> 1) - ((LOBYTE (hiword) % (band_height - 2)) + 1);
+			cur_y = cur_y * pRect->extent.height / ORIGINAL_MAP_HEIGHT;
 			r.corner.x = r.corner.y = 0;
 			r.extent.width = pRect->extent.width;
-			r.extent.height = 5;
+			// r.extent.height = 5;
+			r.extent.height = 5 * pRect->extent.height / ORIGINAL_MAP_HEIGHT;
 			DeltaTopography (50,
-					&DepthArray[(cur_y - 2) * r.extent.width],
+					 &DepthArray[(cur_y - (r.extent.height >>1)) * r.extent.width],
 					&r, depth_delta);
 		}
 
@@ -1232,21 +1233,21 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 				& (((1 << RANGE_SHIFT) * NUM_BAND_COLORS) - 1);
 	}
 
-	MakeStorms (4 + (TFB_Random () & 3) + 1, DepthArray);
+	MakeStorms (4 + (TFB_Random () & 7) + 1, DepthArray, pRect->extent.width, pRect->extent.height);
 
-	DitherMap (DepthArray);
+	DitherMap (DepthArray, pRect->extent.width, pRect->extent.height);
 }
 
 static void
-ValidateMap (SBYTE *DepthArray)
+ValidateMap (SBYTE *DepthArray, COUNT width, COUNT height)
 {
 	BYTE state;
 	BYTE pixel_count[2], lb[2];
 	SBYTE last_byte;
-	COUNT i;
+	DWORD i;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
 	SBYTE *lpDst;
 
-	i = MAP_WIDTH - 1;
+	i = width - 1;
 	lpDst = DepthArray;
 	last_byte = *lpDst++;
 	state = pixel_count[0] = pixel_count[1] = 0;
@@ -1268,7 +1269,7 @@ ValidateMap (SBYTE *DepthArray)
 		last_byte = *lpDst++;
 	} while (--i);
 
-	i = MAP_WIDTH * MAP_HEIGHT;
+	i = width * height;
 	lpDst = DepthArray;
 	if (pixel_count[0] > pixel_count[1])
 		last_byte = lb[0];
@@ -1291,24 +1292,40 @@ ValidateMap (SBYTE *DepthArray)
 }
 
 static void
-planet_orbit_init (void)
+planet_orbit_init (COUNT width, COUNT height, BOOLEAN forOrbit)
 {
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-
+	COUNT spherespanx = height;
+	COUNT shieldradius = (height >> 1) * SHIELD_RADIUS / RADIUS;
+	COUNT shielddiam = (shieldradius << 1) + 1;
+	COUNT diameter = height + 1;
+	COUNT i;
+	
 	Orbit->SphereFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP | WANT_ALPHA, DIAMETER, DIAMETER, 2));
-	Orbit->TintFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP, MAP_WIDTH, MAP_HEIGHT, 1));
+			WANT_PIXMAP | WANT_ALPHA, diameter, diameter, 2));
 	Orbit->ObjectFrame = 0;
 	Orbit->WorkFrame = 0;
-	Orbit->lpTopoData = HCalloc (MAP_WIDTH * MAP_HEIGHT);
-	Orbit->TopoZoomFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP, MAP_WIDTH << 2, MAP_HEIGHT << 2, 1));
+	Orbit->lpTopoData = HCalloc (width * height);
 	Orbit->TopoColors = HMalloc (sizeof (Orbit->TopoColors[0])
-			* (MAP_HEIGHT * (MAP_WIDTH + SPHERE_SPAN_X)));
+			* (height * (width + spherespanx)));
 	// always allocate the scratch array to largest needed size
 	Orbit->ScratchArray = HMalloc (sizeof (Orbit->ScratchArray[0])
-			* (SHIELD_DIAM) * (SHIELD_DIAM));
+			* (shielddiam) * (shielddiam));
+	Orbit->light_diff = HMalloc (sizeof (DWORD *) * diameter);
+	Orbit->map_rotate = HMalloc (sizeof (MAP3D_POINT *) * diameter);
+	for (i=0 ; i < diameter ; i++)
+	{
+		Orbit->light_diff[i] = HMalloc (sizeof (DWORD)* diameter);
+		Orbit->map_rotate[i] = HMalloc (sizeof (MAP3D_POINT) * diameter);
+	}
+
+	if (forOrbit)
+	{
+		Orbit->TintFrame = CaptureDrawable (CreateDrawable (
+				WANT_PIXMAP, width, height, 1));
+		Orbit->TopoZoomFrame = CaptureDrawable (CreateDrawable (
+				WANT_PIXMAP, width << 2, height << 2, 1));
+	}
 }
 
 static unsigned
@@ -1542,7 +1559,7 @@ TopoScale4x (SBYTE *pDstTopo, SBYTE *pSr
 // Lots of pure Voodoo here ;)
 //  the goal is a 3D illusion, not mathematically correct lighting
 
-#define LMAP_AVG_BLOCK    ((MAP_HEIGHT + 4) / 5)
+#define LMAP_AVG_BLOCK    ((75 + 4) / 5) // BW: hacky but this shouldn't really depend on the size of the original map
 #define LMAP_MAX_DIST     ((LMAP_AVG_BLOCK + 1) >> 1)
 #define LMAP_WEIGHT_THRES (LMAP_MAX_DIST * 2 / 3)
 
@@ -1555,7 +1572,7 @@ typedef struct
 } elev_block_t;
 
 static inline void
-get_vblock_avg (elev_block_t *pblk, SBYTE *pTopo, int x, int y)
+get_vblock_avg (elev_block_t *pblk, SBYTE *pTopo, int x, int y, COUNT width, COUNT height)
 {
 	SBYTE *elev = pTopo;
 	int y0, y1, i;
@@ -1563,17 +1580,17 @@ get_vblock_avg (elev_block_t *pblk, SBYT
 	int avg = 0, total_weight = 0;
 
 	// surface wraps around along x
-	x = (x + MAP_WIDTH) % MAP_WIDTH;
+	x = (x + width) % width;
 	
 	y0 = y - LMAP_MAX_DIST;
 	y1 = y + LMAP_MAX_DIST;
 	if (y0 < 0)
 		y0 = 0;
-	if (y1 > MAP_HEIGHT)
-		y1 = MAP_HEIGHT;
+	if (y1 > height)
+		y1 = height;
 
-	elev = pTopo + y0 * MAP_HEIGHT + x;
-	for (i = y0; i < y1; ++i, elev += MAP_HEIGHT)
+	elev = pTopo + y0 * height + x;
+	for (i = y0; i < y1; ++i, elev += height)
 	{
 		int delta = abs (i - y);
 		int weight = 255; // full weight
@@ -1604,14 +1621,17 @@ static void
 GenerateLightMap (SBYTE *pTopo, int w, int h)
 {
 #define LMAP_BLOCKS       (2 * LMAP_MAX_DIST + 1)
+	
 	int x, y;
-	elev_block_t vblocks[LMAP_BLOCKS];
-			// we use a running block average to reduce the amount of work
-			// where a block is a vertical line of map points
+	
 	SBYTE *elev;
 	int min, max, med;
 	int sfact, spread;
-
+	
+	elev_block_t vblocks[LMAP_BLOCKS];
+	// we use a running block average to reduce the amount of work
+	// where a block is a vertical line of map points
+	
 	// normalize the topo data
 	min = 127;
 	max = -128;
@@ -1663,7 +1683,7 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 			// blocks wrap around on both sides
 			pblk = vblocks + ((i + LMAP_BLOCKS) % LMAP_BLOCKS);
 
-			get_vblock_avg (pblk, pTopo, i, y);
+			get_vblock_avg (pblk, pTopo, i, y, w, h);
 		}
 
 		for (x = 0; x < w; ++x, ++elev)
@@ -1675,7 +1695,7 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 
 			// prepare next block as we move along x
 			pblk = vblocks + ((x + LMAP_MAX_DIST) % LMAP_BLOCKS);
-			get_vblock_avg (pblk, pTopo, x + LMAP_MAX_DIST, y);
+			get_vblock_avg (pblk, pTopo, x + LMAP_MAX_DIST, y, w, h);
 
 			// compute the min, max and weighted avg of blocks
 			for (i = x - LMAP_MAX_DIST; i <= x + LMAP_MAX_DIST; ++i)
@@ -1725,11 +1745,12 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	DWORD old_seed;
 	const PlanetFrame *PlanDataPtr;
 	PLANET_INFO *PlanetInfo = &pSolarSysState->SysInfo.PlanetInfo;
-	COUNT i, y;
+	DWORD i, y;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
 	POINT loc;
 	CONTEXT OldContext;
 	CONTEXT TopoContext;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
+	BOOLEAN SurfDef = FALSE;
 	BOOLEAN shielded = (pPlanetDesc->data_index & PLANET_SHIELDED) != 0;
 
 	old_seed = TFB_SeedRandom (pPlanetDesc->rand_seed);
@@ -1737,7 +1758,7 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	TopoContext = CreateContext ("Plangen.TopoContext");
 	LockMutex (GraphicsLock);
 	OldContext = SetContext (TopoContext);
-	planet_orbit_init ();
+	planet_orbit_init (MAP_WIDTH, (MAP_HEIGHT+1), TRUE); // JMS_GFX: Was MAP_HEIGHT without the +1. Added this to avoid overflows.
 
 	PlanDataPtr = &PlanData[pPlanetDesc->data_index & ~PLANET_SHIELDED];
 
@@ -1745,15 +1766,17 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	{	// This is a defined planet; pixmap for the topography and
 		// elevation data is supplied in Surface Definition frame
 		BOOLEAN DeleteDef = FALSE;
+		BOOLEAN DeleteElev = FALSE;
 		FRAME ElevFrame;
 
 		// surface pixmap
+		SurfDef = TRUE;
 		SurfDefFrame = SetAbsFrameIndex (SurfDefFrame, 0);
 		if (GetFrameWidth (SurfDefFrame) != MAP_WIDTH
 				|| GetFrameHeight (SurfDefFrame) != MAP_HEIGHT)
 		{
 			pSolarSysState->TopoFrame = CaptureDrawable (RescaleFrame (
-					SurfDefFrame, MAP_WIDTH, MAP_HEIGHT));
+					SurfDefFrame, MAP_WIDTH, MAP_HEIGHT, FALSE));
 			// will not need the passed FRAME anymore
 			DeleteDef = TRUE;
 		}
@@ -1770,12 +1793,13 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 					|| GetFrameHeight (ElevFrame) != MAP_HEIGHT)
 			{
 				ElevFrame = CaptureDrawable (RescaleFrame (ElevFrame,
-						MAP_WIDTH, MAP_HEIGHT));
+						MAP_WIDTH, MAP_HEIGHT, TRUE));
+				DeleteElev = TRUE;
 			}
 
 			// grab the elevation data in 1 byte per pixel format
 			ReadFramePixelIndexes (ElevFrame, (BYTE *)Orbit->lpTopoData,
-					MAP_WIDTH, MAP_HEIGHT);
+					MAP_WIDTH, MAP_HEIGHT, TRUE);
 			// the supplied data is in unsigned format, must convert
 			for (i = 0, elev = Orbit->lpTopoData;
 					i < MAP_WIDTH * MAP_HEIGHT;
@@ -1788,9 +1812,44 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 		{	// no elevation data -- planet flat as a pancake
 			memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
 		}
+		
+		// JMS: Planets with special colormaps
+		if (pPlanetDesc->alternate_colormap)
+		{
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (pPlanetDesc->alternate_colormap));
+			pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (SPECIAL_CMAP_XLAT_TAB));
+		}
+		// JMS: Normal planets
+		else
+		{
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (PlanDataPtr->CMapInstance));
+			pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (PlanDataPtr->XlatTabInstance));
+
+			if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
+			{
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 2);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 2);
+			}
+			else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
+			{
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 1);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 1);
+			}
+		}
+		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
 
 		if (DeleteDef)
 			DestroyDrawable (ReleaseDrawable (SurfDefFrame));
+		if (DeleteElev)
+			DestroyDrawable (ReleaseDrawable (ElevFrame));
 	}
 	else
 	{	// Generate planet surface elevation data and look
@@ -1816,56 +1875,86 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 					for (i = 0; i < PlanDataPtr->num_blemishes; ++i)
 					{
 						RECT crater_r;
+						DWORD random_value; // JMS_GFX
 						UWORD loword;
-				
-						loword = LOWORD (TFB_Random ());
+						// UWORD hiword; // JMS_GFX
+						// BW: reinstate original values...
+						
+						random_value = TFB_Random(); // JMS_GFX
+						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
 						switch (HIBYTE (loword) & 31)
 						{
 							case 0:
-								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 2))
-										+ (MAP_HEIGHT >> 2);
+								// if (RESOLUTION_FACTOR == 0)
+								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 2)) + (ORIGINAL_MAP_HEIGHT >> 2);
+								// else
+								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 2)) + (MAP_HEIGHT >> 2);
+								
 								break;
 							case 1:
 							case 2:
 							case 3:
 							case 4:
-								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 3))
-										+ (MAP_HEIGHT >> 3);
+								// if (RESOLUTION_FACTOR == 0)
+								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 3)) + (ORIGINAL_MAP_HEIGHT >> 3);
+								// else
+								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 3)) + (MAP_HEIGHT >> 3);
 								break;
 							default:
-								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 4))
-										+ 4;
+								// if (RESOLUTION_FACTOR == 0)
+								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 4)) + 4;
+								// else
+								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 4)) + 4;
 								break;
 						}
 					
-						loword = LOWORD (TFB_Random ());
+						random_value = TFB_Random(); // JMS_GFX
+						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
+						// hiword = HIWORD (random_value); 
+						// JMS_GFX
+						crater_r.extent.height = crater_r.extent.width;	
+						crater_r.corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - crater_r.extent.width);
+						// crater_r.corner.x = loword % (MAP_WIDTH - crater_r.extent.width); // JMS_GFX: changed the previous line to this. BYTE was too small for 4x resolution
+						crater_r.corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - crater_r.extent.height);
+						// crater_r.corner.y = hiword % (MAP_HEIGHT - crater_r.extent.height); // JMS_GFX: The same
+						// BW: ... then scale them up
+						crater_r.extent.width = crater_r.extent.width * MAP_WIDTH / ORIGINAL_MAP_WIDTH;
 						crater_r.extent.height = crater_r.extent.width;
-						crater_r.corner.x = HIBYTE (loword)
-								% (MAP_WIDTH - crater_r.extent.width);
-						crater_r.corner.y = LOBYTE (loword)
-								% (MAP_HEIGHT - crater_r.extent.height);
+						crater_r.corner.x = crater_r.corner.x * MAP_WIDTH / ORIGINAL_MAP_WIDTH;
+						crater_r.corner.y = crater_r.corner.y * MAP_HEIGHT / ORIGINAL_MAP_HEIGHT;
+						
 						MakeCrater (&crater_r, Orbit->lpTopoData,
 								PlanDataPtr->fault_depth << 2,
 								-(PlanDataPtr->fault_depth << 2),
-								FALSE);
+							    FALSE, MAP_WIDTH);
 					}
 
 					if (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO)
-						DitherMap (Orbit->lpTopoData);
-					ValidateMap (Orbit->lpTopoData);
+						DitherMap (Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
+					ValidateMap (Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
 					break;
 			}
 		}
 		pSolarSysState->TopoFrame = CaptureDrawable (
 				CreateDrawable (WANT_PIXMAP, (SIZE)MAP_WIDTH,
 				(SIZE)MAP_HEIGHT, 1));
-		pSolarSysState->OrbitalCMap = CaptureColorMap (
+				
+		// JMS: Planets with special colormaps
+		if (pPlanetDesc->alternate_colormap)
+		{
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (pPlanetDesc->alternate_colormap));
+			pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (SPECIAL_CMAP_XLAT_TAB));
+		}
+		// JMS: Normal planets
+		else
+		{
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
 				LoadColorMap (PlanDataPtr->CMapInstance));
-		pSolarSysState->XlatRef = CaptureStringTable (
+			pSolarSysState->XlatRef = CaptureStringTable (
 				LoadStringTable (PlanDataPtr->XlatTabInstance));
+		}
 
 		if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
 		{
@@ -1882,8 +1971,7 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 					pSolarSysState->XlatRef, 1);
 		}
 		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
-		RenderTopography (pSolarSysState->TopoFrame,
-				Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
+		RenderTopography (pSolarSysState->TopoFrame, Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT, FALSE);
 
 	}
 
@@ -1897,7 +1985,7 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 					PlanDataPtr->num_faults, PlanDataPtr->fault_depth
 					* (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO ? 2 : 1  ));
 			RenderTopography (Orbit->TopoZoomFrame, pScaledTopo,
-					MAP_WIDTH * 4, MAP_HEIGHT * 4);
+					  MAP_WIDTH * 4, MAP_HEIGHT * 4, SurfDef);
 
 			HFree (pScaledTopo);
 		}
@@ -1911,7 +1999,7 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	ReadFramePixelColors (pSolarSysState->TopoFrame, Orbit->TopoColors,
 			MAP_WIDTH + SPHERE_SPAN_X, MAP_HEIGHT);
 	// Extend the width from MAP_WIDTH to MAP_WIDTH+SPHERE_SPAN_X
-	for (y = 0; y < MAP_HEIGHT * (MAP_WIDTH + SPHERE_SPAN_X);
+	for (y = 0; y < (DWORD)(MAP_HEIGHT * (MAP_WIDTH + SPHERE_SPAN_X));
 			y += MAP_WIDTH + SPHERE_SPAN_X)
 		memcpy (Orbit->TopoColors + y + MAP_WIDTH, Orbit->TopoColors + y,
 				SPHERE_SPAN_X * sizeof (Orbit->TopoColors[0]));
@@ -1937,11 +2025,11 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	}
 	
 	// Rotating planet sphere initialization
-	GenerateSphereMask (loc);
-	CreateSphereTiltMap (PlanetInfo->AxialTilt);
+	GenerateSphereMask (loc, RADIUS);
+	CreateSphereTiltMap (PlanetInfo->AxialTilt, MAP_HEIGHT, RADIUS);
 	if (shielded)
-		Orbit->ObjectFrame = CreateShieldMask ();
-	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded);
+		Orbit->ObjectFrame = CreateShieldMask (RADIUS);
+	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded, MAP_WIDTH, MAP_HEIGHT);
 
 	if (shielded)
 	{	// This overwrites pSolarSysState->TopoFrame, so everything that
@@ -1956,3 +2044,294 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	TFB_SeedRandom (old_seed);
 }
 
+
+
+void
+GeneratePlanetSurfaceForIP (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame, COUNT width, COUNT height)
+{
+	RECT r;
+	DWORD old_seed;
+	const PlanetFrame *PlanDataPtr;
+	PLANET_INFO *PlanetInfo = &pSolarSysState->SysInfo.PlanetInfo;
+	DWORD i, y;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
+	POINT loc;
+	CONTEXT OldContext;
+	CONTEXT TopoContext;
+	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
+	BOOLEAN SurfDef = FALSE;
+	BOOLEAN shielded = (pPlanetDesc->data_index & PLANET_SHIELDED) != 0;
+	COUNT spherespanx = height;
+	COUNT radius = (height >> 1) - RESOLUTION_FACTOR;
+	
+	old_seed = TFB_SeedRandom (pPlanetDesc->rand_seed);
+
+	TopoContext = CreateContext ("Plangen.TopoContext");
+	LockMutex (GraphicsLock);
+	OldContext = SetContext (TopoContext);
+	planet_orbit_init (width, height, FALSE);
+
+	PlanDataPtr = &PlanData[pPlanetDesc->data_index & ~PLANET_SHIELDED];
+
+	if (SurfDefFrame)
+	{	// This is a defined planet; pixmap for the topography and
+		// elevation data is supplied in Surface Definition frame
+		BOOLEAN DeleteDef = FALSE;
+		BOOLEAN DeleteElev = FALSE;
+		FRAME ElevFrame;
+
+		// surface pixmap
+		SurfDef = TRUE;
+		SurfDefFrame = SetAbsFrameIndex (SurfDefFrame, 0);
+		if (GetFrameWidth (SurfDefFrame) != width
+				|| GetFrameHeight (SurfDefFrame) != height)
+		{
+			pSolarSysState->TopoFrame = CaptureDrawable (RescaleFrame (
+					SurfDefFrame, width, height, FALSE));
+			// will not need the passed FRAME anymore
+			DeleteDef = TRUE;
+		}
+		else
+			pSolarSysState->TopoFrame = SurfDefFrame;
+
+		if (GetFrameCount (SurfDefFrame) > 1)
+		{	// 2nd frame is elevation data 
+			int i;
+			SBYTE* elev;
+
+			ElevFrame = SetAbsFrameIndex (SurfDefFrame, 1);
+			if (GetFrameWidth (ElevFrame) != width
+					|| GetFrameHeight (ElevFrame) != height)
+			{
+				ElevFrame = CaptureDrawable (RescaleFrame (ElevFrame,
+						width, height, TRUE));
+				DeleteElev = TRUE;
+			}
+
+			// grab the elevation data in 1 byte per pixel format
+			ReadFramePixelIndexes (ElevFrame, (BYTE *)Orbit->lpTopoData,
+					width, height, FALSE);
+			// the supplied data is in unsigned format, must convert
+			for (i = 0, elev = Orbit->lpTopoData;
+					i < width * height;
+					++i, ++elev)
+			{
+				*elev = *(BYTE *)elev - 128;
+			}
+		}
+		else
+		{	// no elevation data -- planet flat as a pancake
+			memset (Orbit->lpTopoData, 0, width * height);
+		}
+
+		// JMS: Planets with special colormaps
+		if (pPlanetDesc->alternate_colormap)
+		{
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (pPlanetDesc->alternate_colormap));
+			pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (SPECIAL_CMAP_XLAT_TAB));
+		}
+		// JMS: Normal planets
+		else
+		{
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (PlanDataPtr->CMapInstance));
+			pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (PlanDataPtr->XlatTabInstance));
+		}
+
+		if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
+		{
+			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+					pSolarSysState->OrbitalCMap, 2);
+			pSolarSysState->XlatRef = SetAbsStringTableIndex (
+					pSolarSysState->XlatRef, 2);
+		}
+		else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
+		{
+			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+					pSolarSysState->OrbitalCMap, 1);
+			pSolarSysState->XlatRef = SetAbsStringTableIndex (
+					pSolarSysState->XlatRef, 1);
+		}
+		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
+
+		if (DeleteDef)
+			DestroyDrawable (ReleaseDrawable (SurfDefFrame));
+		if (DeleteElev)
+			DestroyDrawable (ReleaseDrawable (ElevFrame));
+	}
+	else
+	{	// Generate planet surface elevation data and look
+
+		r.corner.x = r.corner.y = 0;
+		r.extent.width = width;
+		r.extent.height = height;
+		{
+			memset (Orbit->lpTopoData, 0, width * height);
+			switch (PLANALGO (PlanDataPtr->Type))
+			{
+				case GAS_GIANT_ALGO:
+					MakeGasGiant (PlanDataPtr->num_faults,
+							Orbit->lpTopoData, &r, PlanDataPtr->fault_depth);
+					break;
+				case TOPO_ALGO:
+				case CRATERED_ALGO:
+					if (PlanDataPtr->num_faults)
+						DeltaTopography (PlanDataPtr->num_faults,
+								Orbit->lpTopoData, &r,
+								PlanDataPtr->fault_depth);
+
+					for (i = 0; i < PlanDataPtr->num_blemishes; ++i)
+					{
+						RECT crater_r;
+						DWORD random_value; // JMS_GFX
+						UWORD loword;
+						// UWORD hiword; // JMS_GFX
+						// BW: reinstate original values...
+						
+						random_value = TFB_Random(); // JMS_GFX
+						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
+						switch (HIBYTE (loword) & 31)
+						{
+							case 0:
+								// if (RESOLUTION_FACTOR == 0)
+								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 2)) + (ORIGINAL_MAP_HEIGHT >> 2);
+								// else
+								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 2)) + (MAP_HEIGHT >> 2);
+								
+								break;
+							case 1:
+							case 2:
+							case 3:
+							case 4:
+								// if (RESOLUTION_FACTOR == 0)
+								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 3)) + (ORIGINAL_MAP_HEIGHT >> 3);
+								// else
+								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 3)) + (MAP_HEIGHT >> 3);
+								break;
+							default:
+								// if (RESOLUTION_FACTOR == 0)
+								crater_r.extent.width = (LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT >> 4)) + 4;
+								// else
+								// 	crater_r.extent.width = (loword % (MAP_HEIGHT >> 4)) + 4;
+								break;
+						}
+
+						random_value = TFB_Random(); // JMS_GFX
+						loword = LOWORD (random_value); // JMS_GFX: Was loword = LOWORD (TFB_Random ());
+						// hiword = HIWORD (random_value); 
+						// JMS_GFX
+	
+						crater_r.extent.height = crater_r.extent.width;
+						crater_r.corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - crater_r.extent.width);
+						// crater_r.corner.x = loword % (MAP_WIDTH - crater_r.extent.width); // JMS_GFX: changed the previous line to this. BYTE was too small for 4x resolution
+						crater_r.corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - crater_r.extent.height);
+						// crater_r.corner.y = hiword % (MAP_HEIGHT - crater_r.extent.height); // JMS_GFX: The same
+
+						// BW: ... then scale them up
+						crater_r.extent.width = crater_r.extent.width * height / ORIGINAL_MAP_HEIGHT;
+						crater_r.extent.height = crater_r.extent.width;
+						crater_r.corner.x = crater_r.corner.x * width / ORIGINAL_MAP_WIDTH;					
+						crater_r.corner.y = crater_r.corner.y * height / ORIGINAL_MAP_HEIGHT;
+						
+						MakeCrater (&crater_r, Orbit->lpTopoData,
+								PlanDataPtr->fault_depth << 2,
+								-(PlanDataPtr->fault_depth << 2),
+							    FALSE, width);
+					}
+					if (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO)
+						DitherMap (Orbit->lpTopoData, width, height);
+					ValidateMap (Orbit->lpTopoData, width, height);
+					break;
+			}
+		}
+		pSolarSysState->TopoFrame = CaptureDrawable (
+				CreateDrawable (WANT_PIXMAP, (SIZE)width,
+				(SIZE)height, 1));
+		
+		{
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (PlanDataPtr->CMapInstance));
+			pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (PlanDataPtr->XlatTabInstance));
+
+			if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
+			{
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 2);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 2);
+			}
+			else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
+			{
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 1);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 1);
+			}
+		}
+			
+		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
+		RenderTopography (pSolarSysState->TopoFrame, Orbit->lpTopoData, width, height, FALSE);
+
+	}
+
+	// Generate a pixel array from the Topography map.
+	// We use this instead of lpTopoData because it needs to be
+	// WAP_WIDTH+SPHERE_SPAN_X wide and we need this method for Earth anyway.
+	// It may be more efficient to build it from lpTopoData instead of the
+	// FRAMPTR though.
+	ReadFramePixelColors (pSolarSysState->TopoFrame, Orbit->TopoColors,
+			width + spherespanx, height);
+	// Extend the width from MAP_WIDTH to MAP_WIDTH+SPHERE_SPAN_X
+	for (y = 0; y < (DWORD)(height * (width + spherespanx));
+			y += width + spherespanx)
+		memcpy (Orbit->TopoColors + y + width, Orbit->TopoColors + y,
+				spherespanx * sizeof (Orbit->TopoColors[0]));
+
+	if (PLANALGO (PlanDataPtr->Type) != GAS_GIANT_ALGO)
+	{	// convert topo data to a light map, based on relative
+		// map point elevations
+		GenerateLightMap (Orbit->lpTopoData, width, height);
+	}
+	else
+	{	// gas giants are pretty much flat
+		memset (Orbit->lpTopoData, 0, width * height);
+	}
+
+	if (pSolarSysState->pOrbitalDesc->pPrevDesc ==
+			&pSolarSysState->SunDesc[0])
+	{	// this is a planet -- get its location
+		loc = pSolarSysState->pOrbitalDesc->location;
+	}
+	else
+	{	// this is a moon -- get its planet's location
+		loc = pSolarSysState->pOrbitalDesc->pPrevDesc->location;
+	}
+	
+	// Rotating planet sphere initialization
+	GenerateSphereMask (loc, radius);
+	CreateSphereTiltMap (PlanetInfo->AxialTilt, height, radius);
+	if (shielded)
+		Orbit->ObjectFrame = CreateShieldMask (radius);
+	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded, width, height);
+	pPlanetDesc->rotDirection = 1 - 2 * (PlanetInfo->AxialTilt & 1);
+	pPlanetDesc->rotwidth = width;
+	pPlanetDesc->rotheight = height;
+	pPlanetDesc->rotFrameIndex = 0;
+	pPlanetDesc->rotPointIndex = 0;
+	pPlanetDesc->rot_speed = ((double)(pPlanetDesc->rotwidth * pPlanetDesc->rotDirection * 240)) / PlanetInfo->RotationPeriod;
+	
+	if (shielded)
+	{	// This overwrites pSolarSysState->TopoFrame, so everything that
+		// needs it has to come before
+		ApplyShieldTint ();
+	}
+
+	SetContext (OldContext);
+	UnlockMutex (GraphicsLock);
+	DestroyContext (TopoContext);
+
+	TFB_SeedRandom (old_seed);
+}
diff -ruNp ./src.orig/uqm/planets/pstarmap.c ./src/uqm/planets/pstarmap.c
--- ./src.orig/uqm/planets/pstarmap.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/pstarmap.c	2017-10-23 11:41:34 -0700
@@ -36,6 +36,9 @@
 #include "../sounds.h"
 #include "../state.h"
 #include "../uqmdebug.h"
+#include "../util.h"
+		/* For get_fuel_to_sol() */
+
 #include "options.h"
 #include "libs/inplib.h"
 #include "libs/strlib.h"
@@ -45,12 +48,19 @@
 
 #include <stdlib.h>
 
+typedef enum {
+	NORMAL_STARMAP		  = 0,
+	PREWAR_STARMAP		  = 1,
+	CONSTELLATION_STARMAP = 2,
+	NUM_STARMAPS
+} CURRENT_STARMAP_SHOWN;
 
 static POINT cursorLoc;
 static POINT mapOrigin;
 static int zoomLevel;
 static FRAME StarMapFrame;
-
+static BOOLEAN show_prewar_situation; // JMS
+static CURRENT_STARMAP_SHOWN which_starmap; // JMS
 
 static inline long
 signedDivWithError (long val, long divisor)
@@ -279,13 +289,176 @@ GetSphereRect (FLEET_INFO *FleetPtr, REC
 	}
 }
 
+// JMS: For showing the SC1-era situation in starmap
+static void
+GetPrewarSphereRect (COUNT index, FLEET_INFO *FleetPtr, RECT *pRect, RECT *pRepairRect)
+{
+	long diameter;
+	
+	static const COUNT prewar_strengths[] =
+	{
+		RACE_PREWAR_STRENGTHS
+	};
+	static const POINT prewar_locations[] =
+	{
+		RACE_PREWAR_LOCATIONS
+	};
+	static const BOOLEAN prewar_name_unknown[] =
+	{
+		RACE_PREWAR_NAME_UNKNOWN
+	};
+
+	diameter = (long)(prewar_strengths[index] * 2);
+	pRect->extent.width = UNIVERSE_TO_DISPX (diameter) - UNIVERSE_TO_DISPX (0);
+	if (pRect->extent.width < 0)
+		pRect->extent.width = -pRect->extent.width;
+	else if (pRect->extent.width == 0)
+		pRect->extent.width = 1;
+	pRect->extent.height = UNIVERSE_TO_DISPY (diameter)
+			- UNIVERSE_TO_DISPY (0);
+	if (pRect->extent.height < 0)
+		pRect->extent.height = -pRect->extent.height;
+	else if (pRect->extent.height == 0)
+		pRect->extent.height = 1;
+
+	pRect->corner.x = UNIVERSE_TO_DISPX (prewar_locations[index].x);
+	pRect->corner.y = UNIVERSE_TO_DISPY (prewar_locations[index].y);
+	pRect->corner.x -= pRect->extent.width >> 1;
+	pRect->corner.y -= pRect->extent.height >> 1;
+
+	{
+		TEXT t;
+		STRING locString;
+
+		SetContextFont (TinyFont);
+
+		t.baseline.x = pRect->corner.x + (pRect->extent.width >> 1);
+		t.baseline.y = pRect->corner.y + (pRect->extent.height >> 1) - 1;
+		t.align = ALIGN_CENTER;
+		
+		if (prewar_name_unknown[index])
+		{
+			t.CharCount = 7;
+			t.pStr = GAME_STRING (STAR_STRING_BASE + 132);
+		}
+		else
+		{
+			locString = SetAbsStringTableIndex (FleetPtr->race_strings, 1);
+			t.CharCount = GetStringLength (locString);
+			t.pStr = (UNICODE *)GetStringAddress (locString);
+		}
+		
+		if (prewar_strengths[index])
+			TextRect (&t, pRepairRect, NULL);
+		
+		if (pRepairRect->corner.x <= 0)
+			pRepairRect->corner.x = 1;
+		else if (pRepairRect->corner.x + pRepairRect->extent.width >=
+				SIS_SCREEN_WIDTH)
+			pRepairRect->corner.x =
+					SIS_SCREEN_WIDTH - pRepairRect->extent.width - 1;
+		if (pRepairRect->corner.y <= 0)
+			pRepairRect->corner.y = 1;
+		else if (pRepairRect->corner.y + pRepairRect->extent.height >=
+				SIS_SCREEN_HEIGHT)
+			pRepairRect->corner.y =
+					SIS_SCREEN_HEIGHT - pRepairRect->extent.height - 1;
+
+		BoxUnion (pRepairRect, pRect, pRepairRect);
+		pRepairRect->extent.width++;
+		pRepairRect->extent.height++;
+	}
+}
+
+static void
+DrawFuelCircles ()
+{
+	RECT r;
+	long diameter;
+	long diameter_no_return;
+	POINT corner;
+	Color OldColor;
+
+	diameter = (long) GLOBAL_SIS (FuelOnBoard) << 1;
+
+	/* Terribly ugly hack to keep this from being assigned
+	 * a negative value, and also to make sure the inner circle
+	 * is not drawn if we don't have enough fuel to get to Sol at
+	 * all.
+	 */
+	if ((((long)GLOBAL_SIS (FuelOnBoard)) - (long)get_fuel_to_sol() < 0) ||
+		(get_fuel_to_sol () > GLOBAL_SIS (FuelOnBoard)))
+	{
+		diameter_no_return = 0;
+	} else
+	{
+		diameter_no_return = GLOBAL_SIS (FuelOnBoard) - get_fuel_to_sol();
+	}
+
+	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+		corner = CurStarDescPtr->star_pt;
+	else
+	{
+		corner.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+		corner.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+	}
+
+	/* Draw outer circle*/
+	r.extent.width = UNIVERSE_TO_DISPX (diameter)
+	                 - UNIVERSE_TO_DISPX (0);
+
+	if (r.extent.width < 0)
+		r.extent.width = -r.extent.width;
+
+	r.extent.height = UNIVERSE_TO_DISPY (diameter)
+	                  - UNIVERSE_TO_DISPY (0);
+
+	if (r.extent.height < 0)
+		r.extent.height = -r.extent.height;
+
+	r.corner.x = UNIVERSE_TO_DISPX (corner.x)
+	             - (r.extent.width >> 1);
+	r.corner.y = UNIVERSE_TO_DISPY (corner.y)
+	             - (r.extent.height >> 1);
+
+	OldColor = SetContextForeGroundColor (
+	                   BUILD_COLOR (MAKE_RGB15 (0x03, 0x03, 0x03), 0x22));
+	DrawFilledOval (&r);
+	SetContextForeGroundColor (OldColor);
+
+	/* Draw a second fuel circle showing the 'point of no return', past which there will
+	 * not be enough fuel to return to Sol.
+	 */
+
+	r.extent.width = UNIVERSE_TO_DISPX (diameter_no_return)
+	                 - UNIVERSE_TO_DISPX (0);
+
+	if (r.extent.width < 0)
+		r.extent.width = -r.extent.width;
+
+	r.extent.height = UNIVERSE_TO_DISPY (diameter_no_return)
+	                  - UNIVERSE_TO_DISPY (0);
+
+	if (r.extent.height < 0)
+		r.extent.height = -r.extent.height;
+
+	r.corner.x = UNIVERSE_TO_DISPX (corner.x)
+	             - (r.extent.width >> 1);
+	r.corner.y = UNIVERSE_TO_DISPY (corner.y)
+	             - (r.extent.height >> 1);
+
+	OldColor = SetContextForeGroundColor (
+	                   BUILD_COLOR (MAKE_RGB15 (0x04, 0x04, 0x05), 0x22));
+	DrawFilledOval (&r);
+	SetContextForeGroundColor (OldColor);
+}
+
 static void
 DrawStarMap (COUNT race_update, RECT *pClipRect)
 {
 #define GRID_DELTA 500
 	SIZE i;
 	COUNT which_space;
-	long diameter;
 	RECT r, old_r;
 	POINT oldOrigin = {0, 0};
 	STAMP s;
@@ -343,38 +516,9 @@ DrawStarMap (COUNT race_update, RECT *pC
 	}
 	ClearDrawable ();
 
-	if (race_update == 0
-			&& which_space < 2
-			&& (diameter = (long)GLOBAL_SIS (FuelOnBoard) << 1))
+	if (race_update == 0 && which_space < 2)
 	{
-		Color OldColor;
-
-		if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
-			r.corner = CurStarDescPtr->star_pt;
-		else
-		{
-			r.corner.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
-			r.corner.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
-		}
-
-		r.extent.width = UNIVERSE_TO_DISPX (diameter)
-				- UNIVERSE_TO_DISPX (0);
-		if (r.extent.width < 0)
-			r.extent.width = -r.extent.width;
-		r.extent.height = UNIVERSE_TO_DISPY (diameter)
-				- UNIVERSE_TO_DISPY (0);
-		if (r.extent.height < 0)
-			r.extent.height = -r.extent.height;
-
-		r.corner.x = UNIVERSE_TO_DISPX (r.corner.x)
-				- (r.extent.width >> 1);
-		r.corner.y = UNIVERSE_TO_DISPY (r.corner.y)
-				- (r.extent.height >> 1);
-
-		OldColor = SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x03, 0x03, 0x03), 0x22));
-		DrawFilledOval (&r);
-		SetContextForeGroundColor (OldColor);
+		DrawFuelCircles ();
 	}
 
 	for (i = MAX_Y_UNIVERSE + 1; i >= 0; i -= GRID_DELTA)
@@ -398,7 +542,7 @@ DrawStarMap (COUNT race_update, RECT *pC
 	}
 
 	star_frame = SetRelFrameIndex (StarMapFrame, 2);
-	if (which_space <= 1)
+	if (which_space <= 1 && which_starmap != CONSTELLATION_STARMAP)
 	{
 		COUNT index;
 		HFLEETINFO hStarShip, hNextShip;
@@ -407,6 +551,19 @@ DrawStarMap (COUNT race_update, RECT *pC
 			RACE_COLORS
 		};
 
+		// JMS: For drawing SC1-era starmap.
+		static const BOOLEAN prewar_name_unknown[] =
+		{
+			RACE_PREWAR_NAME_UNKNOWN
+		};
+		static const COUNT prewar_strengths[] =
+		{
+			RACE_PREWAR_STRENGTHS
+		};
+		const char name_androsynth[] = "Androsynth";
+		const char name_chenjesu[] = "Chenjesu";
+		const char name_mmrnmhrm[] = "Mmrnmhrm";
+
 		for (index = 0,
 				hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
 				hStarShip != 0; ++index, hStarShip = hNextShip)
@@ -416,11 +573,16 @@ DrawStarMap (COUNT race_update, RECT *pC
 			FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 			hNextShip = _GetSuccLink (FleetPtr);
 
-			if (FleetPtr->known_strength)
+			if (FleetPtr->known_strength || 
+				(show_prewar_situation && prewar_strengths[index]))
 			{
 				RECT repair_r;
 
-				GetSphereRect (FleetPtr, &r, &repair_r);
+				if (show_prewar_situation)
+					GetPrewarSphereRect (index, FleetPtr, &r, &repair_r);
+				else
+					GetSphereRect (FleetPtr, &r, &repair_r);
+				
 				if (r.corner.x < SIS_SCREEN_WIDTH
 						&& r.corner.y < SIS_SCREEN_HEIGHT
 						&& r.corner.x + r.extent.width > 0
@@ -447,10 +609,41 @@ DrawStarMap (COUNT race_update, RECT *pC
 					t.baseline.x = r.corner.x + (r.extent.width >> 1);
 					t.baseline.y = r.corner.y + (r.extent.height >> 1) - 1;
 					t.align = ALIGN_CENTER;
-					locString = SetAbsStringTableIndex (
-							FleetPtr->race_strings, 1);
-					t.CharCount = GetStringLength (locString);
-					t.pStr = (UNICODE *)GetStringAddress (locString);
+					
+					// JMS: For drawing SC1-era starmap.
+					if (show_prewar_situation && prewar_name_unknown[index])
+					{
+						t.CharCount = 7;
+						t.pStr = GAME_STRING (STAR_STRING_BASE + 132);
+					}
+					// JMS: A kludgy way to fix Mrns, Chenjesus and Andros' names.
+					else if (show_prewar_situation && 
+						(index == 1 || index == 16 || index == 20))
+					{
+						if (index == 1)
+						{
+							t.CharCount = 8;
+							t.pStr = (UNICODE *)name_mmrnmhrm;
+						}
+						else if (index == 16)
+						{
+							t.CharCount = 8;
+							t.pStr = (UNICODE *)name_chenjesu;
+						}
+						else if (index == 20)
+						{
+							t.CharCount = 10;
+							t.pStr = (UNICODE *)name_androsynth;
+						}
+					}
+					else
+					{
+						locString = SetAbsStringTableIndex (
+								FleetPtr->race_strings, 1);
+						t.CharCount = GetStringLength (locString);
+						t.pStr = (UNICODE *)GetStringAddress (locString);
+					}
+					
 					TextRect (&t, &r, NULL);
 
 					if (r.corner.x <= 0)
@@ -474,7 +667,10 @@ DrawStarMap (COUNT race_update, RECT *pC
 							0xff : c.b + CC5TO8 (0x03);
 
 					SetContextForeGroundColor (c);
-					font_DrawText (&t);
+					
+					if ((!show_prewar_situation) ||
+						(show_prewar_situation && prewar_strengths[index]))
+						font_DrawText (&t);
 				}
 			}
 
@@ -508,6 +704,20 @@ DrawStarMap (COUNT race_update, RECT *pC
 	} while (SDPtr->star_pt.x <= MAX_X_UNIVERSE
 			&& SDPtr->star_pt.y <= MAX_Y_UNIVERSE);
 
+	// JMS: This draws the constellation lines on the constellation starmap.
+	if (which_space <= 1 && which_starmap == CONSTELLATION_STARMAP)
+	{
+		s.frame = SetAbsFrameIndex (ConstellationsFrame, 0);
+		DrawStamp (&s);
+		
+		// JMS: If we have a separate frame containing the constellation names, display it.
+		if (GetFrameCount(ConstellationsFrame) > 1)
+		{
+			s.frame = IncFrameIndex (s.frame);
+			DrawStamp (&s);
+		}
+	}
+
 	if (GET_GAME_STATE (ARILOU_SPACE))
 	{
 		if (which_space <= 1)
@@ -583,7 +793,7 @@ EraseCursor (COORD curs_x, COORD curs_y)
 		r.extent.height = SIS_SCREEN_HEIGHT - r.corner.y;
 
 #ifndef OLD
-	RepairBackRect (&r);
+	RepairBackRect (&r, FALSE);
 #else /* NEW */
 	r.extent.height += r.corner.y & 1;
 	r.corner.y &= ~1;
@@ -596,10 +806,10 @@ EraseCursor (COORD curs_x, COORD curs_y)
 static void
 ZoomStarMap (SIZE dir)
 {
-#define MAX_ZOOM_SHIFT 4
+#define MAX_ZOOM_SHIFT (BYTE)(4 - RESOLUTION_FACTOR)
 	if (dir > 0)
 	{
-		if (zoomLevel < MAX_ZOOM_SHIFT)
+		if (zoomLevel < MAX_ZOOM_SHIFT) // JMS_GFX
 		{
 			++zoomLevel;
 			mapOrigin = cursorLoc;
@@ -675,6 +885,11 @@ UpdateCursorLocation (int sx, int sy, co
 			cursorLoc.y = MAX_Y_UNIVERSE;
 
 		s.origin.y = UNIVERSE_TO_DISPY (cursorLoc.y);
+		if (s.origin.y < 0)
+		{
+			s.origin.y = 0;
+			cursorLoc.y = DISP_TO_UNIVERSEY (0);
+		}
 	}
 
 	if (s.origin.x < 0 || s.origin.y < 0
@@ -699,6 +914,10 @@ UpdateCursorLocation (int sx, int sy, co
 
 #define CURSOR_INFO_BUFSIZE 256
 
+// JMS: How close to a star the cursor has to be to 'snap' into it.
+// Don't make this larger than 1 for lo-res(1x). Otherwise the cursor gets stuck on stars.
+#define CURSOR_SNAP_AREA (RES_CASE(0,3,6))
+
 static void
 UpdateCursorInfo (UNICODE *prevbuf)
 {
@@ -706,24 +925,57 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	POINT pt;
 	STAR_DESC *SDPtr;
 	STAR_DESC *BestSDPtr;
+	
+	// JMS: Display star map title.
+	if (which_starmap == CONSTELLATION_STARMAP)
+	{	
+		// "- Known constellations -"
+		utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 4));
+	}
+	else if (which_starmap == PREWAR_STARMAP)
+	{	
+		// "- Old map from 2135 -"
+		utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 3));
+	}
+	else
+	{	
+		// "(Star search:F6 Toggle maps:F7)"
+		utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 2));
+	}
 
 	pt.x = UNIVERSE_TO_DISPX (cursorLoc.x);
 	pt.y = UNIVERSE_TO_DISPY (cursorLoc.y);
 
 	SDPtr = BestSDPtr = 0;
+	
 	while ((SDPtr = FindStar (SDPtr, &cursorLoc, 75, 75)))
 	{
-		if (UNIVERSE_TO_DISPX (SDPtr->star_pt.x) == pt.x
-				&& UNIVERSE_TO_DISPY (SDPtr->star_pt.y) == pt.y
-				&& (BestSDPtr == 0
-				|| STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
+		if ((UNIVERSE_TO_DISPX (SDPtr->star_pt.x) >= pt.x - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPX (SDPtr->star_pt.x) <= pt.x + CURSOR_SNAP_AREA)
+			&& (UNIVERSE_TO_DISPY (SDPtr->star_pt.y) >= pt.y - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPY (SDPtr->star_pt.y) <= pt.y + CURSOR_SNAP_AREA)
+			&& (BestSDPtr == 0 || STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
 			BestSDPtr = SDPtr;
 	}
 
 	if (BestSDPtr)
 	{
-		cursorLoc = BestSDPtr->star_pt;
-		GetClusterName (BestSDPtr, buf);
+		// JMS: For masking the names of QS portals not yet entered.
+		BYTE QuasiPortalsKnown[] =
+		{
+			QS_PORTALS_KNOWN
+		};
+		
+		// A star is near the cursor:
+		// Snap cursor onto star only in 1x res. In hi-res modes,
+		// snapping is done when the star is selected as auto-pilot target.
+		if (RESOLUTION_FACTOR == 0)
+			cursorLoc = BestSDPtr->star_pt;
+		
+		if (GET_GAME_STATE(ARILOU_SPACE_SIDE) >= 2
+			&& !(QuasiPortalsKnown[BestSDPtr->Postfix - 133]))
+			utf8StringCopy (buf, sizeof (buf),
+				GAME_STRING (STAR_STRING_BASE + 132));
+		else
+			GetClusterName (BestSDPtr, buf);
 	}
 	else
 	{	// No star found. Reset the coordinates to the cursor's location
@@ -768,7 +1020,36 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	if (strcmp (buf, prevbuf) != 0)
 	{
 		strcpy (prevbuf, buf);
-		DrawSISMessage (buf);
+		
+		// Cursor is on top of a star. Display its name.
+		if (BestSDPtr)
+			DrawSISMessage (buf);
+		// Cursor is elsewhere.
+		else
+		{
+			// In HS, display default star search button name.
+			if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+			{
+				CONTEXT OldContext;
+				OldContext = SetContext (OffScreenContext);
+				
+				if (show_prewar_situation)
+					SetContextForeGroundColor 
+						(BUILD_COLOR (MAKE_RGB15 (0x18, 0x00, 0x00), 0x00));
+				else
+					SetContextForeGroundColor 
+						(BUILD_COLOR (MAKE_RGB15 (0x0E, 0xA7, 0xD9), 0x00));
+						
+				DrawSISMessageEx (buf, -1, -1, DSME_MYCOLOR);
+				SetContext (OldContext);
+			}
+			// In QS, don't display star search button - the search is unusable.
+			else
+			{
+				strcpy (buf, "QuasiSpace");
+				DrawSISMessage (buf);
+			}
+		}
 	}
 	UnlockMutex (GraphicsLock);
 }
@@ -1233,6 +1514,8 @@ DoMoveCursor (MENU_STATE *pMS)
 #define STEP_ACCEL_DELAY (ONE_SECOND / 120)
 	static UNICODE last_buf[CURSOR_INFO_BUFSIZE];
 	DWORD TimeIn = GetTimeCounter ();
+	static COUNT moveRepeats;
+	BOOLEAN isMove = FALSE;
 
 	if (!pMS->Initialized)
 	{
@@ -1262,6 +1545,34 @@ DoMoveCursor (MENU_STATE *pMS)
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SELECT])
 	{
+		// JMS: The hi-res modes now have a user-friendly starmap cursor.
+		// The cursor finds a star even if the cursor is several pixels away from it (CURSOR_SNAP_AREA)
+		// The cursor centers on the star only when selected as an auto-pilot target.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			STAR_DESC *SDPtr;
+			STAR_DESC *BestSDPtr;
+			POINT pt;
+			
+			pt.x = UNIVERSE_TO_DISPX (cursorLoc.x);
+			pt.y = UNIVERSE_TO_DISPY (cursorLoc.y);
+			SDPtr = BestSDPtr = 0;
+			
+			while ((SDPtr = FindStar (SDPtr, &cursorLoc, 75, 75)))
+			{
+				if ((UNIVERSE_TO_DISPX (SDPtr->star_pt.x) >= pt.x - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPX (SDPtr->star_pt.x) <= pt.x + CURSOR_SNAP_AREA)
+					&& (UNIVERSE_TO_DISPY (SDPtr->star_pt.y) >= pt.y -CURSOR_SNAP_AREA && UNIVERSE_TO_DISPY (SDPtr->star_pt.y) <= pt.y + CURSOR_SNAP_AREA)
+					&& (BestSDPtr == 0 || STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
+					BestSDPtr = SDPtr;
+			}
+			
+			if (BestSDPtr)
+			{
+				cursorLoc = BestSDPtr->star_pt;
+				UpdateCursorLocation (0, 0, &BestSDPtr->star_pt);
+			}
+		}
+		
 		GLOBAL (autopilot) = cursorLoc;
 #ifdef DEBUG
 		if (instantMove)
@@ -1311,6 +1622,22 @@ DoMoveCursor (MENU_STATE *pMS)
 			PlayMenuSound (MENU_SOUND_FAILURE);
 		}
 	}
+	else if (PulsedInputState.menu[KEY_MENU_TOGGLEMAP] 
+		&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+	{
+		++which_starmap;
+		which_starmap %= NUM_STARMAPS;
+		
+		if (which_starmap == PREWAR_STARMAP) 
+			show_prewar_situation = TRUE;
+		else
+			show_prewar_situation = FALSE;
+	
+		DrawStarMap (0, NULL);
+		last_buf[0] = '\0';
+		UpdateCursorInfo (last_buf);
+		SleepThread (ONE_SECOND / 8);
+	}
 	else
 	{
 		SBYTE sx, sy;
@@ -1330,16 +1657,31 @@ DoMoveCursor (MENU_STATE *pMS)
 		if (PulsedInputState.menu[KEY_MENU_UP])      sy =   -1;
 		if (PulsedInputState.menu[KEY_MENU_DOWN])    sy =    1;
 
+		if (moveRepeats > 20)
+		{
+			sx *= 1 << RESOLUTION_FACTOR;
+			sy *= 1 << RESOLUTION_FACTOR;
+		}
+		// BW: we need to go through this because 4x only checks for
+		// input every ONE_SECOND/40 or so, thus reducing
+		// MIN_ACCEL_STEP is of no use. In practice it's similar.
+
 		if (sx != 0 || sy != 0)
 		{
 			UpdateCursorLocation (sx, sy, NULL);
 			UpdateCursorInfo (last_buf);
 			UpdateFuelRequirement ();
+			isMove = TRUE;
 		}
 
 		SleepThreadUntil (TimeIn + MIN_ACCEL_DELAY);
 	}
 
+	if (isMove)
+		++moveRepeats;
+	else
+		moveRepeats = 0;
+
 	flashCurrentLocation (NULL);
 
 	return !(GLOBAL (CurrentActivity) & CHECK_ABORT);
@@ -1581,6 +1923,27 @@ DoneSphereGrowth:
 	}
 }
 
+static void
+DrawSubmenuStarmapKeys (bool menu_visible)
+{
+	STAMP s;
+	CONTEXT OldContext;
+	
+	OldContext = SetContext (ScreenContext);
+
+	s.origin.x = 0;
+	s.origin.y = 0;
+		
+	if (menu_visible)
+		s.frame = SetAbsFrameIndex (SubmenuStarmapKeysFrame, 1);
+	else
+		s.frame = SetAbsFrameIndex (SubmenuStarmapKeysFrame, 0);
+
+	DrawStamp (&s);
+	
+	SetContext (OldContext);
+}
+
 BOOLEAN
 StarMap (void)
 {
@@ -1592,6 +1955,10 @@ StarMap (void)
 
 	memset (&MenuState, 0, sizeof (MenuState));
 
+	// JMS: For showing SC1-era starmap / starmap with constellations.
+	show_prewar_situation = FALSE; 
+	which_starmap = NORMAL_STARMAP;
+
 	zoomLevel = 0;
 	mapOrigin.x = MAX_X_UNIVERSE >> 1;
 	mapOrigin.y = MAX_Y_UNIVERSE >> 1;
@@ -1618,6 +1985,10 @@ StarMap (void)
 
 	LockMutex (GraphicsLock);
 	
+	// JMS: This will show the table of mineral values on the status bar.
+	if (optMineralSubmenu)
+		DrawSubmenuStarmapKeys (TRUE);
+	
 	DrawStarMap (0, (RECT*)-1);
 	transition_pending = FALSE;
 	
@@ -1642,6 +2013,11 @@ StarMap (void)
 	DrawHyperCoords (universe);
 	DrawSISMessage (NULL);
 	DrawStatusMessage (NULL);
+	
+	// JMS: This will hide the table of mineral values on the status bar.
+	if (optMineralSubmenu)
+		DrawSubmenuStarmapKeys (FALSE);
+		
 	UnlockMutex (GraphicsLock);
 
 	if (GLOBAL (autopilot.x) == universe.x
diff -ruNp ./src.orig/uqm/planets/report.c ./src/uqm/planets/report.c
--- ./src.orig/uqm/planets/report.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/report.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "lander.h"
 #include "scan.h"
 #include "planets.h"
@@ -33,8 +35,8 @@
 #include <string.h>
 
 
-#define NUM_CELL_COLS MAP_WIDTH / 6
-#define NUM_CELL_ROWS MAP_HEIGHT / 6
+#define NUM_CELL_COLS (MAP_WIDTH / (6 << RESOLUTION_FACTOR) + RES_CASE(0,3,7) - (optWhichFonts == OPT_PC ? 0 : RES_CASE(0,0,1))) // JMS_GFX 
+#define NUM_CELL_ROWS (MAP_HEIGHT / (6 << RESOLUTION_FACTOR) + RES_CASE(0,1,2)) // JMS_GFX
 #define MAX_CELL_COLS 40
 
 extern FRAME SpaceJunkFrame;
@@ -43,9 +45,22 @@ static void
 ClearReportArea (void)
 {
 	COUNT x, y;
+	BYTE emptycols, emptyrows;  // JMS_GFX
 	RECT r;
 	STAMP s;
 	COORD startx;
+	
+	// JMS_GFX
+	if (RESOLUTION_FACTOR > 0)
+	{
+		emptycols = NUM_CELL_COLS + 1;
+		emptyrows = NUM_CELL_ROWS + 1;
+	}
+	else
+	{
+		emptycols = NUM_CELL_COLS;
+		emptyrows = NUM_CELL_ROWS;
+	}
 
 	if (optWhichFonts == OPT_PC)
 		s.frame = SetAbsFrameIndex (SpaceJunkFrame, 21);
@@ -60,12 +75,12 @@ ClearReportArea (void)
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x00, 0x07, 0x00), 0x57));
 	
-	startx = 1 + (r.extent.width >> 1) - 1;
+	startx = 1 + (r.extent.width >> 1) - 1 - 4 * RESOLUTION_FACTOR;  // JMS_GFX
 	s.origin.y = 1;
-	for (y = 0; y < NUM_CELL_ROWS; ++y)
+	for (y = 0; y < emptyrows; ++y)
 	{
 		s.origin.x = startx;
-		for (x = 0; x < NUM_CELL_COLS; ++x)
+		for (x = 0; x < emptycols; ++x)
 		{
 			if (optWhichFonts == OPT_PC)
 				DrawStamp (&s);
@@ -133,8 +148,7 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 			t.pStr = end_page_buf;
 			StrLen += end_page_len;
 		}
-		t.baseline.x = 1 + (r.extent.width >> 1)
-				+ (col_cells * (r.extent.width + 1)) - 1;
+		t.baseline.x = 1 + (r.extent.width >> 1) + (col_cells * (r.extent.width + 1)) - 1 - 3 * RESOLUTION_FACTOR; // JMS_GFX
 		do
 		{
 			COUNT word_chars;
@@ -212,7 +226,7 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 
 InitPageCell:
 			ButtonState = 1;
-			t.baseline.y = r.extent.height + 1;
+			t.baseline.y = r.extent.height + (1 << RESOLUTION_FACTOR) + 3 * RESOLUTION_FACTOR; // JMS_GFX
 			row_cells = 0;
 			if (StrLen)
 			{
diff -ruNp ./src.orig/uqm/planets/roster.c ./src/uqm/planets/roster.c
--- ./src.orig/uqm/planets/roster.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/roster.c	2017-10-23 11:41:34 -0700
@@ -21,16 +21,22 @@
 #include "../controls.h"
 #include "../races.h"
 #include "../units.h"
+#include "../util.h" // JMS: For SaveContextFrame()
 #include "../sis.h"
 #include "../shipcont.h"
 #include "../setup.h"
 #include "../sounds.h"
 #include "port.h"
 #include "libs/gfxlib.h"
+#include "libs/log.h"
 #include "libs/tasklib.h"
 
 #include <stdlib.h>
 
+// JMS_GFX: These exist to prevent the leftover red borders of the rostered ships in hi-res.
+static RECT  savedShipFrame_r;
+static STAMP savedShipFrame;
+
 // Ship icon positions in status display around the flagship
 static const POINT ship_pos[MAX_BUILT_SHIPS] =
 {
@@ -58,20 +64,37 @@ typedef struct
 static SHIP_FRAGMENT* LockSupportShip (ROSTER_STATE *, HSHIPFRAG *phFrag);
 
 static void
-drawSupportShip (ROSTER_STATE *rosterState, bool filled)
+drawSupportShip (ROSTER_STATE *rosterState, bool filled, bool saveFrame)
 {
 	STAMP s;
-
+	
 	if (!rosterState->curShipFrame)
 		return;
 
-	s.origin = rosterState->curShipPt;
+	s.origin.x = RES_STAT_SCALE(rosterState->curShipPt.x)
+		+ (rosterState->curShipPt.x >= ship_pos[1].x ? RES_CASE(0,3,5) : RES_CASE(0,-2,-2)); // JMS_GFX
+	s.origin.y = RES_STAT_SCALE(rosterState->curShipPt.y) + RES_CASE(0,5,0);
 	s.frame = rosterState->curShipFrame;
 	
-	if (filled)
-		DrawFilledStamp (&s);
+	// JMS: 
+	if (saveFrame)
+	{
+		savedShipFrame_r.corner.x = s.origin.x;
+		savedShipFrame_r.corner.y = s.origin.y;
+		savedShipFrame_r.extent.width  = 16 << RESOLUTION_FACTOR;
+		savedShipFrame_r.extent.height = 16 << RESOLUTION_FACTOR; 
+	
+		savedShipFrame = SaveContextFrame (&savedShipFrame_r);
+		
+		log_add (log_Debug,"Saved x:%u, y:%u", savedShipFrame_r.corner.x ,savedShipFrame_r.corner.y);
+	}
 	else
-		DrawStamp (&s);
+	{
+		if (filled)
+			DrawFilledStamp (&s);
+		else
+			DrawStamp (&s);
+	}
 }
 
 static void
@@ -85,16 +108,18 @@ getSupportShipIcon (ROSTER_STATE *roster
 	if (!ShipFragPtr)
 		return;
 
-	rosterState->curShipFrame = ShipFragPtr->icons;
+	rosterState->curShipFrame = SetAbsFrameIndex (ShipFragPtr->icons, 2);
 	UnlockShipFrag (&GLOBAL (built_ship_q), hShipFrag);
 }
 
 static void
-flashSupportShip (ROSTER_STATE *rosterState)
+flashSupportShip (ROSTER_STATE *rosterState, bool saveFrame)
 {
 	static Color c = BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x00, 0x00), 0x24);
 	static TimeCount NextTime = 0;
 
+	drawSupportShip (rosterState, TRUE, saveFrame);
+
 	if (GetTimeCounter () >= NextTime)
 	{
 		NextTime = GetTimeCounter () + (ONE_SECOND / 15);
@@ -121,7 +146,7 @@ flashSupportShip (ROSTER_STATE *rosterSt
 		}
 		SetContextForeGroundColor (c);
 
-		drawSupportShip (rosterState, TRUE);
+		drawSupportShip (rosterState, TRUE, FALSE);
 	}
 }
 
@@ -218,7 +243,7 @@ drawModifiedSupportShip (ROSTER_STATE *r
 {
 	SetContext (StatusContext);
 	SetContextForeGroundColor (ROSTER_MODIFY_SHIP_COLOR);
-	drawSupportShip (rosterState, TRUE);
+	drawSupportShip (rosterState, TRUE, FALSE);
 }
 
 static void
@@ -354,14 +379,27 @@ DoModifyRoster (MENU_STATE *pMS)
 
 		if (NewState != pMS->CurState)
 		{
-			// Draw the previous escort in unselected state
-			drawSupportShip (rosterState, FALSE);
+			// Draw the previous escort in unselected state.
+			// JMS_GFX: In 4x and 2x modes we draw the rectangle of screen
+			// we captured earlier.
+			if (RESOLUTION_FACTOR > 0)
+				DrawStamp (&savedShipFrame);
+			else // In 1x mode we just draw the icon.
+				drawSupportShip (rosterState, FALSE, FALSE);
+			
 			// Select the new one
 			selectSupportShip (rosterState, NewState);
 			pMS->CurState = NewState;
+			
+			// JMS_GFX: In 2x and 4x modes we now have to capture the
+			// location of this new rectangle.
+			if (RESOLUTION_FACTOR > 0)
+				flashSupportShip (rosterState, TRUE);
+			else
+				flashSupportShip (rosterState, FALSE);
 		}
-
-		flashSupportShip (rosterState);
+		else
+			flashSupportShip (rosterState, FALSE);
 
 		UnbatchGraphics ();
 		UnlockMutex (GraphicsLock);
@@ -417,6 +455,12 @@ RosterMenu (void)
 	LockMutex (GraphicsLock);
 	SetContext (StatusContext);
 	selectSupportShip (&RosterState, MenuState.CurState);
+
+	// JMS_GFX: Remember the location of the first ship to be able to erase
+	// the red junk from around it after rostering.
+	if (RESOLUTION_FACTOR > 0)
+		drawSupportShip (&RosterState, TRUE, TRUE);
+		
 	UnlockMutex (GraphicsLock);
 
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
@@ -426,8 +470,15 @@ RosterMenu (void)
 
 	LockMutex (GraphicsLock);
 	SetContext (StatusContext);
-	// unselect the last ship
-	drawSupportShip (&RosterState, FALSE);
+	
+	// Draw the last escort in unselected state.
+	// JMS_GFX: In 4x and 2x modes we draw the rectangle of screen
+	// we captured earlier.
+	if (RESOLUTION_FACTOR > 0)
+		DrawStamp (&savedShipFrame);
+	else // In 1x mode we just draw the icon.
+		drawSupportShip (&RosterState, FALSE, FALSE);
+	
 	DrawStatusMessage (NULL);
 	UnlockMutex (GraphicsLock);
 
diff -ruNp ./src.orig/uqm/planets/scan.c ./src/uqm/planets/scan.c
--- ./src.orig/uqm/planets/scan.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/scan.c	2017-10-23 11:41:34 -0700
@@ -16,9 +16,14 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "lander.h"
 #include "lifeform.h"
 #include "scan.h"
+
+#include "../util.h"
+		/* for get_fuel_to_sol() */
 #include "../build.h"
 #include "../colors.h"
 #include "../cons_res.h"
@@ -43,6 +48,8 @@
 #include "libs/inplib.h"
 #include "libs/mathlib.h"
 
+#define HAZARD_COLORS
+
 extern FRAME SpaceJunkFrame;
 
 // define SPIN_ON_SCAN to allow the planet to spin 
@@ -68,18 +75,22 @@ enum ScanMenuItems
 
 
 void
-RepairBackRect (RECT *pRect)
+RepairBackRect (RECT *pRect, BOOLEAN Fullscreen)
 {
 	RECT new_r, old_r;
-
+	
 	GetContextClipRect (&old_r);
 	new_r.corner.x = pRect->corner.x + old_r.corner.x;
 	new_r.corner.y = pRect->corner.y + old_r.corner.y;
 	new_r.extent = pRect->extent;
-
+	
 	new_r.extent.height += new_r.corner.y & 1;
 	new_r.corner.y &= ~1;
-	DrawFromExtraScreen (&new_r);
+	
+	if (Fullscreen)
+		DrawFromExtraScreen_Fs (&new_r);
+	else
+		DrawFromExtraScreen (&new_r);
 }
 
 static void
@@ -152,12 +163,20 @@ GetPlanetTitle (UNICODE *buf, COUNT bufs
 static void
 PrintCoarseScanPC (void)
 {
-#define SCAN_LEADING_PC 14
+#define SCAN_LEADING_PC (14 << RESOLUTION_FACTOR) // JMS_GFX
 	SDWORD val;
 	TEXT t;
 	RECT r;
 	UNICODE buf[200];
 
+	/* We need this for the new color-changing hazard readouts.
+	 * We initialize it to SCAN_PC_TITLE_COLOR because we'll need
+	 * to reset the ContextForeGroundColor to this value whenever
+	 * we may have changed it - and having it always be set to a
+	 * sane value removes the need to only reset it conditionally.
+	 */
+	Color OldColor = (SCAN_PC_TITLE_COLOR);
+
 	GetPlanetTitle (buf, sizeof (buf));
 
 	LockMutex (GraphicsLock);
@@ -165,7 +184,7 @@ PrintCoarseScanPC (void)
 
 	t.align = ALIGN_CENTER;
 	t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-	t.baseline.y = 13;
+	t.baseline.y = (13 << RESOLUTION_FACTOR) + 4*RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
@@ -176,9 +195,9 @@ PrintCoarseScanPC (void)
 	SetContextFont (TinyFont);
 	UnlockMutex (GraphicsLock);
 
-#define LEFT_SIDE_BASELINE_X_PC 5
-#define RIGHT_SIDE_BASELINE_X_PC (SIS_SCREEN_WIDTH - 75)
-#define SCAN_BASELINE_Y_PC 40
+#define LEFT_SIDE_BASELINE_X_PC (5 << RESOLUTION_FACTOR) // JMS_GFX
+#define RIGHT_SIDE_BASELINE_X_PC (SIS_SCREEN_WIDTH - (75 << RESOLUTION_FACTOR)) // JMS_GFX
+#define SCAN_BASELINE_Y_PC (40 << RESOLUTION_FACTOR) // JMS_GFX
 
 	t.baseline.y = SCAN_BASELINE_Y_PC;
 	t.align = ALIGN_LEFT;
@@ -212,6 +231,7 @@ PrintCoarseScanPC (void)
 		MakeScanValue (buf, val,
 				GAME_STRING (ORBITSCAN_STRING_BASE + 5)); // " atm"
 	}
+
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
@@ -223,9 +243,22 @@ PrintCoarseScanPC (void)
 			LEFT_SIDE_BASELINE_X_PC); // "Temp: "
 	sprintf (buf, "%d" STR_DEGREE_SIGN " c",
 			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature);
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) >= (100) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) <= (400))
+	{ /* Between 100 and 400 temperature the planet is still explorable,
+	   * draw the readout in yellow */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature > 400)
+	{ /* Above 400 the planet is quite dangerous, draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -241,8 +274,22 @@ PrintCoarseScanPC (void)
 				pSolarSysState->SysInfo.PlanetInfo.Weather + 1);
 		t.pStr = buf;
 	}
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Weather + 1) <= (4))
+	{ /* Weather values of 3 or 4 will unavoidably kill a few
+	   * crew, draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (5))
+	{ /* Weather values >= 5 will unavoidably kill many crew,
+	   * draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING_PC;
 	UnlockMutex (GraphicsLock);
 
@@ -259,8 +306,22 @@ PrintCoarseScanPC (void)
 				pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1);
 		t.pStr = buf;
 	}
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) <= (5))
+	{ /* Between class 3 and 5 tectonics the planet is still explorable,
+	   * draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) > (5))
+	{ /* Above class 5 tectonics the planet is quite dangerous, draw the
+	   * readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	UnlockMutex (GraphicsLock);
 
 	t.baseline.y = SCAN_BASELINE_Y_PC;
@@ -337,12 +398,20 @@ PrintCoarseScanPC (void)
 static void
 PrintCoarseScan3DO (void)
 {
-#define SCAN_LEADING 19
+#define SCAN_LEADING (19 << RESOLUTION_FACTOR) // JMS_GFX
 	SDWORD val;
 	TEXT t;
 	STAMP s;
 	UNICODE buf[200];
 
+	/* We need this for the new color-changing hazard readouts.
+	 * We initialize it to SCAN_PC_TITLE_COLOR because we'll need
+	 * to reset the ContextForeGroundColor to this value whenever
+	 * we may have changed it - and having it always be set to a
+	 * sane value removes the need to only reset it conditionally.
+	 */
+	Color OldColor = (SCAN_PC_TITLE_COLOR);
+
 	GetPlanetTitle (buf, sizeof (buf));
 
 	LockMutex (GraphicsLock);
@@ -350,7 +419,7 @@ PrintCoarseScan3DO (void)
 
 	t.align = ALIGN_CENTER;
 	t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-	t.baseline.y = 13;
+	t.baseline.y = (13 << RESOLUTION_FACTOR); // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
@@ -359,15 +428,15 @@ PrintCoarseScan3DO (void)
 	font_DrawText (&t);
 
 	s.origin.x = s.origin.y = 0;
-	s.origin.x = 16 - SAFE_X;
+	s.origin.x = ((16 - SAFE_X) << RESOLUTION_FACTOR); // JMS_GFX
 	s.frame = SetAbsFrameIndex (SpaceJunkFrame, 20);
 	DrawStamp (&s);
 
 	UnlockMutex (GraphicsLock);
 
-#define LEFT_SIDE_BASELINE_X (27 + (16 - SAFE_X))
+#define LEFT_SIDE_BASELINE_X ((27 + (16 - SAFE_X)) << RESOLUTION_FACTOR) // JMS_GFX
 #define RIGHT_SIDE_BASELINE_X (SIS_SCREEN_WIDTH - LEFT_SIDE_BASELINE_X)
-#define SCAN_BASELINE_Y 25
+#define SCAN_BASELINE_Y (25 << RESOLUTION_FACTOR) // JMS_GFX
 
 	t.baseline.x = LEFT_SIDE_BASELINE_X;
 	t.baseline.y = SCAN_BASELINE_Y;
@@ -377,7 +446,8 @@ PrintCoarseScan3DO (void)
 	t.pStr = buf;
 	val = ((pSolarSysState->SysInfo.PlanetInfo.PlanetToSunDist * 100L
 			+ (EARTH_RADIUS >> 1)) / EARTH_RADIUS);
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 1)); // " a.u."
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
@@ -391,7 +461,8 @@ PrintCoarseScan3DO (void)
 	{
 		val = (pSolarSysState->SysInfo.PlanetInfo.AtmoDensity * 100
 				+ (EARTH_ATMOSPHERE >> 1)) / EARTH_ATMOSPHERE;
-		MakeScanValue (buf, val, STR_EARTH_SIGN);
+		MakeScanValue (buf, val,
+				GAME_STRING (ORBITSCAN_STRING_BASE + 5)); // " atm"
 	}
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
@@ -400,31 +471,74 @@ PrintCoarseScan3DO (void)
 
 	LockMutex (GraphicsLock);
 	t.pStr = buf;
-	sprintf (buf, "%d" STR_DEGREE_SIGN,
+	sprintf (buf, "%d" STR_DEGREE_SIGN " c",
 			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature);
+
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) >= (100) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) <= (400))
+	{ /* Between 100 and 400 temperature the planet is still explorable,
+	   * draw the readout in yellow */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature > 400)
+	{ /* Above 400 the planet is quite dangerous, draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
+
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING;
 	UnlockMutex (GraphicsLock);
 
 	LockMutex (GraphicsLock);
 	t.pStr = buf;
-	sprintf (buf, "<%u>", pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == 0
+	sprintf (buf, "%s %u", GAME_STRING (ORBITSCAN_STRING_BASE + 9), // Class
+			pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == 0
 			? 0 : (pSolarSysState->SysInfo.PlanetInfo.Weather + 1));
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Weather + 1) <= (4))
+	{ /* Weather values of 3 or 4 will unavoidably kill a few
+	   * crew, draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (5))
+	{ /* Weather values < 5 will unavoidably kill many crew,
+	   * draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING;
 	UnlockMutex (GraphicsLock);
-
 	LockMutex (GraphicsLock);
 	t.pStr = buf;
-	sprintf (buf, "<%u>",
+	sprintf (buf, "%s %u", GAME_STRING (ORBITSCAN_STRING_BASE + 9), // Class
 			PLANSIZE (
 			pSolarSysState->SysInfo.PlanetInfo.PlanDataPtr->Type
 			) == GAS_GIANT
 			? 0 : (pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1));
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) <= (5))
+	{ /* Between class 3 and 5 tectonics the planet is still explorable,
+	   * draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) > (5))
+	{ /* Above class 5 tectonics the planet is quite dangerous, draw the
+	   * readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	UnlockMutex (GraphicsLock);
 
 	t.baseline.x = RIGHT_SIDE_BASELINE_X;
@@ -439,7 +553,8 @@ PrintCoarseScan3DO (void)
 			+ ((100L * 100L) >> 1)) / (100L * 100L);
 	if (val == 0)
 		val = 1;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 12)); // " e.s."
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
@@ -448,7 +563,8 @@ PrintCoarseScan3DO (void)
 	LockMutex (GraphicsLock);
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 12)); // " e.s."
 
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
@@ -460,7 +576,8 @@ PrintCoarseScan3DO (void)
 	val = pSolarSysState->SysInfo.PlanetInfo.SurfaceGravity;
 	if (val == 0)
 		val = 1;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 15)); // " g."
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
@@ -481,7 +598,8 @@ PrintCoarseScan3DO (void)
 	t.pStr = buf;
 	val = (SDWORD)pSolarSysState->SysInfo.PlanetInfo.RotationPeriod
 			* 10 / 24;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 17)); // " days"
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	UnlockMutex (GraphicsLock);
@@ -712,7 +830,8 @@ DoPickPlanetSide (MENU_STATE *pMS)
 	PICK_PLANET_STATE *pickState = pMS->privData;
 	DWORD TimeIn = GetTimeCounter ();
 	BOOLEAN select, cancel;
-
+	POINT	new_pt;
+	
 	select = PulsedInputState.menu[KEY_MENU_SELECT];
 	cancel = PulsedInputState.menu[KEY_MENU_CANCEL];
 	
@@ -721,7 +840,7 @@ DoPickPlanetSide (MENU_STATE *pMS)
 		pickState->success = false;
 		return FALSE;
 	}
-
+	
 	if (cancel)
 	{
 		pickState->success = false;
@@ -734,12 +853,12 @@ DoPickPlanetSide (MENU_STATE *pMS)
 	}
 	else
 	{
-		SIZE dx = 0;
-		SIZE dy = 0;
-		POINT new_pt;
-
+		COUNT	i, j = 0; // JMS_GFX
+		SIZE	dx = 0;
+		SIZE	dy = 0;
+		
 		new_pt = planetLoc;
-
+		
 		if (CurrentInputState.menu[KEY_MENU_LEFT])
 			dx = -1;
 		if (CurrentInputState.menu[KEY_MENU_RIGHT])
@@ -748,52 +867,107 @@ DoPickPlanetSide (MENU_STATE *pMS)
 			dy = -1;
 		if (CurrentInputState.menu[KEY_MENU_DOWN])
 			dy = 1;
-
-		LockMutex (GraphicsLock);
-		BatchGraphics ();
-
+		
 		dx = dx << MAG_SHIFT;
-		if (dx)
-		{
-			new_pt.x += dx;
-			if (new_pt.x < 0)
-				new_pt.x += (MAP_WIDTH << MAG_SHIFT);
-			else if (new_pt.x >= (MAP_WIDTH << MAG_SHIFT))
-				new_pt.x -= (MAP_WIDTH << MAG_SHIFT);
-		}
 		dy = dy << MAG_SHIFT;
-		if (dy)
-		{
-			new_pt.y += dy;
-			if (new_pt.y < 0 || new_pt.y >= (MAP_HEIGHT << MAG_SHIFT))
-				new_pt.y = planetLoc.y;
-		}
-
-		if (!pointsEqual (new_pt, planetLoc))
+		
+		// JMS_GFX: 1 for 320x240, 3 for 640x480, 7 for 1280x960
+		// XXX: This was good for debugging build, but too fast on opitmized release build.
+		//j = (1 << (RESOLUTION_FACTOR + 1)) - 1;
+		
+		// JMS_GFX: 1 for 320x240, 2 for 640x480, 4 for 1280x960
+		j = 1 << RESOLUTION_FACTOR;
+		
+		// JMS_GFX: This makes the scan cursor faster in hi-res modes.
+		// (Originally there was no loop, just the contents.)
+		for (i = 0; i < j; i++)
 		{
-			setPlanetLoc (new_pt, TRUE);
+			LockMutex (GraphicsLock);
+			BatchGraphics ();
+			
+			if (dx)
+			{
+				new_pt.x += dx;
+				if (new_pt.x < 0)
+					new_pt.x += (MAP_WIDTH << MAG_SHIFT);
+				else if (new_pt.x >= (MAP_WIDTH << MAG_SHIFT))
+					new_pt.x -= (MAP_WIDTH << MAG_SHIFT);
+			}
+			
+			if (dy)
+			{
+				new_pt.y += dy;
+				if (new_pt.y < 0 || new_pt.y >= (MAP_HEIGHT << MAG_SHIFT))
+					new_pt.y = planetLoc.y;
+			}
+			
+			if (!pointsEqual (new_pt, planetLoc))
+				setPlanetLoc (new_pt, TRUE);
+			
+			flashPlanetLocation ();
+			
+			// JMS_GFX: Just upping the denominator wouldn't do no good since
+			// something else limits entering this function to about once per 1/40 secs...
+			// Since I couldn't find that mysterious element, I had to do speed things up
+			// with a loop and this thing here.
+			// XXX: Actually, with the optimized release build the best solution now seems is to keep all at 1/40th, but keep the loop...
+			if (RESOLUTION_FACTOR == 0)
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			else if (RESOLUTION_FACTOR == 1)
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			else
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			
+			UnbatchGraphics ();
+			UnlockMutex (GraphicsLock);
 		}
-
-		flashPlanetLocation ();
-
-		UnbatchGraphics ();
-		UnlockMutex (GraphicsLock);
-
-		SleepThreadUntil (TimeIn + ONE_SECOND / 40);
 	}
-
+	
+	// JMS_GFX: For some reason, 1280x960 is choppy, no matter how many iterations
+	// the loop has or how short the sleepthread is. This final redraw makes things
+	// a bit smoother.
+	// XXX: This was good at debugging build but mad the cursor blink too fast in optimized release build.
+	/*if (RESOLUTION_FACTOR == 2)
+	 {
+	 LockMutex (GraphicsLock);
+	 BatchGraphics ();
+	 
+	 if (!pointsEqual (new_pt, planetLoc))
+	 setPlanetLoc (new_pt, TRUE);
+	 
+	 flashPlanetLocation ();
+	 
+	 UnbatchGraphics ();
+	 UnlockMutex (GraphicsLock);
+	 }*/
+	
 	return TRUE;
 }
 
 static void
 drawLandingFuelUsage (COUNT fuel)
 {
+	/* We need this so we can save the StatusMessageMode
+	 * and fix it when we're done.
+	 */
+	StatMsgMode old_status_message_mode;
+
 	UNICODE buf[100];
 
+	if (((SDWORD) (GLOBAL_SIS (FuelOnBoard)) - fuel) <= (SDWORD)(get_fuel_to_sol ()))
+	{ /* We will not have enough fuel to get to Sol if we dispatch the lander */
+		old_status_message_mode = SetStatusMessageMode (SMM_ALERT);
+	} else if (((SDWORD) (GLOBAL_SIS (FuelOnBoard)) - fuel) <= (SDWORD)(get_fuel_to_sol () + (5 * FUEL_TANK_SCALE)))
+	{ /* We will have enough fuel to get to Sol if we dispatch the lander, but will have less than 5 to spare */
+		old_status_message_mode = SetStatusMessageMode (SMM_WARNING);
+	}
+
 	sprintf (buf, "%s%1.1f",
 			GAME_STRING (NAVIGATION_STRING_BASE + 5),
 			(float) fuel / FUEL_TANK_SCALE);
 	DrawStatusMessage (buf);
+
+	SetStatusMessageMode (old_status_message_mode);
 }
 
 static void
@@ -979,9 +1153,12 @@ callPickupForScanType (SOLARSYS_STATE *s
 static void
 ScanPlanet (COUNT scanType)
 {
-#define SCAN_DURATION   (ONE_SECOND * 7 / 4)
+// BW: picked up experimentally ; any value that results into
+// SCAN_LINE_WAIT below 6 makes scanning hang up badly
+// Is this specific to my machine ?
+#define SCAN_DURATION   RES_CASE(ONE_SECOND * 7 / 4, ONE_SECOND * 7 / 4, ONE_SECOND * 12 / 4)
 // NUM_FLASH_COLORS for flashing blips; 1 for the final frame
-#define SCAN_LINES      (MAP_HEIGHT + NUM_FLASH_COLORS + 1)
+#define SCAN_LINES      (MAP_HEIGHT + NUM_FLASH_COLORS - 8)
 #define SCAN_LINE_WAIT  (SCAN_DURATION / SCAN_LINES)
 
 	COUNT startScan, endScan;
@@ -1020,7 +1197,7 @@ ScanPlanet (COUNT scanType)
 		TimeCount TimeOut;
 
 		t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-		t.baseline.y = SIS_SCREEN_HEIGHT - MAP_HEIGHT - 7;
+		t.baseline.y = SIS_SCREEN_HEIGHT - MAP_HEIGHT - (7 << RESOLUTION_FACTOR); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 
@@ -1029,12 +1206,12 @@ ScanPlanet (COUNT scanType)
 		LockMutex (GraphicsLock);
 		SetContext (PlanetContext);
 		r.corner.x = 0;
-		r.corner.y = t.baseline.y - 10;
+		r.corner.y = t.baseline.y - (10 << RESOLUTION_FACTOR); // JMS_GFX
 		r.extent.width = SIS_SCREEN_WIDTH;
-		r.extent.height = t.baseline.y - r.corner.y + 1;
+		r.extent.height = t.baseline.y - r.corner.y + (1 << RESOLUTION_FACTOR); // JMS_GFX
 		// XXX: I do not know why we are repairing it here, as there
 		//   should not be anything drawn over the stars at the moment
-		RepairBackRect (&r);
+		RepairBackRect (&r, FALSE);
 
 		SetContextFont (MicroFont);
 		SetContextForeGroundColor (textColors[scan]);
@@ -1054,7 +1231,7 @@ ScanPlanet (COUNT scanType)
 
 		// Draw the scan slowly line by line
 		TimeOut = GetTimeCounter ();
-		for (i = 0; i < SCAN_LINES; i++)
+		for (i = 0; i < (SWORD)SCAN_LINES; i++)
 		{
 			TimeOut += SCAN_LINE_WAIT;
 			if (WaitForAnyButtonUntil (TRUE, TimeOut, FALSE))
@@ -1071,7 +1248,7 @@ ScanPlanet (COUNT scanType)
 			UnlockMutex (GraphicsLock);
 		}
 
-		if (i < SCAN_LINES)
+		if (i < (SWORD)SCAN_LINES)
 		{	// Aborted by a keypress; draw in finished state
 			LockMutex (GraphicsLock);
 			BatchGraphics ();
@@ -1084,7 +1261,7 @@ ScanPlanet (COUNT scanType)
 
 	LockMutex (GraphicsLock);
 	SetContext (PlanetContext);
-	RepairBackRect (&r);
+	RepairBackRect (&r, FALSE);
 
 	SetContext (ScanContext);
 	if (scanType == AUTO_SCAN)
@@ -1297,6 +1474,7 @@ generateBioNode (SOLARSYS_STATE *system,
 {
 	COUNT i;
 	COUNT creatureType;
+	DWORD j;
 
 	creatureType = system->SysInfo.PlanetInfo.CurType;
 
@@ -1304,10 +1482,18 @@ generateBioNode (SOLARSYS_STATE *system,
 	{
 		// Place moving creatures at a random location.
 		i = (COUNT)TFB_Random ();
-		NodeElementPtr->current.location.x =
-				(LOBYTE (i) % (MAP_WIDTH - (8 << 1))) + 8;
-		NodeElementPtr->current.location.y =
-				(HIBYTE (i) % (MAP_HEIGHT - (8 << 1))) + 8;
+		j = (DWORD)TFB_Random ();
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			NodeElementPtr->current.location.x = (LOBYTE (i) % (MAP_WIDTH - (8 << 1))) + 8;
+			NodeElementPtr->current.location.y = (HIBYTE (i) % (MAP_HEIGHT - (8 << 1))) + 8;
+		}
+		else 
+		{
+			NodeElementPtr->current.location.x = (LOWORD (j) % (MAP_WIDTH - (8 << 1))) + 8;	// JMS_GFX: Replaced previous line with this line (BYTE was too small for 640x480 maps.)
+			NodeElementPtr->current.location.y = (HIWORD (j) % (MAP_HEIGHT - (8 << 1))) + 8;  // JMS_GFX: Replaced previous line with this line (BYTE was too small for 1280x960 maps.)
+		}
 	}
 
 	if (system->PlanetSideFrame[0] == 0)
@@ -1394,8 +1580,11 @@ GeneratePlanetSide (void)
 
 				EType = pSolarSysState->SysInfo.PlanetInfo.CurType;
 				NodeElementPtr->turn_wait = (BYTE)EType;
-				NodeElementPtr->mass_points = HIBYTE (
-						pSolarSysState->SysInfo.PlanetInfo.CurDensity);
+				
+				// JMS: Partially scavenged energy blips won't return anymore to original size after leaving planet.
+				NodeElementPtr->mass_points = HIBYTE (pSolarSysState->SysInfo.PlanetInfo.CurDensity)
+				- pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[scan][num_nodes];
+				
 				NodeElementPtr->current.image.frame = SetAbsFrameIndex (
 						MiscDataFrame, (NUM_SCANDOT_TRANSITIONS * 2)
 						+ ElementCategory (EType) * 5);
diff -ruNp ./src.orig/uqm/planets/scan.h ./src/uqm/planets/scan.h
--- ./src.orig/uqm/planets/scan.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/scan.h	2017-10-23 11:41:34 -0700
@@ -45,7 +45,7 @@ struct scan_block
 
 extern void ScanSystem (void);
 
-extern void RepairBackRect (RECT *pRect);
+extern void RepairBackRect (RECT *pRect, BOOLEAN Fullscreen);
 extern void GeneratePlanetSide (void);
 extern COUNT callGenerateForScanType (SOLARSYS_STATE *solarSys,
 		PLANET_DESC *world, COUNT node, BYTE scanType);
diff -ruNp ./src.orig/uqm/planets/solarsys.c ./src/uqm/planets/solarsys.c
--- ./src.orig/uqm/planets/solarsys.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/solarsys.c	2017-10-23 11:41:34 -0700
@@ -16,7 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "lander.h"
+#include "scan.h"
 #include "../colors.h"
 #include "../controls.h"
 #include "../menustat.h"
@@ -47,17 +50,29 @@
 #include "libs/log.h"
 #include "libs/misc.h"
 
+#include <math.h>
+#include <time.h>
 
 //#define DEBUG_SOLARSYS
 //#define SMOOTH_SYSTEM_ZOOM  1
 
 #define IP_FRAME_RATE  (ONE_SECOND / 30)
 
+// BW: those do not depend on the resolution because numbers too small
+// cause crashes in the generation and rendering
+#define GENERATE_PLANET_DIAMETER (29 << 2)
+#define GENERATE_MOON_DIAMETER (7 << 2)
+#define GENERATE_PLANET_PERIMETER (GENERATE_PLANET_DIAMETER * ORIGINAL_MAP_WIDTH / ORIGINAL_MAP_HEIGHT)
+#define GENERATE_MOON_PERIMETER (GENERATE_MOON_DIAMETER * ORIGINAL_MAP_WIDTH / ORIGINAL_MAP_HEIGHT)
+
+static void AnimateSun (SIZE radius); // JMS
 static BOOLEAN DoIpFlight (SOLARSYS_STATE *pSS);
 static void DrawSystem (SIZE radius, BOOLEAN IsInnerSystem);
 static FRAME CreateStarBackGround (void);
 static void DrawInnerSystem (void);
 static void DrawOuterSystem (void);
+static void SetPlanetColorMap (PLANET_DESC *planet); // JMS, BW
+static void ValidateInnerOrbits (void);
 static void ValidateOrbits (void);
 
 // SolarSysMenu() items
@@ -210,6 +225,110 @@ playerInInnerSystem (void)
 	return pSolarSysState->pBaseDesc != pSolarSysState->PlanetDesc;
 }
 
+void GenerateTexturedMoons (SOLARSYS_STATE *system, PLANET_DESC *planet)
+{
+	COUNT i;
+	FRAME SurfFrame;
+	PLANET_DESC *pMoonDesc;
+	PLANET_DESC *previousOrbitalDesc;
+	previousOrbitalDesc = pSolarSysState->pOrbitalDesc;
+	
+	for (i = 0, pMoonDesc = &system->MoonDesc[0];
+			i < planet->NumPlanets; ++i, ++pMoonDesc)
+	{
+		SurfFrame = NULL;
+	
+		// BW : precompute the generated texture to display it in IP
+		if (!(pMoonDesc->data_index & WORLD_TYPE_SPECIAL))
+		{
+			DoPlanetaryAnalysis (&pSolarSysState->SysInfo, pMoonDesc);
+			
+			if (CurStarDescPtr->Index == SOL_DEFINED)
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 0;
+
+			pSolarSysState->pOrbitalDesc = pMoonDesc;
+
+			if (CurStarDescPtr->Index == SOL_DEFINED)
+			{	// png defined moons in Sol
+			
+				COUNT curr_planet_index = planetIndex (pSolarSysState, planet);
+		
+				if (curr_planet_index == 2)
+				{
+					// EARTH
+					switch (i)
+					{
+						case 1: /* LUNA */
+							SurfFrame = CaptureDrawable (LoadGraphic (IP_LUNA_MASK_ANIM));
+							break;
+					}
+				}
+				else if (curr_planet_index == 4)
+				{
+					// JUPITER
+					switch (i)
+					{
+						case 0: /* IO */
+							SurfFrame = CaptureDrawable (LoadGraphic (IP_IO_MASK_ANIM));
+							break;
+						case 1: /* EUROPA */
+							SurfFrame = CaptureDrawable (LoadGraphic (IP_EUROPA_MASK_ANIM));
+							break;
+						case 2: /* GANYMEDE */
+							SurfFrame = CaptureDrawable (LoadGraphic (IP_GANYMEDE_MASK_ANIM));
+							break;
+						case 3: /* CALLISTO */
+							SurfFrame = CaptureDrawable (LoadGraphic (IP_CALLISTO_MASK_ANIM));
+							break;
+					}
+				}
+				else if (curr_planet_index == 5)
+				{
+					// SATURN
+					switch (i)
+					{
+						case 0: /* TITAN */
+							SurfFrame = CaptureDrawable (LoadGraphic (IP_TITAN_MASK_ANIM));
+							break;
+					}
+				}
+				else if (curr_planet_index == 7)
+				{
+					// NEPTUNE
+					switch (i)
+					{
+						case 0: /* TRITON */
+							SurfFrame = CaptureDrawable (LoadGraphic (IP_TRITON_MASK_ANIM));
+							break;
+					}
+				}
+			}
+
+			GeneratePlanetSurfaceForIP (pMoonDesc, SurfFrame, GENERATE_MOON_PERIMETER, GENERATE_MOON_DIAMETER);
+			pMoonDesc->orbit = pSolarSysState->Orbit;
+			PrepareNextRotationFrameForIP (pMoonDesc, 0);
+
+			// Clean up some parasitic use of pSolarSysState
+			LockMutex (GraphicsLock);
+			// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
+			// pSolarSysState->Orbit.TintFrame = 0;
+			// pSolarSysState->Orbit.TintColor = BLACK_COLOR;
+		
+			// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
+			// pSolarSysState->Orbit.TopoZoomFrame = 0;
+			DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+			pSolarSysState->XlatRef = 0;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+			pSolarSysState->TopoFrame = 0;
+			DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+			pSolarSysState->OrbitalCMap = 0;
+			UnlockMutex (GraphicsLock);
+			// End clean up
+		}
+	}
+	pSolarSysState->pOrbitalDesc = previousOrbitalDesc;
+}
+
 static void
 GenerateMoons (SOLARSYS_STATE *system, PLANET_DESC *planet)
 {
@@ -220,11 +339,6 @@ GenerateMoons (SOLARSYS_STATE *system, P
 
 	old_seed = TFB_SeedRandom (planet->rand_seed);
 
-	(*system->genFuncs->generateName) (system, planet);
-	(*system->genFuncs->generateMoons) (system, planet);
-
-	facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-			ARCTAN (planet->location.x, planet->location.y)));
 	for (i = 0, pMoonDesc = &system->MoonDesc[0];
 			i < MAX_MOONS; ++i, ++pMoonDesc)
 	{
@@ -235,6 +349,12 @@ GenerateMoons (SOLARSYS_STATE *system, P
 		pMoonDesc->temp_color = planet->temp_color;
 	}
 
+	(*system->genFuncs->generateName) (system, planet);
+	(*system->genFuncs->generateMoons) (system, planet);
+
+	facing = NORMALIZE_FACING (ANGLE_TO_FACING (
+			ARCTAN (planet->location.x, planet->location.y)));
+
 	TFB_SeedRandom (old_seed);
 }
 
@@ -260,6 +380,27 @@ FreeIPData (void)
 void
 LoadIPData (void)
 {
+	if (RESOLUTION_FACTOR == 0)
+	{
+		SunFrame = CaptureDrawable (LoadGraphic (SUN_MASK_PMAP_ANIM));
+	}
+	// JMS: In hi-res separate animations are used for each star color.
+	else 
+	{
+		if (STAR_COLOR(CurStarDescPtr->Type) == BLUE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNBLUE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == GREEN_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNGREEN_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == ORANGE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNORANGE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == RED_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNRED_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type)== WHITE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNWHITE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == YELLOW_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNYELLOW_MASK_PMAP_ANIM));
+	}
+	
 	if (SpaceJunkFrame == 0)
 	{
 		SpaceJunkFrame = CaptureDrawable (
@@ -270,7 +411,6 @@ LoadIPData (void)
 		OrbitalFrame = CaptureDrawable (
 				LoadGraphic (ORBPLAN_MASK_PMAP_ANIM));
 		SunCMap = CaptureColorMap (LoadColorMap (IPSUN_COLOR_MAP));
-		SunFrame = CaptureDrawable (LoadGraphic (SUN_MASK_PMAP_ANIM));
 
 		SpaceMusic = LoadMusic (IP_MUSIC);
 	}
@@ -356,6 +496,100 @@ seedRandomForSolarSys (void)
 			CurStarDescPtr->star_pt.y));
 }
 
+void GenerateTexturedPlanets (void)
+{
+	COUNT i;
+	FRAME SurfFrame;
+	PLANET_DESC *pCurDesc;
+	PLANET_DESC *previousOrbitalDesc;
+	previousOrbitalDesc = pSolarSysState->pOrbitalDesc;
+	
+	for (i = 0, pCurDesc = pSolarSysState->PlanetDesc;
+			i < pSolarSysState->SunDesc[0].NumPlanets; ++i, ++pCurDesc)
+	{
+		SurfFrame = NULL;
+
+		DoPlanetaryAnalysis (&pSolarSysState->SysInfo, pCurDesc);
+		
+		// BW : precompute the generated texture to display it in IP
+		pSolarSysState->pOrbitalDesc = pCurDesc;
+		if (CurStarDescPtr->Index == SOL_DEFINED)
+		{	// png defined planets in Sol
+			switch (i)
+			{
+			case 0: /* MERCURY */
+				SurfFrame = CaptureDrawable (LoadGraphic (IP_MERCURY_MASK_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 59 * 240;
+				break;
+			case 1: /* VENUS */
+				SurfFrame = CaptureDrawable (LoadGraphic (IP_VENUS_MASK_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 177;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 243 * 240;
+				break;
+			case 2: // EARTH
+				SurfFrame = CaptureDrawable (LoadGraphic (IP_EARTH_MASK_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 23;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 240;
+				break;
+			case 3: // MARS
+				SurfFrame = CaptureDrawable (LoadGraphic (IP_MARS_MASK_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 24;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 246;
+				break;
+			case 4: /* JUPITER */
+				SurfFrame = CaptureDrawable (LoadGraphic (IP_JUPITER_MASK_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 98;
+				break;
+			case 5: /* SATURN */
+				SurfFrame = CaptureDrawable (LoadGraphic (IP_SATURN_MASK_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 27;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 102;
+				break;
+			case 6: /* URANUS */
+				SurfFrame = CaptureDrawable (LoadGraphic (IP_URANUS_MASK_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 98;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 172;
+				break;
+			case 7: /* NEPTUNE */
+				SurfFrame = CaptureDrawable (LoadGraphic (IP_NEPTUNE_MASK_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 30;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 182;
+				break;
+			case 8: /* PLUTO */
+				SurfFrame = CaptureDrawable (LoadGraphic (IP_PLUTO_MASK_ANIM));
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 119;
+				pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 1533;
+				break;
+			}
+		}
+		
+		GeneratePlanetSurfaceForIP (pCurDesc, SurfFrame, GENERATE_PLANET_PERIMETER, GENERATE_PLANET_DIAMETER);
+		pCurDesc->orbit = pSolarSysState->Orbit;
+		PrepareNextRotationFrameForIP (pCurDesc, 0);
+		
+		// Clean up some parasitic use of pSolarSysState
+		LockMutex (GraphicsLock);
+		// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
+		// pSolarSysState->Orbit.TintFrame = 0;
+		// pSolarSysState->Orbit.TintColor = BLACK_COLOR;
+		
+		// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
+		// pSolarSysState->Orbit.TopoZoomFrame = 0;
+		DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+		pSolarSysState->XlatRef = 0;
+		DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+		pSolarSysState->TopoFrame = 0;
+		DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+		pSolarSysState->OrbitalCMap = 0;
+		UnlockMutex (GraphicsLock);
+		// End clean up
+	}
+	pSolarSysState->pOrbitalDesc = previousOrbitalDesc;
+}
+
+
 // Returns an orbital PLANET_DESC when player is in orbit
 static PLANET_DESC *
 LoadSolarSys (void)
@@ -365,7 +599,10 @@ LoadSolarSys (void)
 	PLANET_DESC *pCurDesc;
 	DWORD old_seed;
 #define NUM_TEMP_RANGES 5
-	static const Color temp_color_array[NUM_TEMP_RANGES] =
+
+	// JMS_GFX: Let's make the dark blue planet orbit dots a little
+	// more visible in 640x480 and 1280x960.
+	static const Color temp_color_array_1x[NUM_TEMP_RANGES] =
 	{
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x0E), 0x54),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),
@@ -373,10 +610,22 @@ LoadSolarSys (void)
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x08, 0x00), 0x75),
 	};
+	static const Color temp_color_array_2x4x[NUM_TEMP_RANGES] =
+	{
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x12), 0x54),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0B, 0x00), 0x6D),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x08, 0x00), 0x75),
+	};
 
 	old_seed = seedRandomForSolarSys ();
 
-	SunFrame = SetAbsFrameIndex (SunFrame, STAR_TYPE (CurStarDescPtr->Type));
+	// JMS: Animating IP sun in hi-res...
+	if (RESOLUTION_FACTOR == 0)
+		SunFrame = SetAbsFrameIndex (SunFrame, STAR_TYPE (CurStarDescPtr->Type));
+	else
+		SunFrame = SetAbsFrameIndex (SunFrame, (STAR_TYPE (CurStarDescPtr->Type)) * 32);
 
 	pCurDesc = &pSolarSysState->SunDesc[0];
 	pCurDesc->pPrevDesc = 0;
@@ -413,7 +662,13 @@ LoadSolarSys (void)
 			index = (SysInfo.PlanetInfo.SurfaceTemperature + 250) / 100;
 			if (index >= NUM_TEMP_RANGES)
 				index = NUM_TEMP_RANGES - 1;
-			pCurDesc->temp_color = temp_color_array[index];
+				
+			// JMS_GFX: Let's make the dark blue planet orbit dots a little
+			// more visible in 640x480 and 1280x960.
+			if (RESOLUTION_FACTOR == 0)
+				pCurDesc->temp_color = temp_color_array_1x[index];
+			else
+				pCurDesc->temp_color = temp_color_array_2x4x[index];
 		}
 	}
 
@@ -494,17 +749,128 @@ saveNonOrbitalLocation (void)
 static void
 FreeSolarSys (void)
 {
+	COUNT i, j;
+	PLANET_DESC *pCurDesc;
+
 	if (pSolarSysState->InIpFlight)
+		{
+			pSolarSysState->InIpFlight = FALSE;
+			
+			if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
+				saveNonOrbitalLocation ();
+		}
+	
+	DestroyDrawable (ReleaseDrawable (SolarSysFrame));
+	SolarSysFrame = NULL;
+	
+	if (TEXTURED_PLANETS)
 	{
-		pSolarSysState->InIpFlight = FALSE;
+	// BW: clean up data generated for textured IP planets
+	for (i = 0, pCurDesc = pSolarSysState->PlanetDesc;
+	     i < pSolarSysState->SunDesc[0].NumPlanets; ++i, ++pCurDesc)
+	{
+		PLANET_ORBIT *Orbit = &pCurDesc->orbit;
 		
-		if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
-			saveNonOrbitalLocation ();
-	}
+		LockMutex (GraphicsLock);
 
-	DestroyDrawable (ReleaseDrawable (SolarSysFrame));
-	SolarSysFrame = NULL;
+		HFree (Orbit->lpTopoData);
+		Orbit->lpTopoData = 0;
+		DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+		Orbit->SphereFrame = NULL;
+		
+		DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+		Orbit->ObjectFrame = 0;
+		DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+		Orbit->WorkFrame = 0;
+		
+		// JMS: Not sure if these do any good...
+		DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
+		pSolarSysState->Orbit.TintFrame = 0;
+		pSolarSysState->Orbit.TintColor = BLACK_COLOR;
+		DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
+		pSolarSysState->Orbit.TopoZoomFrame = 0;
+		DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+		pSolarSysState->XlatRef = 0;
+		DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+		pSolarSysState->TopoFrame = 0;
+		DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+		pSolarSysState->OrbitalCMap = 0;
+		// JMS ends.
+		
+		HFree (Orbit->TopoColors);
+		Orbit->TopoColors = NULL;
+		HFree (Orbit->ScratchArray);
+		Orbit->ScratchArray = NULL;
+		if (Orbit->map_rotate && Orbit->light_diff)
+		{
+			for (j=0 ; j < GENERATE_PLANET_DIAMETER+1 ; j++)
+			{
+				HFree (Orbit->map_rotate[j]);
+				HFree (Orbit->light_diff[j]);
+			}
+		}
 
+		HFree (Orbit->map_rotate);
+		Orbit->map_rotate = NULL;
+		HFree (Orbit->light_diff);
+		Orbit->light_diff = NULL;
+
+		UnlockMutex (GraphicsLock);
+	}	
+
+	// BW: if we were in Inner System, clean up data for textured IP moons
+	if (playerInInnerSystem())
+	{
+		COUNT numMoons;
+		if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
+			numMoons = pSolarSysState->pOrbitalDesc->pPrevDesc->NumPlanets;
+		else
+			numMoons = pSolarSysState->pOrbitalDesc->NumPlanets;
+		
+		for (i = 0, pCurDesc = pSolarSysState->MoonDesc;
+		     i < numMoons; ++i, ++pCurDesc)
+		{
+			if (!(pCurDesc->data_index & WORLD_TYPE_SPECIAL))
+			{
+				PLANET_ORBIT *Orbit = &pCurDesc->orbit;
+			
+				LockMutex (GraphicsLock);
+			
+				HFree (Orbit->lpTopoData);
+				Orbit->lpTopoData = 0;
+				DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+				Orbit->SphereFrame = NULL;
+			
+				DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+				Orbit->ObjectFrame = 0;
+				DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+				Orbit->WorkFrame = 0;
+			
+				HFree (Orbit->TopoColors);
+				Orbit->TopoColors = NULL;
+				HFree (Orbit->ScratchArray);
+				Orbit->ScratchArray = NULL;
+				if (Orbit->map_rotate && Orbit->light_diff)
+				{
+					for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++)
+					{
+						HFree (Orbit->map_rotate[j]);
+						HFree (Orbit->light_diff[j]);
+					}
+				}
+				
+				HFree (Orbit->map_rotate);
+				Orbit->map_rotate = NULL;
+				HFree (Orbit->light_diff);
+				Orbit->light_diff = NULL;
+
+				UnlockMutex (GraphicsLock);
+			}
+		}
+	}
+	// End clean up
+	}
+	
 	StopMusic ();
 
 //    FreeIPData ();
@@ -548,10 +914,12 @@ CheckIntersect (BOOLEAN just_checking)
 	PlanetIntersect.IntersectStamp.origin.x = SIS_SCREEN_WIDTH >> 1;
 	PlanetIntersect.IntersectStamp.origin.y = SIS_SCREEN_HEIGHT >> 1;
 	PlanetIntersect.EndPoint = PlanetIntersect.IntersectStamp.origin;
-
+	
 	PlanetIntersect.IntersectStamp.frame = getCollisionFrame (pCurDesc,
 			MAKE_WORD (PlanetOffset, MoonOffset));
 
+	//log_add (log_Debug,"Nyt: x:%d, y:%d", PlanetIntersect.IntersectStamp.origin.x, PlanetIntersect.IntersectStamp.origin.y);
+	
 	// Start with no collisions
 	NewWaitPlanet = 0;
 
@@ -599,6 +967,8 @@ CheckIntersect (BOOLEAN just_checking)
 		PlanetIntersect.IntersectStamp.frame = getCollisionFrame (pCurDesc,
 				MAKE_WORD (PlanetOffset, MoonOffset));
 
+		//log_add (log_Debug, "Ship x:%d y:%d. Planet x:%d, y:%d", ShipIntersect.IntersectStamp.origin.x, ShipIntersect.IntersectStamp.origin.y, PlanetIntersect.IntersectStamp.origin.x, PlanetIntersect.IntersectStamp.origin.y);
+		
 		if (DrawablesIntersect (&ShipIntersect,
 				&PlanetIntersect, MAX_TIME_VALUE))
 		{
@@ -672,6 +1042,19 @@ static void
 ValidateOrbit (PLANET_DESC *planet, int sizeNumer, int dyNumer, int denom)
 {
 	COUNT index;
+	
+	if (ORBITING_PLANETS)
+	{
+		// BW: recompute planet position to account for orbiting
+		// COUNT newAngle;
+		// newAngle = NORMALIZE_ANGLE(planet->angle + (COUNT)(daysElapsed() * planet->orb_speed));
+		// planet->location.x = COSINE (newAngle, planet->radius);
+		// planet->location.y = SINE (newAngle, planet->radius);
+		double newAngle;
+		newAngle = (planet->angle + daysElapsed() * planet->orb_speed) * M_PI / 32 - M_PI/2 ;
+		planet->location.x = (COORD)(cos(newAngle) * planet->radius);
+		planet->location.y = (COORD)(sin(newAngle) * planet->radius);
+	}
 
 	if (sizeNumer <= DISPLAY_FACTOR)
 	{	// All planets in outer view, and moons in inner
@@ -706,7 +1089,9 @@ ValidateOrbit (PLANET_DESC *planet, int
 		}
 		else if (worldIsMoon (pSolarSysState, planet))
 		{
-			Size += 2;
+			Size = 2; // += 2;
+			// BW: Force moons to size 2 to avoid issues with
+			//     Triton (the one and only large rocky moon)
 		}
 		else if (denom <= (MAX_ZOOM_RADIUS >> 2))
 		{
@@ -724,6 +1109,25 @@ ValidateOrbit (PLANET_DESC *planet, int
 			angle = ARCTAN (planet->pPrevDesc->location.x,
 					planet->pPrevDesc->location.y);
 		}
+		if (TEXTURED_PLANETS)
+		{
+			// Those match the sizes of the png planets
+			switch (Size)
+			{
+			case 0: planet->size = 3;
+				break;
+			case 1: planet->size = 4;
+				break;
+			case 2: planet->size = 7;
+				break;
+			case 3: planet->size = 11;
+				break;
+			case 4: planet->size = 15;
+				break;
+			case 5: planet->size = 29;
+				break;
+			}
+		}
 		planet->image.frame =	SetAbsFrameIndex (OrbitalFrame,
 				(Size << FACING_SHIFT) + NORMALIZE_FACING (
 				ANGLE_TO_FACING (angle)));
@@ -910,7 +1314,7 @@ enterInnerSystem (PLANET_DESC *planet)
 	else if (GLOBAL (ShipStamp.origin.y) >= SIS_SCREEN_HEIGHT)
 		GLOBAL (ShipStamp.origin.y) =
 				(SIS_SCREEN_HEIGHT - 1) - 1;
-
+	
 	GLOBAL (ip_location) = displayToLocation (
 			GLOBAL (ShipStamp.origin), MAX_ZOOM_RADIUS);
 	
@@ -919,6 +1323,8 @@ enterInnerSystem (PLANET_DESC *planet)
 	ZeroVelocityComponents (&GLOBAL (velocity));
 
 	GenerateMoons (pSolarSysState, planet);
+	if (TEXTURED_PLANETS)
+		GenerateTexturedMoons (pSolarSysState, planet);
 	pSolarSysState->pBaseDesc = pSolarSysState->MoonDesc;
 	pSolarSysState->pOrbitalDesc = planet;
 }
@@ -927,17 +1333,70 @@ static void
 leaveInnerSystem (PLANET_DESC *planet)
 {
 	COUNT outerPlanetWait;
+	COUNT i, j;
+	PLANET_DESC *pMoonDesc;
 
 	pSolarSysState->pBaseDesc = pSolarSysState->PlanetDesc;
 	pSolarSysState->pOrbitalDesc = NULL;
 
 	outerPlanetWait = MAKE_WORD (planet - pSolarSysState->PlanetDesc + 1, 0);
+	// BW: planet may have moved while we were into Inner System
+	ValidateOrbit (planet, DISPLAY_FACTOR, DISPLAY_FACTOR / 4,
+		       pSolarSysState->SunDesc[0].radius);
+	pSolarSysState->SunDesc[0].location =
+			planetOuterLocation (planetIndex (pSolarSysState, planet));
 	GLOBAL (ip_location) = pSolarSysState->SunDesc[0].location;
 	XFormIPLoc (&GLOBAL (ip_location), &GLOBAL (ShipStamp.origin), TRUE);
 	ZeroVelocityComponents (&GLOBAL (velocity));
 
 	// Now the ship is in outer system (as per game logic)
 
+	if (TEXTURED_PLANETS)
+	{
+	// BW: clean up data generated for textured IP moons
+	for (i = 0, pMoonDesc = pSolarSysState->MoonDesc;
+	     i < planet->NumPlanets; ++i, ++pMoonDesc)
+	{
+		if (!(pMoonDesc->data_index & WORLD_TYPE_SPECIAL))
+		{
+			PLANET_ORBIT *Orbit = &pMoonDesc->orbit;
+		
+			LockMutex (GraphicsLock);
+
+			HFree (Orbit->lpTopoData);
+			Orbit->lpTopoData = 0;
+			DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+			Orbit->SphereFrame = NULL;
+		
+			DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+			Orbit->ObjectFrame = 0;
+			DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+			Orbit->WorkFrame = 0;
+
+			HFree (Orbit->TopoColors);
+			Orbit->TopoColors = NULL;
+			HFree (Orbit->ScratchArray);
+			Orbit->ScratchArray = NULL;
+			if (Orbit->map_rotate && Orbit->light_diff)
+			{
+				for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++)
+				{
+					HFree (Orbit->map_rotate[j]);
+					HFree (Orbit->light_diff[j]);
+				}
+			}
+
+			HFree (Orbit->map_rotate);
+			Orbit->map_rotate = NULL;
+			HFree (Orbit->light_diff);
+			Orbit->light_diff = NULL;
+
+			UnlockMutex (GraphicsLock);
+		}
+	}
+	// End clean up
+	}
+	
 	pSolarSysState->WaitIntersect = outerPlanetWait;
 	// See if we also intersect with another planet, and if we do,
 	// disable collisions comletely until we stop intersecting
@@ -959,6 +1418,7 @@ static BOOLEAN
 CheckShipLocation (SIZE *newRadius)
 {
 	SIZE radius;
+	BYTE ec = GET_GAME_STATE (ESCAPE_COUNTER); // JMS_GFX
 
 	radius = pSolarSysState->SunDesc[0].radius;
 	*newRadius = pSolarSysState->SunDesc[0].radius;
@@ -996,7 +1456,11 @@ CheckShipLocation (SIZE *newRadius)
 		return TRUE;
 	}
 
-	if (GLOBAL (autopilot.x) == ~0 && GLOBAL (autopilot.y) == ~0)
+	// JMS: Added the escape counter check to prevent transitting back
+	// to planet close-up view after encounter near the planet in outer
+	// system view
+	if (GLOBAL (autopilot.x) == ~0 && GLOBAL (autopilot.y) == ~0
+		&& (ec < 60 || RESOLUTION_FACTOR == 0))
 	{	// Not on autopilot -- may collide with a planet
 		PLANET_DESC *planet = CheckIntersect (FALSE);
 		if (planet)
@@ -1114,17 +1578,244 @@ RestoreSystemView (void)
 	DrawStamp (&s);
 }
 
+
+// JMS: This animates the truespace suns!
+#define SUN_ANIMFRAMES_NUM 32
+static void
+AnimateSun (SIZE radius)
+{
+	PLANET_DESC *pSunDesc = &pSolarSysState->SunDesc[0];
+	PLANET_DESC *pNearestPlanetDesc = &pSolarSysState->PlanetDesc[0];
+	static COUNT sunAnimIndex = 0;
+	COUNT zoomLevelIndex = 0;
+	
+	// Advance to the next frame.
+	sunAnimIndex++;
+	
+	// Go back to start of the anim after advancing past the last frame.
+	if (sunAnimIndex % SUN_ANIMFRAMES_NUM == 0)
+		sunAnimIndex = 0;
+	
+	// Zoom according to how close we are to the sun.
+	if (radius <= (MAX_ZOOM_RADIUS >> 1))
+	{
+		zoomLevelIndex += SUN_ANIMFRAMES_NUM;
+		if (radius <= (MAX_ZOOM_RADIUS >> 2))
+			zoomLevelIndex += SUN_ANIMFRAMES_NUM;
+	}
+	
+	// Tell the imageset which frame it should use.
+	pSunDesc->image.frame = SetRelFrameIndex (SunFrame, zoomLevelIndex + sunAnimIndex);
+	
+	// Draw the image.
+	DrawStamp (&pSunDesc->image);
+	
+	// BW: temporary workaround, drawing order will have to be redone anyway
+	if (!TEXTURED_PLANETS)
+	{
+		// Re-draw the image of the nearest planet, so the sun won't obscure it.
+		SetPlanetColorMap (pNearestPlanetDesc);
+		DrawStamp (&pNearestPlanetDesc->image);
+	}
+}
+
+static void
+CalcSunSize (PLANET_DESC *pSunDesc, SIZE radius)
+{
+	SIZE index = 0;
+
+	if (radius <= (MAX_ZOOM_RADIUS >> 1))
+	{
+		++index;
+		if (radius <= (MAX_ZOOM_RADIUS >> 2))
+			++index;
+	}
+
+	pSunDesc->image.origin.x = SIS_SCREEN_WIDTH >> 1;
+	pSunDesc->image.origin.y = SIS_SCREEN_HEIGHT >> 1;
+	// JMS: Animating IP sun in hi-res modes...
+	if (RESOLUTION_FACTOR == 0)
+		pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index);
+	else
+		pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index * SUN_ANIMFRAMES_NUM);
+}
+
+static void
+SetPlanetColorMap (PLANET_DESC *planet)
+{
+	COUNT index = planet->data_index & ~WORLD_TYPE_SPECIAL;
+	assert (index < NUMBER_OF_PLANET_TYPES);
+	SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (OrbitalCMap,
+			PLANCOLOR (PlanData[index].Type))));
+}
+
+static void
+DrawTexturedBody (PLANET_DESC* planet, STAMP s)
+{
+	int oldScale;
+	int oldMode;
+
+	//LockMutex (GraphicsLock);
+	//SetContext (SpaceContext);
+	
+	BatchGraphics ();
+	oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
+	if (worldIsMoon(pSolarSysState, planet))
+		oldScale = SetGraphicScale (GSCALE_IDENTITY * (planet->size << RESOLUTION_FACTOR) / GENERATE_MOON_DIAMETER);
+	else
+		oldScale = SetGraphicScale (GSCALE_IDENTITY * (planet->size << RESOLUTION_FACTOR) / GENERATE_PLANET_DIAMETER);
+	s.frame = planet->orbit.SphereFrame;
+	DrawStamp (&s);
+	if (planet->orbit.ObjectFrame)
+	{
+		s.frame = planet->orbit.ObjectFrame;
+		DrawStamp (&s);
+	}
+	SetGraphicScale (oldScale);
+	SetGraphicScaleMode (oldMode);
+	
+	UnbatchGraphics ();
+	//UnlockMutex (GraphicsLock);
+}
+
+static void
+DrawInnerPlanets (PLANET_DESC *planet)
+{
+	STAMP s;
+	COUNT i;
+	PLANET_DESC *moon;
+
+	s.origin.x = SIS_SCREEN_WIDTH >> 1;
+	s.origin.y = SIS_SCREEN_HEIGHT >> 1;
+
+	if (TEXTURED_PLANETS)
+	{
+		// Draw the planet image
+		DrawTexturedBody (planet, s);
+		
+		// Draw the moon images
+		for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
+		     i; --i, ++moon)
+		{
+			if (moon->data_index & WORLD_TYPE_SPECIAL)
+				DrawStamp (&moon->image);
+			else
+				DrawTexturedBody(moon, moon->image);
+		}
+	}
+	else
+	{
+		// Draw the planet image
+		SetPlanetColorMap (planet);
+		s.frame = planet->image.frame;
+
+		i = planet->data_index & ~WORLD_TYPE_SPECIAL;
+		if (i < NUMBER_OF_PLANET_TYPES
+			&& (planet->data_index & PLANET_SHIELDED))
+		{	// Shielded world looks "shielded" in inner view
+			s.frame = SetAbsFrameIndex (SpaceJunkFrame, 17);
+		}
+		DrawStamp (&s);
+
+		// Draw the moon images
+		for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
+			i; --i, ++moon)
+		{
+			if (!(moon->data_index & WORLD_TYPE_SPECIAL))
+				SetPlanetColorMap (moon);
+			DrawStamp (&moon->image);
+		}
+	}
+}
+
+static void
+DrawOuterPlanets (SIZE radius)
+{
+	SIZE index;
+	PLANET_DESC *pCurDesc;
+	
+	CalcSunSize (&pSolarSysState->SunDesc[0], radius);
+	
+	index = pSolarSysState->FirstPlanetIndex;
+	for (;;)
+	{
+		pCurDesc = &pSolarSysState->PlanetDesc[index];
+		if (TEXTURED_PLANETS)
+		{
+			if (pCurDesc == &pSolarSysState->SunDesc[0])
+			{	// It's a sun
+				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
+					SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
+				DrawStamp (&pCurDesc->image);
+			}
+			else
+			{	// It's a planet
+				DrawTexturedBody(pCurDesc, pCurDesc->image);
+			}
+		}
+		else
+		{
+			if (pCurDesc == &pSolarSysState->SunDesc[0])
+			{	// It's a sun
+				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
+					SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
+			}
+			else
+			{	// It's a planet
+				SetPlanetColorMap (pCurDesc);
+			}
+			DrawStamp (&pCurDesc->image);
+		}
+		
+		if (index == pSolarSysState->LastPlanetIndex)
+			break;
+		index = pCurDesc->NextIndex;
+	}
+}
+
+void RotatePlanets (BOOLEAN IsInnerSystem, SIZE frameCounter)
+{
+	PLANET_DESC *planet;
+	PLANET_DESC *moon;
+	COUNT i;
+
+	// Do not try to rotate planets that haven't been generated yet.
+	if (!pSolarSysState->PlanetDesc->orbit.lpTopoData)
+		return;
+	
+	if (IsInnerSystem)
+	{
+		planet = pSolarSysState->pOrbitalDesc;
+		PrepareNextRotationFrameForIP (planet, frameCounter);
+		for (i = 0; i < planet->NumPlanets; ++i)
+		{
+			moon = &pSolarSysState->MoonDesc[i];
+			if (!(moon->data_index & WORLD_TYPE_SPECIAL))
+				PrepareNextRotationFrameForIP (moon, frameCounter);
+		}
+	}
+	else
+	{
+		for (i = pSolarSysState->SunDesc[0].NumPlanets,
+			     planet = &pSolarSysState->PlanetDesc[0]; i; --i, ++planet)
+			PrepareNextRotationFrameForIP (planet, frameCounter);
+	}
+}
+
 // Normally called by DoIpFlight() to process a frame
 static void
 IP_frame (void)
 {
 	BOOLEAN locChange;
 	SIZE newRadius;
-
+	static SIZE frameCounter;
+	
 	LockMutex (GraphicsLock);
 	SetContext (SpaceContext);
 
 	GameClockTick ();
+	++frameCounter;
+	//frameCounter = frameCounter % 5; // (ONE_SECOND/IP_FRAME_RATE); // % 30
 	ProcessShipControls ();
 	
 	locChange = CheckShipLocation (&newRadius);
@@ -1143,10 +1834,54 @@ IP_frame (void)
 			ScaleSystem (newRadius);
 		}
 	}
-	else
+	else if (!pSolarSysState->InOrbit)
 	{	// Just flying around, minding own business..
 		BatchGraphics ();
 		RestoreSystemView ();
+
+		if (ORBITING_PLANETS)
+		{	// BW: recompute planet position to account for orbiting
+			if (playerInInnerSystem ())
+			{	// Draw the inner system view
+				ValidateInnerOrbits ();
+			}
+			else
+			{	// Draw the outer system view
+				ValidateOrbits ();
+			}
+		}
+		
+		if (ROTATING_PLANETS)
+		{
+		// BW: rotate planets
+		// every frame in Inner (not much CPU required)
+		// depending on planet size and speed in Outer
+			if (playerInInnerSystem ())
+			{
+				RotatePlanets (TRUE, frameCounter);
+			}
+			else
+			{
+				RotatePlanets (FALSE, frameCounter);
+			}
+		}
+
+		if (ORBITING_PLANETS || ROTATING_PLANETS)
+		{ // Planets have probably moved or changed
+			if (playerInInnerSystem ())
+			{	// Draw the inner system view
+				DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
+			}
+			else
+			{	// Draw the outer system view
+				DrawOuterPlanets (pSolarSysState->SunDesc[0].radius);
+			}
+		}
+
+		// JMS: Animating IP sun in hi-res modes...
+		if (!playerInInnerSystem () && RESOLUTION_FACTOR != 0)
+			AnimateSun (newRadius);
+		
 		RedrawQueue (FALSE);
 		DrawAutoPilotMessage (FALSE);
 		UnbatchGraphics ();
@@ -1215,6 +1950,8 @@ DrawInnerSystem (void)
 {
 	ValidateInnerOrbits ();
 	DrawSystem (pSolarSysState->pOrbitalDesc->radius, TRUE);
+	if (ORBITING_PLANETS || ROTATING_PLANETS)
+		DrawInnerPlanets(pSolarSysState->pOrbitalDesc);
 	DrawSISTitle (GLOBAL_SIS (PlanetName));
 }
 
@@ -1223,6 +1960,8 @@ DrawOuterSystem (void)
 {
 	ValidateOrbits ();
 	DrawSystem (pSolarSysState->SunDesc[0].radius, FALSE);
+	if (ORBITING_PLANETS || ROTATING_PLANETS)
+		DrawOuterPlanets(pSolarSysState->SunDesc[0].radius);
 	DrawHyperCoords (CurStarDescPtr->star_pt);
 }
 
@@ -1233,7 +1972,7 @@ ResetSolarSys (void)
 	// where flash_task could be set at the time of call. The test was
 	// probably needed on 3DO when IP_frame() was a task.
 	assert (!pSolarSysState->InIpFlight);
-
+	
 	DrawMenuStateStrings (PM_STARMAP, -(PM_NAVIGATE - PM_SCAN));
 
 	InitDisplayList ();
@@ -1258,24 +1997,37 @@ ResetSolarSys (void)
 static void
 EnterPlanetOrbit (void)
 {
-	if (pSolarSysState->InIpFlight)
-	{	// This means we hit a planet in IP flight; not a Load into orbit
+	//	if (pSolarSysState->InIpFlight)
+	//	{	// This means we hit a planet in IP flight; not a Load into orbit
+	// BW: It seems that even a Load generates a solar system...
 		FreeSolarSys ();
 
 		if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
-		{	// Moon -- use its origin
+		{	
+			int moon;
+			
+			// Moon -- use its origin
 			// XXX: The conversion functions do not error-correct, so the
 			//   point we set here will change once flag_ship_preprocess()
 			//   in ipdisp.c starts over again.
 			GLOBAL (ShipStamp.origin) =
-					pSolarSysState->pOrbitalDesc->image.origin;
+				pSolarSysState->pOrbitalDesc->image.origin;
+				
+			// JMS_GFX: Draw the moon letter when orbiting a moon in 1280x960
+			// and 640x480 modes. Do not draw it in 320x240 since there's no room!
+			if (RESOLUTION_FACTOR > 0 && !(GetNamedPlanetaryBody()) && pSolarSysState->pOrbitalDesc->data_index != HIERARCHY_STARBASE)
+			{
+				moon = moonIndex (pSolarSysState, pSolarSysState->pOrbitalDesc);
+				snprintf ((GLOBAL_SIS (PlanetName)) + strlen(GLOBAL_SIS (PlanetName)), 3, "-%c%c", 'A' + moon, '\0');
+				DrawSISTitle (GLOBAL_SIS (PlanetName));
+			}
 		}
 		else
 		{	// Planet -- its origin is for the outer view, so use mid-screen
 			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
 			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
 		}
-	}
+		//	}
 
 	GetPlanetInfo ();
 	(*pSolarSysState->genFuncs->generateOrbital) (pSolarSysState,
@@ -1284,7 +2036,9 @@ EnterPlanetOrbit (void)
 	if ((GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD |
 			START_ENCOUNTER)) || GLOBAL_SIS (CrewEnlisted) == (COUNT)~0
 			|| GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
-		return;
+		{
+			return;
+		}
 
 	// Implement a to-do in generate.h for a better test
 	if (pSolarSysState->TopoFrame)
@@ -1309,7 +2063,17 @@ EnterPlanetOrbit (void)
 		ValidateOrbits ();
 		ValidateInnerOrbits ();
 		ResetSolarSys ();
-
+		if (TEXTURED_PLANETS)
+		{
+			if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
+			{
+				GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc->pPrevDesc);
+			}
+			else
+			{
+				GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc);
+			}
+		}
 		LockMutex (GraphicsLock);
 		RepairSISBorder ();
 		UnlockMutex (GraphicsLock);
@@ -1390,6 +2154,10 @@ InitSolarSys (void)
 
 		ResetSolarSys ();
 
+		// JMS: This is to prevent flashing the 3do "navigate"
+		// unnecessarily whilst starting a new game.
+		SetFlashRect (NULL);
+
 		if (LastActivity == (CHECK_LOAD | CHECK_RESTART))
 		{	// Starting a new game, NOT from load!
 			// We have to fade the screen in from intro or menu
@@ -1408,7 +2176,13 @@ InitSolarSys (void)
 		else
 		{	// Entered a new system, or loaded into inner or outer
 			if (InnerSystem)
+			{
+				if (TEXTURED_PLANETS)
+				{
+					GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc);
+				}
 				DrawInnerSystem ();
+			}
 			else
 				DrawOuterSystem ();
 			RedrawQueue (FALSE);
@@ -1472,9 +2246,8 @@ static void
 UninitSolarSys (void)
 {
 	FreeSolarSys ();
-
-//FreeLanderData ();
-//FreeIPData ();
+	//FreeLanderData (); // JMS: This is not needed since the landerframes won't reload if they're already loaded once.
+	FreeIPData (); // JMS This IS necessary.
 
 	DestroyDrawable (ReleaseDrawable (StarsFrame));
 	StarsFrame = NULL;
@@ -1502,63 +2275,6 @@ UninitSolarSys (void)
 }
 
 static void
-CalcSunSize (PLANET_DESC *pSunDesc, SIZE radius)
-{
-	SIZE index = 0;
-
-	if (radius <= (MAX_ZOOM_RADIUS >> 1))
-	{
-		++index;
-		if (radius <= (MAX_ZOOM_RADIUS >> 2))
-			++index;
-	}
-
-	pSunDesc->image.origin.x = SIS_SCREEN_WIDTH >> 1;
-	pSunDesc->image.origin.y = SIS_SCREEN_HEIGHT >> 1;
-	pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index);
-}
-
-static void
-SetPlanetColorMap (PLANET_DESC *planet)
-{
-	COUNT index = planet->data_index & ~WORLD_TYPE_SPECIAL;
-	assert (index < NUMBER_OF_PLANET_TYPES);
-	SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (OrbitalCMap,
-			PLANCOLOR (PlanData[index].Type))));
-}
-
-static void
-DrawInnerPlanets (PLANET_DESC *planet)
-{
-	STAMP s;
-	COUNT i;
-	PLANET_DESC *moon;
-
-	// Draw the planet image
-	SetPlanetColorMap (planet);
-	s.origin.x = SIS_SCREEN_WIDTH >> 1;
-	s.origin.y = SIS_SCREEN_HEIGHT >> 1;
-	s.frame = planet->image.frame;
-
-	i = planet->data_index & ~WORLD_TYPE_SPECIAL;
-	if (i < NUMBER_OF_PLANET_TYPES
-			&& (planet->data_index & PLANET_SHIELDED))
-	{	// Shielded world looks "shielded" in inner view
-		s.frame = SetAbsFrameIndex (SpaceJunkFrame, 17);
-	}
-	DrawStamp (&s);
-
-	// Draw the moon images
-	for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
-			i; --i, ++moon)
-	{
-		if (!(moon->data_index & WORLD_TYPE_SPECIAL))
-			SetPlanetColorMap (moon);
-		DrawStamp (&moon->image);
-	}
-}
-
-static void
 DrawSystem (SIZE radius, BOOLEAN IsInnerSystem)
 {
 	BYTE i;
@@ -1567,6 +2283,13 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 	CONTEXT oldContext;
 	STAMP s;
 
+	if (TEXTURED_PLANETS)
+	{
+		// BW: This to test if we have already rendered 
+		if (!pSolarSysState->PlanetDesc->orbit.lpTopoData)
+			GenerateTexturedPlanets();
+	}
+	
 	if (!SolarSysFrame)
 	{	// Create the saved view graphic
 		RECT clipRect;
@@ -1588,7 +2311,7 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 		pCurDesc = pSolarSysState->pOrbitalDesc;
 		DrawOrbit (pCurDesc, DISPLAY_FACTOR * 4, DISPLAY_FACTOR, radius);
 	}
-
+	
 	// Draw the planet orbits or moon orbits
 	for (i = pBaseDesc->pPrevDesc->NumPlanets, pCurDesc = pBaseDesc;
 			i; --i, ++pCurDesc)
@@ -1600,34 +2323,15 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 					radius);
 	}
 
-	if (IsInnerSystem)
-	{	// Draw the inner system view
-		DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
-	}
-	else
-	{	// Draw the outer system view
-		SIZE index;
-
-		CalcSunSize (&pSolarSysState->SunDesc[0], radius);
-
-		index = pSolarSysState->FirstPlanetIndex;
-		for (;;)
-		{
-			pCurDesc = &pSolarSysState->PlanetDesc[index];
-			if (pCurDesc == &pSolarSysState->SunDesc[0])
-			{	// It's a sun
-				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
-						SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
-			}
-			else
-			{	// It's a planet
-				SetPlanetColorMap (pCurDesc);
-			}
-			DrawStamp (&pCurDesc->image);
-
-			if (index == pSolarSysState->LastPlanetIndex)
-				break;
-			index = pCurDesc->NextIndex;
+	if (!ORBITING_PLANETS && !ROTATING_PLANETS)
+	{
+		if (IsInnerSystem)
+		{	// Draw the inner system view
+			DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
+		}
+		else
+		{	// Draw the outer system view
+			DrawOuterPlanets (radius);
 		}
 	}
 
@@ -1655,13 +2359,14 @@ static FRAME
 CreateStarBackGround (void)
 {
 	COUNT i, j;
+	COUNT num_brt_drawn;
 	DWORD rand_val;
-	STAMP s;
+	STAMP s, nebula; // JMS (added that nebula there)
 	DWORD old_seed;
 	CONTEXT oldContext;
 	RECT clipRect;
 	FRAME frame;
-
+	
 	oldContext = SetContext (SpaceContext);
 	GetContextClipRect (&clipRect);
 
@@ -1677,6 +2382,15 @@ CreateStarBackGround (void)
 
 	old_seed = seedRandomForSolarSys ();
 
+	// JMS, BW: The beautiful nebula background.
+	if (optNebulae)
+	{
+#define NUM_NEBULAE 16
+		nebula.origin.x = nebula.origin.y = 0;
+		nebula.frame = SetAbsFrameIndex (nebulaeFrame, CurStarDescPtr->star_pt.x % NUM_NEBULAE);
+		DrawStamp(&nebula);
+	}
+	
 #define NUM_DIM_PIECES 8
 	s.frame = SpaceJunkFrame;
 	for (i = 0; i < NUM_DIM_PIECES; ++i)
@@ -1692,11 +2406,17 @@ CreateStarBackGround (void)
 		}
 		s.frame = IncFrameIndex (s.frame);
 	}
+	
+	// JMS
+	if (optNebulae)
+		num_brt_drawn = RES_CASE(30, 60, 90); // JMS_GFX
+	else
+		num_brt_drawn = RES_CASE(30, 120, 480); // JMS_GFX
+		
 #define NUM_BRT_PIECES 8
 	for (i = 0; i < NUM_BRT_PIECES; ++i)
 	{
-#define NUM_BRT_DRAWN 30
-		for (j = 0; j < NUM_BRT_DRAWN; ++j)
+		for (j = 0; j < num_brt_drawn; ++j)
 		{
 			rand_val = TFB_Random ();
 			s.origin.x = LOWORD (rand_val) % SIS_SCREEN_WIDTH;
@@ -1839,8 +2559,10 @@ void
 GetPlanetOrMoonName (UNICODE *buf, COUNT bufsize)
 {
 	UNICODE *named;
-	int moon;
-	int i;
+	UNICODE *tempbuf;
+	int		moon;
+	int		i;
+	BOOLEAN name_has_suffix = FALSE;
 
 	named = GetNamedPlanetaryBody ();
 	if (named)
@@ -1860,10 +2582,22 @@ GetPlanetOrMoonName (UNICODE *buf, COUNT
 
 	// Orbiting an unnamed moon
 	i = strlen (buf);
+	tempbuf = buf;
 	buf += i;
 	bufsize -= i;
 	moon = moonIndex (pSolarSysState, pSolarSysState->pOrbitalDesc);
-	if (bufsize >= 3)
+	
+	
+log_add (log_Debug,"last %02d, i %d", tempbuf[i-1], i);	
+	// JMS: Prevent printing something like 'planet II-A-A' in summary screen.
+	if (i > 0)
+	{
+		if(tempbuf[i-1] == 'A' || tempbuf[i-1] == 'B' 
+			|| tempbuf[i-1] == 'C' || tempbuf[i-1] == 'D')
+			name_has_suffix = TRUE;
+	}
+	
+	if (bufsize >= 3 && !name_has_suffix)
 	{
 		snprintf (buf, bufsize, "-%c", 'A' + moon);
 		buf[bufsize - 1] = '\0';
diff -ruNp ./src.orig/uqm/planets/surface.c ./src/uqm/planets/surface.c
--- ./src.orig/uqm/planets/surface.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/planets/surface.c	2017-10-23 11:41:34 -0700
@@ -46,18 +46,36 @@ CalcMineralDeposits (SYSTEM_INFO *SysInf
 		while (num_possible--)
 		{
 #define MEDIUM_DEPOSIT_THRESHOLD 150
-#define LARGE_DEPOSIT_THRESHOLD 225
+#define LARGE_DEPOSIT_THRESHOLD 220
 			COUNT deposit_quality_fine,
 						deposit_quality_gross;
+			
+			// JMS: For making the mineral blip smaller in case it is partially scavenged.
+			SDWORD temp_deposit_quality;
 
 			deposit_quality_fine = ((COUNT)TFB_Random () % 100)
 					+ (
 					DEPOSIT_QUALITY (eptr->Density)
 					+ SysInfoPtr->StarSize
 					) * 50;
-			if (deposit_quality_fine < MEDIUM_DEPOSIT_THRESHOLD)
+			
+			// JMS: This makes the mineral blip smaller in case it is partially scavenged.
+			if (which_deposit < 32)
+				temp_deposit_quality = deposit_quality_fine - ((SysInfoPtr->PlanetInfo.PartiallyScavengedList[MINERAL_SCAN][which_deposit]) * 10);
+			// JMS: In case which_deposit >= 32 (most likely 65535), it means that this
+			// function is being called only to count the number of deposit nodes on the
+			// surface. In that case we don't need to use the PartiallyScavengedList
+			// since the amount of minerals in that node is not stored yet.
+			// (AND we cannot use the list since accessing element 65535 would crash the game ;)
+			else
+				temp_deposit_quality = deposit_quality_fine;
+			
+			if (temp_deposit_quality < 0)
+				temp_deposit_quality = 0;
+			
+			if (temp_deposit_quality < MEDIUM_DEPOSIT_THRESHOLD)
 				deposit_quality_gross = 0;
-			else if (deposit_quality_fine < LARGE_DEPOSIT_THRESHOLD)
+			else if (temp_deposit_quality < LARGE_DEPOSIT_THRESHOLD)
 				deposit_quality_gross = 1;
 			else
 				deposit_quality_gross = 2;
@@ -204,14 +222,16 @@ CalcLifeForms (SYSTEM_INFO *SysInfoPtr,
 			do
 			{
 				BYTE index, num_creatures;
-				UWORD rand_val;
-
+				DWORD rand_val; // JMS_GFX: Was UWORD
+				
 				rand_val = (UWORD)TFB_Random ();
-				index = LOBYTE (rand_val) % NUM_CREATURE_TYPES;
-				num_creatures = (BYTE)((HIBYTE (rand_val) % 10) + 1);
+				index = LOBYTE ((UWORD)rand_val) % NUM_CREATURE_TYPES; // JMS_GFX
+				num_creatures = (BYTE)((HIBYTE ((UWORD)rand_val) % 10) + 1); // JMS_GFX
 				do
 				{
 					GenerateRandomLocation (SysInfoPtr);
+					
+					
 					SysInfoPtr->PlanetInfo.CurType = index;
 
 					if (num_life_forms >= which_life
@@ -247,13 +267,29 @@ GenerateLifeForms (SYSTEM_INFO *SysInfoP
 void
 GenerateRandomLocation (SYSTEM_INFO *SysInfoPtr)
 {
-	UWORD rand_val;
-
-	rand_val = (UWORD)TFB_Random ();
-	SysInfoPtr->PlanetInfo.CurPt.x =
-			(LOBYTE (rand_val) % (MAP_WIDTH - (8 << 1))) + 8;
-	SysInfoPtr->PlanetInfo.CurPt.y =
-			(HIBYTE (rand_val) % (MAP_HEIGHT - (8 << 1))) + 8;
+	UWORD rand_val = (UWORD)TFB_Random ();
+	UWORD x, y; // JMS_GFX: Helpers.
+	
+	x = (LOBYTE (rand_val) % (ORIGINAL_MAP_WIDTH - (8 << 1)));
+	y = (HIBYTE (rand_val) % (ORIGINAL_MAP_HEIGHT - (8 << 1)));
+	
+	// JMS_GFX
+	x <<= RESOLUTION_FACTOR;
+	y <<= RESOLUTION_FACTOR;
+	SysInfoPtr->PlanetInfo.CurPt.x = x;
+	SysInfoPtr->PlanetInfo.CurPt.y = y;
+	
+	SysInfoPtr->PlanetInfo.CurPt.x += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	SysInfoPtr->PlanetInfo.CurPt.y += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	
+	// JMS_GFX: Compensate for 1280x960's different aspect ratio
+	if (RESOLUTION_FACTOR == 2)
+	{
+		DWORD xx = (DWORD)SysInfoPtr->PlanetInfo.CurPt.x;
+		xx *= 111;
+		xx /= 100;
+		SysInfoPtr->PlanetInfo.CurPt.x = (COUNT)xx;
+	}
 }
 
 DWORD
diff -ruNp ./src.orig/uqm/process.c ./src/uqm/process.c
--- ./src.orig/uqm/process.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/process.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "process.h"
 
 #include "races.h"
@@ -39,7 +41,7 @@
 
 COUNT DisplayFreeList;
 PRIMITIVE DisplayArray[MAX_DISPLAY_PRIMS];
-extern POINT SpaceOrg;
+extern DPOINT SpaceOrg; // JMS: Changed to DPOINT from POINT
 
 SIZE zoom_out = 1 << ZOOM_SHIFT;
 static SIZE opt_max_zoom_out;
@@ -203,103 +205,108 @@ PostProcess (ELEMENT *ElementPtr)
 			| POST_PROCESS;
 }
 
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
 static COUNT
-CalcReduction (SIZE dx, SIZE dy)
+CalcReduction (SDWORD dx, SDWORD dy)
 {
 	COUNT next_reduction;
-
+	
 #ifdef KDEBUG
 	log_add (log_Debug, "CalcReduction:");
 #endif
-
+	
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{
-		SIZE sdx, sdy;
-
+		SDWORD sdx, sdy;
+		
 		if (LOBYTE (GLOBAL (CurrentActivity)) > IN_ENCOUNTER)
 			return (0);
-
+		
 		sdx = dx;
 		sdy = dy;
 		for (next_reduction = MAX_VIS_REDUCTION;
-				(dx <<= REDUCTION_SHIFT) <= TRANSITION_WIDTH
-				&& (dy <<= REDUCTION_SHIFT) <= TRANSITION_HEIGHT
-				&& next_reduction > 0;
-				next_reduction -= REDUCTION_SHIFT)
+			 (dx <<= REDUCTION_SHIFT) <= TRANSITION_WIDTH
+			 && (dy <<= REDUCTION_SHIFT) <= TRANSITION_HEIGHT
+			 && next_reduction > 0;
+			 next_reduction -= REDUCTION_SHIFT)
 			;
-
-				/* check for "real" zoom in */
+		
+		/* check for "real" zoom in */
 		if (next_reduction < zoom_out
-				&& zoom_out <= MAX_VIS_REDUCTION)
+			&& zoom_out <= MAX_VIS_REDUCTION)
 		{
-#define HYSTERESIS_X DISPLAY_TO_WORLD(24)
-#define HYSTERESIS_Y DISPLAY_TO_WORLD(20)
-		if (((sdx + HYSTERESIS_X)
-				<< (MAX_VIS_REDUCTION - next_reduction)) > TRANSITION_WIDTH
+#define HYSTERESIS_X DISPLAY_TO_WORLD(24 << RESOLUTION_FACTOR) // JMS_GFX
+#define HYSTERESIS_Y DISPLAY_TO_WORLD(20 << RESOLUTION_FACTOR) // JMS_GFX
+			if (((sdx + HYSTERESIS_X)
+				 << (MAX_VIS_REDUCTION - next_reduction)) > TRANSITION_WIDTH
 				|| ((sdy + HYSTERESIS_Y)
-				<< (MAX_VIS_REDUCTION - next_reduction)) > TRANSITION_HEIGHT)
-		   /* if we don't zoom in, we want to stay at next+1 */
-		   next_reduction += REDUCTION_SHIFT;
+					<< (MAX_VIS_REDUCTION - next_reduction)) > TRANSITION_HEIGHT)
+			/* if we don't zoom in, we want to stay at next+1 */
+				next_reduction += REDUCTION_SHIFT;
 		}
-
-		if (next_reduction == 0
-				&& LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
+		
+		if (next_reduction == 0 && LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
 			next_reduction += REDUCTION_SHIFT;
 	}
 	else
 	{
 		if (LOBYTE (GLOBAL (CurrentActivity)) > IN_ENCOUNTER)
 			return (1 << ZOOM_SHIFT);
-			
+		
 		dx = (dx * MAX_ZOOM_OUT) / (LOG_SPACE_WIDTH >> 2);
 		if (dx < (1 << ZOOM_SHIFT))
 			dx = 1 << ZOOM_SHIFT;
 		else if (dx > MAX_ZOOM_OUT)
 			dx = MAX_ZOOM_OUT;
-			
+		
 		dy = (dy * MAX_ZOOM_OUT) / (LOG_SPACE_HEIGHT >> 2);
 		if (dy < (1 << ZOOM_SHIFT))
 			dy = 1 << ZOOM_SHIFT;
 		else if (dy > MAX_ZOOM_OUT)
 			dy = MAX_ZOOM_OUT;
-			
+		
 		if (dy > dx)
 			next_reduction = dy;
 		else
 			next_reduction = dx;
-
+		
 		if (next_reduction < (2 << ZOOM_SHIFT)
-				&& LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
+			&& LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE)
 			next_reduction = (2 << ZOOM_SHIFT);
 	}
-
+	
 #ifdef KDEBUG
 	log_add (log_Debug, "CalcReduction: exit");
 #endif
-
+	
 	return (next_reduction);
 }
 
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
 static VIEW_STATE
-CalcView (POINT *pNewScrollPt, SIZE next_reduction,
-		SIZE *pdx, SIZE *pdy, COUNT ships_alive)
+CalcView (DPOINT *pNewScrollPt, SIZE next_reduction,
+		  SDWORD *pdx, SDWORD *pdy, COUNT ships_alive)
 {
-	SIZE dx, dy;
+	SDWORD dx, dy;
 	VIEW_STATE view_state;
-
+	
 #ifdef KDEBUG
 	log_add (log_Debug, "CalcView:");
 #endif
-	dx = ((COORD)(LOG_SPACE_WIDTH >> 1) - pNewScrollPt->x);
-	dy = ((COORD)(LOG_SPACE_HEIGHT >> 1) - pNewScrollPt->y);
+	dx = ((SDWORD)(LOG_SPACE_WIDTH >> 1) - pNewScrollPt->x);
+	dy = ((SDWORD)(LOG_SPACE_HEIGHT >> 1) - pNewScrollPt->y);
 	dx = WRAP_DELTA_X (dx);
 	dy = WRAP_DELTA_Y (dy);
 	if (ships_alive == 1)
 	{
-#define ORG_JUMP_X ((SIZE)DISPLAY_ALIGN(LOG_SPACE_WIDTH / 75))
-#define ORG_JUMP_Y ((SIZE)DISPLAY_ALIGN(LOG_SPACE_HEIGHT / 75))
+#define ORG_JUMP_X ((SDWORD)DISPLAY_ALIGN(LOG_SPACE_WIDTH / 75))
+#define ORG_JUMP_Y ((SDWORD)DISPLAY_ALIGN(LOG_SPACE_HEIGHT / 75))
 		if (dx > ORG_JUMP_X)
+		{
 			dx = ORG_JUMP_X;
+		}
 		else if (dx < -ORG_JUMP_X)
 			dx = -ORG_JUMP_X;
 		if (dy > ORG_JUMP_Y)
@@ -307,58 +314,51 @@ CalcView (POINT *pNewScrollPt, SIZE next
 		else if (dy < -ORG_JUMP_Y)
 			dy = -ORG_JUMP_Y;
 	}
-
+	
 	if ((dx || dy) && LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
 		MoveSIS (&dx, &dy);
-
+	
 	if (zoom_out == next_reduction)
 		view_state = dx == 0 && dy == 0
-				&& LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE
-				? VIEW_STABLE : VIEW_SCROLL;
+		&& LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE
+		? VIEW_STABLE : VIEW_SCROLL;
 	else
 	{
 		if (optMeleeScale == TFB_SCALE_STEP)
 		{
-			SpaceOrg.x = (COORD)(LOG_SPACE_WIDTH >> 1)
-					- (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1)
-					- next_reduction));
-			SpaceOrg.y = (COORD)(LOG_SPACE_HEIGHT >> 1)
-					- (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1)
-					- next_reduction));
+			SpaceOrg.x = (SDWORD)(LOG_SPACE_WIDTH >> 1) - (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1) - next_reduction));
+			SpaceOrg.y = (SDWORD)(LOG_SPACE_HEIGHT >> 1) - (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1) - next_reduction));
 		}
 		else
 		{
 #define ZOOM_JUMP ((1 << ZOOM_SHIFT) >> 3)
 			if (ships_alive == 1
-					&& zoom_out > next_reduction
-					&& zoom_out <= MAX_ZOOM_OUT
-					&& zoom_out - next_reduction > ZOOM_JUMP)
+				&& zoom_out > next_reduction
+				&& zoom_out <= MAX_ZOOM_OUT
+				&& zoom_out - next_reduction > ZOOM_JUMP)
 				next_reduction = zoom_out - ZOOM_JUMP;
-				
+			
 			// Always align the origin on a whole pixel to reduce the
 			// amount of object positioning jitter
-			SpaceOrg.x = DISPLAY_ALIGN((int)(LOG_SPACE_WIDTH >> 1) -
-					(LOG_SPACE_WIDTH * next_reduction / (MAX_ZOOM_OUT << 2)));
-			SpaceOrg.y = DISPLAY_ALIGN((int)(LOG_SPACE_HEIGHT >> 1) -
-					(LOG_SPACE_HEIGHT * next_reduction / (MAX_ZOOM_OUT << 2)));
+			SpaceOrg.x = DISPLAY_ALIGN((int)(LOG_SPACE_WIDTH >> 1) - (LOG_SPACE_WIDTH * next_reduction / (MAX_ZOOM_OUT << 2)));
+			SpaceOrg.y = DISPLAY_ALIGN((int)(LOG_SPACE_HEIGHT >> 1) - (LOG_SPACE_HEIGHT * next_reduction / (MAX_ZOOM_OUT << 2)));
 		}
 		zoom_out = next_reduction;
 		view_state = VIEW_CHANGE;
 	}
-
+	
 	if (LOBYTE (GLOBAL (CurrentActivity)) <= IN_HYPERSPACE)
 		MoveGalaxy (view_state, dx, dy);
-
+	
 	*pdx = dx;
 	*pdy = dy;
-
+	
 #ifdef KDEBUG
 	log_add (log_Debug, "CalcView: exit");
 #endif
 	return (view_state);
 }
 
-
 static ELEMENT_FLAGS
 ProcessCollisions (HELEMENT hSuccElement, ELEMENT *ElementPtr,
 		TIME_VALUE min_time, ELEMENT_FLAGS process_flags)
@@ -627,69 +627,70 @@ ProcessCollisions (HELEMENT hSuccElement
 	return (ElementPtr->state_flags & COLLISION);
 }
 
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
 static VIEW_STATE
-PreProcessQueue (SIZE *pscroll_x, SIZE *pscroll_y)
+PreProcessQueue (SDWORD *pscroll_x, SDWORD *pscroll_y)
 {
 	SIZE min_reduction, max_reduction;
 	COUNT sides_active;
-	POINT Origin;
+	DPOINT Origin;
 	HELEMENT hElement;
 	COUNT ships_alive;
-
+	
 #ifdef KDEBUG
 	log_add (log_Debug, "PreProcess:");
 #endif
 	sides_active = (battle_counter[0] ? 1 : 0)
-			+ (battle_counter[1] ? 1 : 0);
-
+	+ (battle_counter[1] ? 1 : 0);
+	
 	if (optMeleeScale == TFB_SCALE_STEP)
 		min_reduction = max_reduction = MAX_VIS_REDUCTION + 1;
 	else
 		min_reduction = max_reduction = MAX_ZOOM_OUT + (1 << ZOOM_SHIFT);
-
-	Origin.x = (COORD)(LOG_SPACE_WIDTH >> 1);
-	Origin.y = (COORD)(LOG_SPACE_HEIGHT >> 1);
-
+	
+	Origin.x = (SDWORD)(LOG_SPACE_WIDTH >> 1);
+	Origin.y = (SDWORD)(LOG_SPACE_HEIGHT >> 1);
+	
 	hElement = GetHeadElement ();
 	ships_alive = 0;
 	while (hElement != 0)
 	{
 		ELEMENT *ElementPtr;
 		HELEMENT hNextElement;
-
+		
 		LockElement (hElement, &ElementPtr);
-
+		
 		if (!(ElementPtr->state_flags & PRE_PROCESS))
 			PreProcess (ElementPtr);
 		hNextElement = GetSuccElement (ElementPtr);
-
-		if (CollidingElement (ElementPtr)
-				&& !(ElementPtr->state_flags & COLLISION))
-			ProcessCollisions (hNextElement, ElementPtr,
-					MAX_TIME_VALUE, PRE_PROCESS);
-
+		
+		if (CollidingElement (ElementPtr) && !(ElementPtr->state_flags & COLLISION))
+			ProcessCollisions (hNextElement, ElementPtr, MAX_TIME_VALUE, PRE_PROCESS);
+		
 		if (ElementPtr->state_flags & PLAYER_SHIP)
 		{
-			SIZE dx, dy;
-
+			SDWORD dx, dy;
+			
 			ships_alive++;
+			
 			if (max_reduction > opt_max_zoom_out
-					&& min_reduction > opt_max_zoom_out)
+				&& min_reduction > opt_max_zoom_out)
 			{
 				Origin.x = DISPLAY_ALIGN (ElementPtr->next.location.x);
 				Origin.y = DISPLAY_ALIGN (ElementPtr->next.location.y);
 			}
-
+			
 			dx = DISPLAY_ALIGN (ElementPtr->next.location.x) - Origin.x;
 			dx = WRAP_DELTA_X (dx);
 			dy = DISPLAY_ALIGN (ElementPtr->next.location.y) - Origin.y;
 			dy = WRAP_DELTA_Y (dy);
-
+			
 			if (sides_active <= 2 || ElementPtr->playerNr == 0)
 			{
 				Origin.x = DISPLAY_ALIGN (Origin.x + (dx >> 1));
 				Origin.y = DISPLAY_ALIGN (Origin.y + (dy >> 1));
-
+				
 				if (dx < 0)
 					dx = -dx;
 				if (dy < 0)
@@ -697,11 +698,11 @@ PreProcessQueue (SIZE *pscroll_x, SIZE *
 				max_reduction = CalcReduction (dx, dy);
 			}
 			else if (max_reduction > opt_max_zoom_out
-					&& min_reduction <= opt_max_zoom_out)
+					 && min_reduction <= opt_max_zoom_out)
 			{
 				Origin.x = DISPLAY_ALIGN (Origin.x + (dx >> 1));
 				Origin.y = DISPLAY_ALIGN (Origin.y + (dy >> 1));
-
+				
 				if (dx < 0)
 					dx = -dx;
 				if (dy < 0)
@@ -711,35 +712,33 @@ PreProcessQueue (SIZE *pscroll_x, SIZE *
 			else
 			{
 				SIZE reduction;
-
+				
 				if (dx < 0)
 					dx = -dx;
 				if (dy < 0)
 					dy = -dy;
 				reduction = CalcReduction (dx << 1, dy << 1);
-
+				
 				if (min_reduction > opt_max_zoom_out
-						|| reduction < min_reduction)
+					|| reduction < min_reduction)
 					min_reduction = reduction;
 			}
-//			log_add (log_Debug, "dx = %d dy = %d min_red = %d max_red = %d",
-//					dx, dy, min_reduction, max_reduction);
 		}
-
+		
 		UnlockElement (hElement);
 		hElement = hNextElement;
 	}
-
+	
 	if ((min_reduction > opt_max_zoom_out || min_reduction <= max_reduction)
-			&& (min_reduction = max_reduction) > opt_max_zoom_out
-			&& (min_reduction = zoom_out) > opt_max_zoom_out)
+		&& (min_reduction = max_reduction) > opt_max_zoom_out
+		&& (min_reduction = zoom_out) > opt_max_zoom_out)
 	{
 		if (optMeleeScale == TFB_SCALE_STEP)
 			min_reduction = 0;
 		else
 			min_reduction = 1 << ZOOM_SHIFT;
 	}
-
+	
 #ifdef KDEBUG
 	log_add (log_Debug, "PreProcess: exit");
 #endif
@@ -783,8 +782,10 @@ InsertPrim (PRIM_LINKS *pLinks, COUNT pr
 
 PRIM_LINKS DisplayLinks;
 
-static inline COORD
-CalcDisplayCoord (COORD c, COORD orgc, SIZE reduction)
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
+static inline SDWORD
+CalcDisplayCoord (SDWORD c, SDWORD orgc, SIZE reduction)
 {
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{	/* old fixed-step zoom style */
@@ -796,14 +797,15 @@ CalcDisplayCoord (COORD c, COORD orgc, S
 	}
 }
 
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
 static void
-PostProcessQueue (VIEW_STATE view_state, SIZE scroll_x,
-		SIZE scroll_y)
+PostProcessQueue (VIEW_STATE view_state, SDWORD scroll_x, SDWORD scroll_y)
 {
-	POINT delta;
+	DPOINT delta;
 	SIZE reduction;
 	HELEMENT hElement;
-
+	
 #ifdef KDEBUG
 	log_add (log_Debug, "PostProcess:");
 #endif
@@ -811,16 +813,16 @@ PostProcessQueue (VIEW_STATE view_state,
 		reduction = zoom_out + ONE_SHIFT;
 	else
 		reduction = zoom_out << ONE_SHIFT;
-
+	
 	hElement = GetHeadElement ();
 	while (hElement != 0)
 	{
 		ELEMENT_FLAGS state_flags;
 		ELEMENT *ElementPtr;
 		HELEMENT hNextElement;
-
+		
 		LockElement (hElement, &ElementPtr);
-
+		
 		state_flags = ElementPtr->state_flags;
 		if (state_flags & PRE_PROCESS)
 		{
@@ -828,7 +830,7 @@ PostProcessQueue (VIEW_STATE view_state,
 				ElementPtr->state_flags &= ~DEFY_PHYSICS;
 			else
 				ElementPtr->state_flags &= ~COLLISION;
-
+			
 			if (state_flags & POST_PROCESS)
 			{
 				delta.x = 0;
@@ -843,34 +845,34 @@ PostProcessQueue (VIEW_STATE view_state,
 		else
 		{
 			HELEMENT hPostElement;
-
+			
 			hPostElement = hElement;
 			do
 			{
 				ELEMENT *PostElementPtr;
-
+				
 				LockElement (hPostElement, &PostElementPtr);
 				if (!(PostElementPtr->state_flags & PRE_PROCESS))
 					PreProcess (PostElementPtr);
 				hNextElement = GetSuccElement (PostElementPtr);
-
+				
 				if (CollidingElement (PostElementPtr)
-						&& !(PostElementPtr->state_flags & COLLISION))
+					&& !(PostElementPtr->state_flags & COLLISION))
 					ProcessCollisions (GetHeadElement (), PostElementPtr,
-							MAX_TIME_VALUE, PRE_PROCESS | POST_PROCESS);
+									   MAX_TIME_VALUE, PRE_PROCESS | POST_PROCESS);
 				UnlockElement (hPostElement);
 				hPostElement = hNextElement;
 			} while (hPostElement != 0);
-
+			
 			scroll_x = 0;
 			scroll_y = 0;
 			delta.x = 0;
 			delta.y = 0;
-					/* because these are newly added elements that are
-					 * already in adjusted coordinates */
+			/* because these are newly added elements that are
+			 * already in adjusted coordinates */
 			state_flags = ElementPtr->state_flags;
 		}
-
+		
 		if (state_flags & DISAPPEARING)
 		{
 			hNextElement = GetSuccElement (ElementPtr);
@@ -881,73 +883,66 @@ PostProcessQueue (VIEW_STATE view_state,
 		else
 		{
 			GRAPHICS_PRIM ObjType;
-
+			
 			ObjType = GetPrimType (&DisplayArray[ElementPtr->PrimIndex]);
 			if (view_state != VIEW_STABLE
-					|| (state_flags & (APPEARING | CHANGING)))
+				|| (state_flags & (APPEARING | CHANGING)))
 			{
 				POINT next;
-
+				
 				if (ObjType == LINE_PRIM)
 				{
-					SIZE dx, dy;
-
-					dx = ElementPtr->next.location.x
-							- ElementPtr->current.location.x;
-					dy = ElementPtr->next.location.y
-							- ElementPtr->current.location.y;
-
+					SDWORD dx, dy;
+					
+					dx = ElementPtr->next.location.x - ElementPtr->current.location.x;
+					dy = ElementPtr->next.location.y - ElementPtr->current.location.y;
+					
 					next.x = WRAP_X (ElementPtr->current.location.x + delta.x);
 					next.y = WRAP_Y (ElementPtr->current.location.y + delta.y);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
-
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					
 					next.x += dx;
 					next.y += dy;
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
 				}
 				else
 				{
 					next.x = WRAP_X (ElementPtr->next.location.x + delta.x);
 					next.y = WRAP_Y (ElementPtr->next.location.y + delta.y);
-					DisplayArray[ElementPtr->PrimIndex].Object.Point.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Point.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
-
+					
+					DisplayArray[ElementPtr->PrimIndex].Object.Point.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Point.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					
 					if (ObjType == STAMP_PRIM || ObjType == STAMPFILL_PRIM)
 					{
 						if (view_state == VIEW_CHANGE
-								|| (state_flags & (APPEARING | CHANGING)))
+							|| (state_flags & (APPEARING | CHANGING)))
 						{
 							COUNT index, scale = GSCALE_IDENTITY;
-						
+							
 							if (optMeleeScale == TFB_SCALE_STEP)
 								index = zoom_out;
 							else
 								CALC_ZOOM_STUFF (&index, &scale);
-
+							
 							ElementPtr->next.image.frame = SetEquFrameIndex (
-									ElementPtr->next.image.farray[index],
-									ElementPtr->next.image.frame);
-
+								ElementPtr->next.image.farray[index],
+								ElementPtr->next.image.frame);
+							
 							if (optMeleeScale == TFB_SCALE_TRILINEAR &&
-									index < 2 && scale != GSCALE_IDENTITY)
+								index < 2 && scale != GSCALE_IDENTITY)
 							{
 								// enqueues drawcommand to assign next
 								// (smaller) zoom level image as mipmap,
 								// needed for trilinear scaling
-
+								
 								FRAME frame = ElementPtr->next.image.frame;
 								FRAME mmframe = SetEquFrameIndex (
-										ElementPtr->next.image.farray[
-										index + 1], frame);
-
+									ElementPtr->next.image.farray[
+									index + 1], frame);
+								
 								// TODO: This is currently hacky, this code
 								//   really should not dereference FRAME.
 								//   Perhaps make mipmap part of STAMP prim?
@@ -955,27 +950,27 @@ PostProcessQueue (VIEW_STATE view_state,
 								{
 									HOT_SPOT mmhs = GetFrameHot (mmframe);
 									TFB_DrawScreen_SetMipmap (frame->image,
-											mmframe->image, mmhs.x, mmhs.y);
+										mmframe->image, mmhs.x, mmhs.y);
 								}
 							}
 						}
 						DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
-								ElementPtr->next.image.frame;
+						ElementPtr->next.image.frame;
 					}
 				}
-
+				
 				ElementPtr->next.location = next;
 			}
-
+			
 			PostProcess (ElementPtr);
-
+			
 			if (ObjType < NUM_PRIMS)
 				InsertPrim (&DisplayLinks, ElementPtr->PrimIndex, END_OF_LIST);
-
+			
 			hNextElement = GetSuccElement (ElementPtr);
 			UnlockElement (hElement);
 		}
-
+		
 		hElement = hNextElement;
 	}
 #ifdef KDEBUG
@@ -1010,26 +1005,28 @@ InitDisplayList (void)
 
 UWORD nth_frame = 0;
 
+// JMS: Changed a shitload of POINTs to DPOINTs and SIZEs to SDWORDs to
+// avoid overflows in hi-res.
 void
 RedrawQueue (BOOLEAN clear)
 {
-	SIZE scroll_x, scroll_y;
+	SDWORD scroll_x, scroll_y;
 	VIEW_STATE view_state;
-
+	
 	SetContext (StatusContext);
-
+	
 	view_state = PreProcessQueue (&scroll_x, &scroll_y);
 	PostProcessQueue (view_state, scroll_x, scroll_y);
-
+	
 	if (optStereoSFX)
 		UpdateSoundPositions ();
-
+	
 	SetContext (SpaceContext);
 	if (LOBYTE (GLOBAL (CurrentActivity)) == SUPER_MELEE
 		|| !(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 	{
 		BYTE skip_frames;
-
+		
 		skip_frames = HIBYTE (nth_frame);
 		if (skip_frames != (BYTE)~0
 			&& (skip_frames == 0 || (--nth_frame & 0x00FF) == 0))
@@ -1037,19 +1034,19 @@ RedrawQueue (BOOLEAN clear)
 			nth_frame += skip_frames;
 			if (clear)
 				ClearDrawable (); // this is for BATCH_BUILD_PAGE effect, but not scaled by SetGraphicScale
-
+			
 			if (optMeleeScale != TFB_SCALE_STEP)
 			{
 				COUNT index, scale;
-
+				
 				CALC_ZOOM_STUFF (&index, &scale);
 				SetGraphicScale (scale);
 			}
-
+			
 			DrawBatch (DisplayArray, DisplayLinks, 0);//BATCH_BUILD_PAGE);
 			SetGraphicScale (0);
 		}
-
+		
 		FlushSounds ();
 	}
 	else
@@ -1057,7 +1054,7 @@ RedrawQueue (BOOLEAN clear)
 		ProcessSound ((SOUND)~0, NULL);
 		FlushSounds ();
 	}
-
+	
 	DisplayLinks = MakeLinks (END_OF_LIST, END_OF_LIST);
 }
 
diff -ruNp ./src.orig/uqm/races.h ./src/uqm/races.h
--- ./src.orig/uqm/races.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/races.h	2017-10-23 11:41:34 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
+
 #ifndef _RACES_H
 #define _RACES_H
 
@@ -38,20 +41,22 @@ typedef HLINK HSTARSHIP;
 
 /* SHIP_INFO.ship_flags - ship specific flags */
 /* bits 0 and 1 are now available */
-#define SEEKING_WEAPON    (1 << 2)
-#define SEEKING_SPECIAL   (1 << 3)
-#define POINT_DEFENSE     (1 << 4)
+#define SEEKING_WEAPON      (1 << 2)
+#define SEEKING_SPECIAL     (1 << 3)
+#define POINT_DEFENSE       (1 << 4)
 		/* Ship has some point-defense capabilities */
-#define IMMEDIATE_WEAPON  (1 << 5)
-#define CREW_IMMUNE       (1 << 6)
-#define FIRES_FORE        (1 << 7)
-#define FIRES_RIGHT       (1 << 8)
-#define FIRES_AFT         (1 << 9)
-#define FIRES_LEFT        (1 << 10)
-#define SHIELD_DEFENSE    (1 << 11)
-#define DONT_CHASE        (1 << 12)
-#define PLAYER_CAPTAIN    (1 << 13)
+#define IMMEDIATE_WEAPON    (1 << 5)
+#define CREW_IMMUNE         (1 << 6)
+#define FIRES_FORE          (1 << 7)
+#define FIRES_RIGHT         (1 << 8)
+#define FIRES_AFT           (1 << 9)
+#define FIRES_LEFT          (1 << 10)
+#define SHIELD_DEFENSE      (1 << 11)
+#define DONT_CHASE          (1 << 12)
+#define PLAYER_CAPTAIN      (1 << 13)
 		/* The protagonist himself is on board. He gets a different color. */
+#define LIGHT_POINT_DEFENSE (1 << 14)
+#define HEAVY_POINT_DEFENSE (1 << 15)
 
 typedef UWORD STATUS_FLAGS;
 
@@ -535,29 +540,29 @@ enum
 
 #define LOG_TO_HYPER(s) (WORLD_TO_VELOCITY (s) >> 1)
 #define RACE_HYPER_SPEED \
-		LOG_TO_HYPER (40),  /* ARILOU_SHIP */ \
-		LOG_TO_HYPER (27),  /* CHMMR_SHIP */ \
-		LOG_TO_HYPER (24),  /* HUMAN_SHIP */ \
-		LOG_TO_HYPER (40),  /* ORZ_SHIP */ \
-		LOG_TO_HYPER (40),  /* PKUNK_SHIP */ \
-		LOG_TO_HYPER (35),  /* SHOFIXTI_SHIP */ \
-		LOG_TO_HYPER (48),  /* SPATHI_SHIP */ \
-		LOG_TO_HYPER (40),  /* SUPOX_SHIP */ \
-		LOG_TO_HYPER (50),  /* THRADDASH_SHIP */ \
-		LOG_TO_HYPER (30),  /* UTWIG_SHIP */ \
-		LOG_TO_HYPER (21),  /* VUX_SHIP */ \
-		LOG_TO_HYPER (30),  /* YEHAT_SHIP */ \
-		LOG_TO_HYPER (40),  /* MELNORME_SHIP */ \
-		LOG_TO_HYPER (20),  /* DRUUGE_SHIP */ \
-		LOG_TO_HYPER (25),  /* ILWRATH_SHIP */ \
-		LOG_TO_HYPER (27),  /* MYCON_SHIP */ \
-		LOG_TO_HYPER (60),  /* SLYLANDRO_SHIP */ \
-		LOG_TO_HYPER (18),  /* UMGAH_SHIP */ \
-		LOG_TO_HYPER (30),  /* URQUAN_SHIP */ \
-		LOG_TO_HYPER (40),  /* ZOQFOTPIK_SHIP */ \
-		LOG_TO_HYPER (36),  /* SYREEN_SHIP */ \
-		LOG_TO_HYPER (30),  /* BLACK_URQUAN_SHIP */ \
-		LOG_TO_HYPER (30),  /* YEHAT_REBEL_SHIP */
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ARILOU_SHIP */ \
+		LOG_TO_HYPER (27 << RESOLUTION_FACTOR),  /* CHMMR_SHIP */ \
+		LOG_TO_HYPER (24 << RESOLUTION_FACTOR),  /* HUMAN_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ORZ_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* PKUNK_SHIP */ \
+		LOG_TO_HYPER (35 << RESOLUTION_FACTOR),  /* SHOFIXTI_SHIP */ \
+		LOG_TO_HYPER (48 << RESOLUTION_FACTOR),  /* SPATHI_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* SUPOX_SHIP */ \
+		LOG_TO_HYPER (50 << RESOLUTION_FACTOR),  /* THRADDASH_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* UTWIG_SHIP */ \
+		LOG_TO_HYPER (21 << RESOLUTION_FACTOR),  /* VUX_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* YEHAT_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* MELNORME_SHIP */ \
+		LOG_TO_HYPER (20 << RESOLUTION_FACTOR),  /* DRUUGE_SHIP */ \
+		LOG_TO_HYPER (25 << RESOLUTION_FACTOR),  /* ILWRATH_SHIP */ \
+		LOG_TO_HYPER (27 << RESOLUTION_FACTOR),  /* MYCON_SHIP */ \
+		LOG_TO_HYPER (60 << RESOLUTION_FACTOR),  /* SLYLANDRO_SHIP */ \
+		LOG_TO_HYPER (18 << RESOLUTION_FACTOR),  /* UMGAH_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* URQUAN_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ZOQFOTPIK_SHIP */ \
+		LOG_TO_HYPER (36 << RESOLUTION_FACTOR),  /* SYREEN_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* BLACK_URQUAN_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* YEHAT_REBEL_SHIP */
 
 #define RACE_HYPERSPACE_PERCENT \
 		20,  /* ARILOU_SHIP */ \
@@ -640,29 +645,107 @@ enum
 		MAKE_BYTE (1, 5),  /* YEHAT_REBEL_SHIP */
 
 #define RACE_COLORS \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x10), 0x53),  /* ARILOU_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* CHMMR_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x12), 0x53),  /* ARILOU_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0D, 0x0D, 0x0D), 0x00),  /* CHMMR_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x01, 0x1f), 0x4D),  /* HUMAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x00, 0x0E), 0x36),  /* ORZ_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* PKUNK_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* SHOFIXTI_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0C, 0x05, 0x00), 0x76),  /* SPATHI_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0C, 0x05, 0x00), 0x76),  /* SUPOX_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* THRADDASH_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* UTWIG_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x10), 0x53),  /* VUX_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x00, 0x11), 0x3D),  /* YEHAT_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x09, 0x11), 0x62),  /* PKUNK_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x06, 0x00), 0x77),  /* SHOFIXTI_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x07, 0x00), 0x76),  /* SPATHI_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x07, 0x00), 0x76),  /* SUPOX_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x09, 0x11), 0x62),  /* THRADDASH_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x09, 0x11), 0x62),  /* UTWIG_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x12), 0x53),  /* VUX_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0B, 0x00, 0x12), 0x3D),  /* YEHAT_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* MELNORME_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),  /* DRUUGE_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x00, 0x0E), 0x36),  /* ILWRATH_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x00, 0x0E), 0x36),  /* MYCON_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0C, 0x05, 0x00), 0x76),  /* SLYLANDRO_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x08, 0x08, 0x0D), 0x76),  /* SLYLANDRO_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x00, 0x11), 0x3D),  /* UMGAH_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x08, 0x00), 0x6E),  /* URQUAN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x10, 0x00), 0x6E),  /* URQUAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),  /* ZOQFOTPIK_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* SYREEN_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x06, 0x06, 0x06), 0x20),  /* BLACK_URQUAN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0B, 0x00), 0x00),  /* SYREEN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x08, 0x08, 0x08), 0x20),  /* BLACK_URQUAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x14, 0x07, 0x1F), 0x39),  /* YEHAT_REBEL_SHIP */
 
+// JMS: For showing the SC1-era situation in starmap
+#define RACE_PREWAR_STRENGTHS \
+		0,    /* ARILOU_SHIP */ \
+		500,  /* CHMMR_SHIP masquerading as Mmrnmhrm */ \
+		400,  /* HUMAN_SHIP */ \
+		0,    /* ORZ_SHIP */ \
+		642,  /* PKUNK_SHIP, should be marked 'Unknown' */ \
+		400,  /* SHOFIXTI_SHIP */ \
+		1003, /* SPATHI_SHIP */ \
+		0,	  /* SUPOX_SHIP */ \
+		835,  /* THRADDASH_SHIP, should be marked 'Unknown' */ \
+		0,    /* UTWIG_SHIP masquerading as Chenjesu */ \
+		700,  /* VUX_SHIP */ \
+		1100, /* YEHAT_SHIP */ \
+		0,	  /* MELNORME_SHIP */ \
+		800,  /* DRUUGE_SHIP, should be marked 'Unknown' */ \
+		500,  /* ILWRATH_SHIP */ \
+		650,  /* MYCON_SHIP */ \
+		750,  /* SLYLANDRO_SHIP masquerading as Chenjesu */ \
+		633,  /* UMGAH_SHIP */ \
+		0,    /* URQUAN_SHIP */ \
+		0,	  /* ZOQFOTPIK_SHIP */ \
+		450,  /* SYREEN_SHIP masquareding as Androsynth */ \
+		0,	  /* BLACK_URQUAN_SHIP */ \
+		0,	  /* YEHAT_REBEL_SHIP */
+		
+// JMS: For showing the SC1-era situation in starmap
+#define RACE_PREWAR_LOCATIONS \
+		{0,0},		 /* ARILOU_SHIP */ \
+		{742,2968},	 /* CHMMR_SHIP masquerading as Mmrnmhrm */ \
+		{1752,1450}, /* HUMAN_SHIP */ \
+		{0,0 },		 /* ORZ_SHIP */ \
+		{502,401},   /* PKUNK_SHIP, should be marked 'Unknown' */ \
+		{2908,269},	 /* SHOFIXTI_SHIP */ \
+		{2549,3600}, /* SPATHI_SHIP */ \
+		{0,0},		 /* SUPOX_SHIP */ \
+		{2535,8358}, /* THRADDASH_SHIP, should be marked 'Unknown' */ \
+		{0,0},		 /* UTWIG_SHIP masquerading as Chenjesu */ \
+		{4333,1687}, /* VUX_SHIP */ \
+		{4923,294},  /* YEHAT_SHIP */ \
+		{0,0},		 /* MELNORME_SHIP */ \
+		{9469,2806}, /* DRUUGE_SHIP, should be marked 'Unknown' */ \
+		{229,3666},  /* ILWRATH_SHIP */ \
+		{6392,2200}, /* MYCON_SHIP */ \
+		{0742,2268}, /* SLYLANDRO_SHIP masquerading as Chenjesu */ \
+		{1978,5968}, /* UMGAH_SHIP */ \
+		{0,0},		 /* URQUAN_SHIP */ \
+		{0,0},		 /* ZOQFOTPIK_SHIP */ \
+		{3587,2566}, /* SYREEN_SHIP masquerading as Androsynth */ \
+		{0,0},		 /* BLACK_URQUAN_SHIP */ \
+		{0,0},		 /* YEHAT_REBEL_SHIP */
+		
+// JMS: For showing the SC1-era situation in starmap
+#define RACE_PREWAR_NAME_UNKNOWN \
+		FALSE,  /* ARILOU_SHIP */ \
+		FALSE,  /* CHMMR_SHIP masquerading as Mmrnmhrm */ \
+		FALSE,  /* HUMAN_SHIP */ \
+		FALSE,  /* ORZ_SHIP */ \
+		TRUE,   /* PKUNK_SHIP, should be marked 'Unknown' */ \
+		FALSE,  /* SHOFIXTI_SHIP */ \
+		FALSE,  /* SPATHI_SHIP */ \
+		FALSE,	/* SUPOX_SHIP */ \
+		TRUE,   /* THRADDASH_SHIP, should be marked 'Unknown' */ \
+		FALSE,  /* UTWIG_SHIP */ \
+		FALSE,  /* VUX_SHIP */ \
+		FALSE,  /* YEHAT_SHIP */ \
+		FALSE,	/* MELNORME_SHIP */ \
+		TRUE,   /* DRUUGE_SHIP, should be marked 'Unknown' */ \
+		FALSE,  /* ILWRATH_SHIP */ \
+		FALSE,  /* MYCON_SHIP */ \
+		FALSE,	/* SLYLANDRO_SHIP masquerading as Chenjesu */ \
+		FALSE,  /* UMGAH_SHIP */ \
+		FALSE,  /* URQUAN_SHIP */ \
+		FALSE,	/* ZOQFOTPIK_SHIP */ \
+		FALSE,  /* SYREEN_SHIP masquareding as Androsynth */ \
+		FALSE,	/* BLACK_URQUAN_SHIP */ \
+		FALSE,	/* YEHAT_REBEL_SHIP */
+
 #endif /* _RACES_H */
 
diff -ruNp ./src.orig/uqm/restart.c ./src/uqm/restart.c
--- ./src.orig/uqm/restart.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/restart.c	2017-10-23 11:41:34 -0700
@@ -16,8 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#include "restart.h"
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
 
+#include "restart.h"
+ 
 #include "colors.h"
 #include "controls.h"
 #include "credits.h"
@@ -39,9 +41,16 @@
 #include "util.h"
 #include "starcon.h"
 #include "uqmversion.h"
+#include "svnversion.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
 
+#include "libs/log.h"
+
+#include "libs/graphics/sdl/pure.h"
+
+#include "options.h" // JMS: To make the game recognize resFactorWasChanged even without network support.
+
 
 // TODO: This entire module fails to uphold the GraphicsLock semantics
 //   This either has to be fixed, or GraphicsLock completely ignored,
@@ -64,8 +73,38 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	STAMP s;
 	TEXT t;
 	UNICODE buf[64];
+	COUNT svn_revision = 0; // JMS
 
-	s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
+	//DC: Load the different menus depending on the resolution factor
+	if (resolutionFactor < 1)
+		s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
+	if (resolutionFactor == 1)
+		s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM2x));
+	if (resolutionFactor > 1)
+		s.frame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM4x));
+
+	// Re-load the info box font so the text shows in correct size after changing the resolution.
+	if (resFactorWasChanged)
+	{	
+		DestroyFont (StarConFont);
+		
+		if (resolutionFactor < 1)
+			StarConFont = LoadFont (FALLBACK_TO1X_FONT);
+		if (resolutionFactor == 1)
+			StarConFont = LoadFont (FALLBACK_TO2X_FONT);
+		if (resolutionFactor > 1)
+			StarConFont = LoadFont (FALLBACK_TO4X_FONT);
+		
+		DestroyFont (TinyFont);
+		
+		if (resolutionFactor < 1)
+			TinyFont = LoadFont (TINY_FALLBACK_TO1X_FONT);
+		if (resolutionFactor == 1)
+			TinyFont = LoadFont (TINY_FALLBACK_TO2X_FONT);
+		if (resolutionFactor > 1)
+			TinyFont = LoadFont (TINY_FALLBACK_TO4X_FONT);
+	}
+	
 	pMS->CurFrame = s.frame;
 	GetFrameRect (s.frame, &r);
 	s.origin.x = (SCREEN_WIDTH - r.extent.width) >> 1;
@@ -78,6 +117,33 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	LockMutex (GraphicsLock);
 	DrawStamp (&s);
 
+	// JMS: Hack for printing out the correct SVN revision number.
+	{
+		UNICODE svn_buf[64] = {0};
+		char *colonPtr;
+		
+		strcpy(svn_buf, UQMHD_SVN_REVISION);
+		colonPtr = strchr(svn_buf, ':');
+		
+		// The revision number is in format rXXX
+		if (colonPtr == NULL)
+		{
+			// Let's just take the only number and be happy.
+			svn_revision = atoi(svn_buf);
+		}
+		// the revision number is in format rXXX:ZZZ
+		else
+		{
+			// Now we need to extract only the ZZZ number.
+			UNICODE svn_buf2[10];
+			strcpy(svn_buf2, colonPtr+1);
+			svn_revision = atoi(svn_buf2);
+		}
+		
+		// Think about this for a while ;)
+		++svn_revision;
+	}
+	
 	// Put the version number in the bottom right corner.
 	SetContextFont (TinyFont);
 	t.pStr = buf;
@@ -85,8 +151,7 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	t.baseline.y = SCREEN_HEIGHT - 2;
 	t.align = ALIGN_RIGHT;
 	t.CharCount = (COUNT)~0;
-	sprintf (buf, "v%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
-			UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
+	sprintf (buf, "v%d.%d.%d%s - SVN r%d", UQM_MAJOR_VERSION, UQM_MINOR_VERSION, UQM_PATCH_VERSION, UQM_EXTRA_VERSION, svn_revision);
 	SetContextForeGroundColor (WHITE_COLOR);
 	font_DrawText (&t);
 
@@ -94,14 +159,14 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	UnbatchGraphics ();
 }
 
+// JMS_GFX: The cleanup boolean can be used to avoid drawing a wrong-sized "Setup" flash overlay.
 static void
-DrawRestartMenu (MENU_STATE *pMS, BYTE NewState, FRAME f)
+DrawRestartMenu (MENU_STATE *pMS, BYTE NewState, FRAME f, BOOLEAN cleanup)
 {
 	POINT origin;
 	origin.x = 0;
 	origin.y = 0;
-	Flash_setOverlay(pMS->flashContext,
-			&origin, SetAbsFrameIndex (f, NewState + 1));
+	Flash_setOverlay (pMS->flashContext, &origin, SetAbsFrameIndex (f, NewState + 1), cleanup);
 }
 
 static BOOLEAN
@@ -125,23 +190,28 @@ DoRestart (MENU_STATE *pMS)
 			DestroyMusic (pMS->hMusic);
 			pMS->hMusic = 0;
 		}
+		
 		pMS->hMusic = LoadMusic (MAINMENU_MUSIC);
-		InactTimeOut = (pMS->hMusic ? 120 : 20) * ONE_SECOND;
+		InactTimeOut = (pMS->hMusic && optMainmenuMusic ? 86 : 20) * ONE_SECOND;
 		pMS->flashContext = Flash_createOverlay (ScreenContext,
 				NULL, NULL);
 		Flash_setMergeFactors (pMS->flashContext, -3, 3, 16);
-		Flash_setSpeed (pMS->flashContext, (6 * ONE_SECOND) / 16, 0,
-				(6 * ONE_SECOND) / 16, 0);
+		Flash_setSpeed (pMS->flashContext, (6 * ONE_SECOND) / 14, 0,
+				(6 * ONE_SECOND) / 14, 0);
 		Flash_setFrameTime (pMS->flashContext, ONE_SECOND / 16);
 		Flash_setState(pMS->flashContext, FlashState_fadeIn,
 				(3 * ONE_SECOND) / 16);
-		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
+		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 		Flash_start (pMS->flashContext);
-		PlayMusic (pMS->hMusic, TRUE, 1);
 		LastInputTime = GetTimeCounter ();
 		pMS->Initialized = TRUE;
 
 		SleepThreadUntil (FadeScreen (FadeAllToColor, ONE_SECOND / 2));
+		FadeMusic(0,0);
+		PlayMusic (pMS->hMusic, TRUE, 1);
+		
+		if (optMainmenuMusic)
+			FadeMusic (NORMAL_VOLUME+70, ONE_SECOND * 3);
 	}
 	else if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 	{
@@ -149,32 +219,166 @@ DoRestart (MENU_STATE *pMS)
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SELECT])
 	{
+		//BYTE fade_buf[1];
+		COUNT oldresfactor;
+		BOOLEAN packsInstalled;
+		
+		if (resolutionFactor == 0)
+			packsInstalled = TRUE;
+		else if (resolutionFactor == 1 && hires2xPackPresent)
+			packsInstalled = TRUE;
+		else if (resolutionFactor == 2 && hires4xPackPresent)
+			packsInstalled = TRUE;
+		else
+			packsInstalled = FALSE;
+		
 		switch (pMS->CurState)
 		{
 			case LOAD_SAVED_GAME:
-				LastActivity = CHECK_LOAD;
-				GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				if (resFactorWasChanged)
+				{
+					LockMutex (GraphicsLock);
+					SetFlashRect (NULL);
+					UnlockMutex (GraphicsLock);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					//fade_buf[0] = FadeAllToBlack;
+					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				}
+				else if (!packsInstalled)
+				{
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				}
+				else
+				{
+					LastActivity = CHECK_LOAD;
+					GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				}
 				break;
 			case START_NEW_GAME:
-				LastActivity = CHECK_LOAD | CHECK_RESTART;
-				GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				if (resFactorWasChanged)
+				{
+					LockMutex (GraphicsLock);
+					SetFlashRect (NULL);
+					UnlockMutex (GraphicsLock);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					//fade_buf[0] = FadeAllToBlack;
+					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				}
+				else if (!packsInstalled)
+				{
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				}
+				else
+				{
+					LastActivity = CHECK_LOAD | CHECK_RESTART;
+					GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				}				
 				break;
 			case PLAY_SUPER_MELEE:
-				GLOBAL (CurrentActivity) = SUPER_MELEE;
+				if (resFactorWasChanged)
+				{
+					LockMutex (GraphicsLock);
+					SetFlashRect (NULL);
+					UnlockMutex (GraphicsLock);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					//fade_buf[0] = FadeAllToBlack;
+					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				}
+				else if (!packsInstalled)
+				{
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + resolutionFactor));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				}
+				else
+				{
+					GLOBAL (CurrentActivity) = SUPER_MELEE;
+				}
 				break;
 			case SETUP_GAME:
+				oldresfactor = resolutionFactor;
 				Flash_pause(pMS->flashContext);
 				Flash_setState(pMS->flashContext, FlashState_fadeIn,
 						(3 * ONE_SECOND) / 16);
 				SetupMenu ();
 				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
 						MENU_SOUND_SELECT);
+				InactTimeOut = (pMS->hMusic && optMainmenuMusic ? 86 : 20) * ONE_SECOND;
 				LastInputTime = GetTimeCounter ();
 				SetTransitionSource (NULL);
 				BatchGraphics ();
 				DrawRestartMenuGraphic (pMS);
 				ScreenTransition (3, NULL);
-				DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
+				
+				// JMS_GFX: This prevents drawing an annoying wrong-sized "Setup" frame when changing resolution. 
+				if (oldresfactor < resolutionFactor)
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, TRUE);
+				
+				DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 				Flash_continue(pMS->flashContext);
 				UnbatchGraphics ();
 				return TRUE;
@@ -211,7 +415,7 @@ DoRestart (MENU_STATE *pMS)
 		if (NewState != pMS->CurState)
 		{
 			BatchGraphics ();
-			DrawRestartMenu (pMS, NewState, pMS->CurFrame);
+			DrawRestartMenu (pMS, NewState, pMS->CurFrame, FALSE);
 			UnbatchGraphics ();
 			pMS->CurState = NewState;
 		}
@@ -232,7 +436,7 @@ DoRestart (MENU_STATE *pMS)
 		SetTransitionSource (NULL);
 		BatchGraphics ();
 		DrawRestartMenuGraphic (pMS);
-		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
+		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 		ScreenTransition (3, NULL);
 		UnbatchGraphics ();
 		Flash_continue(pMS->flashContext);
@@ -241,9 +445,14 @@ DoRestart (MENU_STATE *pMS)
 	}
 	else
 	{	// No input received, check if timed out
-		if (GetTimeCounter () - LastInputTime > InactTimeOut)
+		//
+		// JMS: After changing resolution mode, prevent displaying credits
+		// (until the next time the game is restarted). This is to prevent
+		// showing the credits with the wrong resolution mode's font&background.
+		if (GetTimeCounter () - LastInputTime > InactTimeOut
+			&& !resFactorWasChanged)
 		{
-			SleepThreadUntil (FadeMusic (0, ONE_SECOND));
+			SleepThreadUntil (FadeMusic (0, ONE_SECOND/2));
 			StopMusic ();
 			FadeMusic (NORMAL_VOLUME, 0);
 
@@ -307,17 +516,24 @@ RestartMenu (MENU_STATE *pMS)
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, TimeOut));
 	if (TimeOut == ONE_SECOND / 8)
 		SleepThread (ONE_SECOND * 3);
+	
 	DrawRestartMenuGraphic (pMS);
 	GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
 	SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);
 	SetDefaultMenuRepeatDelay ();
 	DoInput (pMS, TRUE);
 	
+	if (optMainmenuMusic)
+		SleepThreadUntil (FadeMusic (0, ONE_SECOND));
+	
 	StopMusic ();
 	if (pMS->hMusic)
 	{
 		DestroyMusic (pMS->hMusic);
 		pMS->hMusic = 0;
+		
+		if (optMainmenuMusic)
+			FadeMusic (NORMAL_VOLUME, 0);
 	}
 
 	Flash_terminate (pMS->flashContext);
diff -ruNp ./src.orig/uqm/save.c ./src/uqm/save.c
--- ./src.orig/uqm/save.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/save.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2011: - Added saving res_factor to summary_desc. It'll help making saves between different resolutions compatible.
+
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include <assert.h>
 
 #include "save.h"
@@ -304,8 +308,9 @@ SaveEncounter (const ENCOUNTER *Encounte
 	}
 	
 	// Save the stuff after the BRIEF_SHIP_INFO array
-	cwrite_32  (fh, EncounterPtr->log_x);
-	cwrite_32  (fh, EncounterPtr->log_y);
+	// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_32  (fh, ((EncounterPtr->log_x) >> RESOLUTION_FACTOR));
+	cwrite_32  (fh, ((EncounterPtr->log_y) >> RESOLUTION_FACTOR));
 }
 
 static void
@@ -360,6 +365,14 @@ SaveClockState (const CLOCK_STATE *Clock
 static void
 SaveGameState (const GAME_STATE *GSPtr, DECODE_REF fh)
 {
+	BYTE res_scale; // JMS
+	
+	// JMS
+	if (LOBYTE (GSPtr->CurrentActivity) != IN_INTERPLANETARY)
+		res_scale = RESOLUTION_FACTOR; 
+	else
+		res_scale = 0;
+	
 	cwrite_8   (fh, 0); /* obsolete; BYTE cur_state */
 	cwrite_8   (fh, GSPtr->glob_flags);
 	cwrite_8   (fh, GSPtr->CrewCost);
@@ -377,24 +390,24 @@ SaveGameState (const GAME_STATE *GSPtr,
 	cwrite_16  (fh, GSPtr->ip_location.x);
 	cwrite_16  (fh, GSPtr->ip_location.y);
 	/* STAMP ShipStamp */
-	cwrite_16  (fh, GSPtr->ShipStamp.origin.x);
-	cwrite_16  (fh, GSPtr->ShipStamp.origin.y);
+	cwrite_16  (fh, (GSPtr->ShipStamp.origin.x >> RESOLUTION_FACTOR)); // JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, (GSPtr->ShipStamp.origin.y >> RESOLUTION_FACTOR)); // JMS: Let's make savegames work even between different resolution modes.
 	cwrite_16  (fh, GSPtr->ShipFacing);
 	cwrite_8   (fh, GSPtr->ip_planet);
 	cwrite_8   (fh, GSPtr->in_orbit);
 
 	/* VELOCITY_DESC velocity */
 	cwrite_16  (fh, GSPtr->velocity.TravelAngle);
-	cwrite_16  (fh, GSPtr->velocity.vector.width);
-	cwrite_16  (fh, GSPtr->velocity.vector.height);
-	cwrite_16  (fh, GSPtr->velocity.fract.width);
-	cwrite_16  (fh, GSPtr->velocity.fract.height);
-	cwrite_16  (fh, GSPtr->velocity.error.width);
-	cwrite_16  (fh, GSPtr->velocity.error.height);
-	cwrite_16  (fh, GSPtr->velocity.incr.width);
-	cwrite_16  (fh, GSPtr->velocity.incr.height);
+	cwrite_16  (fh, GSPtr->velocity.vector.width >> res_scale); // JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.vector.height >> res_scale);// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.fract.width >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.fract.height >> res_scale); // JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.error.width >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.error.height >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.incr.width >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
+	cwrite_16  (fh, GSPtr->velocity.incr.height >> res_scale);	// JMS: Let's make savegames work even between different resolution modes.
 	cwrite_16  (fh, 0); /* VELOCITY_DESC padding */
-
+	
 	cwrite_32  (fh, GSPtr->BattleGroupRef);
 	
 	DummySaveQueue (&GSPtr->avail_race_q, fh);
@@ -405,7 +418,9 @@ SaveGameState (const GAME_STATE *GSPtr,
 
 	cwrite_a8  (fh, GSPtr->GameState, sizeof (GSPtr->GameState));
 
-	assert (sizeof (GSPtr->GameState) % 4 == 3);
+	//log_add (log_Debug, "Size:%lu, divided:%lu", sizeof (GSPtr->GameState), sizeof (GSPtr->GameState) % 4);
+	
+	//assert (sizeof (GSPtr->GameState) % 4 == 1);
 	cwrite_8  (fh, 0); /* GAME_STATE alignment padding */
 }
 
@@ -413,8 +428,8 @@ static BOOLEAN
 SaveSisState (const SIS_STATE *SSPtr, void *fp)
 {
 	if (
-			write_32  (fp, SSPtr->log_x) != 1 ||
-			write_32  (fp, SSPtr->log_y) != 1 ||
+		write_32  (fp, ((SSPtr->log_x) >> RESOLUTION_FACTOR)) != 1 || // JMS: Let's make savegames work even between different resolution modes.
+		write_32  (fp, ((SSPtr->log_y) >> RESOLUTION_FACTOR)) != 1 || // JMS: Let's make savegames work even between different resolution modes.
 			write_32  (fp, SSPtr->ResUnits) != 1 ||
 			write_32  (fp, SSPtr->FuelOnBoard) != 1 ||
 			write_16  (fp, SSPtr->CrewEnlisted) != 1 ||
@@ -440,6 +455,17 @@ SaveSisState (const SIS_STATE *SSPtr, vo
 static BOOLEAN
 SaveSummary (const SUMMARY_DESC *SummPtr, void *fp)
 {
+	UNICODE SaveNameCheck[SAVE_CHECKER_SIZE] = {0};
+	strncpy(SaveNameCheck, SAVE_NAME_CHECKER, SAVE_CHECKER_SIZE);
+	
+	// JMS: First we store the savegamename identifier (which tells the code
+	// that this savegame has an user-given name) and the name itself.
+	if (
+		write_str (fp, SaveNameCheck, SAVE_CHECKER_SIZE) != 1 ||
+		write_str (fp, Global_save_name, SAVE_NAME_SIZE) != 1
+		)
+		return FALSE;
+	
 	if (!SaveSisState (&SummPtr->SS, fp))
 		return FALSE;
 
@@ -455,7 +481,8 @@ SaveSummary (const SUMMARY_DESC *SummPtr
 			write_8  (fp, SummPtr->NumDevices) != 1 ||
 			write_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
 			write_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
-
+			write_8  (fp, SummPtr->res_factor) != 1 || // JMS: This'll help making saves in different resolutions compatible.
+		
 			write_16  (fp, 0) != 1 /* padding */
 		)
 		return FALSE;
@@ -532,6 +559,8 @@ PrepareSummary (SUMMARY_DESC *SummPtr)
 	SummPtr->day_index = GLOBAL (GameClock.day_index);
 	SummPtr->month_index = GLOBAL (GameClock.month_index);
 	SummPtr->year_index = GLOBAL (GameClock.year_index);
+	
+	SummPtr->res_factor = RESOLUTION_FACTOR; // JMS: This'll help making saves in different resolutions compatible.
 }
 
 static void
@@ -570,10 +599,10 @@ SaveProblemMessage (STAMP *MsgStamp)
 			- r.corner.x;
 	t.baseline.y = ((SIS_SCREEN_HEIGHT >> 1) - (r.extent.height >> 1))
 			- r.corner.y;
-	r.corner.x += t.baseline.x - 4;
-	r.corner.y += t.baseline.y - 4;
-	r.extent.width += 8;
-	r.extent.height += 8;
+	r.corner.x += t.baseline.x - (4 << RESOLUTION_FACTOR);
+	r.corner.y += t.baseline.y - (4 << RESOLUTION_FACTOR);
+	r.extent.width += (8 << RESOLUTION_FACTOR);
+	r.extent.height += (8 << RESOLUTION_FACTOR);
 
 	*MsgStamp = SaveContextFrame (&r);
 	
@@ -830,7 +859,7 @@ RetrySave:
 
 		// Write the memory file to the actual savegame file.
 		sprintf (file, "starcon2.%02u", which_game);
-		log_add (log_Debug, "'%s' is %u bytes long", file,
+		log_add (log_Debug, "'%s' is %lu bytes long", file,
 				flen + sizeof (*SummPtr));
 		if (flen && (out_fp = res_OpenResFile (saveDir, file, "wb")))
 		{
diff -ruNp ./src.orig/uqm/setup.c ./src/uqm/setup.c
--- ./src.orig/uqm/setup.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/setup.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "setup.h"
 
 #include "coderes.h"
@@ -62,17 +64,22 @@ FONT TinyFont;
 QUEUE race_q[NUM_PLAYERS];
 FRAME ActivityFrame;
 FRAME StatusFrame;
+FRAME SubmenuStarmapKeysFrame;
+FRAME ConstellationsFrame; // JMS
+FRAME hyperspacesuns; // BW
+FRAME nebulaeFrame; // JMS
 FRAME FlagStatFrame;
 FRAME MiscDataFrame;
 FRAME FontGradFrame;
 Mutex GraphicsLock;
 STRING GameStrings;
 QUEUE disp_q;
+BOOLEAN hires2xPackPresent; // JMS_GFX
+BOOLEAN hires4xPackPresent; // JMS_GFX
 
 uio_Repository *repository;
 uio_DirHandle *rootDir;
 
-
 static void
 InitPlayerInput (void)
 {
@@ -133,6 +140,19 @@ LoadKernel (int argc, char *argv[])
 		loadAddon ("3dovideo");
 	}
 
+	// JMS_GFX
+	if (resolutionFactor == 1 && loadAddon ("hires2x"))
+	{
+		hires2xPackPresent = TRUE;
+		log_add (log_Debug, "loading addon hires2x");
+	}
+	else if (resolutionFactor == 2 && loadAddon ("hires4x"))
+	{
+		hires4xPackPresent = TRUE;
+		log_add (log_Debug, "loading addon hires4x");
+	}
+	// END JMS_GFX
+
 	/* Now load the rest of the addons, in order. */
 	prepareAddons (optAddons);
 
@@ -206,6 +226,26 @@ InitKernel (void)
 	StatusFrame = CaptureDrawable (LoadGraphic (STATUS_MASK_PMAP_ANIM));
 	if (StatusFrame == NULL)
 		return FALSE;
+	
+	// JMS: Animated hyperspace suns.
+	hyperspacesuns = CaptureDrawable (LoadGraphic (HYPERSUNS_MASK_PMAP_ANIM));
+	if (hyperspacesuns == NULL)
+		return FALSE;
+	
+	// JMS: Background nebulae in IP.
+	nebulaeFrame = CaptureDrawable (LoadGraphic (NEBULAE_PMAP_ANIM));
+	if (nebulaeFrame == NULL)
+		return FALSE;
+		
+	// JMS: Constellation lines for the constellation starmap.
+	ConstellationsFrame = CaptureDrawable (LoadGraphic (CONSTELLATIONS_MASK_PMAP_ANIM));
+	if (ConstellationsFrame == NULL)
+		return FALSE;
+		
+	// JMS: This is a table of mineral values that will be shown on the status bar.
+	SubmenuStarmapKeysFrame = CaptureDrawable (LoadGraphic (SUBMENUSTARMAPKEYS_MASK_PMAP_ANIM));
+	if (SubmenuStarmapKeysFrame == NULL)
+		return FALSE;
 
 	GameStrings = CaptureStringTable (LoadStringTable (STARCON_GAME_STRINGS));
 	if (GameStrings == 0)
diff -ruNp ./src.orig/uqm/setup.h ./src/uqm/setup.h
--- ./src.orig/uqm/setup.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/setup.h	2017-10-23 11:41:34 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef _SETUP_H
 #define _SETUP_H
 
@@ -29,6 +31,10 @@ extern RESOURCE_INDEX hResIndex;
 extern FRAME Screen;
 extern FRAME ActivityFrame;
 extern FRAME StatusFrame;
+extern FRAME SubmenuStarmapKeysFrame; // JMS
+extern FRAME ConstellationsFrame; // JMS
+extern FRAME nebulaeFrame;	// JMS
+extern FRAME hyperspacesuns;	// BW
 extern FRAME FlagStatFrame;
 extern FRAME MiscDataFrame;
 extern FRAME FontGradFrame;
@@ -54,6 +60,9 @@ extern QUEUE race_q[];
 		/* Array of lists of ships involved in a battle, one queue per side;
 		 * queue element is STARSHIP */
 
+extern BOOLEAN hires2xPackPresent; // JMS
+extern BOOLEAN hires4xPackPresent; // JMS
+
 extern ACTIVITY LastActivity;
 
 extern BYTE PlayerControl[];
diff -ruNp ./src.orig/uqm/setupmenu.c ./src/uqm/setupmenu.c
--- ./src.orig/uqm/setupmenu.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/setupmenu.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,12 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2011: Originally, the smooth zoom was TFB_SCALE_TRILINEAR instead of bilinear.
+// Using bilinear alleviates the smooth zoom performance choppiness problems in 2x and 4x, but
+// is kinda hacky solution...
+
+// JMS_GFX 2012: Merged resolution Factor stuff from P6014.
+
 #include "setupmenu.h"
 
 #include "controls.h"
@@ -38,11 +44,15 @@
 #include "resinst.h"
 #include "nameref.h"
 
+#include "gamestr.h"
+
+#include "libs/graphics/bbox.h"
+
 static STRING SetupTab;
 
 typedef struct setup_menu_state {
 	BOOLEAN (*InputFunc) (struct setup_menu_state *pInputState);
-
+	
 	BOOLEAN initialized;
 	int anim_frame_count;
 	DWORD NextTime;
@@ -67,13 +77,13 @@ static void rebind_control (WIDGET_CONTR
 static void clear_control (WIDGET_CONTROLENTRY *widget);
 
 #ifdef HAVE_OPENGL
-#define RES_OPTS 4
+#define RES_OPTS 3 // JMS_GFX was 4
 #else
-#define RES_OPTS 2
+#define RES_OPTS 3 // JMS_GFX was 2
 #endif
 
 #define MENU_COUNT          8
-#define CHOICE_COUNT       22
+#define CHOICE_COUNT       29 // JMS: New options added.
 #define SLIDER_COUNT        3
 #define BUTTON_COUNT       10
 #define LABEL_COUNT         4
@@ -94,21 +104,24 @@ static WIDGET_CONTROLENTRY controlentrie
 typedef int (*HANDLER)(WIDGET *, int);
 
 static int choice_widths[CHOICE_COUNT] = {
-	3, 2, 3, 3, 2, 2, 2, 2, 2, 2, 
-	2, 2, 3, 2, 2, 3, 3, 2,	3, 3, 
-	3, 2 };
+	3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 
+	2, 2, 2, 2, 2, 3, 3, 2,	3, 3, 
+	3, 2, 3, 2, 2, 2, 2, 2, 2 };
 
 static HANDLER button_handlers[BUTTON_COUNT] = {
 	quit_main_menu, quit_sub_menu, do_graphics, do_engine,
 	do_audio, do_resources, do_keyconfig, do_advanced, do_editkeys, 
 	do_keyconfig };
 
+// JMS: The second 8 was 9 - removed one since the pulsating slave shield is removed.
+// JMS: The first 8 was 7 (sound options.) Added mainmenumusic on/off.
+// JMS: The HAVE_OPENGL options were 5 and 4. Added cheatMode, mineralSubmenu, nebulae and planet options.
 static int menu_sizes[MENU_COUNT] = {
-	7, 5, 7, 9, 2, 5,
+	7, 6, 8, 8, 2, 5,
 #ifdef HAVE_OPENGL
-	5,
+	10,
 #else
-	4,
+	9,
 #endif
 	11
 };
@@ -128,6 +141,7 @@ static WIDGET *main_widgets[] = {
 
 static WIDGET *graphics_widgets[] = {
 	(WIDGET *)(&choices[0]),
+	(WIDGET *)(&choices[22]), // JMS: lores blowup
 	(WIDGET *)(&choices[10]),
 	(WIDGET *)(&choices[2]),
 	(WIDGET *)(&choices[3]),
@@ -140,6 +154,7 @@ static WIDGET *audio_widgets[] = {
 	(WIDGET *)(&choices[14]),
 	(WIDGET *)(&choices[9]),
 	(WIDGET *)(&choices[21]),
+	(WIDGET *)(&choices[23]), // JMS: Mainmenumusic on/off
 	(WIDGET *)(&buttons[1]) };
 
 static WIDGET *engine_widgets[] = {
@@ -150,7 +165,7 @@ static WIDGET *engine_widgets[] = {
 	(WIDGET *)(&choices[8]),
 	(WIDGET *)(&choices[13]),
 	(WIDGET *)(&choices[11]),
-	(WIDGET *)(&choices[17]),
+	//(WIDGET *)(&choices[17]), // JMS: Removed the pulsating shield
 	(WIDGET *)(&buttons[1]) };
 
 static WIDGET *advanced_widgets[] = {
@@ -160,8 +175,13 @@ static WIDGET *advanced_widgets[] = {
 	(WIDGET *)(&choices[12]),
 	(WIDGET *)(&choices[15]),
 	(WIDGET *)(&choices[16]),
+	(WIDGET *)(&choices[24]), // JMS: mineralSubmenu on/off
+	(WIDGET *)(&choices[25]), // JMS: IP nebulae on/off
+	(WIDGET *)(&choices[26]), // JMS: rotatingIpPlanets on/off
+	(WIDGET *)(&choices[27]), // JMS: texturedIpPlanets on/off
+	(WIDGET *)(&choices[28]), // JMS: cheatMode on/off
 	(WIDGET *)(&buttons[1]) };
-	
+
 static WIDGET *keyconfig_widgets[] = {
 	(WIDGET *)(&choices[18]),
 	(WIDGET *)(&choices[19]),
@@ -338,10 +358,10 @@ static void
 rename_template (WIDGET_TEXTENTRY *self)
 {
 	/* TODO: This will have to change if the size of the
-	   input_templates name is changed.  It would probably be nice
-	   to track this symbolically or ensure that self->value's
-	   buffer is always at least this big; this will require some
-	   reworking of widgets */
+	 input_templates name is changed.  It would probably be nice
+	 to track this symbolically or ensure that self->value's
+	 buffer is always at least this big; this will require some
+	 reworking of widgets */
 	strncpy (input_templates[choices[20].selected].name, self->value, 30);
 	input_templates[choices[20].selected].name[29] = 0;
 }
@@ -357,14 +377,14 @@ SetDefaults (void)
 	GLOBALOPTS opts;
 	
 	GetGlobalOptions (&opts);
-	if (opts.res == OPTVAL_CUSTOM)
-	{
-		choices[0].numopts = RES_OPTS + 1;
-	}
-	else
-	{
-		choices[0].numopts = RES_OPTS;
-	}
+	/*if (opts.res == OPTVAL_CUSTOM)
+	 {
+	 choices[0].numopts = RES_OPTS + 1;
+	 }
+	 else
+	 {*/
+	choices[0].numopts = RES_OPTS;
+	//}
 	choices[0].selected = opts.res;
 	choices[1].selected = opts.driver;
 	choices[2].selected = opts.scaler;
@@ -387,7 +407,14 @@ SetDefaults (void)
 	choices[19].selected = opts.player2;
 	choices[20].selected = 0;
 	choices[21].selected = opts.musicremix;
-
+	choices[22].selected = opts.loresBlowup; // JMS
+	choices[23].selected = opts.mainmenuMusic; // JMS
+	choices[24].selected = opts.mineralSubmenu; // JMS
+	choices[25].selected = opts.nebulae; // JMS
+	choices[26].selected = opts.rotatingIpPlanets; // JMS
+	choices[27].selected = opts.texturedIpPlanets || opts.rotatingIpPlanets; // JMS
+	choices[28].selected = opts.cheatMode; // JMS
+	
 	sliders[0].value = opts.musicvol;
 	sliders[1].value = opts.sfxvol;
 	sliders[2].value = opts.speechvol;
@@ -418,7 +445,14 @@ PropagateResults (void)
 	opts.player1 = choices[18].selected;
 	opts.player2 = choices[19].selected;
 	opts.musicremix = choices[21].selected;
-
+	opts.loresBlowup = choices[22].selected; // JMS
+	opts.mainmenuMusic = choices[23].selected; // JMS
+	opts.mineralSubmenu = choices[24].selected; // JMS
+	opts.nebulae = choices[25].selected; // JMS
+	opts.rotatingIpPlanets = choices[26].selected; // JMS
+	opts.texturedIpPlanets = choices[27].selected || opts.rotatingIpPlanets; // JMS
+	opts.cheatMode = choices[28].selected; // JMS
+	
 	opts.musicvol = sliders[0].value;
 	opts.sfxvol = sliders[1].value;
 	opts.speechvol = sliders[2].value;
@@ -430,7 +464,7 @@ DoSetupMenu (SETUP_MENU_STATE *pInputSta
 {
 	/* Cancel any presses of the Pause key. */
 	GamePaused = FALSE;
-
+	
 	if (!pInputState->initialized) 
 	{
 		SetDefaultMenuRepeatDelay ();
@@ -439,7 +473,7 @@ DoSetupMenu (SETUP_MENU_STATE *pInputSta
 		Widget_SetFont (StarConFont);
 		Widget_SetWindowColors (SHADOWBOX_BACKGROUND_COLOR,
 				SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
-
+		
 		current = NULL;
 		next = (WIDGET *)(&menus[0]);
 		(*next->receiveFocus) (next, WIDGET_EVENT_DOWN);
@@ -453,15 +487,15 @@ DoSetupMenu (SETUP_MENU_STATE *pInputSta
 	
 	BatchGraphics ();
 	(*next->draw)(next, 0, 0);
-
+	
 	if (current != next)
 	{
 		ScreenTransition (3, NULL);
 		current = next;
 	}
-
+	
 	UnbatchGraphics ();
-
+	
 	if (PulsedInputState.menu[KEY_MENU_UP])
 	{
 		Widget_Event (WIDGET_EVENT_UP);
@@ -490,11 +524,11 @@ DoSetupMenu (SETUP_MENU_STATE *pInputSta
 	{
 		Widget_Event (WIDGET_EVENT_DELETE);
 	}
-
+	
 	SleepThreadUntil (pInputState->NextTime + MENU_FRAME_RATE);
 	pInputState->NextTime = GetTimeCounter ();
 	return !((GLOBAL (CurrentActivity) & CHECK_ABORT) || 
-		 (next == NULL));
+			 (next == NULL));
 }
 
 static void
@@ -509,7 +543,7 @@ static BOOLEAN
 OnTextEntryChange (TEXTENTRY_STATE *pTES)
 {
 	WIDGET_TEXTENTRY *widget = (WIDGET_TEXTENTRY *) pTES->CbParam;
-
+	
 	widget->cursor_pos = pTES->CursorPos;
 	if (pTES->JoystickMode)
 		widget->state |= WTE_BLOCKCUR;
@@ -527,10 +561,10 @@ static BOOLEAN
 OnTextEntryFrame (TEXTENTRY_STATE *pTES)
 {
 	redraw_menu ();
-
+	
 	SleepThreadUntil (pTES->NextTime);
 	pTES->NextTime = GetTimeCounter () + MENU_FRAME_RATE;
-
+	
 	return TRUE; // continue
 }
 
@@ -539,15 +573,15 @@ OnTextEntryEvent (WIDGET_TEXTENTRY *widg
 {	// Going to edit the text
 	TEXTENTRY_STATE tes;
 	UNICODE revert_buf[256];
-
+	
 	// position cursor at the end of text
 	widget->cursor_pos = utf8StringCount (widget->value);
 	widget->state = WTE_EDITING;
 	redraw_menu ();
-
+	
 	// make a backup copy for revert on cancel
 	utf8StringCopy (revert_buf, sizeof (revert_buf), widget->value);
-
+	
 	// text entry setup
 	tes.Initialized = FALSE;
 	tes.NextTime = GetTimeCounter () + MENU_FRAME_RATE;
@@ -557,7 +591,7 @@ OnTextEntryEvent (WIDGET_TEXTENTRY *widg
 	tes.CbParam = widget;
 	tes.ChangeCallback = OnTextEntryChange;
 	tes.FrameCallback = OnTextEntryFrame;
-
+	
 	SetMenuSounds (MENU_SOUND_NONE, MENU_SOUND_SELECT);
 	if (!DoTextEntry (&tes))
 	{	// editing failed (canceled) -- revert the changes
@@ -571,10 +605,10 @@ OnTextEntryEvent (WIDGET_TEXTENTRY *widg
 		}
 	}
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
-
+	
 	widget->state = WTE_NORMAL;
 	redraw_menu ();
-
+	
 	return TRUE; // event handled
 }
 
@@ -584,7 +618,7 @@ rebind_control (WIDGET_CONTROLENTRY *wid
 	int template = choices[20].selected;
 	int control = widget->controlindex;
 	int index = widget->highlighted;
-
+	
 	FlushInput ();
 	DrawLabelAsWindow (&labels[3], NULL);
 	RebindInputState (template, control, index);
@@ -598,7 +632,7 @@ clear_control (WIDGET_CONTROLENTRY *widg
 	int template = choices[20].selected;
 	int control = widget->controlindex;
 	int index = widget->highlighted;
-      
+	
 	RemoveInputState (template, control, index);
 	populate_editkeys (template);
 }	
@@ -611,34 +645,40 @@ init_widgets (void)
 {
 	const char *buffer[100], *str, *title;
 	int count, i, index;
-
+	
 	if (bank == NULL)
 	{
 		bank = StringBank_Create ();
 	}
 	
-	if (setup_frame == NULL)
+	if (setup_frame == NULL || resFactorWasChanged)
 	{
-		setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM));
+		// JMS: Load the different menus depending on the resolution factor.
+		if (resolutionFactor < 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM));
+		if (resolutionFactor == 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM2X));
+		if (resolutionFactor > 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM4X));
 	}
-
+	
 	count = GetStringTableCount (SetupTab);
-
+	
 	if (count < 3)
 	{
 		log_add (log_Fatal, "PANIC: Setup string table too short to even hold all indices!");
 		exit (EXIT_FAILURE);
 	}
-
+	
 	/* Menus */
 	title = StringBank_AddOrFindString (bank, GetStringAddress (SetAbsStringTableIndex (SetupTab, 0)));
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 1)), '\n', 100, buffer, bank) != MENU_COUNT)
 	{
 		/* TODO: Ignore extras instead of dying. */
-		log_add (log_Fatal, "PANIC: Incorrect number of Menu Subtitles");
+		log_add (log_Fatal, "PANIC: Incorrect number of Menu Subtitles:");
 		exit (EXIT_FAILURE);
 	}
-
+	
 	for (i = 0; i < MENU_COUNT; i++)
 	{
 		menus[i].tag = WIDGET_TYPE_MENU_SCREEN;
@@ -657,14 +697,14 @@ init_widgets (void)
 		menus[i].child = menu_widgets[i];
 		menus[i].highlighted = 0;
 	}
-		
+	
 	/* Options */
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 2)), '\n', 100, buffer, bank) != CHOICE_COUNT)
 	{
-		log_add (log_Fatal, "PANIC: Incorrect number of Choice Options");
+		log_add (log_Fatal, "PANIC: Incorrect number of Choice Options: %d. Should be %d", CHOICE_COUNT, SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 2)), '\n', 100, buffer, bank));
 		exit (EXIT_FAILURE);
 	}
-
+	
 	for (i = 0; i < CHOICE_COUNT; i++)
 	{
 		choices[i].tag = WIDGET_TYPE_CHOICE;
@@ -682,13 +722,13 @@ init_widgets (void)
 		choices[i].maxcolumns = choice_widths[i];
 		choices[i].onChange = NULL;
 	}
-
+	
 	/* Fill in the options now */
 	index = 3;  /* Index into string table */
 	for (i = 0; i < CHOICE_COUNT; i++)
 	{
 		int j, optcount;
-
+		
 		if (index >= count)
 		{
 			log_add (log_Fatal, "PANIC: String table cut short while reading choices");
@@ -708,7 +748,7 @@ init_widgets (void)
 		for (j = 0; j < optcount; j++)
 		{
 			int k, tipcount;
-
+			
 			if (index >= count)
 			{
 				log_add (log_Fatal, "PANIC: String table cut short while reading choices");
@@ -726,10 +766,10 @@ init_widgets (void)
 			}
 		}
 	}
-
+	
 	/* The first choice is resolution, and is handled specially */
 	choices[0].numopts = RES_OPTS;
-
+	
 	/* Choices 18-20 are also special, being the names of the key configurations */
 	for (i = 0; i < 6; i++)
 	{
@@ -737,24 +777,24 @@ init_widgets (void)
 		choices[19].options[i].optname = input_templates[i].name;
 		choices[20].options[i].optname = input_templates[i].name;
 	}
-
+	
 	/* Choice 20 has a special onChange handler, too. */
 	choices[20].onChange = change_template;
-
+	
 	/* Sliders */
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading sliders");
 		exit (EXIT_FAILURE);
 	}
-
+	
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != SLIDER_COUNT)
 	{
 		/* TODO: Ignore extras instead of dying. */
 		log_add (log_Fatal, "PANIC: Incorrect number of Slider Options");
 		exit (EXIT_FAILURE);
 	}
-
+	
 	for (i = 0; i < SLIDER_COUNT; i++)
 	{
 		sliders[i].tag = WIDGET_TYPE_SLIDER;
@@ -774,7 +814,7 @@ init_widgets (void)
 		sliders[i].tooltip[1] = "";
 		sliders[i].tooltip[2] = "";
 	}
-
+	
 	for (i = 0; i < SLIDER_COUNT; i++)
 	{
 		int j, tipcount;
@@ -795,21 +835,21 @@ init_widgets (void)
 			sliders[i].tooltip[j] = buffer[j];
 		}
 	}
-
+	
 	/* Buttons */
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading buttons");
 		exit (EXIT_FAILURE);
 	}
-
+	
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != BUTTON_COUNT)
 	{
 		/* TODO: Ignore extras instead of dying. */
 		log_add (log_Fatal, "PANIC: Incorrect number of Button Options");
 		exit (EXIT_FAILURE);
 	}
-
+	
 	for (i = 0; i < BUTTON_COUNT; i++)
 	{
 		buttons[i].tag = WIDGET_TYPE_BUTTON;
@@ -824,7 +864,7 @@ init_widgets (void)
 		buttons[i].tooltip[1] = "";
 		buttons[i].tooltip[2] = "";
 	}
-
+	
 	for (i = 0; i < BUTTON_COUNT; i++)
 	{
 		int j, tipcount;
@@ -845,21 +885,21 @@ init_widgets (void)
 			buttons[i].tooltip[j] = buffer[j];
 		}
 	}
-
+	
 	/* Labels */
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading labels");
 		exit (EXIT_FAILURE);
 	}
-
+	
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != LABEL_COUNT)
 	{
 		/* TODO: Ignore extras instead of dying. */
 		log_add (log_Fatal, "PANIC: Incorrect number of Label Options");
 		exit (EXIT_FAILURE);
 	}
-
+	
 	for (i = 0; i < LABEL_COUNT; i++)
 	{
 		labels[i].tag = WIDGET_TYPE_LABEL;
@@ -872,7 +912,7 @@ init_widgets (void)
 		labels[i].line_count = 0;
 		labels[i].lines = NULL;
 	}
-
+	
 	for (i = 0; i < LABEL_COUNT; i++)
 	{
 		int j, linecount;
@@ -891,14 +931,14 @@ init_widgets (void)
 			labels[i].lines[j] = buffer[j];
 		}
 	}
-
+	
 	/* Text Entry boxes */
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading text entries");
 		exit (EXIT_FAILURE);
 	}
-
+	
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != TEXTENTRY_COUNT)
 	{
 		log_add (log_Fatal, "PANIC: Incorrect number of Text Entries");
@@ -920,13 +960,13 @@ init_widgets (void)
 		textentries[i].state = WTE_NORMAL;
 		textentries[i].cursor_pos = 0;
 	}
-
+	
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading text entries");
 		exit (EXIT_FAILURE);
 	}
-
+	
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != TEXTENTRY_COUNT)
 	{
 		/* TODO: Ignore extras instead of dying. */
@@ -939,14 +979,14 @@ init_widgets (void)
 		textentries[i].value[textentries[i].maxlen] = 0;
 	}
 	textentries[0].onChange = rename_template;
-
+	
 	/* Control Entry boxes */
 	if (index >= count)
 	{
 		log_add (log_Fatal, "PANIC: String table cut short while reading control entries");
 		exit (EXIT_FAILURE);
 	}
-
+	
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, index++)), '\n', 100, buffer, bank) != CONTROLENTRY_COUNT)
 	{
 		log_add (log_Fatal, "PANIC: Incorrect number of Control Entries");
@@ -969,12 +1009,12 @@ init_widgets (void)
 		controlentries[i].onChange = rebind_control;
 		controlentries[i].onDelete = clear_control;
 	}
-
+	
 	/* Check for garbage at the end */
 	if (index < count)
 	{
 		log_add (log_Warning, "WARNING: Setup strings had %d garbage entries at the end.",
-				count - index);
+				 count - index);
 	}
 }
 
@@ -982,7 +1022,7 @@ static void
 clean_up_widgets (void)
 {
 	int i;
-
+	
 	for (i = 0; i < CHOICE_COUNT; i++)
 	{
 		if (choices[i].options)
@@ -990,7 +1030,7 @@ clean_up_widgets (void)
 			HFree (choices[i].options);
 		}
 	}
-
+	
 	for (i = 0; i < LABEL_COUNT; i++)
 	{
 		if (labels[i].lines)
@@ -998,7 +1038,7 @@ clean_up_widgets (void)
 			HFree ((void *)labels[i].lines);
 		}
 	}
-
+	
 	/* Clear out the master tables */
 	
 	if (SetupTab)
@@ -1022,7 +1062,7 @@ void
 SetupMenu (void)
 {
 	SETUP_MENU_STATE s;
-
+	
 	s.InputFunc = DoSetupMenu;
 	s.initialized = FALSE;
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
@@ -1037,7 +1077,7 @@ SetupMenu (void)
 		exit (EXIT_FAILURE);
 	}
 	done = FALSE;
-
+	
 	DoInput (&s, TRUE);
 	GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
 	PropagateResults ();
@@ -1075,10 +1115,10 @@ GetGlobalOptions (GLOBALOPTS *opts)
 		opts->scaler = OPTVAL_NO_SCALE;
 	}
 	opts->fullscreen = (GfxFlags & TFB_GFXFLAGS_FULLSCREEN) ?
-			OPTVAL_ENABLED : OPTVAL_DISABLED;
+	OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->subtitles = optSubtitles ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->scanlines = (GfxFlags & TFB_GFXFLAGS_SCANLINES) ? 
-		OPTVAL_ENABLED : OPTVAL_DISABLED;
+	OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->menu = (optWhichMenu == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
 	opts->text = (optWhichFonts == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
 	opts->cscan = (optWhichCoarseScan == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
@@ -1086,23 +1126,23 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	opts->intro = (optWhichIntro == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
 	opts->shield = (optWhichShield == OPT_3DO) ? OPTVAL_3DO : OPTVAL_PC;
 	opts->fps = (GfxFlags & TFB_GFXFLAGS_SHOWFPS) ? 
-			OPTVAL_ENABLED : OPTVAL_DISABLED;
+	OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->meleezoom = (optMeleeScale == TFB_SCALE_STEP) ? 
-			OPTVAL_PC : OPTVAL_3DO;
+	OPTVAL_PC : OPTVAL_3DO;
 	opts->stereo = optStereoSFX ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	/* These values are read in, but won't change during a run. */
 	opts->music3do = opt3doMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	opts->musicremix = optRemixMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 	switch (snddriver) {
-	case audio_DRIVER_OPENAL:
-		opts->adriver = OPTVAL_OPENAL;
-		break;
-	case audio_DRIVER_MIXSDL:
-		opts->adriver = OPTVAL_MIXSDL;
-		break;
-	default:
-		opts->adriver = OPTVAL_SILENCE;
-		break;
+		case audio_DRIVER_OPENAL:
+			opts->adriver = OPTVAL_OPENAL;
+			break;
+		case audio_DRIVER_MIXSDL:
+			opts->adriver = OPTVAL_MIXSDL;
+			break;
+		default:
+			opts->adriver = OPTVAL_SILENCE;
+			break;
 	}
 	if (soundflags & audio_QUALITY_HIGH)
 	{
@@ -1116,73 +1156,76 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	{
 		opts->aquality = OPTVAL_MEDIUM;
 	}
-
+	
+	// JMS
+	opts->mainmenuMusic = optMainmenuMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->mineralSubmenu = optMineralSubmenu ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->nebulae = optNebulae ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->rotatingIpPlanets = optRotatingIpPlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->texturedIpPlanets = (optTexturedIpPlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED) || opts->rotatingIpPlanets;
+	opts->cheatMode = optCheatMode ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	
 	/* Work out resolution.  On the way, try to guess a good default
 	 * for config.alwaysgl, then overwrite it if it was set previously. */
+	opts->loresBlowup = res_GetInteger ("config.loresBlowupScale");
 	opts->driver = OPTVAL_PURE_IF_POSSIBLE;
-	switch (ScreenWidthActual)
+	
+	// JMS_GFX: 1280x960
+	if (resolutionFactor == 2)
 	{
-	case 320:
-		if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
-		{
-			opts->res = OPTVAL_320_240;
-		}
-		else
+		opts->res = OPTVAL_REAL_1280_960;
+		opts->loresBlowup = NO_BLOWUP;	
+	}
+	// JMS_GFX: 640x480
+	else if (resolutionFactor == 1)
+	{
+		opts->res = OPTVAL_REAL_640_480;
+		opts->loresBlowup = NO_BLOWUP;
+	}
+	// JMS_GFX: 320x240
+	else
+	{
+		switch (ScreenWidthActual)
 		{
-			if (ScreenHeightActual != 240)
-			{
-				opts->res = OPTVAL_CUSTOM;
-			}
-			else
-			{
+			case 320:
+				if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
+				{
+					opts->res = OPTVAL_320_240;
+				}
+				else
+				{
+					opts->res = OPTVAL_320_240;
+					opts->driver = OPTVAL_ALWAYS_GL;
+				}
+				break;
+			case 640:
+				if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
+				{
+					opts->res = OPTVAL_320_240;
+					opts->loresBlowup = OPTVAL_320_TO_640;
+				}
+				else
+				{
+					opts->res = OPTVAL_320_240;
+					opts->loresBlowup = OPTVAL_320_TO_640;
+					opts->driver = OPTVAL_ALWAYS_GL;
+				}
+				break;
+			case 800:
 				opts->res = OPTVAL_320_240;
-				opts->driver = OPTVAL_ALWAYS_GL;
-			}
-		}
-		break;
-	case 640:
-		if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
-		{
-			opts->res = OPTVAL_640_480;
-		}
-		else
-		{
-			if (ScreenHeightActual != 480)
-			{
-				opts->res = OPTVAL_CUSTOM;
-			}
-			else
-			{
-				opts->res = OPTVAL_640_480;
-				opts->driver = OPTVAL_ALWAYS_GL;
-			}
-		}
-		break;
-	case 800:
-		if (ScreenHeightActual != 600)
-		{
-			opts->res = OPTVAL_CUSTOM;
-		}
-		else
-		{
-			opts->res = OPTVAL_800_600;
-		}
-		break;
-	case 1024:
-		if (ScreenHeightActual != 768)
-		{
-			opts->res = OPTVAL_CUSTOM;
+				opts->loresBlowup = OPTVAL_320_TO_800;
+				break;
+			case 1024:
+				opts->res = OPTVAL_320_240;
+				opts->loresBlowup = OPTVAL_320_TO_1024;	
+				break;
+			default:
+				opts->res = OPTVAL_320_240;
+				opts->loresBlowup = NO_BLOWUP;
+				break;
 		}
-		else
-		{
-			opts->res = OPTVAL_1024_768;
-		}		
-		break;
-	default:
-		opts->res = OPTVAL_CUSTOM;
-		break;
 	}
-
+	
 	if (res_IsBoolean ("config.alwaysgl"))
 	{
 		if (res_GetBoolean ("config.alwaysgl"))
@@ -1194,14 +1237,13 @@ GetGlobalOptions (GLOBALOPTS *opts)
 			opts->driver = OPTVAL_PURE_IF_POSSIBLE;
 		}
 	}
-
+	
 	opts->player1 = PlayerControls[0];
 	opts->player2 = PlayerControls[1];
-
+	
 	opts->musicvol = (((int)(musicVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->sfxvol = (((int)(sfxVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->speechvol = (((int)(speechVolumeScale * 100.0f) + 2) / 5) * 5;
-	
 }
 
 void
@@ -1211,95 +1253,244 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	int NewWidth = ScreenWidthActual;
 	int NewHeight = ScreenHeightActual;
 	int NewDriver = GraphicsDriver;
-
+	
+	unsigned int oldResFactor = resolutionFactor; // JMS_GFX
+	
 	NewGfxFlags &= ~TFB_GFXFLAGS_SCALE_ANY;
-
+	
+	// JMS_GFX
 	switch (opts->res) {
-	case OPTVAL_320_240:
-		NewWidth = 320;
-		NewHeight = 240;
+		case OPTVAL_320_240:
+			NewWidth = 320;
+			NewHeight = 240;
 #ifdef HAVE_OPENGL	       
-		NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
+			NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
 #else
-		NewDriver = TFB_GFXDRIVER_SDL_PURE;
+			NewDriver = TFB_GFXDRIVER_SDL_PURE;
 #endif
-		break;
-	case OPTVAL_640_480:
-		NewWidth = 640;
-		NewHeight = 480;
+			resolutionFactor = 0;				
+			forceAspectRatio = FALSE;
+			break;
+		case OPTVAL_REAL_640_480:
+			NewWidth = 640;	
+			NewHeight = 480;
 #ifdef HAVE_OPENGL	       
-		NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
+			NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
 #else
-		NewDriver = TFB_GFXDRIVER_SDL_PURE;
+			NewDriver = TFB_GFXDRIVER_SDL_PURE;
 #endif
-		break;
-	case OPTVAL_800_600:
-		NewWidth = 800;
-		NewHeight = 600;
-		NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
-		break;
-	case OPTVAL_1024_768:
-		NewWidth = 1024;
-		NewHeight = 768;
-		NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
-		break;
-	default:
-		/* Don't mess with the custom value */
-		break;
+			resolutionFactor = 1;
+			forceAspectRatio = FALSE;
+			break;
+		case OPTVAL_REAL_1280_960:
+			NewWidth = 1280;
+			NewHeight = 960;
+#ifdef HAVE_OPENGL	       
+			NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
+#else
+			NewDriver = TFB_GFXDRIVER_SDL_PURE;
+#endif
+			resolutionFactor = 2;
+			forceAspectRatio = FALSE;
+			break;
+		default:
+			/* Don't mess with the custom value */
+			resolutionFactor = 0; // JMS_GFX
+			break;
 	}
-
+	
+	if (NewWidth == 320 && NewHeight == 240)
+	{	
+		switch (opts->loresBlowup) {
+			case NO_BLOWUP:
+				// JMS: Default value: Don't do anything.
+				break;
+			case OPTVAL_320_TO_640:
+				NewWidth = 640;
+				NewHeight = 480;
+#ifdef HAVE_OPENGL	       
+				NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
+#else
+				NewDriver = TFB_GFXDRIVER_SDL_PURE;
+#endif
+				resolutionFactor = 0;
+				break;
+			case OPTVAL_320_TO_800:
+				NewWidth = 800;
+				NewHeight = 600;
+				NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
+				resolutionFactor = 0;
+				break;
+			case OPTVAL_320_TO_1024:
+				NewWidth = 1024;
+				NewHeight = 768;
+				NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
+				resolutionFactor = 0;
+				break;
+			default:
+				break;
+		}
+	}
+	else
+		opts->loresBlowup = NO_BLOWUP;
+	
+	if (oldResFactor != resolutionFactor)
+		resFactorWasChanged = TRUE;
+	
 	res_PutInteger ("config.reswidth", NewWidth);
 	res_PutInteger ("config.resheight", NewHeight);
 	res_PutBoolean ("config.alwaysgl", opts->driver == OPTVAL_ALWAYS_GL);
 	res_PutBoolean ("config.usegl", NewDriver == TFB_GFXDRIVER_SDL_OPENGL);
-
-	switch (opts->scaler) {
-	case OPTVAL_BILINEAR_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
-		res_PutString ("config.scaler", "bilinear");
-		break;
-	case OPTVAL_BIADAPT_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPT;
-		res_PutString ("config.scaler", "biadapt");
-		break;
-	case OPTVAL_BIADV_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPTADV;
-		res_PutString ("config.scaler", "biadv");
-		break;
-	case OPTVAL_TRISCAN_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_TRISCAN;
-		res_PutString ("config.scaler", "triscan");
-		break;
-	case OPTVAL_HQXX_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_HQXX;
-		res_PutString ("config.scaler", "hq");
-		break;
-	default:
-		/* OPTVAL_NO_SCALE has no equivalent in gfxflags. */
-		res_PutString ("config.scaler", "no");
-		break;
+	
+	// JMS_GFX
+	res_PutInteger ("config.resolutionfactor", resolutionFactor);
+	res_PutBoolean ("config.forceaspectratio", forceAspectRatio);
+	res_PutInteger ("config.loresBlowupScale", opts->loresBlowup);
+	
+	// JMS: Main menu music
+	res_PutBoolean ("config.mainmenuMusic", opts->mainmenuMusic == OPTVAL_ENABLED);
+	optMainmenuMusic = opts->mainmenuMusic == OPTVAL_ENABLED;
+	if(!optMainmenuMusic)
+		FadeMusic (0,ONE_SECOND);
+	else
+		FadeMusic (NORMAL_VOLUME+70, ONE_SECOND);
+		
+	// JMS: A list of mineral values can be displayed upon landing on a planet.
+	res_PutBoolean ("config.mineralSubmenu", opts->mineralSubmenu == OPTVAL_ENABLED);
+	optMineralSubmenu = opts->mineralSubmenu == OPTVAL_ENABLED;
+	
+	// JMS: Is a beautiful nebula background shown as the background of solarsystems.
+	res_PutBoolean ("config.nebulae", opts->nebulae == OPTVAL_ENABLED);
+	optNebulae = opts->nebulae == OPTVAL_ENABLED;
+	
+	// JMS: Rotating planets in IP.
+	res_PutBoolean ("config.rotatingIpPlanets", opts->rotatingIpPlanets == OPTVAL_ENABLED);
+	optRotatingIpPlanets = opts->rotatingIpPlanets == OPTVAL_ENABLED;
+	
+	// JMS: Textured or plain(==vanilla UQM style) planets in IP.
+	res_PutBoolean ("config.texturedIpPlanets", (opts->texturedIpPlanets == OPTVAL_ENABLED) || opts->rotatingIpPlanets == OPTVAL_ENABLED);
+	optTexturedIpPlanets = opts->texturedIpPlanets == OPTVAL_ENABLED
+		|| opts->rotatingIpPlanets == OPTVAL_ENABLED;
+	
+	// JMS: Cheat Mode: Kohr-Ah move at zero speed when trying to cleanse the galaxy
+	res_PutBoolean ("config.cheatMode", opts->cheatMode == OPTVAL_ENABLED);
+	optCheatMode = opts->cheatMode == OPTVAL_ENABLED;
+	
+	if (NewWidth == 320 && NewHeight == 240)
+	{
+		switch (opts->scaler)
+		{
+			case OPTVAL_BILINEAR_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
+				res_PutString ("config.scaler", "bilinear");
+				break;
+			case OPTVAL_BIADAPT_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPT;
+				res_PutString ("config.scaler", "biadapt");
+				break;
+			case OPTVAL_BIADV_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPTADV;
+				res_PutString ("config.scaler", "biadv");
+				break;
+			case OPTVAL_TRISCAN_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_TRISCAN;
+				res_PutString ("config.scaler", "triscan");
+				break;
+			case OPTVAL_HQXX_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_HQXX;
+				res_PutString ("config.scaler", "hq");
+				break;
+			default:
+				/* OPTVAL_NO_SCALE has no equivalent in gfxflags. */
+				res_PutString ("config.scaler", "no");
+				break;
+		}
+	}
+	else
+	{
+		// JMS: For now, only bilinear works in 1280x960 and 640x480.
+		switch (opts->scaler)
+		{
+			case OPTVAL_BILINEAR_SCALE:
+			case OPTVAL_BIADAPT_SCALE:
+			case OPTVAL_BIADV_SCALE:
+			case OPTVAL_TRISCAN_SCALE:
+			case OPTVAL_HQXX_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
+				res_PutString ("config.scaler", "bilinear");
+				break;
+			default:
+				/* OPTVAL_NO_SCALE has no equivalent in gfxflags. */
+				res_PutString ("config.scaler", "no");
+				break;
+		}
 	}
+	
 	if (opts->scanlines) {
 		NewGfxFlags |= TFB_GFXFLAGS_SCANLINES;
 	} else {
 		NewGfxFlags &= ~TFB_GFXFLAGS_SCANLINES;
 	}
 	if (opts->fullscreen)
+	{
 		NewGfxFlags |= TFB_GFXFLAGS_FULLSCREEN;
+		
+		// JMS: Force the usage of bilinear scaler in 1280x960 and 640x480 fullscreen.
+		if ((NewWidth == 1280 || NewWidth == 640) && resolutionFactor > 0)
+		{
+			NewGfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
+			res_PutString ("config.scaler", "bilinear");
+		}
+	}
 	else
+	{
 		NewGfxFlags &= ~TFB_GFXFLAGS_FULLSCREEN;
-
+		
+		// JMS: Force the usage of no scaler in 1280x960 and 640x480 windowed modes.
+		// When running in windowed mode, the image isn't stretched,
+		// thus using a scaler would yield no benefits.
+		// Not using a scaler should make the performance a little better.
+		if (NewWidth == 1280 || NewWidth == 640)
+		{
+			NewGfxFlags &= ~TFB_GFXFLAGS_SCALE_BILINEAR;
+			res_PutString ("config.scaler", "bilinear");
+		}
+	}
+	
 	res_PutBoolean ("config.scanlines", opts->scanlines);
 	res_PutBoolean ("config.fullscreen", opts->fullscreen);
-
-
+	
 	if ((NewWidth != ScreenWidthActual) ||
 	    (NewHeight != ScreenHeightActual) ||
 	    (NewDriver != GraphicsDriver) ||
+		(resFactorWasChanged) || // JMS_GFX
 	    (NewGfxFlags != GfxFlags)) 
 	{
 		FlushGraphics ();
 		UninitVideoPlayer ();
+		
+		// JMS_GFX
+		if (resFactorWasChanged)
+		{
+			// Tell the game the new screen's size.
+			ScreenWidth  = 320 << resolutionFactor;
+			ScreenHeight = 240 << resolutionFactor;
+			
+			log_add (log_Debug, "ScreenWidth:%d, ScreenHeight:%d, Wactual:%d, Hactual:%d",
+				ScreenWidth, ScreenHeight, ScreenWidthActual, ScreenHeightActual);
+			
+			// These solve the FUCKING context problem that plagued the setupmenu when changing to higher resolution.
+			TFB_BBox_Reset ();
+			TFB_BBox_Init (ScreenWidth, ScreenHeight);
+			
+			// Change how big area of the screen is update-able.
+			DestroyDrawable (ReleaseDrawable (Screen));
+			Screen = CaptureDrawable (CreateDisplay (WANT_MASK | WANT_PIXMAP, &screen_width, &screen_height));
+			SetContext (ScreenContext);
+			SetContextFGFrame ((FRAME)NULL);
+			SetContextFGFrame (Screen);
+		}
+		
 		TFB_DrawScreen_ReinitVideo (NewDriver, NewGfxFlags, NewWidth, NewHeight);
 		FlushGraphics ();
 		InitVideoPlayer (TRUE);
@@ -1311,17 +1502,22 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	optWhichCoarseScan = (opts->cscan == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optSmoothScroll = (opts->scroll == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	optWhichShield = (opts->shield == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
-	optMeleeScale = (opts->meleezoom == OPTVAL_3DO) ? TFB_SCALE_TRILINEAR : TFB_SCALE_STEP;
+	
+	// JMS: Originally, the smooth zoom was TFB_SCALE_TRILINEAR instead of bilinear.
+	// Using bilinear alleviates the smooth zoom performance choppiness problems in 2x and 4x, but
+	// is kinda hacky solution...
+	optMeleeScale = (opts->meleezoom == OPTVAL_3DO) ? TFB_SCALE_BILINEAR : TFB_SCALE_STEP;
+	
 	optWhichIntro = (opts->intro == OPTVAL_3DO) ? OPT_3DO : OPT_PC;
 	PlayerControls[0] = opts->player1;
 	PlayerControls[1] = opts->player2;
-
+	
 	res_PutBoolean ("config.subtitles", opts->subtitles == OPTVAL_ENABLED);
 	res_PutBoolean ("config.textmenu", opts->menu == OPTVAL_PC);
 	res_PutBoolean ("config.textgradients", opts->text == OPTVAL_PC);
 	res_PutBoolean ("config.iconicscan", opts->cscan == OPTVAL_3DO);
 	res_PutBoolean ("config.smoothscroll", opts->scroll == OPTVAL_3DO);
-
+	
 	res_PutBoolean ("config.3domusic", opts->music3do == OPTVAL_ENABLED);
 	res_PutBoolean ("config.remixmusic", opts->musicremix == OPTVAL_ENABLED);
 	res_PutBoolean ("config.3domovies", opts->intro == OPTVAL_3DO);
@@ -1331,36 +1527,36 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	res_PutBoolean ("config.pulseshield", opts->shield == OPTVAL_3DO);
 	res_PutInteger ("config.player1control", opts->player1);
 	res_PutInteger ("config.player2control", opts->player2);
-
+	
 	switch (opts->adriver) {
-	case OPTVAL_SILENCE:
-		res_PutString ("config.audiodriver", "none");
-		break;
-	case OPTVAL_MIXSDL:
-		res_PutString ("config.audiodriver", "mixsdl");
-		break;
-	case OPTVAL_OPENAL:
-		res_PutString ("config.audiodriver", "openal");
-	default:
-		/* Shouldn't happen; leave config untouched */
-		break;
+		case OPTVAL_SILENCE:
+			res_PutString ("config.audiodriver", "none");
+			break;
+		case OPTVAL_MIXSDL:
+			res_PutString ("config.audiodriver", "mixsdl");
+			break;
+		case OPTVAL_OPENAL:
+			res_PutString ("config.audiodriver", "openal");
+		default:
+			/* Shouldn't happen; leave config untouched */
+			break;
 	}
-
+	
 	switch (opts->aquality) {
-	case OPTVAL_LOW:
-		res_PutString ("config.audioquality", "low");
-		break;
-	case OPTVAL_MEDIUM:
-		res_PutString ("config.audioquality", "medium");
-		break;
-	case OPTVAL_HIGH:
-		res_PutString ("config.audioquality", "high");
-		break;
-	default:
-		/* Shouldn't happen; leave config untouched */
-		break;
+		case OPTVAL_LOW:
+			res_PutString ("config.audioquality", "low");
+			break;
+		case OPTVAL_MEDIUM:
+			res_PutString ("config.audioquality", "medium");
+			break;
+		case OPTVAL_HIGH:
+			res_PutString ("config.audioquality", "high");
+			break;
+		default:
+			/* Shouldn't happen; leave config untouched */
+			break;
 	}
-
+	
 	res_PutInteger ("config.musicvol", opts->musicvol);
 	res_PutInteger ("config.sfxvol", opts->sfxvol);
 	res_PutInteger ("config.speechvol", opts->speechvol);
@@ -1370,14 +1566,14 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	// update actual volumes
 	SetMusicVolume (musicVolume);
 	SetSpeechVolume (speechVolumeScale);
-
+	
 	res_PutString ("keys.1.name", input_templates[0].name);
 	res_PutString ("keys.2.name", input_templates[1].name);
 	res_PutString ("keys.3.name", input_templates[2].name);
 	res_PutString ("keys.4.name", input_templates[3].name);
 	res_PutString ("keys.5.name", input_templates[4].name);
 	res_PutString ("keys.6.name", input_templates[5].name);
-
+	
 	SaveResourceIndex (configDir, "uqm.cfg", "config.", TRUE);
 	SaveKeyConfiguration (configDir, "flight.cfg");
 }
diff -ruNp ./src.orig/uqm/setupmenu.h ./src/uqm/setupmenu.h
--- ./src.orig/uqm/setupmenu.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/setupmenu.h	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged resolution Factor stuff from P6014.
+
 #ifndef _SETUPMENU_H
 #define _SETUPMENU_H
 
@@ -42,13 +44,18 @@ typedef enum {
 
 typedef enum {
 	OPTVAL_320_240,
-	OPTVAL_640_480,
-	OPTVAL_800_600,
-	OPTVAL_1024_768,
-	OPTVAL_CUSTOM
+	OPTVAL_REAL_640_480, // JMS_GFX
+	OPTVAL_REAL_1280_960, // JMS_GFX
 } OPT_RESTYPE;
 
 typedef enum {
+	NO_BLOWUP,
+	OPTVAL_320_TO_640,
+	OPTVAL_320_TO_800,
+	OPTVAL_320_TO_1024,
+} OPT_LORESBLOWUPTYPE;
+
+typedef enum {
 	OPTVAL_PURE_IF_POSSIBLE,
 	OPTVAL_ALWAYS_GL
 } OPT_DRIVERTYPE;
@@ -71,6 +78,7 @@ typedef enum {
 typedef struct globalopts_struct {
 	OPT_SCALETYPE scaler;
 	OPT_RESTYPE res;
+	OPT_LORESBLOWUPTYPE loresBlowup;
 	OPT_DRIVERTYPE driver;
 	OPT_ADRIVERTYPE adriver;
 	OPT_AQUALITYTYPE aquality;
@@ -78,6 +86,7 @@ typedef struct globalopts_struct {
 	OPT_CONSOLETYPE menu, text, cscan, scroll, intro, meleezoom, shield;
 	CONTROL_TEMPLATE player1, player2;
 	int speechvol, musicvol, sfxvol;
+	BOOLEAN mainmenuMusic, mineralSubmenu, nebulae, rotatingIpPlanets, texturedIpPlanets, cheatMode; // JMS
 } GLOBALOPTS;
 
 void SetupMenu (void);
diff -ruNp ./src.orig/uqm/ship.c ./src/uqm/ship.c
--- ./src.orig/uqm/ship.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/ship.c	2017-10-23 11:41:34 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "ship.h"
 
 #include "build.h"
@@ -55,7 +57,7 @@ animation_preprocess (ELEMENT *ElementPt
 STATUS_FLAGS
 inertial_thrust (ELEMENT *ElementPtr)
 {
-#define MAX_ALLOWED_SPEED     WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (18))
+#define MAX_ALLOWED_SPEED     WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (18 << RESOLUTION_FACTOR)) // JMS_GFX
 #define MAX_ALLOWED_SPEED_SQR ((DWORD)MAX_ALLOWED_SPEED * MAX_ALLOWED_SPEED)
 
 	COUNT CurrentAngle, TravelAngle;
@@ -186,7 +188,7 @@ ship_preprocess (ELEMENT *ElementPtr)
 		{
 			CONTEXT OldContext;
 
-			InitShipStatus (&RDPtr->ship_info, StarShipPtr, NULL);
+			InitShipStatus (&RDPtr->ship_info, StarShipPtr, NULL, FALSE);
 			OldContext = SetContext (StatusContext);
 			DrawCaptainsWindow (StarShipPtr);
 			SetContext (OldContext);
diff -ruNp ./src.orig/uqm/shipcont.h ./src/uqm/shipcont.h
--- ./src.orig/uqm/shipcont.h	2017-10-23 11:42:16 -0700
+++ ./src/uqm/shipcont.h	2017-10-23 11:41:34 -0700
@@ -16,12 +16,14 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef _SHIPCONT_H
 #define _SHIPCONT_H
 
 #include "menustat.h"
 
-#define FIELD_WIDTH (STATUS_WIDTH - 5)
+#define FIELD_WIDTH (STATUS_WIDTH - RES_CASE(5,5,7)) // JMS_GFX
 
 extern void CargoMenu (void);
 extern BOOLEAN RosterMenu (void);
diff -ruNp ./src.orig/uqm/ships/androsyn/androsyn.c ./src/uqm/ships/androsyn/androsyn.c
--- ./src.orig/uqm/ships/androsyn/androsyn.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/ships/androsyn/androsyn.c	2017-10-23 11:41:34 -0700
@@ -52,7 +52,6 @@ static RACE_DESC androsynth_desc =
 	},
 	{ /* FLEET_STUFF */
 		INFINITE_RADIUS, /* Initial sphere of influence radius */
-				// XXX: Why infinite radius? Bug?
 		{ /* Known location (center of SoI) */
 			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
 		},
@@ -110,6 +109,156 @@ static RACE_DESC androsynth_desc =
 	0, /* CodeRef */
 };
 
+#define MAX_THRUST_2XRES 48  // JMS_GFX
+#define THRUST_INCREMENT_2XRES 6 // JMS_GFX
+
+ // JMS_GFX
+static RACE_DESC androsynth_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON,
+		15, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ANDROSYNTH_RACE_STRINGS,
+		ANDROSYNTH_ICON_MASK_PMAP_ANIM,
+		ANDROSYNTH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ANDROSYNTH_BIG_MASK_PMAP_ANIM,
+			ANDROSYNTH_MED_MASK_PMAP_ANIM,
+			ANDROSYNTH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUBBLE_BIG_MASK_PMAP_ANIM,
+			BUBBLE_MED_MASK_PMAP_ANIM,
+			BUBBLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BLAZER_BIG_MASK_PMAP_ANIM,
+			BLAZER_MED_MASK_PMAP_ANIM,
+			BLAZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ANDROSYNTH_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ANDROSYNTH_VICTORY_SONG,
+		ANDROSYNTH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_2XRES >> 2,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MAX_THRUST_4XRES 96  // JMS_GFX
+#define THRUST_INCREMENT_4XRES 12 // JMS_GFX
+
+// JMS_GFX
+static RACE_DESC androsynth_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON,
+		15, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ANDROSYNTH_RACE_STRINGS,
+		ANDROSYNTH_ICON_MASK_PMAP_ANIM,
+		ANDROSYNTH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ANDROSYNTH_BIG_MASK_PMAP_ANIM,
+			ANDROSYNTH_MED_MASK_PMAP_ANIM,
+			ANDROSYNTH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUBBLE_BIG_MASK_PMAP_ANIM,
+			BUBBLE_MED_MASK_PMAP_ANIM,
+			BUBBLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BLAZER_BIG_MASK_PMAP_ANIM,
+			BLAZER_MED_MASK_PMAP_ANIM,
+			BLAZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ANDROSYNTH_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ANDROSYNTH_VICTORY_SONG,
+		ANDROSYNTH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_4XRES >> 2,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 #define BLAZER_DAMAGE 3
 #define BLAZER_MASS 1
 
@@ -117,11 +266,11 @@ static void
 blazer_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
 {
-#define BLAZER_OFFSET 10
+#define BLAZER_OFFSET (10 << RESOLUTION_FACTOR) // JMS_GFX
 	BYTE old_offs;
 	COUNT old_crew_level;
 	COUNT old_life;
-
+	
 	old_crew_level = ElementPtr0->crew_level;
 	old_life = ElementPtr0->life_span;
 	old_offs = ElementPtr0->blast_offset;
@@ -132,12 +281,12 @@ blazer_collision (ELEMENT *ElementPtr0,
 	ElementPtr0->blast_offset = old_offs;
 	ElementPtr0->life_span = old_life;
 	ElementPtr0->crew_level = old_crew_level;
-
+	
 	ElementPtr0->state_flags &= ~(DISAPPEARING | NONSOLID);
 	collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 }
 
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8)
+#define MISSILE_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 bubble_preprocess (ELEMENT *ElementPtr)
@@ -188,8 +337,8 @@ bubble_preprocess (ELEMENT *ElementPtr)
 static COUNT
 initialize_bubble (ELEMENT *ShipPtr, HELEMENT BubbleArray[])
 {
-#define ANDROSYNTH_OFFSET 14
-#define MISSILE_OFFSET 3
+#define ANDROSYNTH_OFFSET (14 << RESOLUTION_FACTOR) // JMS_GFX
+#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 3
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -256,13 +405,14 @@ androsynth_intelligence (ELEMENT *ShipPt
 		if (lpEvalDesc->ObjectPtr)
 		{
 			GetElementStarShip (lpEvalDesc->ObjectPtr, &pEnemyStarShip);
+			// JMS_GFX
 			if (lpEvalDesc->which_turn <= 16
 					&& (StarShipPtr->special_counter > 0
 					|| StarShipPtr->RaceDescPtr->ship_info.energy_level < MAX_ENERGY / 3
-					|| ((WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) <= CLOSE_RANGE_WEAPON
+					|| ((WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) <= (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)
 					&& lpEvalDesc->ObjectPtr->crew_level > BLAZER_DAMAGE)
 					|| (lpEvalDesc->ObjectPtr->crew_level > (BLAZER_DAMAGE * 3)
-					&& MANEUVERABILITY (&pEnemyStarShip->RaceDescPtr->cyborg_control) > SLOW_SHIP))))
+					&& MANEUVERABILITY (&pEnemyStarShip->RaceDescPtr->cyborg_control) > RESOLUTION_COMPENSATED(SLOW_SHIP)))))
 				lpEvalDesc->MoveState = ENTICE;
 		}
 
@@ -271,6 +421,7 @@ androsynth_intelligence (ELEMENT *ShipPt
 		if (StarShipPtr->special_counter == 0)
 		{
 			StarShipPtr->ship_input_state &= ~SPECIAL;
+			// JMS_GFX
 			if ((ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr
 					&& ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn <= 4)
 					|| (lpEvalDesc->ObjectPtr
@@ -278,11 +429,11 @@ androsynth_intelligence (ELEMENT *ShipPt
 					&& (WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) >=
 					WEAPON_RANGE (&StarShipPtr->RaceDescPtr->cyborg_control) << 1
 					|| (lpEvalDesc->which_turn < 16
-					&& (WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) > CLOSE_RANGE_WEAPON
+					&& (WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) > (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)
 					|| lpEvalDesc->ObjectPtr->crew_level <= BLAZER_DAMAGE)
 					&& (lpEvalDesc->ObjectPtr->crew_level <= (BLAZER_DAMAGE * 3)
 					|| MANEUVERABILITY (&pEnemyStarShip->RaceDescPtr->cyborg_control) <=
-					SLOW_SHIP)))))
+					RESOLUTION_COMPENSATED(SLOW_SHIP))))))
 				StarShipPtr->ship_input_state |= SPECIAL;
 		}
 
@@ -296,13 +447,13 @@ androsynth_intelligence (ELEMENT *ShipPt
 					&& lpEvalDesc->which_turn <= 12)
 			{
 				COUNT travel_facing, direction_facing;
-				SIZE delta_x, delta_y,
+				SDWORD delta_x, delta_y,
 							ship_delta_x, ship_delta_y,
 							other_delta_x, other_delta_y;
 
-				GetCurrentVelocityComponents (&ShipPtr->velocity,
+				GetCurrentVelocityComponentsSdword (&ShipPtr->velocity,
 						&ship_delta_x, &ship_delta_y);
-				GetCurrentVelocityComponents (&lpEvalDesc->ObjectPtr->velocity,
+				GetCurrentVelocityComponentsSdword (&lpEvalDesc->ObjectPtr->velocity,
 						&other_delta_x, &other_delta_y);
 				delta_x = ship_delta_x - other_delta_x;
 				delta_y = ship_delta_y - other_delta_y;
@@ -441,7 +592,7 @@ androsynth_preprocess (ELEMENT *ElementP
 				--ElementPtr->thrust_wait;
 			else
 			{
-#define BLAZER_THRUST 60
+#define BLAZER_THRUST (60 << RESOLUTION_FACTOR) // JMS_GFX
 				COUNT facing;
 
 				facing = StarShipPtr->ShipFacing;
@@ -468,12 +619,31 @@ init_androsynth (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	androsynth_desc.preprocess_func = androsynth_preprocess;
-	androsynth_desc.postprocess_func = androsynth_postprocess;
-	androsynth_desc.init_weapon_func = initialize_bubble;
-	androsynth_desc.cyborg_control.intelligence_func = androsynth_intelligence;
-
-	RaceDescPtr = &androsynth_desc;
+	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res modes.
+	if (RESOLUTION_FACTOR == 0)
+	{
+		androsynth_desc.preprocess_func = androsynth_preprocess;
+		androsynth_desc.postprocess_func = androsynth_postprocess;
+		androsynth_desc.init_weapon_func = initialize_bubble;
+		androsynth_desc.cyborg_control.intelligence_func = androsynth_intelligence;
+		RaceDescPtr = &androsynth_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		androsynth_desc_2xres.preprocess_func = androsynth_preprocess;
+		androsynth_desc_2xres.postprocess_func = androsynth_postprocess;
+		androsynth_desc_2xres.init_weapon_func = initialize_bubble;
+		androsynth_desc_2xres.cyborg_control.intelligence_func = androsynth_intelligence;
+		RaceDescPtr = &androsynth_desc_2xres;
+	}
+	else
+	{
+		androsynth_desc_4xres.preprocess_func = androsynth_preprocess;
+		androsynth_desc_4xres.postprocess_func = androsynth_postprocess;
+		androsynth_desc_4xres.init_weapon_func = initialize_bubble;
+		androsynth_desc_4xres.cyborg_control.intelligence_func = androsynth_intelligence;
+		RaceDescPtr = &androsynth_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/arilou/arilou.c ./src/uqm/ships/arilou/arilou.c
--- ./src.orig/uqm/ships/arilou/arilou.c	2017-10-23 11:42:16 -0700
+++ ./src/uqm/ships/arilou/arilou.c	2017-10-23 11:41:35 -0700
@@ -111,6 +111,162 @@ static RACE_DESC arilou_desc =
 	0, /* CodeRef */
 };
 
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (20) */ 80					// JMS_GFX
+#define THRUST_INCREMENT_2XRES MAX_THRUST_2XRES							// JMS_GFX
+#define ARILOU_OFFSET_2XRES 18											// JMS_GFX
+#define LASER_RANGE_2XRES DISPLAY_TO_WORLD (200 + ARILOU_OFFSET_2XRES)	// JMS_GFX
+
+// JMS_GFX
+static RACE_DESC arilou_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		/* FIRES_FORE | */ IMMEDIATE_WEAPON,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ARILOU_RACE_STRINGS,
+		ARILOU_ICON_MASK_PMAP_ANIM,
+		ARILOU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			438, 6372,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ARILOU_BIG_MASK_PMAP_ANIM,
+			ARILOU_MED_MASK_PMAP_ANIM,
+			ARILOU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			WARP_BIG_MASK_PMAP_ANIM,
+			WARP_MED_MASK_PMAP_ANIM,
+			WARP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ARILOU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ARILOU_VICTORY_SONG,
+		ARILOU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LASER_RANGE_2XRES >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (20) */ 160				// JMS_GFX
+#define THRUST_INCREMENT_4XRES MAX_THRUST_4XRES							// JMS_GFX
+#define ARILOU_OFFSET_4XRES 36											// JMS_GFX
+#define LASER_RANGE_4XRES DISPLAY_TO_WORLD (400 + ARILOU_OFFSET_4XRES)	// JMS_GFX
+
+// JMS_GFX
+static RACE_DESC arilou_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		/* FIRES_FORE | */ IMMEDIATE_WEAPON,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ARILOU_RACE_STRINGS,
+		ARILOU_ICON_MASK_PMAP_ANIM,
+		ARILOU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			438, 6372,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ARILOU_BIG_MASK_PMAP_ANIM,
+			ARILOU_MED_MASK_PMAP_ANIM,
+			ARILOU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			WARP_BIG_MASK_PMAP_ANIM,
+			WARP_MED_MASK_PMAP_ANIM,
+			WARP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ARILOU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ARILOU_VICTORY_SONG,
+		ARILOU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LASER_RANGE_4XRES >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+
+
 static COUNT
 initialize_autoaim_laser (ELEMENT *ShipPtr, HELEMENT LaserArray[])
 {
@@ -118,6 +274,16 @@ initialize_autoaim_laser (ELEMENT *ShipP
 	SIZE delta_facing;
 	STARSHIP *StarShipPtr;
 	LASER_BLOCK LaserBlock;
+	
+	COUNT laser_range_resscaled; // JMS_GFX
+	
+	// JMS_GFX
+	if (RESOLUTION_FACTOR == 0)
+		laser_range_resscaled = LASER_RANGE;
+	else if (RESOLUTION_FACTOR == 1)
+		laser_range_resscaled = LASER_RANGE_2XRES;
+	else
+		laser_range_resscaled = LASER_RANGE_4XRES;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	LaserBlock.face = orig_facing = StarShipPtr->ShipFacing;
@@ -127,11 +293,11 @@ initialize_autoaim_laser (ELEMENT *ShipP
 
 	LaserBlock.cx = ShipPtr->next.location.x;
 	LaserBlock.cy = ShipPtr->next.location.y;
-	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
-	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
+	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), laser_range_resscaled);
+	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), laser_range_resscaled);
 	LaserBlock.sender = ShipPtr->playerNr;
 	LaserBlock.flags = IGNORE_SIMILAR;
-	LaserBlock.pixoffs = ARILOU_OFFSET;
+	LaserBlock.pixoffs = ARILOU_OFFSET << RESOLUTION_FACTOR; // JMS_GFX
 	LaserBlock.color = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x0A), 0x0E);
 	LaserArray[0] = initialize_laser (&LaserBlock);
 
@@ -147,7 +313,7 @@ arilou_intelligence (ELEMENT *ShipPtr, E
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	StarShipPtr->ship_input_state |= THRUST;
 
-	 ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = ENTICE;
+	ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = ENTICE;
 	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 
 	if (StarShipPtr->special_counter == 0)
@@ -176,10 +342,10 @@ arilou_intelligence (ELEMENT *ShipPtr, E
 				IsTrackingWeapon = FALSE;
 
 			if (((lpEvalDesc->ObjectPtr->state_flags & PLAYER_SHIP) /* means IMMEDIATE WEAPON */
-					|| (IsTrackingWeapon && (lpEvalDesc->which_turn == 1
-					|| (lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT))) /* FIGHTERS!!! */
-					|| PlotIntercept (lpEvalDesc->ObjectPtr, ShipPtr, 3, 0))
-					&& !(TFB_Random () & 3))
+				 || (IsTrackingWeapon && (lpEvalDesc->which_turn == 1
+										  || (lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT))) /* FIGHTERS!!! */
+				 || PlotIntercept (lpEvalDesc->ObjectPtr, ShipPtr, 3, 0))
+				&& !(TFB_Random () & 3))
 			{
 				StarShipPtr->ship_input_state &= ~(LEFT | RIGHT | THRUST | WEAPON);
 				StarShipPtr->ship_input_state |= SPECIAL;
@@ -289,12 +455,28 @@ init_arilou (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	arilou_desc.preprocess_func = arilou_preprocess;
-	arilou_desc.init_weapon_func = initialize_autoaim_laser;
-	arilou_desc.cyborg_control.intelligence_func = arilou_intelligence;
-
-	RaceDescPtr = &arilou_desc;
-
+	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
+	if (RESOLUTION_FACTOR == 0)
+	{
+		arilou_desc.preprocess_func = arilou_preprocess;
+		arilou_desc.init_weapon_func = initialize_autoaim_laser;
+		arilou_desc.cyborg_control.intelligence_func = arilou_intelligence;
+		RaceDescPtr = &arilou_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		arilou_desc_2xres.preprocess_func = arilou_preprocess;
+		arilou_desc_2xres.init_weapon_func = initialize_autoaim_laser;
+		arilou_desc_2xres.cyborg_control.intelligence_func = arilou_intelligence;
+		RaceDescPtr = &arilou_desc_2xres;
+	}
+	else
+	{
+		arilou_desc_4xres.preprocess_func = arilou_preprocess;
+		arilou_desc_4xres.init_weapon_func = initialize_autoaim_laser;
+		arilou_desc_4xres.cyborg_control.intelligence_func = arilou_intelligence;
+		RaceDescPtr = &arilou_desc_4xres;
+	}
 	return (RaceDescPtr);
 }
 
diff -ruNp ./src.orig/uqm/ships/blackurq/blackurq.c ./src/uqm/ships/blackurq/blackurq.c
--- ./src.orig/uqm/ships/blackurq/blackurq.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/blackurq/blackurq.c	2017-10-23 11:41:35 -0700
@@ -22,6 +22,7 @@
 
 #include "uqm/globdata.h"
 
+//remove me -jpw
 
 #define MAX_CREW MAX_CREW_SIZE
 #define MAX_ENERGY MAX_ENERGY_SIZE
@@ -37,10 +38,8 @@
 #define SPECIAL_WAIT 9
 
 #define SHIP_MASS 10
-#define MISSILE_SPEED 64
-#define MISSILE_LIFE 64 /* actually, it's as long as you
-										 * hold the button down.
-										 */
+#define MISSILE_SPEED (64 << RESOLUTION_FACTOR) // JMS_GFX
+#define MISSILE_LIFE 64 /* actually, it's as long as you hold the button down.*/
 
 static RACE_DESC black_urquan_desc =
 {
@@ -113,6 +112,156 @@ static RACE_DESC black_urquan_desc =
 	0, /* CodeRef */
 };
 
+#define MAX_THRUST_2XRES 60			// JMS_GFX
+#define THRUST_INCREMENT_2XRES 12	// JMS_GFX
+
+// JMS_GFX
+static RACE_DESC black_urquan_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		KOHR_AH_RACE_STRINGS,
+		KOHR_AH_ICON_MASK_PMAP_ANIM,
+		KOHR_AH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			6000, 6250,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			KOHR_AH_BIG_MASK_PMAP_ANIM,
+			KOHR_AH_MED_MASK_PMAP_ANIM,
+			KOHR_AH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUZZSAW_BIG_MASK_PMAP_ANIM,
+			BUZZSAW_MED_MASK_PMAP_ANIM,
+			BUZZSAW_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GAS_BIG_MASK_PMAP_ANIM,
+			GAS_MED_MASK_PMAP_ANIM,
+			GAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			KOHR_AH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		KOHR_AH_VICTORY_SONG,
+		KOHR_AH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MAX_THRUST_4XRES 120		// JMS_GFX
+#define THRUST_INCREMENT_4XRES 24	// JMS_GFX
+
+// JMS_GFX
+static RACE_DESC black_urquan_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		KOHR_AH_RACE_STRINGS,
+		KOHR_AH_ICON_MASK_PMAP_ANIM,
+		KOHR_AH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			6000, 6250,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			KOHR_AH_BIG_MASK_PMAP_ANIM,
+			KOHR_AH_MED_MASK_PMAP_ANIM,
+			KOHR_AH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUZZSAW_BIG_MASK_PMAP_ANIM,
+			BUZZSAW_MED_MASK_PMAP_ANIM,
+			BUZZSAW_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GAS_BIG_MASK_PMAP_ANIM,
+			GAS_MED_MASK_PMAP_ANIM,
+			GAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			KOHR_AH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		KOHR_AH_VICTORY_SONG,
+		KOHR_AH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 #define SAW_RATE 0
 #define MAX_SAWS 8
 
@@ -172,8 +321,8 @@ buzztrack_preprocess (ELEMENT *ElementPt
 		}
 		else
 		{
-#define ACTIVATE_RANGE 224 /* Originally SPACE_WIDTH */
-			SIZE delta_x, delta_y;
+#define ACTIVATE_RANGE (224 << RESOLUTION_FACTOR) /* Originally SPACE_WIDTH */ // JMS_GFX
+			SDWORD delta_x, delta_y;
 			ELEMENT *eptr;
 
 			LockElement (ElementPtr->hTarget, &eptr);
@@ -206,7 +355,7 @@ buzztrack_preprocess (ELEMENT *ElementPt
 			{
 				ElementPtr->thrust_wait = TRACK_WAIT;
 				SetVelocityVector (&ElementPtr->velocity,
-						DISPLAY_TO_WORLD (2), facing);
+						DISPLAY_TO_WORLD (2 << RESOLUTION_FACTOR), facing); // JMS_GFX
 			}
 		}
 	}
@@ -217,9 +366,9 @@ buzztrack_preprocess (ELEMENT *ElementPt
 static void
 decelerate_preprocess (ELEMENT *ElementPtr)
 {
-	SIZE dx, dy;
+	SDWORD dx, dy;
 
-	GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+	GetCurrentVelocityComponentsSdword (&ElementPtr->velocity, &dx, &dy);
 	dx /= 2;
 	dy /= 2;
 	SetVelocityComponents (&ElementPtr->velocity, dx, dy);
@@ -234,8 +383,7 @@ decelerate_preprocess (ELEMENT *ElementP
 static void
 splinter_preprocess (ELEMENT *ElementPtr)
 {
-	ElementPtr->next.image.frame =
-			IncFrameIndex (ElementPtr->current.image.frame);
+	ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
 	ElementPtr->state_flags |= CHANGING;
 }
 
@@ -250,8 +398,7 @@ buzzsaw_collision (ELEMENT *ElementPtr0,
 		ElementPtr0->state_flags &= ~DISAPPEARING;
 		ElementPtr0->state_flags |= NONSOLID | CHANGING;
 		ElementPtr0->life_span = 5;
-		ElementPtr0->next.image.frame =
-				SetAbsFrameIndex (ElementPtr0->current.image.frame, 2);
+		ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->current.image.frame, 2);
 
 		ElementPtr0->preprocess_func = splinter_preprocess;
 	}
@@ -289,8 +436,7 @@ buzzsaw_postprocess (ELEMENT *ElementPtr
 		primIndex = ListElementPtr->PrimIndex;
 		*ListElementPtr = *ElementPtr;
 		ListElementPtr->PrimIndex = primIndex;
-		(GLOBAL (DisplayArray))[primIndex] =
-				(GLOBAL (DisplayArray))[ElementPtr->PrimIndex];
+		(GLOBAL (DisplayArray))[primIndex] = (GLOBAL (DisplayArray))[ElementPtr->PrimIndex];
 		ListElementPtr->current = ListElementPtr->next;
 		InitIntersectStartPoint (ListElementPtr);
 		InitIntersectEndPoint (ListElementPtr);
@@ -313,8 +459,8 @@ initialize_buzzsaw (ELEMENT *ShipPtr, HE
 {
 #define MISSILE_HITS 10
 #define MISSILE_DAMAGE 4
-#define MISSILE_OFFSET 9
-#define KOHR_AH_OFFSET 28
+#define MISSILE_OFFSET (9 << RESOLUTION_FACTOR) // JMS_GFX
+#define KOHR_AH_OFFSET (28 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -327,7 +473,7 @@ initialize_buzzsaw (ELEMENT *ShipPtr, HE
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = KOHR_AH_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -356,7 +502,7 @@ black_urquan_intelligence (ELEMENT *Ship
 {
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
-
+	
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
 	if (lpEvalDesc->ObjectPtr
 			&& lpEvalDesc->MoveState == ENTICE
@@ -364,8 +510,7 @@ black_urquan_intelligence (ELEMENT *Ship
 			&& lpEvalDesc->which_turn <= 8)
 		lpEvalDesc->MoveState = PURSUE;
 
-	ship_intelligence (ShipPtr,
-			ObjectsOfConcern, ConcernCounter);
+	ship_intelligence (ShipPtr, ObjectsOfConcern, ConcernCounter);
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	StarShipPtr->ship_input_state &= ~SPECIAL;
@@ -467,11 +612,11 @@ gas_cloud_collision (ELEMENT *ElementPtr
 static void
 spawn_gas_cloud (ELEMENT *ElementPtr)
 {
-#define GAS_SPEED 16
+#define GAS_SPEED (16 << RESOLUTION_FACTOR) // JMS_GFX
 #define GAS_HITS 100
-#define GAS_OFFSET 2
+#define GAS_OFFSET (2 << RESOLUTION_FACTOR) // JMS_GFX
 #define NUM_GAS_CLOUDS 16
-	SIZE dx, dy;
+	SDWORD dx, dy;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -482,7 +627,7 @@ spawn_gas_cloud (ELEMENT *ElementPtr)
 	MissileBlock.index = 0;
 	MissileBlock.sender = ElementPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
-	MissileBlock.pixoffs = 20;
+	MissileBlock.pixoffs = 20 << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.speed = GAS_SPEED;
 	MissileBlock.hit_points = GAS_HITS;
 	MissileBlock.damage = GAS_DAMAGE;
@@ -491,7 +636,7 @@ spawn_gas_cloud (ELEMENT *ElementPtr)
 	MissileBlock.preprocess_func = gas_cloud_preprocess;
 	MissileBlock.blast_offs = GAS_OFFSET;
 
-	GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+	GetCurrentVelocityComponentsSdword (&ElementPtr->velocity, &dx, &dy);
 	for (MissileBlock.face = 0;
 			MissileBlock.face < ANGLE_TO_FACING (FULL_CIRCLE);
 			MissileBlock.face +=
@@ -554,12 +699,30 @@ init_black_urquan (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	black_urquan_desc.preprocess_func = black_urquan_preprocess;
-	black_urquan_desc.postprocess_func = black_urquan_postprocess;
-	black_urquan_desc.init_weapon_func = initialize_buzzsaw;
-	black_urquan_desc.cyborg_control.intelligence_func = black_urquan_intelligence;
-
-	RaceDescPtr = &black_urquan_desc;
-
+	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
+	if (RESOLUTION_FACTOR == 0)
+	{
+		black_urquan_desc.preprocess_func = black_urquan_preprocess;
+		black_urquan_desc.postprocess_func = black_urquan_postprocess;
+		black_urquan_desc.init_weapon_func = initialize_buzzsaw;
+		black_urquan_desc.cyborg_control.intelligence_func = black_urquan_intelligence;
+		RaceDescPtr = &black_urquan_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		black_urquan_desc_2xres.preprocess_func = black_urquan_preprocess;
+		black_urquan_desc_2xres.postprocess_func = black_urquan_postprocess;
+		black_urquan_desc_2xres.init_weapon_func = initialize_buzzsaw;
+		black_urquan_desc_2xres.cyborg_control.intelligence_func = black_urquan_intelligence;
+		RaceDescPtr = &black_urquan_desc_2xres;
+	}
+	else
+	{
+		black_urquan_desc_4xres.preprocess_func = black_urquan_preprocess;
+		black_urquan_desc_4xres.postprocess_func = black_urquan_postprocess;
+		black_urquan_desc_4xres.init_weapon_func = initialize_buzzsaw;
+		black_urquan_desc_4xres.cyborg_control.intelligence_func = black_urquan_intelligence;
+		RaceDescPtr = &black_urquan_desc_4xres;
+	}
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/chenjesu/chenjesu.c ./src/uqm/ships/chenjesu/chenjesu.c
--- ./src.orig/uqm/ships/chenjesu/chenjesu.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/chenjesu/chenjesu.c	2017-10-23 11:41:35 -0700
@@ -22,6 +22,7 @@
 
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
+#include "libs/log.h"
 
 
 #define MAX_CREW 36
@@ -40,10 +41,8 @@
 #define MAX_DOGGIES 4
 
 #define SHIP_MASS 10
-#define MISSILE_SPEED DISPLAY_TO_WORLD (16)
-#define MISSILE_LIFE 90 /* actually, it's as long as you
-										 * hold the button down.
-										 */
+#define MISSILE_SPEED DISPLAY_TO_WORLD (16 << RESOLUTION_FACTOR)
+#define MISSILE_LIFE (90) /* actually, it's as long as you hold the button down. */
 
 static RACE_DESC chenjesu_desc =
 {
@@ -116,7 +115,157 @@ static RACE_DESC chenjesu_desc =
 	0, /* CodeRef */
 };
 
-#define FRAGMENT_LIFE 10
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (14) */ 54 // JMS_GFX
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 6 // JMS_GFX
+
+// JMS_GFX
+static RACE_DESC chenjesu_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL | SEEKING_WEAPON,
+		28, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHENJESU_RACE_STRINGS,
+		CHENJESU_ICON_MASK_PMAP_ANIM,
+		CHENJESU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHENJESU_BIG_MASK_PMAP_ANIM,
+			CHENJESU_MED_MASK_PMAP_ANIM,
+			CHENJESU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPARK_BIG_MASK_PMAP_ANIM,
+			SPARK_MED_MASK_PMAP_ANIM,
+			SPARK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DOGGY_BIG_MASK_PMAP_ANIM,
+			DOGGY_MED_MASK_PMAP_ANIM,
+			DOGGY_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHENJESU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHENJESU_VICTORY_SONG,
+		CHENJESU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (28) */ 108 // JMS_GFX
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 12 // JMS_GFX
+
+// JMS_GFX
+static RACE_DESC chenjesu_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL | SEEKING_WEAPON,
+		28, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHENJESU_RACE_STRINGS,
+		CHENJESU_ICON_MASK_PMAP_ANIM,
+		CHENJESU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHENJESU_BIG_MASK_PMAP_ANIM,
+			CHENJESU_MED_MASK_PMAP_ANIM,
+			CHENJESU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPARK_BIG_MASK_PMAP_ANIM,
+			SPARK_MED_MASK_PMAP_ANIM,
+			SPARK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DOGGY_BIG_MASK_PMAP_ANIM,
+			DOGGY_MED_MASK_PMAP_ANIM,
+			DOGGY_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHENJESU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHENJESU_VICTORY_SONG,
+		CHENJESU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define FRAGMENT_LIFE (10) // JMS_GFX
 #define FRAGMENT_SPEED MISSILE_SPEED
 #define FRAGMENT_RANGE (FRAGMENT_LIFE * FRAGMENT_SPEED)
 
@@ -125,7 +274,7 @@ crystal_postprocess (ELEMENT *ElementPtr
 {
 #define FRAGMENT_HITS 1
 #define FRAGMENT_DAMAGE 2
-#define FRAGMENT_OFFSET 2
+#define FRAGMENT_OFFSET (2 << RESOLUTION_FACTOR) // JMS_GFX
 #define NUM_FRAGMENTS 8
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -138,7 +287,7 @@ crystal_postprocess (ELEMENT *ElementPtr
 	MissileBlock.sender = ElementPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = 0;
-	MissileBlock.speed = FRAGMENT_SPEED;
+	MissileBlock.speed = FRAGMENT_SPEED; // JMS_GFX
 	MissileBlock.hit_points = FRAGMENT_HITS;
 	MissileBlock.damage = FRAGMENT_DAMAGE;
 	MissileBlock.life = FRAGMENT_LIFE;
@@ -231,8 +380,10 @@ crystal_collision (ELEMENT *ElementPtr0,
 	}
 }
 
-#define DOGGY_OFFSET 18
-#define DOGGY_SPEED DISPLAY_TO_WORLD (8)
+// JMS_GFX: Let's ensure the doggy doesn't spawn on top of Chenjesu ship and die.
+#define DOGGY_OFFSET ((18 << RESOLUTION_FACTOR) + 5 * RESOLUTION_FACTOR)
+
+#define DOGGY_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 doggy_preprocess (ELEMENT *ElementPtr)
@@ -248,10 +399,8 @@ doggy_preprocess (ELEMENT *ElementPtr)
 		COUNT facing, orig_facing;
 		SIZE delta_facing;
 
-		facing = orig_facing =
-				NORMALIZE_FACING (ANGLE_TO_FACING (
-				GetVelocityTravelAngle (&ElementPtr->velocity)
-				));
+		facing = orig_facing = NORMALIZE_FACING (ANGLE_TO_FACING (GetVelocityTravelAngle (&ElementPtr->velocity)));
+		
 		if ((delta_facing = TrackShip (ElementPtr, &facing)) < 0)
 			facing = NORMALIZE_FACING (TFB_Random ());
 		else
@@ -265,8 +414,7 @@ doggy_preprocess (ELEMENT *ElementPtr)
 					ShipPtr->current.location.y -
 					ElementPtr->current.location.y)
 					));
-			delta_facing = NORMALIZE_FACING (facing -
-					GetFrameIndex (ShipPtr->current.image.frame));
+			delta_facing = NORMALIZE_FACING (facing - GetFrameIndex (ShipPtr->current.image.frame));
 			UnlockElement (ElementPtr->hTarget);
 
 			if (delta_facing > ANGLE_TO_FACING (HALF_CIRCLE - OCTANT) &&
@@ -282,8 +430,27 @@ doggy_preprocess (ELEMENT *ElementPtr)
 		}
 
 		if (facing != orig_facing)
-			SetVelocityVector (&ElementPtr->velocity,
-					DOGGY_SPEED, facing);
+			SetVelocityVector (&ElementPtr->velocity, DOGGY_SPEED, facing);
+	}
+	
+	// JMS_GFX: Doggy is animated in hi-res modes
+	if (RESOLUTION_FACTOR != 0)
+	{
+		if (ElementPtr->turn_wait > 0)
+			--ElementPtr->turn_wait;
+		else
+		{
+			if (GetFrameIndex (ElementPtr->current.image.frame) == 11)
+				ElementPtr->next.image.frame =
+					SetAbsFrameIndex (ElementPtr->current.image.frame, 0);
+			else
+				ElementPtr->next.image.frame =
+					IncFrameIndex (ElementPtr->current.image.frame);
+					
+			ElementPtr->state_flags |= CHANGING;
+
+			ElementPtr->turn_wait = 1;
+		}
 	}
 }
 
@@ -299,10 +466,16 @@ doggy_death (ELEMENT *ElementPtr)
 
 	ElementPtr->state_flags &= ~DISAPPEARING;
 	ElementPtr->state_flags |= NONSOLID | FINITE_LIFE;
-	ElementPtr->life_span = 6;
+	
+	// JMS_GFX: Doggy's dying animation starts at different frame in hi-res modes.
+	if (RESOLUTION_FACTOR != 0)
 	{
-		ElementPtr->preprocess_func = animate;
+		ElementPtr->current.image.frame = SetRelFrameIndex (
+			ElementPtr->current.image.frame, 12);
 	}
+	
+	ElementPtr->life_span = 6;
+	ElementPtr->preprocess_func = animate;
 	ElementPtr->death_func = NULL;
 	ElementPtr->collision_func = NULL;
 	ZeroVelocityComponents (&ElementPtr->velocity);
@@ -335,7 +508,7 @@ doggy_collision (ELEMENT *ElementPtr0, P
 		ElementPtr0->thrust_wait += COLLISION_THRUST_WAIT << 1;
 }
 
-#define CHENJESU_OFFSET 16
+#define CHENJESU_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 spawn_doggy (ELEMENT *ElementPtr)
@@ -376,8 +549,7 @@ spawn_doggy (ELEMENT *ElementPtr)
 		DoggyElementPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.special;
 		DoggyElementPtr->current.image.frame = StarShipPtr->RaceDescPtr->ship_data.special[0];
 
-		SetVelocityVector (&DoggyElementPtr->velocity,
-				DOGGY_SPEED, NORMALIZE_FACING (ANGLE_TO_FACING (angle)));
+		SetVelocityVector (&DoggyElementPtr->velocity, DOGGY_SPEED, NORMALIZE_FACING (ANGLE_TO_FACING (angle)));
 
 		SetElementStarShip (DoggyElementPtr, StarShipPtr);
 
@@ -395,6 +567,8 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 {
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
+	
+	static DWORD old_dist[NUM_SIDES] = {(DWORD)~0, (DWORD)~0};
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	StarShipPtr->ship_input_state &= ~SPECIAL;
@@ -403,18 +577,18 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 	if (lpEvalDesc->ObjectPtr)
 	{
 		STARSHIP *EnemyStarShipPtr;
-
+		
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
 		if ((lpEvalDesc->which_turn <= 16
 				&& MANEUVERABILITY (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) >= MEDIUM_SHIP)
+				) >= RESOLUTION_COMPENSATED(MEDIUM_SHIP)) // JMS_GFX
 				|| (MANEUVERABILITY (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) <= SLOW_SHIP
+				) <= RESOLUTION_COMPENSATED(SLOW_SHIP) // JMS_GFX
 				&& WEAPON_RANGE (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) >= LONG_RANGE_WEAPON * 3 / 4
+				) >= (LONG_RANGE_WEAPON << RESOLUTION_FACTOR) * 3 / 4 // JMS_GFX
 				&& (EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON)))
 			lpEvalDesc->MoveState = PURSUE;
 	}
@@ -449,16 +623,55 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 				if (ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr)
 				{
 					COUNT which_turn;
+					BOOLEAN crystal_would_miss = false;
 
-					if ((which_turn = PlotIntercept (CrystalPtr,
+					if (RESOLUTION_FACTOR == 0 || lpEvalDesc != &ObjectsOfConcern[ENEMY_SHIP_INDEX])
+					{
+						crystal_would_miss = ((which_turn = PlotIntercept (CrystalPtr,
+							ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
+							CrystalPtr->life_span, FRAGMENT_RANGE / 2)) == 0
+						 || (which_turn == 1
+							 && PlotIntercept (CrystalPtr,
+								ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
+								CrystalPtr->life_span, 0) == 0));
+					}
+					else
+					{
+						DWORD curr_dist = 0;
+						SDWORD dx, dy;
+						
+						dx = CrystalPtr->next.location.x - 
+								ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr->next.location.x;
+						dy = CrystalPtr->next.location.y - 
+								ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr->next.location.y;		
+					
+						curr_dist = square_root ((long)dx * dx + (long)dy * dy);
+					
+						/*which_turn = PlotIntercept (CrystalPtr,
 							ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
-							CrystalPtr->life_span,
-							FRAGMENT_RANGE / 2)) == 0
-							|| (which_turn == 1
-							&& PlotIntercept (CrystalPtr,
+							CrystalPtr->life_span, FRAGMENT_RANGE / 3);*/
+					
+						crystal_would_miss = ((PlotIntercept (CrystalPtr,
 							ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
-							CrystalPtr->life_span, 0) == 0))
+							CrystalPtr->life_span, FRAGMENT_RANGE * 8) == 0)
+							|| curr_dist > old_dist[ShipPtr->playerNr]);
+							
+						old_dist[ShipPtr->playerNr] = curr_dist;
+					}
+					
+					if (crystal_would_miss)
+					{
 						StarShipPtr->ship_input_state &= ~WEAPON;
+						old_dist[ShipPtr->playerNr] = (DWORD)~0;
+						
+						// JMS: Let's try to stop Chenjesu's stupid over-rapid firing behavior in hires modes...
+						if (RESOLUTION_FACTOR > 0 
+							&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 16
+							&& ((ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr
+								 && ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn > 8)
+								|| !(ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr)))
+							StarShipPtr->weapon_counter = 10;
+					}
 					else if (StarShipPtr->weapon_counter == 0)
 					{
 						StarShipPtr->ship_input_state |= WEAPON;
@@ -478,12 +691,54 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 			if (StarShipPtr->old_status_flags & WEAPON)
 			{
 				StarShipPtr->ship_input_state &= ~WEAPON;
+				old_dist[ShipPtr->playerNr] = (DWORD)~0;
+				
 				if (lpEvalDesc == &ObjectsOfConcern[ENEMY_WEAPON_INDEX])
 					StarShipPtr->weapon_counter = 3;
 			}
 			else if (StarShipPtr->weapon_counter == 0
 					&& ship_weapons (ShipPtr, lpEvalDesc->ObjectPtr, FRAGMENT_RANGE / 2))
-				StarShipPtr->ship_input_state |= WEAPON;
+			{
+				if (RESOLUTION_FACTOR > 0)
+				{
+					COUNT num_weapons;
+					ELEMENT Ship;
+					HELEMENT Weapon[6];
+					HELEMENT *WeaponPtr,w;
+					ELEMENT *EPtr;
+					STARSHIP *StarShipPtr2;
+					
+					Ship = *ShipPtr;
+					GetElementStarShip (&Ship, &StarShipPtr2);
+					num_weapons = (*StarShipPtr->RaceDescPtr->init_weapon_func) (ShipPtr, Weapon);
+					WeaponPtr = &Weapon[0];
+					
+					w = *WeaponPtr;
+					if (w)
+					{
+						LockElement (w, &EPtr);
+						if (EPtr->state_flags & APPEARING)
+						{
+							EPtr->next = EPtr->current;
+							InitIntersectStartPoint (EPtr);
+							InitIntersectEndPoint (EPtr);
+							InitIntersectFrame (EPtr);
+						}
+							
+						if (PlotIntercept (EPtr, lpEvalDesc->ObjectPtr, EPtr->life_span, FRAGMENT_RANGE / 2) < 80)
+						{
+							StarShipPtr->ship_input_state |= WEAPON;
+						}
+							
+						UnlockElement (w);
+						FreeElement (w);
+					}
+				}
+				else
+				{
+					StarShipPtr->ship_input_state |= WEAPON;
+				}
+			}
 		}
 	}
 
@@ -514,7 +769,7 @@ initialize_crystal (ELEMENT *ShipPtr, HE
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = CHENJESU_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -573,13 +828,32 @@ init_chenjesu (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	chenjesu_desc.preprocess_func = chenjesu_preprocess;
-	chenjesu_desc.postprocess_func = chenjesu_postprocess;
-	chenjesu_desc.init_weapon_func = initialize_crystal;
-	chenjesu_desc.cyborg_control.intelligence_func = chenjesu_intelligence;
-
-	RaceDescPtr = &chenjesu_desc;
-
+	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
+	if (RESOLUTION_FACTOR == 0)
+	{
+		chenjesu_desc.preprocess_func = chenjesu_preprocess;
+		chenjesu_desc.postprocess_func = chenjesu_postprocess;
+		chenjesu_desc.init_weapon_func = initialize_crystal;
+		chenjesu_desc.cyborg_control.intelligence_func = chenjesu_intelligence;
+		RaceDescPtr = &chenjesu_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		chenjesu_desc_2xres.preprocess_func = chenjesu_preprocess;
+		chenjesu_desc_2xres.postprocess_func = chenjesu_postprocess;
+		chenjesu_desc_2xres.init_weapon_func = initialize_crystal;
+		chenjesu_desc_2xres.cyborg_control.intelligence_func = chenjesu_intelligence;
+		RaceDescPtr = &chenjesu_desc_2xres;
+	}
+	else
+	{
+		chenjesu_desc_4xres.preprocess_func = chenjesu_preprocess;
+		chenjesu_desc_4xres.postprocess_func = chenjesu_postprocess;
+		chenjesu_desc_4xres.init_weapon_func = initialize_crystal;
+		chenjesu_desc_4xres.cyborg_control.intelligence_func = chenjesu_intelligence;
+		RaceDescPtr = &chenjesu_desc_4xres;
+	}
+	
 	return (RaceDescPtr);
 }
 
diff -ruNp ./src.orig/uqm/ships/chmmr/chmmr.c ./src/uqm/ships/chmmr/chmmr.c
--- ./src.orig/uqm/ships/chmmr/chmmr.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/chmmr/chmmr.c	2017-10-23 11:41:35 -0700
@@ -113,6 +113,158 @@ static RACE_DESC chmmr_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 14
+
+// JMS_GFX
+static RACE_DESC chmmr_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | HEAVY_POINT_DEFENSE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHMMR_RACE_STRINGS,
+		CHMMR_ICON_MASK_PMAP_ANIM,
+		CHMMR_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL//, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHMMR_BIG_MASK_PMAP_ANIM,
+			CHMMR_MED_MASK_PMAP_ANIM,
+			CHMMR_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MUZZLE_BIG_MASK_PMAP_ANIM,
+			MUZZLE_MED_MASK_PMAP_ANIM,
+			MUZZLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATELLITE_BIG_MASK_PMAP_ANIM,
+			SATELLITE_MED_MASK_PMAP_ANIM,
+			SATELLITE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHMMR_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHMMR_VICTORY_SONG,
+		CHMMR_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 28
+
+// JMS_GFX
+static RACE_DESC chmmr_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | HEAVY_POINT_DEFENSE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHMMR_RACE_STRINGS,
+		CHMMR_ICON_MASK_PMAP_ANIM,
+		CHMMR_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL//, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHMMR_BIG_MASK_PMAP_ANIM,
+			CHMMR_MED_MASK_PMAP_ANIM,
+			CHMMR_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MUZZLE_BIG_MASK_PMAP_ANIM,
+			MUZZLE_MED_MASK_PMAP_ANIM,
+			MUZZLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATELLITE_BIG_MASK_PMAP_ANIM,
+			SATELLITE_MED_MASK_PMAP_ANIM,
+			SATELLITE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHMMR_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHMMR_VICTORY_SONG,
+		CHMMR_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 animate (ELEMENT *ElementPtr)
 {
@@ -120,10 +272,8 @@ animate (ELEMENT *ElementPtr)
 		--ElementPtr->turn_wait;
 	else
 	{
-		ElementPtr->next.image.frame =
-				IncFrameIndex (ElementPtr->current.image.frame);
+		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
 		ElementPtr->state_flags |= CHANGING;
-
 		ElementPtr->turn_wait = ElementPtr->next_turn;
 	}
 }
@@ -138,21 +288,20 @@ laser_death (ELEMENT *ElementPtr)
 
 	if (StarShipPtr->hShip)
 	{
-		SIZE dx, dy;
+		SDWORD dx, dy;
 		long dist;
 		HELEMENT hIonSpots;
 		ELEMENT *ShipPtr;
 
 		LockElement (StarShipPtr->hShip, &ShipPtr);
 
-		dx = ElementPtr->current.location.x
-				- ShipPtr->current.location.x;
-		dy = ElementPtr->current.location.y
-				- ShipPtr->current.location.y;
+		dx = ElementPtr->current.location.x - ShipPtr->current.location.x;
+		dy = ElementPtr->current.location.y - ShipPtr->current.location.y;
+		
 		if (((BYTE)TFB_Random () & 0x07)
 				&& (dist = (long)dx * dx + (long)dy * dy) >=
-				(long)DISPLAY_TO_WORLD (CHMMR_OFFSET + 10)
-				* DISPLAY_TO_WORLD (CHMMR_OFFSET + 10)
+				(long)DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR) // JMS_GFX
+				* DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR) // JMS_GFX
 				&& (hIonSpots = AllocElement ()))
 		{
 			COUNT angle, magnitude;
@@ -160,16 +309,16 @@ laser_death (ELEMENT *ElementPtr)
 
 			LockElement (hIonSpots, &IonSpotsPtr);
 			IonSpotsPtr->playerNr = ElementPtr->playerNr;
-			IonSpotsPtr->state_flags = FINITE_LIFE | NONSOLID
-					| IGNORE_SIMILAR | APPEARING;
+			IonSpotsPtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR | APPEARING;
 			IonSpotsPtr->turn_wait = IonSpotsPtr->next_turn = 0;
-			IonSpotsPtr->life_span = 9;
+			IonSpotsPtr->life_span = RES_CASE(9,9,14);
+			// BW: account for the extra frames in the hires version
 
 			angle = ARCTAN (dx, dy);
 			magnitude = ((COUNT)TFB_Random ()
 					% ((square_root (dist) + 1)
-					- DISPLAY_TO_WORLD (CHMMR_OFFSET + 10)))
-					+ DISPLAY_TO_WORLD (CHMMR_OFFSET + 10);
+					- DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR))) // JMS_GFX
+					+ DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR); // JMS_GFX
 			IonSpotsPtr->current.location.x =
 					ShipPtr->current.location.x
 					+ COSINE (angle, magnitude);
@@ -187,9 +336,7 @@ laser_death (ELEMENT *ElementPtr)
 
 			SetElementStarShip (IonSpotsPtr, StarShipPtr);
 
-			SetPrimType (&(GLOBAL (DisplayArray))[
-					IonSpotsPtr->PrimIndex
-					], STAMP_PRIM);
+			SetPrimType (&(GLOBAL (DisplayArray))[IonSpotsPtr->PrimIndex], STAMP_PRIM);
 
 			UnlockElement (hIonSpots);
 			PutElement (hIonSpots);
@@ -216,15 +363,13 @@ initialize_megawatt_laser (ELEMENT *Ship
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	LaserBlock.face = StarShipPtr->ShipFacing;
-	GetFrameRect (SetAbsFrameIndex (
-			StarShipPtr->RaceDescPtr->ship_data.weapon[0], LaserBlock.face
-			), &r);
-	LaserBlock.cx = DISPLAY_ALIGN (ShipPtr->next.location.x)
-			+ DISPLAY_TO_WORLD (r.corner.x);
-	LaserBlock.cy = DISPLAY_ALIGN (ShipPtr->next.location.y)
-			+ DISPLAY_TO_WORLD (r.corner.y);
-	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
-	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
+	GetFrameRect (SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.weapon[0], LaserBlock.face), &r);
+	
+	LaserBlock.cx = DISPLAY_ALIGN (ShipPtr->next.location.x) + DISPLAY_TO_WORLD (r.corner.x);
+	LaserBlock.cy = DISPLAY_ALIGN (ShipPtr->next.location.y) + DISPLAY_TO_WORLD (r.corner.y);
+	
+	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), (LASER_RANGE << RESOLUTION_FACTOR)); // JMS_GFX
+	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), (LASER_RANGE << RESOLUTION_FACTOR)); // JMS_GFX
 	LaserBlock.sender = ShipPtr->playerNr;
 	LaserBlock.flags = IGNORE_SIMILAR;
 	LaserBlock.pixoffs = 0;
@@ -239,8 +384,7 @@ initialize_megawatt_laser (ELEMENT *Ship
 
 		LaserPtr->mass_points = 2;
 		LaserPtr->death_func = laser_death;
-		LaserPtr->turn_wait = (BYTE)((StarShipPtr->special_counter + 1)
-				% NUM_CYCLES);
+		LaserPtr->turn_wait = (BYTE)((StarShipPtr->special_counter + 1) % NUM_CYCLES);
 
 		UnlockElement (LaserArray[0]);
 	}
@@ -249,8 +393,7 @@ initialize_megawatt_laser (ELEMENT *Ship
 }
 
 static void
-chmmr_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+chmmr_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	STARSHIP *StarShipPtr;
 	EVALUATE_DESC *lpEvalDesc;
@@ -296,13 +439,11 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 		{
 			LockElement (hMuzzleFlash, &MuzzleFlashPtr);
 			MuzzleFlashPtr->playerNr = ElementPtr->playerNr;
-			MuzzleFlashPtr->state_flags = FINITE_LIFE | NONSOLID
-					| IGNORE_SIMILAR | APPEARING;
+			MuzzleFlashPtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR | APPEARING;
 			MuzzleFlashPtr->life_span = 1;
 
 			MuzzleFlashPtr->current = ElementPtr->next;
-			MuzzleFlashPtr->current.image.farray =
-					StarShipPtr->RaceDescPtr->ship_data.weapon;
+			MuzzleFlashPtr->current.image.farray = StarShipPtr->RaceDescPtr->ship_data.weapon;
 			MuzzleFlashPtr->current.image.frame = SetAbsFrameIndex (
 					StarShipPtr->RaceDescPtr->ship_data.weapon[0],
 					StarShipPtr->ShipFacing + ANGLE_TO_FACING (FULL_CIRCLE)
@@ -320,18 +461,13 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 		UnlockElement (GetTailElement ());
 	}
 
-	if ((StarShipPtr->cur_status_flags & SPECIAL)
-			&& DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
+	if ((StarShipPtr->cur_status_flags & SPECIAL) && DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 	{
 		COUNT facing;
 		ELEMENT *ShipElementPtr;
 
 		LockElement (ElementPtr->hTarget, &ShipElementPtr);
-		
-		ProcessSound (SetAbsSoundIndex (
-				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1),
-				ShipElementPtr);
-
+		ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ShipElementPtr);
 		UnlockElement (ElementPtr->hTarget);
 
 		facing = 0;
@@ -344,7 +480,7 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 			LockElement (ElementPtr->hTarget, &ShipElementPtr);
 			if (!GRAVITY_MASS (ShipElementPtr->mass_points + 1))
 			{
-				SIZE i, dx, dy;
+				SDWORD i, dx, dy;
 				COUNT angle, magnitude;
 				STARSHIP *EnemyStarShipPtr;
 				static const SIZE shadow_offs[] =
@@ -355,6 +491,22 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 					DISPLAY_TO_WORLD (8 + 9 + 11 + 14),
 					DISPLAY_TO_WORLD (8 + 9 + 11 + 14 + 18),
 				};
+				static const SIZE shadow_offs_2xres[] =
+				{
+					DISPLAY_TO_WORLD (16),
+					DISPLAY_TO_WORLD (16 + 18),
+					DISPLAY_TO_WORLD (16 + 18 + 22),
+					DISPLAY_TO_WORLD (16 + 18 + 22 + 28),
+					DISPLAY_TO_WORLD (16 + 18 + 22 + 28 + 36),
+				};
+				static const SIZE shadow_offs_4xres[] =
+				{
+					DISPLAY_TO_WORLD (32),
+					DISPLAY_TO_WORLD (32 + 36),
+					DISPLAY_TO_WORLD (32 + 36 + 44),
+					DISPLAY_TO_WORLD (32 + 36 + 44 + 56),
+					DISPLAY_TO_WORLD (32 + 36 + 44 + 56 + 72),
+				};
 				static const Color color_tab[] =
 				{
 					BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x10), 0x53),
@@ -368,33 +520,27 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 				// calculate tractor beam effect
 				angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 				dx = (ElementPtr->next.location.x
-						+ COSINE (angle, (LASER_RANGE / 3)
-						+ DISPLAY_TO_WORLD (CHMMR_OFFSET)))
+						+ COSINE (angle, ((LASER_RANGE << RESOLUTION_FACTOR) / 3) // JMS_GFX
+						+ DISPLAY_TO_WORLD (CHMMR_OFFSET << RESOLUTION_FACTOR))) // JMS_GFX
 						- ShipElementPtr->next.location.x;
 				dy = (ElementPtr->next.location.y
-						+ SINE (angle, (LASER_RANGE / 3)
-						+ DISPLAY_TO_WORLD (CHMMR_OFFSET)))
+						+ SINE (angle, ((LASER_RANGE << RESOLUTION_FACTOR) / 3) // JMS_GFX
+						+ DISPLAY_TO_WORLD (CHMMR_OFFSET << RESOLUTION_FACTOR))) // JMS_GFX
 						- ShipElementPtr->next.location.y;
 				angle = ARCTAN (dx, dy);
-				magnitude = WORLD_TO_VELOCITY (12) /
-						ShipElementPtr->mass_points;
-				DeltaVelocityComponents (&ShipElementPtr->velocity,
-						COSINE (angle, magnitude), SINE (angle, magnitude));
+				magnitude = WORLD_TO_VELOCITY (12 << RESOLUTION_FACTOR) / ShipElementPtr->mass_points; // JMS_GFX
+				DeltaVelocityComponents (&ShipElementPtr->velocity, COSINE (angle, magnitude), SINE (angle, magnitude));
 
-				GetCurrentVelocityComponents (&ShipElementPtr->velocity,
-						&dx, &dy);
+				GetCurrentVelocityComponentsSdword (&ShipElementPtr->velocity,&dx, &dy);
 				GetElementStarShip (ShipElementPtr, &EnemyStarShipPtr);
 
 				// set the effected ship's speed flags
 				current_speed = VelocitySquared (dx, dy);
-				max_speed = VelocitySquared (WORLD_TO_VELOCITY (
-						EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust),
-						0);
-				EnemyStarShipPtr->cur_status_flags &= ~(SHIP_AT_MAX_SPEED
-						| SHIP_BEYOND_MAX_SPEED);
+				max_speed = VelocitySquared (WORLD_TO_VELOCITY (EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust),0);
+				
+				EnemyStarShipPtr->cur_status_flags &= ~(SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
 				if (current_speed > max_speed)
-					EnemyStarShipPtr->cur_status_flags |= (SHIP_AT_MAX_SPEED
-							| SHIP_BEYOND_MAX_SPEED);
+					EnemyStarShipPtr->cur_status_flags |= (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
 				else if (current_speed == max_speed)
 					EnemyStarShipPtr->cur_status_flags |= SHIP_AT_MAX_SPEED;
 
@@ -407,23 +553,28 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 					if (hShadow)
 					{
 						ELEMENT *ShadowElementPtr;
+						COUNT shadow_magnitude; // JMS_GFX
+						
+						// JMS_GFX
+						if (RESOLUTION_FACTOR == 0)
+							shadow_magnitude = shadow_offs[i];
+						else if (RESOLUTION_FACTOR == 1)
+							shadow_magnitude = shadow_offs_2xres[i];
+						else
+							shadow_magnitude = shadow_offs_4xres[i];
 
 						LockElement (hShadow, &ShadowElementPtr);
 						ShadowElementPtr->playerNr = ShipElementPtr->playerNr;
-						ShadowElementPtr->state_flags = FINITE_LIFE | NONSOLID
-								| IGNORE_SIMILAR | POST_PROCESS;
+						ShadowElementPtr->state_flags = FINITE_LIFE | NONSOLID | IGNORE_SIMILAR | POST_PROCESS;
 						ShadowElementPtr->life_span = 1;
 
 						ShadowElementPtr->current = ShipElementPtr->next;
-						ShadowElementPtr->current.location.x +=
-								COSINE (angle, shadow_offs[i]);
-						ShadowElementPtr->current.location.y +=
-								SINE (angle, shadow_offs[i]);
+						ShadowElementPtr->current.location.x += COSINE (angle, shadow_magnitude); // JMS_GFX: replaced shadow_offs[i] with shadow_magnitude
+						ShadowElementPtr->current.location.y += SINE (angle, shadow_magnitude);   // JMS_GFX
 						ShadowElementPtr->next = ShadowElementPtr->current;
 
 						SetElementStarShip (ShadowElementPtr, EnemyStarShipPtr);
-						SetVelocityComponents (&ShadowElementPtr->velocity,
-								dx, dy);
+						SetVelocityComponents (&ShadowElementPtr->velocity, dx, dy);
 
 						SetPrimType (&(GLOBAL (DisplayArray))[
 								ShadowElementPtr->PrimIndex
@@ -444,7 +595,7 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 	StarShipPtr->special_counter = 0;
 }
 
-#define SATELLITE_OFFSET DISPLAY_TO_WORLD (64)
+#define SATELLITE_OFFSET DISPLAY_TO_WORLD (64 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 satellite_preprocess (ELEMENT *ElementPtr)
@@ -465,7 +616,7 @@ satellite_preprocess (ELEMENT *ElementPt
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->hShip)
 	{
-		SIZE dx, dy;
+		SDWORD dx, dy;
 		ELEMENT *ShipPtr;
 
 		StarShipPtr->RaceDescPtr->ship_info.ship_flags |= POINT_DEFENSE;
@@ -481,7 +632,7 @@ satellite_preprocess (ELEMENT *ElementPt
 		dx = WRAP_DELTA_X (dx);
 		dy = WRAP_DELTA_Y (dy);
 		if ((long)dx * dx + (long)dy * dy
-				<= DISPLAY_TO_WORLD (20L) * DISPLAY_TO_WORLD (20L))
+				<= DISPLAY_TO_WORLD (20L << RESOLUTION_FACTOR) * DISPLAY_TO_WORLD (20L << RESOLUTION_FACTOR)) // JMS_GFX
 			SetVelocityComponents (&ElementPtr->velocity,
 					WORLD_TO_VELOCITY (dx),
 					WORLD_TO_VELOCITY (dy));
@@ -491,8 +642,8 @@ satellite_preprocess (ELEMENT *ElementPt
 
 			angle = ARCTAN (dx, dy);
 			SetVelocityComponents (&ElementPtr->velocity,
-					COSINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20))),
-					SINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20))));
+					COSINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR))),
+					SINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR)))); // JMS_GFX
 		}
 
 		UnlockElement (StarShipPtr->hShip);
@@ -502,7 +653,7 @@ satellite_preprocess (ELEMENT *ElementPt
 static void
 spawn_point_defense (ELEMENT *ElementPtr)
 {
-#define DEFENSE_RANGE (UWORD)64
+#define DEFENSE_RANGE (UWORD)(64 << RESOLUTION_FACTOR) // JMS_GFX
 #define DEFENSE_WAIT 2
 	BYTE weakest;
 	UWORD best_dist;
@@ -514,7 +665,7 @@ spawn_point_defense (ELEMENT *ElementPtr
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	hBestObject = 0;
-	best_dist = DEFENSE_RANGE + 1;
+	best_dist = DEFENSE_RANGE + (1 << RESOLUTION_FACTOR); // JMS_GFX
 	weakest = 255;
 	LockElement (StarShipPtr->hShip, &ShipPtr);
 	LockElement (ElementPtr->hTarget, &SattPtr);
@@ -528,7 +679,7 @@ spawn_point_defense (ELEMENT *ElementPtr
 				&& CollisionPossible (ObjectPtr, ShipPtr)
 				&& !OBJECT_CLOAKED (ObjectPtr))
 		{
-			SIZE delta_x, delta_y;
+			SDWORD delta_x, delta_y;
 			UWORD dist;
 
 			delta_x = ObjectPtr->next.location.x
@@ -773,12 +924,31 @@ init_chmmr (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	chmmr_desc.preprocess_func = chmmr_preprocess;
-	chmmr_desc.postprocess_func = chmmr_postprocess;
-	chmmr_desc.init_weapon_func = initialize_megawatt_laser;
-	chmmr_desc.cyborg_control.intelligence_func = chmmr_intelligence;
-
-	RaceDescPtr = &chmmr_desc;
+	// JMS_GFX: A rather clumsy way of giving ship correct stats at hi-res mode
+	if (RESOLUTION_FACTOR == 0)
+	{
+		chmmr_desc.preprocess_func = chmmr_preprocess;
+		chmmr_desc.postprocess_func = chmmr_postprocess;
+		chmmr_desc.init_weapon_func = initialize_megawatt_laser;
+		chmmr_desc.cyborg_control.intelligence_func = chmmr_intelligence;
+		RaceDescPtr = &chmmr_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		chmmr_desc_2xres.preprocess_func = chmmr_preprocess;
+		chmmr_desc_2xres.postprocess_func = chmmr_postprocess;
+		chmmr_desc_2xres.init_weapon_func = initialize_megawatt_laser;
+		chmmr_desc_2xres.cyborg_control.intelligence_func = chmmr_intelligence;
+		RaceDescPtr = &chmmr_desc_2xres;
+	}
+	else
+	{
+		chmmr_desc_4xres.preprocess_func = chmmr_preprocess;
+		chmmr_desc_4xres.postprocess_func = chmmr_postprocess;
+		chmmr_desc_4xres.init_weapon_func = initialize_megawatt_laser;
+		chmmr_desc_4xres.cyborg_control.intelligence_func = chmmr_intelligence;
+		RaceDescPtr = &chmmr_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/druuge/druuge.c ./src/uqm/ships/druuge/druuge.c
--- ./src.orig/uqm/ships/druuge/druuge.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/druuge/druuge.c	2017-10-23 11:41:35 -0700
@@ -109,7 +109,163 @@ static RACE_DESC druuge_desc =
 	0, /* CodeRef */
 };
 
-#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (6))
+// JMS_GFX
+#define MAX_THRUST_2XRES 40
+#define THRUST_INCREMENT_2XRES 4
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC druuge_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		DRUUGE_RACE_STRINGS,
+		DRUUGE_ICON_MASK_PMAP_ANIM,
+		DRUUGE_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9500, 2792,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			DRUUGE_BIG_MASK_PMAP_ANIM,
+			DRUUGE_MED_MASK_PMAP_ANIM,
+			DRUUGE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DRUUGE_CANNON_BIG_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_MED_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			DRUUGE_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		DRUUGE_VICTORY_SONG,
+		DRUUGE_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 80
+#define THRUST_INCREMENT_4XRES 8
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_4XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC druuge_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		DRUUGE_RACE_STRINGS,
+		DRUUGE_ICON_MASK_PMAP_ANIM,
+		DRUUGE_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9500, 2792,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			DRUUGE_BIG_MASK_PMAP_ANIM,
+			DRUUGE_MED_MASK_PMAP_ANIM,
+			DRUUGE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DRUUGE_CANNON_BIG_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_MED_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			DRUUGE_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		DRUUGE_VICTORY_SONG,
+		DRUUGE_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (6 << RESOLUTION_FACTOR)) // JMS_GFX
 #define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
 
 static void
@@ -123,12 +279,11 @@ cannon_collision (ELEMENT *ElementPtr0,
 			&& !GRAVITY_MASS (ElementPtr1->mass_points + 1))
 	{
 		COUNT angle;
-		SIZE cur_delta_x, cur_delta_y;
+		SDWORD cur_delta_x, cur_delta_y;
 		STARSHIP *StarShipPtr;
 
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
-		StarShipPtr->cur_status_flags &=
-				~(SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
+		StarShipPtr->cur_status_flags &= ~(SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED);
 
 		angle = FACING_TO_ANGLE (
 				GetFrameIndex (ElementPtr0->next.image.frame)
@@ -136,7 +291,7 @@ cannon_collision (ELEMENT *ElementPtr0,
 		DeltaVelocityComponents (&ElementPtr1->velocity,
 				COSINE (angle, RECOIL_VELOCITY),
 				SINE (angle, RECOIL_VELOCITY));
-		GetCurrentVelocityComponents (&ElementPtr1->velocity,
+		GetCurrentVelocityComponentsSdword (&ElementPtr1->velocity,
 				&cur_delta_x, &cur_delta_y);
 		if ((long)cur_delta_x * (long)cur_delta_x
 				+ (long)cur_delta_y * (long)cur_delta_y
@@ -153,8 +308,8 @@ cannon_collision (ELEMENT *ElementPtr0,
 static COUNT
 initialize_cannon (ELEMENT *ShipPtr, HELEMENT CannonArray[])
 {
-#define DRUUGE_OFFSET 24
-#define MISSILE_OFFSET 6
+#define DRUUGE_OFFSET (24 << RESOLUTION_FACTOR) // JMS_GFX
+#define MISSILE_OFFSET (6 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 4
 #define MISSILE_DAMAGE 6
 	STARSHIP *StarShipPtr;
@@ -169,7 +324,7 @@ initialize_cannon (ELEMENT *ShipPtr, HEL
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = DRUUGE_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = (MISSILE_SPEED << RESOLUTION_FACTOR); // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -204,7 +359,7 @@ druuge_intelligence (ELEMENT *ShipPtr, E
 	if (StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED)
 		lpEvalDesc->MoveState = ENTICE;
 	else if (lpEvalDesc->ObjectPtr
-			&& lpEvalDesc->which_turn <= WORLD_TO_TURN (MISSILE_RANGE * 3 / 4))
+			 && lpEvalDesc->which_turn <= (WORLD_TO_TURN ((MISSILE_RANGE << RESOLUTION_FACTOR) * 3 / 4)) >> RESOLUTION_FACTOR) // JMS_GFX
 	{
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
 		ship_flags = EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags;
@@ -254,7 +409,7 @@ druuge_postprocess (ELEMENT *ElementPtr)
 			StarShipPtr->RaceDescPtr->characteristics.weapon_wait)
 	{
 		COUNT angle;
-		SIZE cur_delta_x, cur_delta_y;
+		SDWORD cur_delta_x, cur_delta_y;
 
 		StarShipPtr->cur_status_flags &= ~SHIP_AT_MAX_SPEED;
 
@@ -262,7 +417,7 @@ druuge_postprocess (ELEMENT *ElementPtr)
 		DeltaVelocityComponents (&ElementPtr->velocity,
 				COSINE (angle, RECOIL_VELOCITY),
 				SINE (angle, RECOIL_VELOCITY));
-		GetCurrentVelocityComponents (&ElementPtr->velocity,
+		GetCurrentVelocityComponentsSdword (&ElementPtr->velocity,
 				&cur_delta_x, &cur_delta_y);
 		if ((long)cur_delta_x * (long)cur_delta_x
 				+ (long)cur_delta_y * (long)cur_delta_y
@@ -309,12 +464,30 @@ init_druuge (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	druuge_desc.preprocess_func = druuge_preprocess;
-	druuge_desc.postprocess_func = druuge_postprocess;
-	druuge_desc.init_weapon_func = initialize_cannon;
-	druuge_desc.cyborg_control.intelligence_func = druuge_intelligence;
-
-	RaceDescPtr = &druuge_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		druuge_desc.preprocess_func = druuge_preprocess;
+		druuge_desc.postprocess_func = druuge_postprocess;
+		druuge_desc.init_weapon_func = initialize_cannon;
+		druuge_desc.cyborg_control.intelligence_func = druuge_intelligence;
+		RaceDescPtr = &druuge_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		druuge_desc_2xres.preprocess_func = druuge_preprocess;
+		druuge_desc_2xres.postprocess_func = druuge_postprocess;
+		druuge_desc_2xres.init_weapon_func = initialize_cannon;
+		druuge_desc_2xres.cyborg_control.intelligence_func = druuge_intelligence;
+		RaceDescPtr = &druuge_desc_2xres;
+	}
+	else
+	{
+		druuge_desc_4xres.preprocess_func = druuge_preprocess;
+		druuge_desc_4xres.postprocess_func = druuge_postprocess;
+		druuge_desc_4xres.init_weapon_func = initialize_cannon;
+		druuge_desc_4xres.cyborg_control.intelligence_func = druuge_intelligence;
+		RaceDescPtr = &druuge_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/human/human.c ./src/uqm/ships/human/human.c
--- ./src.orig/uqm/ships/human/human.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/human/human.c	2017-10-23 11:41:35 -0700
@@ -39,8 +39,8 @@
 
 #define SHIP_MASS 6
 #define MISSILE_LIFE 60
-#define MIN_MISSILE_SPEED DISPLAY_TO_WORLD (10)
-#define MAX_MISSILE_SPEED DISPLAY_TO_WORLD (20)
+#define MIN_MISSILE_SPEED DISPLAY_TO_WORLD (10 << RESOLUTION_FACTOR) // JMS_GFX
+#define MAX_MISSILE_SPEED DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR) // JMS_GFX
 
 static RACE_DESC human_desc =
 {
@@ -113,8 +113,159 @@ static RACE_DESC human_desc =
 	0, /* CodeRef */
 };
 
-#define MISSILE_SPEED (MAX_THRUST >= MIN_MISSILE_SPEED ? \
-										MAX_THRUST : MIN_MISSILE_SPEED)
+// JMS_GFX
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (12) */ 48
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 6
+
+// JMS_GFX
+static RACE_DESC human_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON | LIGHT_POINT_DEFENSE,
+		11, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		HUMAN_RACE_STRINGS,
+		HUMAN_ICON_MASK_PMAP_ANIM,
+		HUMAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			1752, 1450,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			HUMAN_BIG_MASK_PMAP_ANIM,
+			HUMAN_MED_MASK_PMAP_ANIM,
+			HUMAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATURN_BIG_MASK_PMAP_ANIM,
+			SATURN_MED_MASK_PMAP_ANIM,
+			SATURN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			HUMAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		HUMAN_VICTORY_SONG,
+		HUMAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (24) */ 96
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 12
+
+// JMS_GFX
+static RACE_DESC human_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON | LIGHT_POINT_DEFENSE,
+		11, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		HUMAN_RACE_STRINGS,
+		HUMAN_ICON_MASK_PMAP_ANIM,
+		HUMAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			1752, 1450,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			HUMAN_BIG_MASK_PMAP_ANIM,
+			HUMAN_MED_MASK_PMAP_ANIM,
+			HUMAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATURN_BIG_MASK_PMAP_ANIM,
+			SATURN_MED_MASK_PMAP_ANIM,
+			SATURN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			HUMAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		HUMAN_VICTORY_SONG,
+		HUMAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MISSILE_SPEED ((MAX_THRUST << RESOLUTION_FACTOR) >= MIN_MISSILE_SPEED ? (MAX_THRUST << RESOLUTION_FACTOR) : MIN_MISSILE_SPEED) // JMS_GFX
 #define TRACK_WAIT 3
 
 static void
@@ -139,12 +290,10 @@ nuke_preprocess (ELEMENT *ElementPtr)
 	}
 
 	{
-		SIZE speed;
+		SDWORD speed;
 
-#define THRUST_SCALE DISPLAY_TO_WORLD (1)
-		if ((speed = MISSILE_SPEED +
-				((MISSILE_LIFE - ElementPtr->life_span) *
-				THRUST_SCALE)) > MAX_MISSILE_SPEED)
+#define THRUST_SCALE DISPLAY_TO_WORLD (1 << RESOLUTION_FACTOR) // JMS_GFX
+		if ((speed = MISSILE_SPEED + ((MISSILE_LIFE - ElementPtr->life_span) * THRUST_SCALE)) > MAX_MISSILE_SPEED)
 			speed = MAX_MISSILE_SPEED;
 		SetVelocityVector (&ElementPtr->velocity,
 				speed, facing);
@@ -196,7 +345,7 @@ spawn_point_defense (ELEMENT *ElementPtr
 			if (ObjectPtr != ShipPtr && CollidingElement (ObjectPtr) &&
 					!OBJECT_CLOAKED (ObjectPtr))
 			{
-#define LASER_RANGE (UWORD)100
+#define LASER_RANGE (UWORD)(100 << RESOLUTION_FACTOR) // JMS_GFX
 				SIZE delta_x, delta_y;
 
 				delta_x = ObjectPtr->next.location.x -
@@ -265,10 +414,10 @@ spawn_point_defense (ELEMENT *ElementPtr
 static COUNT
 initialize_nuke (ELEMENT *ShipPtr, HELEMENT NukeArray[])
 {
-#define HUMAN_OFFSET 42
+#define HUMAN_OFFSET (42 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_DAMAGE 4
 #define MISSILE_HITS 1
-#define NUKE_OFFSET 8
+#define NUKE_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -280,7 +429,7 @@ initialize_nuke (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = 0;
 	MissileBlock.pixoffs = HUMAN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -347,11 +496,27 @@ init_human (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	human_desc.postprocess_func = human_postprocess;
-	human_desc.init_weapon_func = initialize_nuke;
-	human_desc.cyborg_control.intelligence_func = human_intelligence;
-
-	RaceDescPtr = &human_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		human_desc.postprocess_func = human_postprocess;
+		human_desc.init_weapon_func = initialize_nuke;
+		human_desc.cyborg_control.intelligence_func = human_intelligence;
+		RaceDescPtr = &human_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		human_desc_2xres.postprocess_func = human_postprocess;
+		human_desc_2xres.init_weapon_func = initialize_nuke;
+		human_desc_2xres.cyborg_control.intelligence_func = human_intelligence;
+		RaceDescPtr = &human_desc_2xres;
+	}
+	else
+	{
+		human_desc_4xres.postprocess_func = human_postprocess;
+		human_desc_4xres.init_weapon_func = initialize_nuke;
+		human_desc_4xres.cyborg_control.intelligence_func = human_intelligence;
+		RaceDescPtr = &human_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/ilwrath/ilwrath.c ./src/uqm/ships/ilwrath/ilwrath.c
--- ./src.orig/uqm/ships/ilwrath/ilwrath.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/ilwrath/ilwrath.c	2017-10-23 11:41:35 -0700
@@ -111,6 +111,158 @@ static RACE_DESC ilwrath_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 50
+#define THRUST_INCREMENT_2XRES 10
+
+// JMS_GFX
+static RACE_DESC ilwrath_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ILWRATH_RACE_STRINGS,
+		ILWRATH_ICON_MASK_PMAP_ANIM,
+		ILWRATH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1410 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			48, 1700,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ILWRATH_BIG_MASK_PMAP_ANIM,
+			ILWRATH_MED_MASK_PMAP_ANIM,
+			ILWRATH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIRE_BIG_MASK_PMAP_ANIM,
+			FIRE_MED_MASK_PMAP_ANIM,
+			FIRE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			ILWRATH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ILWRATH_VICTORY_SONG,
+		ILWRATH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 100
+#define THRUST_INCREMENT_4XRES 20
+
+// JMS_GFX
+static RACE_DESC ilwrath_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ILWRATH_RACE_STRINGS,
+		ILWRATH_ICON_MASK_PMAP_ANIM,
+		ILWRATH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1410 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			48, 1700,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ILWRATH_BIG_MASK_PMAP_ANIM,
+			ILWRATH_MED_MASK_PMAP_ANIM,
+			ILWRATH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIRE_BIG_MASK_PMAP_ANIM,
+			FIRE_MED_MASK_PMAP_ANIM,
+			FIRE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			ILWRATH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ILWRATH_VICTORY_SONG,
+		ILWRATH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 flame_preprocess (ELEMENT *ElementPtr)
 {
@@ -118,10 +270,8 @@ flame_preprocess (ELEMENT *ElementPtr)
 		--ElementPtr->turn_wait;
 	else
 	{
-		ElementPtr->next.image.frame =
-				IncFrameIndex (ElementPtr->current.image.frame);
+		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
 		ElementPtr->state_flags |= CHANGING;
-
 		ElementPtr->turn_wait = ElementPtr->next_turn;
 	}
 }
@@ -136,14 +286,14 @@ flame_collision (ELEMENT *ElementPtr0, P
 }
 
 static void
-ilwrath_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+ilwrath_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
-	 lpEvalDesc->MoveState = PURSUE;
+	lpEvalDesc->MoveState = PURSUE;
+	
 	if (lpEvalDesc->ObjectPtr && lpEvalDesc->which_turn <= 10)
 				/* don't want to dodge when you could be flaming */
 		ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr = 0;
@@ -178,8 +328,8 @@ ilwrath_intelligence (ELEMENT *ShipPtr,
 static COUNT
 initialize_flame (ELEMENT *ShipPtr, HELEMENT FlameArray[])
 {
-#define ILWRATH_OFFSET 29
-#define MISSILE_SPEED MAX_THRUST
+#define ILWRATH_OFFSET (29 << RESOLUTION_FACTOR)		// JMS_GFX
+#define MISSILE_SPEED (MAX_THRUST << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 0
@@ -205,11 +355,11 @@ initialize_flame (ELEMENT *ShipPtr, HELE
 
 	if (FlameArray[0])
 	{
-		SIZE dx, dy;
+		SDWORD dx, dy;
 		ELEMENT *FlamePtr;
 
 		LockElement (FlameArray[0], &FlamePtr);
-		GetCurrentVelocityComponents (&ShipPtr->velocity, &dx, &dy);
+		GetCurrentVelocityComponentsSdword (&ShipPtr->velocity, &dx, &dy);
 		DeltaVelocityComponents (&FlamePtr->velocity, dx, dy);
 		FlamePtr->current.location.x -= VELOCITY_TO_WORLD (dx);
 		FlamePtr->current.location.y -= VELOCITY_TO_WORLD (dy);
@@ -269,8 +419,9 @@ ilwrath_preprocess (ELEMENT *ElementPtr)
 				ProcessSound (SetAbsSoundIndex (
 								/* CLOAKING_OFF */
 						StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr);
-				SetPrimColor (lpPrim,
-						BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
+				
+				SetPrimColor (lpPrim, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
+				
 				if (weapon_discharge)
 				{
 					COUNT facing;
@@ -392,11 +543,27 @@ init_ilwrath (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	ilwrath_desc.preprocess_func = ilwrath_preprocess;
-	ilwrath_desc.init_weapon_func = initialize_flame;
-	ilwrath_desc.cyborg_control.intelligence_func = ilwrath_intelligence;
-
-	RaceDescPtr = &ilwrath_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		ilwrath_desc.preprocess_func = ilwrath_preprocess;
+		ilwrath_desc.init_weapon_func = initialize_flame;
+		ilwrath_desc.cyborg_control.intelligence_func = ilwrath_intelligence;
+		RaceDescPtr = &ilwrath_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		ilwrath_desc_2xres.preprocess_func = ilwrath_preprocess;
+		ilwrath_desc_2xres.init_weapon_func = initialize_flame;
+		ilwrath_desc_2xres.cyborg_control.intelligence_func = ilwrath_intelligence;
+		RaceDescPtr = &ilwrath_desc_2xres;
+	}
+	else
+	{
+		ilwrath_desc_4xres.preprocess_func = ilwrath_preprocess;
+		ilwrath_desc_4xres.init_weapon_func = initialize_flame;
+		ilwrath_desc_4xres.cyborg_control.intelligence_func = ilwrath_intelligence;
+		RaceDescPtr = &ilwrath_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/lastbat/lastbat.c ./src/uqm/ships/lastbat/lastbat.c
--- ./src.orig/uqm/ships/lastbat/lastbat.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/lastbat/lastbat.c	2017-10-23 11:41:35 -0700
@@ -44,8 +44,8 @@
 #define SPECIAL_WAIT ((ONE_SECOND / BATTLE_FRAME_RATE) * 3)
 
 #define SHIP_MASS (MAX_SHIP_MASS * 10)
-#define SAMATRA_OFFSET 9
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8)
+#define SAMATRA_OFFSET (9 << RESOLUTION_FACTOR) // JMS_GFX
+#define MISSILE_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 
 static RACE_DESC samatra_desc =
 {
@@ -130,7 +130,7 @@ comet_preprocess (ELEMENT *ElementPtr)
 	{
 		if (frame_index == 25)
 		{
-			SIZE cur_delta_x, cur_delta_y;
+			SDWORD cur_delta_x, cur_delta_y;
 			STARSHIP *StarShipPtr;
 
 			GetElementStarShip (ElementPtr, &StarShipPtr);
@@ -138,7 +138,7 @@ comet_preprocess (ELEMENT *ElementPtr)
 			spawn_comet (ElementPtr);
 			ElementPtr->state_flags |= NONSOLID;
 
-			GetCurrentVelocityComponents (&ElementPtr->velocity,
+			GetCurrentVelocityComponentsSdword (&ElementPtr->velocity,
 					&cur_delta_x, &cur_delta_y);
 			SetVelocityComponents (&ElementPtr->velocity,
 					cur_delta_x / 2, cur_delta_y / 2);
@@ -201,7 +201,7 @@ spawn_comet (ELEMENT *ElementPtr)
 {
 #define COMET_OFFSET 0
 #define COMET_HITS 12
-#define COMET_SPEED DISPLAY_TO_WORLD (12)
+#define COMET_SPEED DISPLAY_TO_WORLD (12 << RESOLUTION_FACTOR) // JMS_GFX
 #define COMET_LIFE 2
 	MISSILE_BLOCK MissileBlock;
 	HELEMENT hComet;
@@ -500,7 +500,7 @@ sentinel_preprocess (ELEMENT *ElementPtr
 			hTarget = ElementPtr->hTarget;
 		else
 		{
-			SIZE delta_x0, delta_y0, delta_x1, delta_y1;
+			SDWORD delta_x0, delta_y0, delta_x1, delta_y1;
 			ELEMENT *ShipPtr;
 			ELEMENT *EnemyShipPtr;
 
@@ -532,7 +532,7 @@ sentinel_preprocess (ELEMENT *ElementPtr
 		if (hTarget)
 		{
 			COUNT num_frames;
-			SIZE delta_x, delta_y;
+			SDWORD delta_x, delta_y;
 			ELEMENT *TargetPtr;
 			VELOCITY_DESC TargetVelocity;
 
@@ -552,7 +552,7 @@ sentinel_preprocess (ELEMENT *ElementPtr
 				num_frames = 1;
 
 			TargetVelocity = TargetPtr->velocity;
-			GetNextVelocityComponents (&TargetVelocity,
+			GetNextVelocityComponentsSdword (&TargetVelocity,
 					&delta_x, &delta_y, num_frames);
 
 			delta_x = (TargetPtr->current.location.x + delta_x)
@@ -584,7 +584,7 @@ sentinel_preprocess (ELEMENT *ElementPtr
 	}
 }
 
-#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (10))
+#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (10 << RESOLUTION_FACTOR)) // JMS_GFX
 #define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
 
 static void
@@ -626,7 +626,7 @@ sentinel_collision (ELEMENT *ElementPtr0
 				&& ElementPtr1->crew_level
 				&& !GRAVITY_MASS (ElementPtr1->mass_points + 1))
 		{
-			SIZE cur_delta_x, cur_delta_y;
+			SDWORD cur_delta_x, cur_delta_y;
 
 			ElementPtr0->life_span = old_life;
 			ElementPtr0->hit_points = old_hits;
@@ -646,7 +646,7 @@ sentinel_collision (ELEMENT *ElementPtr0
 			DeltaVelocityComponents (&ElementPtr1->velocity,
 					COSINE (angle, RECOIL_VELOCITY),
 					SINE (angle, RECOIL_VELOCITY));
-			GetCurrentVelocityComponents (&ElementPtr1->velocity,
+			GetCurrentVelocityComponentsSdword (&ElementPtr1->velocity,
 					&cur_delta_x, &cur_delta_y);
 			if ((long)cur_delta_x * (long)cur_delta_x
 					+ (long)cur_delta_y * (long)cur_delta_y
@@ -766,17 +766,51 @@ samatra_preprocess (ELEMENT *ElementPtr)
 	else
 	{
 #define MAX_GENERATORS 8
-		POINT offs[] =
+		POINT offs_1x[] =
 		{
-			{-127-9,  -53+18},
-			{ -38-9,  -88+18},
+			{-127-9,  -53+18}, // Top left generator
+			{ -38-9,  -88+18}, // The one below the top left generator
 			{  44-9,  -85+18},
 			{ 127-9,  -60+18},
 			{ 124-9,   28+18},
 			{  73-9,   61+18},
 			{ -87-9,   58+18},
-			{-136-9,   29+18},
+			{-136-9,   29+18}, // Top right generator
 		};
+		
+		POINT offs_2x[] =
+		{
+			{-153, -116}, // Top left generator
+			{-208, -49 }, // The one below the top left generator
+			{-198,  72},
+			{-104,  132},
+			{113,   132},
+			{205,   70},
+			{220,  -44 },
+			{165,  -107}, // Top right generator
+		};
+		
+		POINT offs_4x[] =
+		{
+			{-305, -234}, // Top left generator
+			{-414, -96 }, // The one below the top left generator
+			{-396,  140},
+			{-208,  262},
+			{215,   262},
+			{410,   140},
+			{441,  -87 },
+			{329,  -214}, // Top right generator
+		};
+		
+		POINT *offs;
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 2)
+			offs = offs_4x;
+		else if (RESOLUTION_FACTOR == 1)
+			offs = offs_2x;
+		else
+			offs = offs_1x;
 
 		for (StarShipPtr->RaceDescPtr->num_generators = 0;
 				StarShipPtr->RaceDescPtr->num_generators < MAX_GENERATORS;
@@ -788,7 +822,7 @@ samatra_preprocess (ELEMENT *ElementPtr)
 			if (hGenerator)
 			{
 				ELEMENT *GeneratorPtr;
-
+				
 				LockElement (hGenerator, &GeneratorPtr);
 				GeneratorPtr->hit_points = GENERATOR_HITS;
 				GeneratorPtr->mass_points = MAX_SHIP_MASS * 10;
@@ -801,12 +835,12 @@ samatra_preprocess (ELEMENT *ElementPtr)
 						);
 				GeneratorPtr->current.location.x =
 						((LOG_SPACE_WIDTH >> 1)
-						+ DISPLAY_TO_WORLD (offs[StarShipPtr->RaceDescPtr->num_generators].x))
-						& ~((SCALED_ONE << MAX_VIS_REDUCTION) - 1);
+						+ DISPLAY_TO_WORLD ((offs[StarShipPtr->RaceDescPtr->num_generators].x)))
+						& ~((SCALED_ONE << MAX_VIS_REDUCTION) - 1); // JMS_GFX
 				GeneratorPtr->current.location.y =
 						((LOG_SPACE_HEIGHT >> 1)
-						+ DISPLAY_TO_WORLD (offs[StarShipPtr->RaceDescPtr->num_generators].y))
-						& ~((SCALED_ONE << MAX_VIS_REDUCTION) - 1);
+						+ DISPLAY_TO_WORLD ((offs[StarShipPtr->RaceDescPtr->num_generators].y)))
+						& ~((SCALED_ONE << MAX_VIS_REDUCTION) - 1); // JMS_GFX
 				GeneratorPtr->current.image.farray =
 						StarShipPtr->RaceDescPtr->ship_data.special;
 				GeneratorPtr->current.image.frame =
diff -ruNp ./src.orig/uqm/ships/melnorme/melnorme.c ./src/uqm/ships/melnorme/melnorme.c
--- ./src.orig/uqm/ships/melnorme/melnorme.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/melnorme/melnorme.c	2017-10-23 11:41:35 -0700
@@ -112,6 +112,160 @@ static RACE_DESC melnorme_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 72
+#define THRUST_INCREMENT_2XRES 12
+#define PUMPUP_SPEED_2XRES DISPLAY_TO_WORLD (90)
+
+// JMS_GFX
+static RACE_DESC melnorme_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MELNORME_RACE_STRINGS,
+		MELNORME_ICON_MASK_PMAP_ANIM,
+		MELNORME_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MELNORME_BIG_MASK_PMAP_ANIM,
+			MELNORME_MED_MASK_PMAP_ANIM,
+			MELNORME_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PUMPUP_BIG_MASK_PMAP_ANIM,
+			PUMPUP_MED_MASK_PMAP_ANIM,
+			PUMPUP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CONFUSE_BIG_MASK_PMAP_ANIM,
+			CONFUSE_MED_MASK_PMAP_ANIM,
+			CONFUSE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MELNORME_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MELNORME_VICTORY_SONG,
+		MELNORME_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		PUMPUP_SPEED_2XRES * PUMPUP_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 144
+#define THRUST_INCREMENT_4XRES 24
+#define PUMPUP_SPEED_4XRES DISPLAY_TO_WORLD (180)
+
+// JMS_GFX
+static RACE_DESC melnorme_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MELNORME_RACE_STRINGS,
+		MELNORME_ICON_MASK_PMAP_ANIM,
+		MELNORME_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MELNORME_BIG_MASK_PMAP_ANIM,
+			MELNORME_MED_MASK_PMAP_ANIM,
+			MELNORME_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PUMPUP_BIG_MASK_PMAP_ANIM,
+			PUMPUP_MED_MASK_PMAP_ANIM,
+			PUMPUP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CONFUSE_BIG_MASK_PMAP_ANIM,
+			CONFUSE_MED_MASK_PMAP_ANIM,
+			CONFUSE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MELNORME_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MELNORME_VICTORY_SONG,
+		MELNORME_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		PUMPUP_SPEED_4XRES * PUMPUP_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 #define NUM_PUMP_ANIMS 5
 #define REVERSE_DIR (BYTE)(1 << 7)
 
@@ -146,7 +300,7 @@ pump_up_preprocess (ELEMENT *ElementPtr)
 
 static COUNT initialize_pump_up (ELEMENT *ShipPtr, HELEMENT PumpUpArray[]);
 
-#define MELNORME_OFFSET 24
+#define MELNORME_OFFSET (24 << RESOLUTION_FACTOR) // JMS_GFX
 #define LEVEL_COUNTER 72
 #define MAX_PUMP 4
 #define PUMPUP_DAMAGE 2
@@ -232,8 +386,8 @@ pump_up_postprocess (ELEMENT *ElementPtr
 
 			angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 			SetVelocityComponents (&EPtr->velocity,
-					COSINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED)),
-					SINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED)));
+					COSINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED << RESOLUTION_FACTOR)), // JMS_GFX
+					SINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED << RESOLUTION_FACTOR))); // JMS_GFX
 
 			ProcessSound (SetAbsSoundIndex (
 					StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), EPtr);
@@ -474,11 +628,11 @@ confusion_collision (ELEMENT *ElementPtr
 static COUNT
 initialize_confusion (ELEMENT *ShipPtr, HELEMENT ConfusionArray[])
 {
-#define CMISSILE_SPEED DISPLAY_TO_WORLD (30)
+#define CMISSILE_SPEED DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR) // JMS_GFX
 #define CMISSILE_HITS 200
 #define CMISSILE_DAMAGE 0
 #define CMISSILE_LIFE 20
-#define CMISSILE_OFFSET 4
+#define CMISSILE_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK ConfusionBlock;
 
@@ -527,7 +681,7 @@ initialize_test_pump_up (ELEMENT *ShipPt
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = MELNORME_OFFSET;
-	MissileBlock.speed = PUMPUP_SPEED;
+	MissileBlock.speed = (PUMPUP_SPEED << RESOLUTION_FACTOR); // JMS_GFX
 	MissileBlock.hit_points = PUMPUP_DAMAGE;
 	MissileBlock.damage = PUMPUP_DAMAGE;
 	MissileBlock.life = PUMPUP_LIFE;
@@ -646,11 +800,27 @@ init_melnorme (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	melnorme_desc.postprocess_func = melnorme_postprocess;
-	melnorme_desc.init_weapon_func = initialize_pump_up;
-	melnorme_desc.cyborg_control.intelligence_func = melnorme_intelligence;
-
-	RaceDescPtr = &melnorme_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		melnorme_desc.postprocess_func = melnorme_postprocess;
+		melnorme_desc.init_weapon_func = initialize_pump_up;
+		melnorme_desc.cyborg_control.intelligence_func = melnorme_intelligence;
+		RaceDescPtr = &melnorme_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		melnorme_desc_2xres.postprocess_func = melnorme_postprocess;
+		melnorme_desc_2xres.init_weapon_func = initialize_pump_up;
+		melnorme_desc_2xres.cyborg_control.intelligence_func = melnorme_intelligence;
+		RaceDescPtr = &melnorme_desc_2xres;
+	}
+	else
+	{
+		melnorme_desc_4xres.postprocess_func = melnorme_postprocess;
+		melnorme_desc_4xres.init_weapon_func = initialize_pump_up;
+		melnorme_desc_4xres.cyborg_control.intelligence_func = melnorme_intelligence;
+		RaceDescPtr = &melnorme_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/mmrnmhrm/mmrnmhrm.c ./src/uqm/ships/mmrnmhrm/mmrnmhrm.c
--- ./src.orig/uqm/ships/mmrnmhrm/mmrnmhrm.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/mmrnmhrm/mmrnmhrm.c	2017-10-23 11:41:35 -0700
@@ -38,16 +38,16 @@
 #define YWING_WEAPON_ENERGY_COST 1
 #define YWING_SPECIAL_ENERGY_COST MAX_ENERGY
 #define YWING_ENERGY_WAIT 6
-#define YWING_MAX_THRUST 50
-#define YWING_THRUST_INCREMENT 10
+#define YWING_MAX_THRUST (50 << RESOLUTION_FACTOR) // JMS_GFX
+#define YWING_THRUST_INCREMENT (10 << RESOLUTION_FACTOR) // JMS_GFX
 #define YWING_TURN_WAIT 14
 #define YWING_THRUST_WAIT 0
 #define YWING_WEAPON_WAIT 20
 #define YWING_SPECIAL_WAIT 0
 
 #define SHIP_MASS 3
-#define MMRNMHRM_OFFSET 16
-#define LASER_RANGE DISPLAY_TO_WORLD (125 + MMRNMHRM_OFFSET)
+#define MMRNMHRM_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define LASER_RANGE DISPLAY_TO_WORLD ((125 << RESOLUTION_FACTOR) + MMRNMHRM_OFFSET) // JMS_GFX
 
 
 static RACE_DESC mmrnmhrm_desc =
@@ -121,7 +121,159 @@ static RACE_DESC mmrnmhrm_desc =
 	0, /* CodeRef */
 };
 
-#define MISSILE_SPEED DISPLAY_TO_WORLD (20)
+// JMS_GFX
+#define MAX_THRUST_2XRES 40
+#define THRUST_INCREMENT_2XRES 10
+
+// JMS_GFX
+static RACE_DESC mmrnmhrm_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		19, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MMRNMHRM_RACE_STRINGS,
+		MMRNMHRM_ICON_MASK_PMAP_ANIM,
+		MMRNMHRM_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MMRNMHRM_BIG_MASK_PMAP_ANIM,
+			MMRNMHRM_MED_MASK_PMAP_ANIM,
+			MMRNMHRM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TORP_BIG_MASK_PMAP_ANIM,
+			TORP_MED_MASK_PMAP_ANIM,
+			TORP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YWING_BIG_MASK_PMAP_ANIM,
+			YWING_MED_MASK_PMAP_ANIM,
+			YWING_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MMRNMHRM_VICTORY_SONG,
+		MMRNMHRM_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 80
+#define THRUST_INCREMENT_4XRES 20
+
+// JMS_GFX
+static RACE_DESC mmrnmhrm_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		19, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MMRNMHRM_RACE_STRINGS,
+		MMRNMHRM_ICON_MASK_PMAP_ANIM,
+		MMRNMHRM_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MMRNMHRM_BIG_MASK_PMAP_ANIM,
+			MMRNMHRM_MED_MASK_PMAP_ANIM,
+			MMRNMHRM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TORP_BIG_MASK_PMAP_ANIM,
+			TORP_MED_MASK_PMAP_ANIM,
+			TORP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YWING_BIG_MASK_PMAP_ANIM,
+			YWING_MED_MASK_PMAP_ANIM,
+			YWING_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MMRNMHRM_VICTORY_SONG,
+		MMRNMHRM_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MISSILE_SPEED DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR) // JMS_GFX
 #define TRACK_WAIT 5
 
 static void
@@ -176,10 +328,10 @@ mmrnmhrm_intelligence (ELEMENT *ShipPtr,
 			&& lpEvalDesc->ObjectPtr
 			&& !(StarShipPtr->ship_input_state & WEAPON))
 	{
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 		COUNT travel_angle, direction_angle;
 
-		GetCurrentVelocityComponents (&lpEvalDesc->ObjectPtr->velocity,
+		GetCurrentVelocityComponentsSdword (&lpEvalDesc->ObjectPtr->velocity,
 				&delta_x, &delta_y);
 		if (delta_x == 0 && delta_y == 0)
 			direction_angle = travel_angle = 0;
@@ -199,7 +351,7 @@ mmrnmhrm_intelligence (ELEMENT *ShipPtr,
 		{
 			if (lpEvalDesc->which_turn > 8)
 			{
-				if (MANEUVERABILITY (&EnemyStarShipPtr->RaceDescPtr->cyborg_control) <= SLOW_SHIP
+				if (MANEUVERABILITY (&EnemyStarShipPtr->RaceDescPtr->cyborg_control) <= RESOLUTION_COMPENSATED(SLOW_SHIP) // JMS_GFX
 						|| NORMALIZE_ANGLE (
 								direction_angle - travel_angle + QUADRANT
 								) > HALF_CIRCLE)
@@ -208,9 +360,9 @@ mmrnmhrm_intelligence (ELEMENT *ShipPtr,
 		}
 		else
 		{
-			SIZE ship_delta_x, ship_delta_y;
+			SDWORD ship_delta_x, ship_delta_y;
 
-			GetCurrentVelocityComponents (&ShipPtr->velocity,
+			GetCurrentVelocityComponentsSdword (&ShipPtr->velocity,
 					&ship_delta_x, &ship_delta_y);
 			delta_x -= ship_delta_x;
 			delta_y -= ship_delta_y;
@@ -253,10 +405,10 @@ twin_laser_collision (ELEMENT *ElementPt
 static COUNT
 initialize_dual_weapons (ELEMENT *ShipPtr, HELEMENT WeaponArray[])
 {
-#define CENTER_OFFS DISPLAY_TO_WORLD (4)
+#define CENTER_OFFS DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR) // JMS_GFX
 	COORD cx, cy;
 	COUNT facing, angle;
-	SIZE offs_x, offs_y;
+	SDWORD offs_x, offs_y;
 	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -267,7 +419,7 @@ initialize_dual_weapons (ELEMENT *ShipPt
 
 	if (ShipPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.ship)
 	{
-#define WING_OFFS DISPLAY_TO_WORLD (10)
+#define WING_OFFS DISPLAY_TO_WORLD (10 << RESOLUTION_FACTOR) // JMS_GFX
 		COORD ex, ey;
 		LASER_BLOCK LaserBlock;
 		ELEMENT *LaserPtr;
@@ -311,7 +463,7 @@ initialize_dual_weapons (ELEMENT *ShipPt
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 0
 #define MISSILE_LIFE 40
-#define LAUNCH_OFFS DISPLAY_TO_WORLD (4)
+#define LAUNCH_OFFS DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR) // JMS_GFX
 		MISSILE_BLOCK TorpBlock;
 		ELEMENT *TorpPtr;
 
@@ -373,8 +525,7 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 		StarShipPtr->weapon_counter = 0;
 
 		/* Swap characteristics descriptors around */
-		otherwing_desc = (CHARACTERISTIC_STUFF *)
-				StarShipPtr->RaceDescPtr->data;
+		otherwing_desc = (CHARACTERISTIC_STUFF *)StarShipPtr->RaceDescPtr->data;
 		t = *otherwing_desc;
 		*otherwing_desc = StarShipPtr->RaceDescPtr->characteristics;
 		StarShipPtr->RaceDescPtr->characteristics = t;
@@ -382,7 +533,7 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 
 		if (ElementPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.special)
 		{
-			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = LONG_RANGE_WEAPON - 1;
+			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = (LONG_RANGE_WEAPON - 1) << RESOLUTION_FACTOR; // JMS_GFX
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags &= ~IMMEDIATE_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags |= SEEKING_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_data.ship_sounds =
@@ -393,7 +544,7 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 		}
 		else
 		{
-			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = CLOSE_RANGE_WEAPON;
+			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR; // JMS_GFX
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags &= ~SEEKING_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags |= IMMEDIATE_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_data.ship_sounds =
@@ -420,8 +571,7 @@ mmrnmhrm_preprocess (ELEMENT *ElementPtr
 				&& StarShipPtr->special_counter == 0)
 		{
 			/* Either we transform or text will flash */
-			if (DeltaEnergy (ElementPtr,
-					-StarShipPtr->RaceDescPtr->characteristics.special_energy_cost))
+			if (DeltaEnergy (ElementPtr, -StarShipPtr->RaceDescPtr->characteristics.special_energy_cost))
 			{
 				if (ElementPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.ship)
 					ElementPtr->next.image.farray =
@@ -452,18 +602,37 @@ RACE_DESC*
 init_mmrnmhrm (void)
 {
 	RACE_DESC *RaceDescPtr;
-
 	static RACE_DESC new_mmrnmhrm_desc;
 	CHARACTERISTIC_STUFF *otherwing_desc;
-
-	mmrnmhrm_desc.uninit_func = uninit_mmrnmhrm;
-	mmrnmhrm_desc.preprocess_func = mmrnmhrm_preprocess;
-	mmrnmhrm_desc.postprocess_func = mmrnmhrm_postprocess;
-	mmrnmhrm_desc.init_weapon_func = initialize_dual_weapons;
-	mmrnmhrm_desc.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
-
-	new_mmrnmhrm_desc = mmrnmhrm_desc;
-
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		mmrnmhrm_desc.uninit_func = uninit_mmrnmhrm;
+		mmrnmhrm_desc.preprocess_func = mmrnmhrm_preprocess;
+		mmrnmhrm_desc.postprocess_func = mmrnmhrm_postprocess;
+		mmrnmhrm_desc.init_weapon_func = initialize_dual_weapons;
+		mmrnmhrm_desc.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
+		new_mmrnmhrm_desc = mmrnmhrm_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		mmrnmhrm_desc_2xres.uninit_func = uninit_mmrnmhrm;
+		mmrnmhrm_desc_2xres.preprocess_func = mmrnmhrm_preprocess;
+		mmrnmhrm_desc_2xres.postprocess_func = mmrnmhrm_postprocess;
+		mmrnmhrm_desc_2xres.init_weapon_func = initialize_dual_weapons;
+		mmrnmhrm_desc_2xres.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
+		new_mmrnmhrm_desc = mmrnmhrm_desc_2xres;
+	}
+	else
+	{
+		mmrnmhrm_desc_4xres.uninit_func = uninit_mmrnmhrm;
+		mmrnmhrm_desc_4xres.preprocess_func = mmrnmhrm_preprocess;
+		mmrnmhrm_desc_4xres.postprocess_func = mmrnmhrm_postprocess;
+		mmrnmhrm_desc_4xres.init_weapon_func = initialize_dual_weapons;
+		mmrnmhrm_desc_4xres.cyborg_control.intelligence_func = mmrnmhrm_intelligence;
+		new_mmrnmhrm_desc = mmrnmhrm_desc_4xres;
+	}
+	
 	otherwing_desc = HMalloc (sizeof (*otherwing_desc));
 	otherwing_desc->max_thrust = YWING_MAX_THRUST;
 	otherwing_desc->thrust_increment = YWING_THRUST_INCREMENT;
@@ -476,9 +645,8 @@ init_mmrnmhrm (void)
 	otherwing_desc->weapon_wait = YWING_WEAPON_WAIT;
 	otherwing_desc->special_wait = YWING_SPECIAL_WAIT;
 	otherwing_desc->ship_mass = SHIP_MASS;
-
 	new_mmrnmhrm_desc.data = (intptr_t) otherwing_desc;
-
+	
 	RaceDescPtr = &new_mmrnmhrm_desc;
 
 	return (RaceDescPtr);
diff -ruNp ./src.orig/uqm/ships/mycon/mycon.c ./src/uqm/ships/mycon/mycon.c
--- ./src.orig/uqm/ships/mycon/mycon.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/mycon/mycon.c	2017-10-23 11:41:35 -0700
@@ -26,7 +26,12 @@
 #define WEAPON_ENERGY_COST 20
 #define SPECIAL_ENERGY_COST MAX_ENERGY
 #define ENERGY_WAIT 4
-#define MAX_THRUST /* DISPLAY_TO_WORLD (7) */ 27
+
+ 
+#define MAX_THRUST /* DISPLAY_TO_WORLD (7) */ 27    
+#define MAX_THRUST_HIRES /* DISPLAY_TO_WORLD (20) */ 108 // DC_GFX
+#define THRUST_INCREMENT_HIRES MAX_THRUST_HIRES // DC_GFX
+
 #define THRUST_INCREMENT /* DISPLAY_TO_WORLD (2) */ 9
 #define TURN_WAIT 6
 #define THRUST_WAIT 6
@@ -39,7 +44,7 @@
 #define NUM_GLOBALLS 8
 #define PLASMA_DURATION 13
 #define MISSILE_LIFE (NUM_PLASMAS * PLASMA_DURATION)
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8)
+#define MISSILE_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 
 static RACE_DESC mycon_desc =
 {
@@ -60,6 +65,8 @@ static RACE_DESC mycon_desc =
 		},
 	},
 	{
+		//MAX_THRUST_HIRES,
+		//THRUST_INCREMENT_HIRES,
 		MAX_THRUST,
 		THRUST_INCREMENT,
 		ENERGY_REGENERATION,
@@ -112,8 +119,159 @@ static RACE_DESC mycon_desc =
 	0, /* CodeRef */
 };
 
-#define MISSILE_DAMAGE 10
+// JMS_GFX
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (14) */ 54
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 18
 
+// JMS_GFX
+static RACE_DESC mycon_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON,
+		21, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MYCON_RACE_STRINGS,
+		MYCON_ICON_MASK_PMAP_ANIM,
+		MYCON_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1070 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			6392, 2200,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MYCON_BIG_MASK_PMAP_ANIM,
+			MYCON_MED_MASK_PMAP_ANIM,
+			MYCON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PLASMA_BIG_MASK_PMAP_ANIM,
+			PLASMA_MED_MASK_PMAP_ANIM,
+			PLASMA_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			MYCON_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MYCON_VICTORY_SONG,
+		MYCON_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		DISPLAY_TO_WORLD (1600),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (28) */ 108
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 36
+
+// JMS_GFX
+static RACE_DESC mycon_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_WEAPON,
+		21, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MYCON_RACE_STRINGS,
+		MYCON_ICON_MASK_PMAP_ANIM,
+		MYCON_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1070 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			6392, 2200,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MYCON_BIG_MASK_PMAP_ANIM,
+			MYCON_MED_MASK_PMAP_ANIM,
+			MYCON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PLASMA_BIG_MASK_PMAP_ANIM,
+			PLASMA_MED_MASK_PMAP_ANIM,
+			PLASMA_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			MYCON_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MYCON_VICTORY_SONG,
+		MYCON_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		DISPLAY_TO_WORLD (3200),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define MISSILE_DAMAGE 10
 #define TRACK_WAIT 1
 
 static void
@@ -124,16 +282,14 @@ plasma_preprocess (ELEMENT *ElementPtr)
 	if (ElementPtr->mass_points > ElementPtr->hit_points)
 		ElementPtr->life_span = ElementPtr->hit_points * PLASMA_DURATION;
 	else
-		ElementPtr->hit_points = (BYTE)((ElementPtr->life_span *
-				MISSILE_DAMAGE + (MISSILE_LIFE - 1)) / MISSILE_LIFE);
+		ElementPtr->hit_points = (BYTE)((ElementPtr->life_span * MISSILE_DAMAGE + (MISSILE_LIFE - 1)) / MISSILE_LIFE);
+	
 	ElementPtr->mass_points = ElementPtr->hit_points;
-	plasma_index = NUM_PLASMAS - ((ElementPtr->life_span +
-			(PLASMA_DURATION - 1)) / PLASMA_DURATION);
+	plasma_index = NUM_PLASMAS - ((ElementPtr->life_span + (PLASMA_DURATION - 1)) / PLASMA_DURATION);
+	
 	if (plasma_index != GetFrameIndex (ElementPtr->next.image.frame))
 	{
-		ElementPtr->next.image.frame =
-				SetAbsFrameIndex (ElementPtr->next.image.frame,
-				plasma_index);
+		ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->next.image.frame, plasma_index);
 		ElementPtr->state_flags |= CHANGING;
 	}
 
@@ -143,12 +299,10 @@ plasma_preprocess (ELEMENT *ElementPtr)
 	{
 		COUNT facing;
 
-		facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-				GetVelocityTravelAngle (&ElementPtr->velocity)
-				));
+		facing = NORMALIZE_FACING (ANGLE_TO_FACING ( GetVelocityTravelAngle (&ElementPtr->velocity)));
+		
 		if (TrackShip (ElementPtr, &facing) > 0)
-			SetVelocityVector (&ElementPtr->velocity,
-					MISSILE_SPEED, facing);
+			SetVelocityVector (&ElementPtr->velocity, MISSILE_SPEED, facing);
 
 		ElementPtr->turn_wait = TRACK_WAIT;
 	}
@@ -254,7 +408,7 @@ mycon_intelligence (ELEMENT *ShipPtr, EV
 			|| ShipPtr->crew_level == StarShipPtr->RaceDescPtr->ship_info.max_crew))
 	{
 		COUNT travel_facing, direction_facing;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 
 		travel_facing = NORMALIZE_FACING (
 				ANGLE_TO_FACING (GetVelocityTravelAngle (&ShipPtr->velocity)
@@ -283,7 +437,7 @@ mycon_intelligence (ELEMENT *ShipPtr, EV
 	if (StarShipPtr->special_counter == 0)
 	{
 		StarShipPtr->ship_input_state &= ~SPECIAL;
-		StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = DISPLAY_TO_WORLD (800);
+		StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = DISPLAY_TO_WORLD (800 << RESOLUTION_FACTOR); // JMS_GFX
 		if (ShipPtr->crew_level < StarShipPtr->RaceDescPtr->ship_info.max_crew)
 		{
 			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = MISSILE_SPEED * MISSILE_LIFE;
@@ -297,7 +451,7 @@ mycon_intelligence (ELEMENT *ShipPtr, EV
 static COUNT
 initialize_plasma (ELEMENT *ShipPtr, HELEMENT PlasmaArray[])
 {
-#define MYCON_OFFSET 24
+#define MYCON_OFFSET (24 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_OFFSET 0
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -364,11 +518,27 @@ init_mycon (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	mycon_desc.postprocess_func = mycon_postprocess;
-	mycon_desc.init_weapon_func = initialize_plasma;
-	mycon_desc.cyborg_control.intelligence_func = mycon_intelligence;
-
-	RaceDescPtr = &mycon_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		mycon_desc.postprocess_func = mycon_postprocess;
+		mycon_desc.init_weapon_func = initialize_plasma;
+		mycon_desc.cyborg_control.intelligence_func = mycon_intelligence;
+		RaceDescPtr = &mycon_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		mycon_desc_2xres.postprocess_func = mycon_postprocess;
+		mycon_desc_2xres.init_weapon_func = initialize_plasma;
+		mycon_desc_2xres.cyborg_control.intelligence_func = mycon_intelligence;
+		RaceDescPtr = &mycon_desc_2xres;
+	}
+	else
+	{
+		mycon_desc_4xres.postprocess_func = mycon_postprocess;
+		mycon_desc_4xres.init_weapon_func = initialize_plasma;
+		mycon_desc_4xres.cyborg_control.intelligence_func = mycon_intelligence;
+		RaceDescPtr = &mycon_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/orz/orz.c ./src/uqm/ships/orz/orz.c
--- ./src.orig/uqm/ships/orz/orz.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/orz/orz.c	2017-10-23 11:41:35 -0700
@@ -114,6 +114,160 @@ static RACE_DESC orz_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 10
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+
+// JMS_GFX
+static RACE_DESC orz_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ORZ_RACE_STRINGS,
+		ORZ_ICON_MASK_PMAP_ANIM,
+		ORZ_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			3608, 2637,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ORZ_BIG_MASK_PMAP_ANIM,
+			ORZ_MED_MASK_PMAP_ANIM,
+			ORZ_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HOWITZER_BIG_MASK_PMAP_ANIM,
+			HOWITZER_MED_MASK_PMAP_ANIM,
+			HOWITZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TURRET_BIG_MASK_PMAP_ANIM,
+			TURRET_MED_MASK_PMAP_ANIM,
+			TURRET_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ORZ_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ORZ_VICTORY_SONG,
+		ORZ_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 20
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+// JMS_GFX
+static RACE_DESC orz_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ORZ_RACE_STRINGS,
+		ORZ_ICON_MASK_PMAP_ANIM,
+		ORZ_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			3608, 2637,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ORZ_BIG_MASK_PMAP_ANIM,
+			ORZ_MED_MASK_PMAP_ANIM,
+			ORZ_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HOWITZER_BIG_MASK_PMAP_ANIM,
+			HOWITZER_MED_MASK_PMAP_ANIM,
+			HOWITZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TURRET_BIG_MASK_PMAP_ANIM,
+			TURRET_MED_MASK_PMAP_ANIM,
+			TURRET_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ORZ_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ORZ_VICTORY_SONG,
+		ORZ_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 howitzer_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -122,7 +276,7 @@ howitzer_collision (ELEMENT *ElementPtr0
 		weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 }
 
-#define TURRET_OFFSET 14
+#define TURRET_OFFSET (14 << RESOLUTION_FACTOR) // JMS_GFX
 #define TURRET_WAIT 3
 
 static COUNT
@@ -130,7 +284,7 @@ initialize_turret_missile (ELEMENT *Ship
 {
 #define MISSILE_HITS 2
 #define MISSILE_DAMAGE 3
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	ELEMENT *TurretPtr;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -160,7 +314,7 @@ initialize_turret_missile (ELEMENT *Ship
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = TURRET_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -229,8 +383,7 @@ count_marines (STARSHIP *StarShipPtr, BO
 }
 
 static void
-orz_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+orz_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	ELEMENT *TurretPtr;
 	STARSHIP *StarShipPtr;
@@ -299,7 +452,7 @@ orz_intelligence (ELEMENT *ShipPtr, EVAL
 				& POINT_DEFENSE)
 				&& (MANEUVERABILITY (
 						&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-						) < SLOW_SHIP
+						) < RESOLUTION_COMPENSATED(SLOW_SHIP)
 				|| lpEvalDesc->which_turn <= 12
 				|| count_marines (StarShipPtr, FALSE) < 2))
 		{
@@ -388,10 +541,17 @@ intruder_preprocess (ELEMENT *ElementPtr
 			{
 				--ElementPtr->thrust_wait;
 
-				s.origin.x = 16 + (ElementPtr->turn_wait & 3) * 9;
-				s.origin.y = 14 + (ElementPtr->turn_wait >> 2) * 11;
-				s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0],
-						GetFrameCount (ElementPtr->next.image.farray[0]) - 2);
+				if (RESOLUTION_FACTOR < 2)
+				{
+					s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+				}
+				else
+				{
+					s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+					s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+				}
+				s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0], GetFrameCount (ElementPtr->next.image.farray[0]) - 2);
 				ModifySilhouette (ShipPtr, &s, 0);
 			}
 
@@ -403,8 +563,16 @@ intruder_preprocess (ELEMENT *ElementPtr
 				UnlockElement (hElement);
 				hElement = 0;
 LeftShip:
-				s.origin.x = 16 + (ElementPtr->turn_wait & 3) * 9;
-				s.origin.y = 14 + (ElementPtr->turn_wait >> 2) * 11;
+				if (RESOLUTION_FACTOR < 2)
+				{
+					s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+				}
+				else
+				{
+					s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+					s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+				}
 				s.frame = ElementPtr->next.image.frame;
 				ModifySilhouette (ShipPtr, &s, MODIFY_SWAP);
 			}
@@ -420,8 +588,7 @@ LeftShip:
 					ElementPtr->life_span = 0;
 					ElementPtr->state_flags |= DISAPPEARING;
 
-					ProcessSound (SetAbsSoundIndex (
-							StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 4), ElementPtr);
+					ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 4), ElementPtr);
 					goto LeftShip;
 				}
 				else if (randval < (0x0100 / 2 + 0x0100 / 16))
@@ -430,13 +597,19 @@ LeftShip:
 						ShipPtr->life_span = 0;
 
 					++ElementPtr->thrust_wait;
-					s.origin.x = 16 + (ElementPtr->turn_wait & 3) * 9;
-					s.origin.y = 14 + (ElementPtr->turn_wait >> 2) * 11;
-					s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0],
-							GetFrameCount (ElementPtr->next.image.farray[0]) - 1);
+					if (RESOLUTION_FACTOR < 2)
+					{
+						s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+						s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					}
+					else
+					{
+						s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+						s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+					}
+					s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0], GetFrameCount (ElementPtr->next.image.farray[0]) - 1);
 					ModifySilhouette (ShipPtr, &s, 0);
-					ProcessSound (SetAbsSoundIndex (
-							StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), ElementPtr);
+					ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), ElementPtr);
 				}
 			}
 
@@ -451,8 +624,7 @@ LeftShip:
 	{
 		ElementPtr->state_flags &= ~NONSOLID;
 		ElementPtr->state_flags |= CHANGING | CREW_OBJECT;
-		SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex],
-				STAMP_PRIM);
+		SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex], STAMP_PRIM);
 
 		ElementPtr->current.image.frame =
 				ElementPtr->next.image.frame =
@@ -496,10 +668,8 @@ spawn_marine_ion_trail (ELEMENT *Element
 				START_ION_COLOR);
 		IonElementPtr->colorCycleIndex = 0;
 		IonElementPtr->current.location = ElementPtr->current.location;
-		IonElementPtr->current.location.x +=
-				(COORD)COSINE (angle, DISPLAY_TO_WORLD (2));
-		IonElementPtr->current.location.y +=
-				(COORD)SINE (angle, DISPLAY_TO_WORLD (2));
+		IonElementPtr->current.location.x += (COORD)COSINE (angle, DISPLAY_TO_WORLD (2 << RESOLUTION_FACTOR)); // JMS_GFX
+		IonElementPtr->current.location.y += (COORD)SINE (angle, DISPLAY_TO_WORLD (2 << RESOLUTION_FACTOR));   // JMS_GFX
 		IonElementPtr->death_func = ion_preprocess;
 
 		SetElementStarShip (IonElementPtr, StarShipPtr);
@@ -542,7 +712,7 @@ marine_preprocess (ELEMENT *ElementPtr)
 	else
 	{
 		COUNT facing, pfacing = 0;
-		SIZE delta_x, delta_y, delta_facing;
+		SDWORD delta_x, delta_y, delta_facing;
 		HELEMENT hObject, hNextObject, hTarget;
 		ELEMENT *ObjectPtr;
 
@@ -629,7 +799,7 @@ marine_preprocess (ELEMENT *ElementPtr)
 			}
 			else
 			{
-				COUNT num_frames;
+				DWORD num_frames; // JMS_GFX: Was COUNT
 				VELOCITY_DESC ShipVelocity;
 
 				if (elementsOfSamePlayer (ObjectPtr, ElementPtr)
@@ -642,20 +812,18 @@ marine_preprocess (ELEMENT *ElementPtr)
 					ElementPtr->state_flags |= CHANGING;
 				}
 
-				num_frames = WORLD_TO_TURN (
-						square_root ((long)delta_x * delta_x
-						+ (long)delta_y * delta_y));
+				num_frames = (WORLD_TO_TURN (square_root ((long)delta_x * delta_x + (long)delta_y * delta_y))) >> RESOLUTION_FACTOR; // JMS_GFX
+				
 				if (num_frames == 0)
 					num_frames = 1;
 
 				ShipVelocity = ObjectPtr->velocity;
-				GetNextVelocityComponents (&ShipVelocity,
+				GetNextVelocityComponentsSdword (&ShipVelocity,
 						&delta_x, &delta_y, num_frames);
 
-				delta_x = (ObjectPtr->current.location.x + delta_x)
-						- ElementPtr->current.location.x;
-				delta_y = (ObjectPtr->current.location.y + delta_y)
-						- ElementPtr->current.location.y;
+				// JMS_GFX: Made the calculations use SDWORD to avoid overflows.
+				delta_x = ((SDWORD)ObjectPtr->current.location.x + delta_x) - (SDWORD)ElementPtr->current.location.x;
+				delta_y = ((SDWORD)ObjectPtr->current.location.y + delta_y) - (SDWORD)ElementPtr->current.location.y;
 
 				delta_facing = NORMALIZE_FACING (
 						ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)) - facing);
@@ -698,8 +866,8 @@ marine_preprocess (ELEMENT *ElementPtr)
 			// XXX: thrust_wait is abused to store marine speed and
 			//   gravity well flags
 			StarShipPtr->cur_status_flags = ElementPtr->thrust_wait << 6;
-			StarShipPtr->RaceDescPtr->characteristics.thrust_increment = 8;
-			StarShipPtr->RaceDescPtr->characteristics.max_thrust = 32;
+			StarShipPtr->RaceDescPtr->characteristics.thrust_increment = 8 << RESOLUTION_FACTOR; // JMS_GFX
+			StarShipPtr->RaceDescPtr->characteristics.max_thrust = 32 << RESOLUTION_FACTOR; // JMS_GFX
 
 			thrust_status = inertial_thrust (ElementPtr);
 
@@ -779,19 +947,29 @@ marine_collision (ELEMENT *ElementPtr0,
 				{
 					ElementPtr0->turn_wait = count_marines (StarShipPtr, TRUE);
 					ElementPtr0->thrust_wait = MARINE_WAIT;
-					ElementPtr0->next.image.frame = SetAbsFrameIndex (
-							ElementPtr0->next.image.farray[0],
-							22 + ElementPtr0->turn_wait
-							);
+					ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
 					ElementPtr0->state_flags |= NONSOLID;
 					ElementPtr0->state_flags &= ~CREW_OBJECT;
-					SetPrimType (&(GLOBAL (DisplayArray))[
-							ElementPtr0->PrimIndex
-							], NO_PRIM);
+					SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr0->PrimIndex], NO_PRIM);
 					ElementPtr0->preprocess_func = intruder_preprocess;
 
-					s.origin.x = 16 + (ElementPtr0->turn_wait & 3) * 9;
-					s.origin.y = 14 + (ElementPtr0->turn_wait >> 2) * 11;
+					if (RESOLUTION_FACTOR < 2)
+					{
+						s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+						s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					}
+					else
+					{
+						s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr0->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+						s.origin.y = (14 + (ElementPtr0->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+					}
+					
+					// JMS: Draw the shadow.
+					s.frame = ElementPtr0->next.image.frame;
+					ModifySilhouette (ElementPtr1, &s, 0);
+					
+					// JMS: Draw the marine.
+					ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
 					s.frame = ElementPtr0->next.image.frame;
 					ModifySilhouette (ElementPtr1, &s, 0);
 				}
@@ -970,11 +1148,11 @@ turret_postprocess (ELEMENT *ElementPtr)
 
 				facing = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 				SpaceMarinePtr->current.location.x =
-						ShipPtr->current.location.x
-						- COSINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET));
+				ShipPtr->current.location.x
+				- COSINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET << ((RESOLUTION_FACTOR + 1)/2))); // JMS_GFX
 				SpaceMarinePtr->current.location.y =
-						ShipPtr->current.location.y
-						- SINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET));
+				ShipPtr->current.location.y
+				- SINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET << ((RESOLUTION_FACTOR + 1)/2))); // JMS_GFX
 				SpaceMarinePtr->current.image.farray =
 						StarShipPtr->RaceDescPtr->ship_data.special;
 				SpaceMarinePtr->current.image.frame = SetAbsFrameIndex (
@@ -1065,11 +1243,27 @@ init_orz (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	orz_desc.preprocess_func = orz_preprocess;
-	orz_desc.init_weapon_func = initialize_turret_missile;
-	orz_desc.cyborg_control.intelligence_func = orz_intelligence;
-
-	RaceDescPtr = &orz_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		orz_desc.preprocess_func = orz_preprocess;
+		orz_desc.init_weapon_func = initialize_turret_missile;
+		orz_desc.cyborg_control.intelligence_func = orz_intelligence;
+		RaceDescPtr = &orz_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		orz_desc_2xres.preprocess_func = orz_preprocess;
+		orz_desc_2xres.init_weapon_func = initialize_turret_missile;
+		orz_desc_2xres.cyborg_control.intelligence_func = orz_intelligence;
+		RaceDescPtr = &orz_desc_2xres;
+	}
+	else
+	{
+		orz_desc_4xres.preprocess_func = orz_preprocess;
+		orz_desc_4xres.init_weapon_func = initialize_turret_missile;
+		orz_desc_4xres.cyborg_control.intelligence_func = orz_intelligence;
+		RaceDescPtr = &orz_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/pkunk/pkunk.c ./src/uqm/ships/pkunk/pkunk.c
--- ./src.orig/uqm/ships/pkunk/pkunk.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/pkunk/pkunk.c	2017-10-23 11:41:35 -0700
@@ -23,6 +23,8 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
+#include "../../settings.h" // JMS: For StopMusic
+
 
 #define MAX_CREW 8
 #define MAX_ENERGY 12
@@ -112,6 +114,158 @@ static RACE_DESC pkunk_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 128
+#define THRUST_INCREMENT_2XRES 32
+
+// JMS_GFX
+static RACE_DESC pkunk_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | FIRES_LEFT | FIRES_RIGHT,
+		20, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		PKUNK_RACE_STRINGS,
+		PKUNK_ICON_MASK_PMAP_ANIM,
+		PKUNK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			502, 401,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		0, /* SPECIAL_WAIT */
+		SHIP_MASS,
+	},
+	{
+		{
+			PKUNK_BIG_MASK_PMAP_ANIM,
+			PKUNK_MED_MASK_PMAP_ANIM,
+			PKUNK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUG_BIG_MASK_PMAP_ANIM,
+			BUG_MED_MASK_PMAP_ANIM,
+			BUG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			PKUNK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		PKUNK_VICTORY_SONG,
+		PKUNK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES + 2,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 256
+#define THRUST_INCREMENT_4XRES 64
+
+// JMS_GFX
+static RACE_DESC pkunk_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | FIRES_LEFT | FIRES_RIGHT,
+		20, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		PKUNK_RACE_STRINGS,
+		PKUNK_ICON_MASK_PMAP_ANIM,
+		PKUNK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			502, 401,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		0, /* SPECIAL_WAIT */
+		SHIP_MASS,
+	},
+	{
+		{
+			PKUNK_BIG_MASK_PMAP_ANIM,
+			PKUNK_MED_MASK_PMAP_ANIM,
+			PKUNK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUG_BIG_MASK_PMAP_ANIM,
+			BUG_MED_MASK_PMAP_ANIM,
+			BUG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			PKUNK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		PKUNK_VICTORY_SONG,
+		PKUNK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES + 4,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 animate (ELEMENT *ElementPtr)
 {
@@ -119,10 +273,8 @@ animate (ELEMENT *ElementPtr)
 		--ElementPtr->turn_wait;
 	else
 	{
-		ElementPtr->next.image.frame =
-				IncFrameIndex (ElementPtr->current.image.frame);
+		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
 		ElementPtr->state_flags |= CHANGING;
-
 		ElementPtr->turn_wait = ElementPtr->next_turn;
 	}
 }
@@ -130,10 +282,10 @@ animate (ELEMENT *ElementPtr)
 static COUNT
 initialize_bug_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define PKUNK_OFFSET 15
+#define PKUNK_OFFSET (15 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	COUNT i;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -146,7 +298,7 @@ initialize_bug_missile (ELEMENT *ShipPtr
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = PKUNK_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -155,20 +307,20 @@ initialize_bug_missile (ELEMENT *ShipPtr
 
 	for (i = 0; i < 3; ++i)
 	{
-		MissileBlock.face =
-				StarShipPtr->ShipFacing
-				+ (ANGLE_TO_FACING (QUADRANT) * i);
+		MissileBlock.face = StarShipPtr->ShipFacing + (ANGLE_TO_FACING (QUADRANT) * i);
+		
 		if (i == 2)
 			MissileBlock.face += ANGLE_TO_FACING (QUADRANT);
+		
 		MissileBlock.face = NORMALIZE_FACING (MissileBlock.face);
 
 		if ((MissileArray[i] = initialize_missile (&MissileBlock)))
 		{
-			SIZE dx, dy;
+			SDWORD dx, dy;
 			ELEMENT *MissilePtr;
 
 			LockElement (MissileArray[i], &MissilePtr);
-			GetCurrentVelocityComponents (&ShipPtr->velocity, &dx, &dy);
+			GetCurrentVelocityComponentsSdword (&ShipPtr->velocity, &dx, &dy);
 			DeltaVelocityComponents (&MissilePtr->velocity, dx, dy);
 			MissilePtr->current.location.x -= VELOCITY_TO_WORLD (dx);
 			MissilePtr->current.location.y -= VELOCITY_TO_WORLD (dy);
@@ -239,8 +391,8 @@ new_pkunk (ELEMENT *ElementPtr)
 		StarShipPtr->RaceDescPtr->ship_info.crew_level = MAX_CREW;
 		StarShipPtr->RaceDescPtr->ship_info.energy_level = MAX_ENERGY;
 					/* fix vux impairment */
-		StarShipPtr->RaceDescPtr->characteristics.max_thrust = MAX_THRUST;
-		StarShipPtr->RaceDescPtr->characteristics.thrust_increment = THRUST_INCREMENT;
+		StarShipPtr->RaceDescPtr->characteristics.max_thrust = MAX_THRUST << RESOLUTION_FACTOR; // JMS_GFX
+		StarShipPtr->RaceDescPtr->characteristics.thrust_increment = THRUST_INCREMENT << RESOLUTION_FACTOR; // JMS_GFX
 		StarShipPtr->RaceDescPtr->characteristics.turn_wait = TURN_WAIT;
 		StarShipPtr->RaceDescPtr->characteristics.thrust_wait = THRUST_WAIT;
 		StarShipPtr->RaceDescPtr->characteristics.special_wait = 0;
@@ -261,9 +413,7 @@ new_pkunk (ELEMENT *ElementPtr)
 		ElementPtr->current.image.frame =
 				SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.ship[0],
 				StarShipPtr->ShipFacing);
-		SetPrimType (&(GLOBAL (DisplayArray))[
-				ElementPtr->PrimIndex
-				], STAMP_PRIM);
+		SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex], STAMP_PRIM);
 
 		do
 		{
@@ -366,7 +516,7 @@ phoenix_transition (ELEMENT *ElementPtr)
 	}
 	else if ((hShipImage = AllocElement ()))
 	{
-#define TRANSITION_SPEED DISPLAY_TO_WORLD (20)
+#define TRANSITION_SPEED DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR) // JMS_GFX
 		COUNT angle;
 
 		PutElement (hShipImage);
@@ -458,6 +608,10 @@ pkunk_preprocess (ELEMENT *ElementPtr)
 		{
 			COUNT angle, facing;
 
+			// JMS: Kill Shofixti victory ditty if the this ship was reborn.
+			// Then play Pkunk's victory music.
+			StopMusic ();
+			
 			ProcessSound (SetAbsSoundIndex (
 					StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1
 					), ElementPtr);
@@ -543,12 +697,30 @@ init_pkunk (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	pkunk_desc.preprocess_func = pkunk_preprocess;
-	pkunk_desc.postprocess_func = pkunk_postprocess;
-	pkunk_desc.init_weapon_func = initialize_bug_missile;
-	pkunk_desc.cyborg_control.intelligence_func = pkunk_intelligence;
-
-	RaceDescPtr = &pkunk_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		pkunk_desc.preprocess_func = pkunk_preprocess;
+		pkunk_desc.postprocess_func = pkunk_postprocess;
+		pkunk_desc.init_weapon_func = initialize_bug_missile;
+		pkunk_desc.cyborg_control.intelligence_func = pkunk_intelligence;
+		RaceDescPtr = &pkunk_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		pkunk_desc_2xres.preprocess_func = pkunk_preprocess;
+		pkunk_desc_2xres.postprocess_func = pkunk_postprocess;
+		pkunk_desc_2xres.init_weapon_func = initialize_bug_missile;
+		pkunk_desc_2xres.cyborg_control.intelligence_func = pkunk_intelligence;
+		RaceDescPtr = &pkunk_desc_2xres;
+	}
+	else
+	{
+		pkunk_desc_4xres.preprocess_func = pkunk_preprocess;
+		pkunk_desc_4xres.postprocess_func = pkunk_postprocess;
+		pkunk_desc_4xres.init_weapon_func = initialize_bug_missile;
+		pkunk_desc_4xres.cyborg_control.intelligence_func = pkunk_intelligence;
+		RaceDescPtr = &pkunk_desc_4xres;
+	}
 
 	LastSound = 0;
 			// We need to reinitialise it at least each battle, to ensure
diff -ruNp ./src.orig/uqm/ships/shofixti/resinst.h ./src/uqm/ships/shofixti/resinst.h
--- ./src.orig/uqm/ships/shofixti/resinst.h	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/shofixti/resinst.h	2017-10-23 11:41:35 -0700
@@ -6,6 +6,7 @@
 #define DESTRUCT_SML_MASK_ANIM "ship.shofixti.graphics.destruct.small"
 #define OLDSHOF_BIG_MASK_PMAP_ANIM "ship.shofixti.graphics.oldscout.large"
 #define OLDSHOF_CAPTAIN_MASK_PMAP_ANIM "ship.shofixti.graphics.oldcaptain"
+#define OLDSHOF_ICON_MASK_PMAP_ANIM "ship.shofixti.oldicons"
 #define OLDSHOF_MED_MASK_PMAP_ANIM "ship.shofixti.graphics.oldscout.medium"
 #define OLDSHOF_SML_MASK_PMAP_ANIM "ship.shofixti.graphics.oldscout.small"
 #define SHOFIXTI_BIG_MASK_PMAP_ANIM "ship.shofixti.graphics.scout.large"
diff -ruNp ./src.orig/uqm/ships/shofixti/shofixti.c ./src/uqm/ships/shofixti/shofixti.c
--- ./src.orig/uqm/ships/shofixti/shofixti.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/shofixti/shofixti.c	2017-10-23 11:41:35 -0700
@@ -23,7 +23,7 @@
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
-
+ 
 #define MAX_CREW 6
 #define MAX_ENERGY 4
 #define ENERGY_REGENERATION 1
@@ -112,13 +112,167 @@ static RACE_DESC shofixti_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 10
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (48)
+
+// JMS_GFX
+static RACE_DESC shofixti_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		5, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SHOFIXTI_RACE_STRINGS,
+		SHOFIXTI_ICON_MASK_PMAP_ANIM,
+		SHOFIXTI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SHOFIXTI_BIG_MASK_PMAP_ANIM,
+			SHOFIXTI_MED_MASK_PMAP_ANIM,
+			SHOFIXTI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DART_BIG_MASK_PMAP_ANIM,
+			DART_MED_MASK_PMAP_ANIM,
+			DART_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DESTRUCT_BIG_MASK_ANIM,
+			DESTRUCT_MED_MASK_ANIM,
+			DESTRUCT_SML_MASK_ANIM,
+		},
+		{
+			SHOFIXTI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SHOFIXTI_VICTORY_SONG,
+		SHOFIXTI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 20
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (96)
+
+// JMS_GFX
+static RACE_DESC shofixti_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		5, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SHOFIXTI_RACE_STRINGS,
+		SHOFIXTI_ICON_MASK_PMAP_ANIM,
+		SHOFIXTI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SHOFIXTI_BIG_MASK_PMAP_ANIM,
+			SHOFIXTI_MED_MASK_PMAP_ANIM,
+			SHOFIXTI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DART_BIG_MASK_PMAP_ANIM,
+			DART_MED_MASK_PMAP_ANIM,
+			DART_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DESTRUCT_BIG_MASK_ANIM,
+			DESTRUCT_MED_MASK_ANIM,
+			DESTRUCT_SML_MASK_ANIM,
+		},
+		{
+			SHOFIXTI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SHOFIXTI_VICTORY_SONG,
+		SHOFIXTI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_standard_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define SHOFIXTI_OFFSET 15
+#define SHOFIXTI_OFFSET (15 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -130,7 +284,7 @@ initialize_standard_missile (ELEMENT *Sh
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SHOFIXTI_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -299,8 +453,8 @@ self_destruct (ELEMENT *ElementPtr)
 
 			if (CollidingElement (ObjPtr) || ORZ_MARINE (ObjPtr))
 			{
-#define DESTRUCT_RANGE 180
-				SIZE delta_x, delta_y;
+#define DESTRUCT_RANGE (180 << RESOLUTION_FACTOR) // JMS_GFX
+				SDWORD delta_x, delta_y;
 				DWORD dist;
 
 				if ((delta_x = ObjPtr->next.location.x
@@ -316,7 +470,7 @@ self_destruct (ELEMENT *ElementPtr)
 						+ (DWORD)(delta_y * delta_y)) <=
 						(DWORD)(DESTRUCT_RANGE * DESTRUCT_RANGE))
 				{
-#define MAX_DESTRUCTION (DESTRUCT_RANGE / 10)
+#define MAX_DESTRUCTION ((DESTRUCT_RANGE >> RESOLUTION_FACTOR) / 10) // JMS_GFX
 					SIZE destruction;
 
 					destruction = ((MAX_DESTRUCTION
@@ -413,11 +567,28 @@ init_shofixti (void)
 
 	static RACE_DESC new_shofixti_desc;
 
-	shofixti_desc.postprocess_func = shofixti_postprocess;
-	shofixti_desc.init_weapon_func = initialize_standard_missile;
-	shofixti_desc.cyborg_control.intelligence_func = shofixti_intelligence;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		shofixti_desc.postprocess_func = shofixti_postprocess;
+		shofixti_desc.init_weapon_func = initialize_standard_missile;
+		shofixti_desc.cyborg_control.intelligence_func = shofixti_intelligence;
+		new_shofixti_desc = shofixti_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		shofixti_desc_2xres.postprocess_func = shofixti_postprocess;
+		shofixti_desc_2xres.init_weapon_func = initialize_standard_missile;
+		shofixti_desc_2xres.cyborg_control.intelligence_func = shofixti_intelligence;
+		new_shofixti_desc = shofixti_desc_2xres;
+	}
+	else
+	{
+		shofixti_desc_4xres.postprocess_func = shofixti_postprocess;
+		shofixti_desc_4xres.init_weapon_func = initialize_standard_missile;
+		shofixti_desc_4xres.cyborg_control.intelligence_func = shofixti_intelligence;
+		new_shofixti_desc = shofixti_desc_4xres;
+	}
 
-	new_shofixti_desc = shofixti_desc;
 	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER
 			&& !GET_GAME_STATE (SHOFIXTI_RECRUITED))
 	{
@@ -433,6 +604,8 @@ init_shofixti (void)
 		new_shofixti_desc.ship_data.special_rsc[2] = NULL_RESOURCE;
 		new_shofixti_desc.ship_data.captain_control.captain_rsc =
 				OLDSHOF_CAPTAIN_MASK_PMAP_ANIM;
+		// JMS: Tanaka also has a corresponding limpeted ship status icon in melee.
+		new_shofixti_desc.ship_info.icons_rsc = OLDSHOF_ICON_MASK_PMAP_ANIM;
 
 		/* Weapon doesn't work as well */
 		new_shofixti_desc.characteristics.weapon_wait = 10;
@@ -444,7 +617,7 @@ init_shofixti (void)
 				--new_shofixti_desc.characteristics.turn_wait;
 			if (++new_shofixti_desc.characteristics.thrust_wait == 0)
 				--new_shofixti_desc.characteristics.thrust_wait;
-#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1)
+#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1 << RESOLUTION_FACTOR)
 			if (new_shofixti_desc.characteristics.thrust_increment <=
 					MIN_THRUST_INCREMENT)
 			{
@@ -457,7 +630,7 @@ init_shofixti (void)
 
 				num_thrusts = new_shofixti_desc.characteristics.max_thrust /
 						new_shofixti_desc.characteristics.thrust_increment;
-				--new_shofixti_desc.characteristics.thrust_increment;
+				new_shofixti_desc.characteristics.thrust_increment -= 1 << RESOLUTION_FACTOR; // JMS_GFX
 				new_shofixti_desc.characteristics.max_thrust =
 						new_shofixti_desc.characteristics.thrust_increment *
 						num_thrusts;
diff -ruNp ./src.orig/uqm/ships/sis_ship/resinst.h ./src/uqm/ships/sis_ship/resinst.h
--- ./src.orig/uqm/ships/sis_ship/resinst.h	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/sis_ship/resinst.h	2017-10-23 11:41:35 -0700
@@ -4,6 +4,7 @@
 #define SIS_BIG_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.large"
 #define SIS_CAPTAIN_MASK_PMAP_ANIM "ship.flagship.graphics.captain"
 #define SIS_HYPER_MASK_PMAP_ANIM "ship.flagship.graphics.hyperspace"
+#define SIS_QUASI_MASK_PMAP_ANIM "ship.flagship.graphics.quasispace"
 #define SIS_ICON_MASK_PMAP_ANIM "ship.flagship.icons"
 #define SIS_MED_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.medium"
 #define SIS_SML_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.small"
diff -ruNp ./src.orig/uqm/ships/sis_ship/sis_ship.c ./src/uqm/ships/sis_ship/sis_ship.c
--- ./src.orig/uqm/ships/sis_ship/sis_ship.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/sis_ship/sis_ship.c	2017-10-23 11:41:35 -0700
@@ -119,6 +119,160 @@ static RACE_DESC sis_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 20
+#define THRUST_INCREMENT_2XRES 8
+#define BLASTER_SPEED_2XRES DISPLAY_TO_WORLD (48)
+
+// JMS_GFX
+static RACE_DESC sis_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		0,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		NULL_RESOURCE,
+		SIS_ICON_MASK_PMAP_ANIM,
+		NULL_RESOURCE,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SIS_BIG_MASK_PMAP_ANIM,
+			SIS_MED_MASK_PMAP_ANIM,
+			SIS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BLASTER_BIG_MASK_PMAP_ANIM,
+			BLASTER_MED_MASK_PMAP_ANIM,
+			BLASTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SIS_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SIS_VICTORY_SONG,
+		SIS_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		BLASTER_SPEED_2XRES * BLASTER_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 40
+#define THRUST_INCREMENT_4XRES 16
+#define BLASTER_SPEED_4XRES DISPLAY_TO_WORLD (96)
+
+// JMS_GFX
+static RACE_DESC sis_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		0,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		NULL_RESOURCE,
+		SIS_ICON_MASK_PMAP_ANIM,
+		NULL_RESOURCE,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SIS_BIG_MASK_PMAP_ANIM,
+			SIS_MED_MASK_PMAP_ANIM,
+			SIS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BLASTER_BIG_MASK_PMAP_ANIM,
+			BLASTER_MED_MASK_PMAP_ANIM,
+			BLASTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SIS_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SIS_VICTORY_SONG,
+		SIS_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		BLASTER_SPEED_4XRES * BLASTER_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 // Private per-instance SIS data
 typedef struct
 {
@@ -142,35 +296,48 @@ void uninit_sis (RACE_DESC *pRaceDesc);
 static void
 sis_hyper_preprocess (ELEMENT *ElementPtr)
 {
-	SIZE udx = 0, udy = 0;
 	SIZE dx = 0, dy = 0;
 	SIZE AccelerateDirection;
 	STARSHIP *StarShipPtr;
-
+	SDWORD udx = 0, udy = 0, dtempx, dtempy;	// JMS_GFX: These babies help to make the hyperspace speed calculations not overflow in hires.
+	
 	if (ElementPtr->state_flags & APPEARING)
 		ElementPtr->velocity = GLOBAL (velocity);
-
+	
 	AccelerateDirection = 0;
-
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	++StarShipPtr->weapon_counter; /* no shooting in hyperspace! */
+	
 	if ((GLOBAL (autopilot)).x == ~0
-			|| (GLOBAL (autopilot)).y == ~0
-			|| (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST)))
+		|| (GLOBAL (autopilot)).y == ~0
+		|| (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST))
+		|| !(GET_GAME_STATE(AUTOPILOT_OK))) // JMS: This check makes autopilot engage only after coming to full stop
 	{
-LeaveAutoPilot:
-		(GLOBAL (autopilot)).x =
-				(GLOBAL (autopilot)).y = ~0;
+	LeaveAutoPilot:
+		
+		// JMS: This re-check is now needed because of the added autopilot_ok variable to previous check
+		if ((GLOBAL (autopilot)).x == ~0 || (GLOBAL (autopilot)).y == ~0 || (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST)))
+			(GLOBAL (autopilot)).x = (GLOBAL (autopilot)).y = ~0;
+		
 		if (!(StarShipPtr->cur_status_flags & THRUST)
-				|| (GLOBAL_SIS (FuelOnBoard) == 0
-				&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+			|| (GLOBAL_SIS (FuelOnBoard) == 0
+				&& (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)))
 		{
 			AccelerateDirection = -1;
-			GetCurrentVelocityComponents (&ElementPtr->velocity,
-					&dx, &dy);
-			udx = dx << 4;
-			udy = dy << 4;
-
+			GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+			
+			// JMS: Engage autopilot only after coming to full stop
+			if (dx==0 && dy==0)
+				SET_GAME_STATE (AUTOPILOT_OK, 1);
+			else
+				SET_GAME_STATE (AUTOPILOT_OK, 0);
+			
+			dtempx = (SDWORD)dx;
+			dtempy = (SDWORD)dy;
+			
+			udx = dtempx;
+			udy = dtempy;
+			
 			StarShipPtr->cur_status_flags &= ~THRUST;
 		}
 	}
@@ -178,38 +345,35 @@ LeaveAutoPilot:
 	{
 		SIZE facing;
 		POINT universe;
-
+		
 		universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
 		universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
 		udx = (GLOBAL (autopilot)).x - universe.x;
 		udy = -((GLOBAL (autopilot)).y - universe.y);
-		if ((dx = udx) < 0)
+		if ((dx = (SIZE)udx) < 0)
 			dx = -dx;
-		if ((dy = udy) < 0)
+		if ((dy = (SIZE)udy) < 0)
 			dy = -dy;
-		if (dx <= 1 && dy <= 1)
+        
+		if (dx <= (1 << RESOLUTION_FACTOR) && dy <= (1 << RESOLUTION_FACTOR))
 			goto LeaveAutoPilot;
-
+		
 		facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (udx, udy)));
-
+		
 		/* This prevents ship from flying backwards on auto-pilot.
 		 * It could also theoretically abort autopilot in a bad savegame */
 		if ((StarShipPtr->cur_status_flags & SHIP_AT_MAX_SPEED)
-				/*|| (ElementPtr->state_flags & APPEARING)*/ )
+			/*|| (ElementPtr->state_flags & APPEARING)*/ )
 		{
-			if (NORMALIZE_FACING (StarShipPtr->ShipFacing
-					+ ANGLE_TO_FACING (QUADRANT)
-					- facing) > ANGLE_TO_FACING (HALF_CIRCLE))
+			if (NORMALIZE_FACING (StarShipPtr->ShipFacing + ANGLE_TO_FACING (QUADRANT) - facing) > ANGLE_TO_FACING (HALF_CIRCLE))
 				goto LeaveAutoPilot;
-
+			
 			facing = StarShipPtr->ShipFacing;
 		}
 		else if ((int)facing != (int)StarShipPtr->ShipFacing
-				&& ElementPtr->turn_wait == 0)
+				 && ElementPtr->turn_wait == 0)
 		{
-			if (NORMALIZE_FACING (
-					StarShipPtr->ShipFacing - facing
-					) >= ANGLE_TO_FACING (HALF_CIRCLE))
+			if (NORMALIZE_FACING (StarShipPtr->ShipFacing - facing) >= ANGLE_TO_FACING (HALF_CIRCLE))
 			{
 				facing = NORMALIZE_FACING (facing - 1);
 				StarShipPtr->cur_status_flags |= RIGHT;
@@ -219,17 +383,16 @@ LeaveAutoPilot:
 				facing = NORMALIZE_FACING (facing + 1);
 				StarShipPtr->cur_status_flags |= LEFT;
 			}
-
+			
 			if ((int)facing == (int)StarShipPtr->ShipFacing)
-			{
 				ZeroVelocityComponents (&ElementPtr->velocity);
-			}
 		}
-
+		
 		GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+		
 		if ((GLOBAL_SIS (FuelOnBoard)
-				|| GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1)
-				&& (int)facing == (int)StarShipPtr->ShipFacing)
+			 || GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) // JMS: Orz space check.
+			&& (int)facing == (int)StarShipPtr->ShipFacing)
 		{
 			StarShipPtr->cur_status_flags |= SHIP_AT_MAX_SPEED;
 			AccelerateDirection = 1;
@@ -237,59 +400,57 @@ LeaveAutoPilot:
 		else
 		{
 			AccelerateDirection = -1;
-			udx = dx << 4;
-			udy = dy << 4;
+			udx = dx;// << 4;
+			udy = dy;// << 4;
 		}
 	}
-
+	
 	if (ElementPtr->thrust_wait == 0 && AccelerateDirection)
 	{
 		COUNT dist;
 		SIZE speed, velocity_increment;
-
-		velocity_increment = WORLD_TO_VELOCITY (
-				StarShipPtr->RaceDescPtr->characteristics.thrust_increment);
-
+		
+		velocity_increment = WORLD_TO_VELOCITY (StarShipPtr->RaceDescPtr->characteristics.thrust_increment);
+		
 		if ((dist = square_root ((long)udx * udx + (long)udy * udy)) == 0)
 			dist = 1; /* prevent divide by zero */
-
+		
 		speed = square_root ((long)dx * dx + (long)dy * dy);
+		
 		if (AccelerateDirection < 0)
 		{
 			dy = (speed / velocity_increment - 1) * velocity_increment;
+			
 			if (dy < speed - velocity_increment)
 				dy = speed - velocity_increment;
 			if ((speed = dy) < 0)
 				speed = 0;
-
+			
 			StarShipPtr->cur_status_flags &= ~SHIP_AT_MAX_SPEED;
 		}
 		else
 		{
 			SIZE max_velocity;
-
+			
 			AccelerateDirection = 0;
-
-			max_velocity = WORLD_TO_VELOCITY (
-					StarShipPtr->RaceDescPtr->characteristics.max_thrust);
-
-			dy = (speed / velocity_increment + 1)
-					* velocity_increment;
+			max_velocity = WORLD_TO_VELOCITY (StarShipPtr->RaceDescPtr->characteristics.max_thrust);
+			dy = (speed / velocity_increment + 1) * velocity_increment;
+			
 			if (dy < speed + velocity_increment)
 				dy = speed + velocity_increment;
+			
 			if ((speed = dy) > max_velocity)
 			{
 				speed = max_velocity;
 				StarShipPtr->cur_status_flags |= SHIP_AT_MAX_SPEED;
 			}
 		}
-
-		dx = (SIZE)((long)udx * speed / (long)dist);
-		dy = (SIZE)((long)udy * speed / (long)dist);
-		SetVelocityComponents (&ElementPtr->velocity, dx, dy);
-
-		ElementPtr->thrust_wait =
-				StarShipPtr->RaceDescPtr->characteristics.thrust_wait;
+		
+		dtempx = (SDWORD)((long)udx * speed / (long)dist);
+		dtempy = (SDWORD)((long)udy * speed / (long)dist);
+		
+		SetVelocityComponents (&ElementPtr->velocity, dtempx, dtempy);
+		ElementPtr->thrust_wait =StarShipPtr->RaceDescPtr->characteristics.thrust_wait;
 	}
 }
 
@@ -372,8 +533,8 @@ spawn_point_defense (ELEMENT *ElementPtr
 			if (ObjectPtr != ShipPtr && CollidingElement (ObjectPtr) &&
 					!OBJECT_CLOAKED (ObjectPtr))
 			{
-#define LASER_RANGE (UWORD)100
-				SIZE delta_x, delta_y;
+#define LASER_RANGE (UWORD)(100 << RESOLUTION_FACTOR) // JMS_GFX
+				SDWORD delta_x, delta_y;
 
 				delta_x = ObjectPtr->next.location.x -
 						ShipPtr->next.location.x;
@@ -547,7 +708,7 @@ blaster_preprocess (ELEMENT *ElementPtr)
 		facing = NORMALIZE_FACING (ANGLE_TO_FACING (
 				GetVelocityTravelAngle (&ElementPtr->velocity)));
 		if (TrackShip (ElementPtr, &facing) > 0)
-			SetVelocityVector (&ElementPtr->velocity, BLASTER_SPEED, facing);
+			SetVelocityVector (&ElementPtr->velocity, BLASTER_SPEED << RESOLUTION_FACTOR, facing); // JMS_GFX
 
 		ElementPtr->turn_wait = MAKE_BYTE (wait, wait);
 	}
@@ -556,10 +717,10 @@ blaster_preprocess (ELEMENT *ElementPtr)
 static COUNT
 initialize_blasters (ELEMENT *ShipPtr, HELEMENT BlasterArray[])
 {
-#define SIS_VERT_OFFSET 28
-#define SIS_HORZ_OFFSET 20
+#define SIS_VERT_OFFSET (28 << RESOLUTION_FACTOR) // JMS_GFX
+#define SIS_HORZ_OFFSET (20 << RESOLUTION_FACTOR) // JMS_GFX
 #define BLASTER_HITS 2
-#define BLASTER_OFFSET 8
+#define BLASTER_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
 	BYTE nt;
 	COUNT i;
 	STARSHIP *StarShipPtr;
@@ -624,7 +785,7 @@ sis_intelligence (ELEMENT *ShipPtr, EVAL
 			lpEvalDesc->ObjectPtr = NULL;
 		}
 		else if (MANEUVERABILITY (&StarShipPtr->RaceDescPtr->cyborg_control)
-				< MEDIUM_SHIP
+				< RESOLUTION_COMPENSATED(MEDIUM_SHIP) // JMS_GFX
 				&& lpEvalDesc->MoveState == ENTICE
 				&& (!(lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT)
 				|| lpEvalDesc->which_turn <= 8)
@@ -645,7 +806,7 @@ sis_intelligence (ELEMENT *ShipPtr, EVAL
 			&& lpEvalDesc->which_turn <= 16)
 	{
 		COUNT direction_facing;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 		UWORD fire_flags, ship_flags;
 		COUNT facing;
 
@@ -675,10 +836,6 @@ sis_intelligence (ELEMENT *ShipPtr, EVAL
 static void
 InitWeaponSlots (RACE_DESC *RaceDescPtr, const BYTE *ModuleSlots)
 {
-#define SIS_VERT_OFFSET 28
-#define SIS_HORZ_OFFSET 20
-#define BLASTER_HITS 2
-#define BLASTER_OFFSET 8
 	COUNT i;
 	SIS_DATA *SisData = (SIS_DATA *) RaceDescPtr->data;
 	MISSILE_BLOCK *lpMB = SisData->MissileBlock;
@@ -702,7 +859,7 @@ InitWeaponSlots (RACE_DESC *RaceDescPtr,
 		
 		lpMB->flags = IGNORE_SIMILAR;
 		lpMB->blast_offs = BLASTER_OFFSET;
-		lpMB->speed = BLASTER_SPEED;
+		lpMB->speed = BLASTER_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 		lpMB->preprocess_func = blaster_preprocess;
 		lpMB->hit_points = BLASTER_HITS * which_gun;
 		lpMB->damage = BLASTER_DAMAGE * which_gun;
@@ -815,7 +972,7 @@ InitDriveSlots (RACE_DESC *RaceDescPtr,
 		switch (DriveSlots[i])
 		{
 			case FUSION_THRUSTER:
-				RaceDescPtr->characteristics.max_thrust += 2;
+				RaceDescPtr->characteristics.max_thrust += (2 << RESOLUTION_FACTOR); // JMS_GFX
 				++RaceDescPtr->characteristics.thrust_wait;
 				break;
 		}
@@ -853,7 +1010,12 @@ init_sis (void)
 	static RACE_DESC new_sis_desc;
 
 	/* copy initial ship settings to new_sis_desc */
-	new_sis_desc = sis_desc;
+	if (RESOLUTION_FACTOR == 0)
+		new_sis_desc = sis_desc;
+	else if (RESOLUTION_FACTOR == 1)
+		new_sis_desc = sis_desc_2xres;
+	else
+		new_sis_desc = sis_desc_4xres;
 	
 	new_sis_desc.uninit_func = uninit_sis;
 
@@ -870,12 +1032,15 @@ init_sis (void)
 		new_sis_desc.ship_data.victory_ditty_rsc = NULL_RESOURCE;
 		new_sis_desc.ship_data.ship_sounds_rsc = NULL_RESOURCE;
 
-		new_sis_desc.ship_data.ship_rsc[0] = SIS_HYPER_MASK_PMAP_ANIM;
+		if (GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1 && RESOLUTION_FACTOR > 0)
+			new_sis_desc.ship_data.ship_rsc[0] = SIS_QUASI_MASK_PMAP_ANIM;
+		else
+			new_sis_desc.ship_data.ship_rsc[0] = SIS_HYPER_MASK_PMAP_ANIM;
 
 		new_sis_desc.preprocess_func = sis_hyper_preprocess;
 		new_sis_desc.postprocess_func = sis_hyper_postprocess;
 
-		new_sis_desc.characteristics.max_thrust -= 4;
+		new_sis_desc.characteristics.max_thrust -= 4 << RESOLUTION_FACTOR; // JMS_GFX
 	}
 	else
 	{
diff -ruNp ./src.orig/uqm/ships/slylandr/slylandr.c ./src/uqm/ships/slylandr/slylandr.c
--- ./src.orig/uqm/ships/slylandr/slylandr.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/slylandr/slylandr.c	2017-10-23 11:41:35 -0700
@@ -111,8 +111,159 @@ static RACE_DESC slylandro_desc =
 	0, /* CodeRef */
 };
 
-static COUNT initialize_lightning (ELEMENT *ElementPtr,
-		HELEMENT LaserArray[]);
+// JMS_GFX
+#define MAX_THRUST_2XRES 120
+#define THRUST_INCREMENT_2XRES MAX_THRUST_2XRES
+
+// JMS_GFX
+static RACE_DESC slylandro_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		SEEKING_WEAPON | CREW_IMMUNE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SLYLANDRO_RACE_STRINGS,
+		SLYLANDRO_ICON_MASK_PMAP_ANIM,
+		SLYLANDRO_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			333, 9812,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SLYLANDRO_BIG_MASK_PMAP_ANIM,
+			SLYLANDRO_MED_MASK_PMAP_ANIM,
+			SLYLANDRO_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SLYLANDRO_VICTORY_SONG,
+		SLYLANDRO_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES << 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 240
+#define THRUST_INCREMENT_4XRES MAX_THRUST_4XRES
+
+// JMS_GFX
+static RACE_DESC slylandro_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		SEEKING_WEAPON | CREW_IMMUNE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SLYLANDRO_RACE_STRINGS,
+		SLYLANDRO_ICON_MASK_PMAP_ANIM,
+		SLYLANDRO_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			333, 9812,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SLYLANDRO_BIG_MASK_PMAP_ANIM,
+			SLYLANDRO_MED_MASK_PMAP_ANIM,
+			SLYLANDRO_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SLYLANDRO_VICTORY_SONG,
+		SLYLANDRO_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES << 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+static COUNT initialize_lightning (ELEMENT *ElementPtr, HELEMENT LaserArray[]);
 
 static void
 lightning_postprocess (ELEMENT *ElementPtr)
@@ -238,10 +389,8 @@ initialize_lightning (ELEMENT *ElementPt
 			angle += LOWORD (rand_val) & (QUADRANT - 1);
 		else
 			angle -= LOWORD (rand_val) & (QUADRANT - 1);
-#define LASER_RANGE 32
-		delta = WORLD_TO_VELOCITY (
-				DISPLAY_TO_WORLD ((HIWORD (rand_val) & (LASER_RANGE - 1)) + 4)
-				);
+#define LASER_RANGE (32 << RESOLUTION_FACTOR) // JMS_GFX
+		delta = WORLD_TO_VELOCITY (DISPLAY_TO_WORLD ((HIWORD (rand_val) & (LASER_RANGE - 1)) + 4));
 		SetVelocityComponents (&LaserPtr->velocity,
 				COSINE (angle, delta), SINE (angle, delta));
 
@@ -314,8 +463,8 @@ harvest_space_junk (ELEMENT *ElementPtr)
 				&& CollisionPossible (ObjPtr, ElementPtr))
 		{
 //HARVEST_RANGE was originally (SPACE_HEIGHT * 3 / 8)
-#define HARVEST_RANGE (208 * 3 / 8)
-			SIZE dx, dy;
+#define HARVEST_RANGE ((208 * 3 / 8) << RESOLUTION_FACTOR) // JMS_GFX
+			SDWORD dx, dy;
 
 			if ((dx = ObjPtr->next.location.x
 					- ElementPtr->next.location.x) < 0)
@@ -422,12 +571,30 @@ init_slylandro (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	slylandro_desc.preprocess_func = slylandro_preprocess;
-	slylandro_desc.postprocess_func = slylandro_postprocess;
-	slylandro_desc.init_weapon_func = initialize_lightning;
-	slylandro_desc.cyborg_control.intelligence_func = slylandro_intelligence;
-
-	RaceDescPtr = &slylandro_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		slylandro_desc.preprocess_func = slylandro_preprocess;
+		slylandro_desc.postprocess_func = slylandro_postprocess;
+		slylandro_desc.init_weapon_func = initialize_lightning;
+		slylandro_desc.cyborg_control.intelligence_func = slylandro_intelligence;
+		RaceDescPtr = &slylandro_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		slylandro_desc_2xres.preprocess_func = slylandro_preprocess;
+		slylandro_desc_2xres.postprocess_func = slylandro_postprocess;
+		slylandro_desc_2xres.init_weapon_func = initialize_lightning;
+		slylandro_desc_2xres.cyborg_control.intelligence_func = slylandro_intelligence;
+		RaceDescPtr = &slylandro_desc_2xres;
+	}
+	else
+	{
+		slylandro_desc_4xres.preprocess_func = slylandro_preprocess;
+		slylandro_desc_4xres.postprocess_func = slylandro_postprocess;
+		slylandro_desc_4xres.init_weapon_func = initialize_lightning;
+		slylandro_desc_4xres.cyborg_control.intelligence_func = slylandro_intelligence;
+		RaceDescPtr = &slylandro_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/spathi/spathi.c ./src/uqm/ships/spathi/spathi.c
--- ./src.orig/uqm/ships/spathi/spathi.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/spathi/spathi.c	2017-10-23 11:41:35 -0700
@@ -109,7 +109,163 @@ static RACE_DESC spathi_desc =
 	0, /* CodeRef */
 };
 
-#define DISCRIMINATOR_SPEED DISPLAY_TO_WORLD (8)
+// JMS_GFX
+#define MAX_THRUST_2XRES 96
+#define THRUST_INCREMENT_2XRES 24
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC spathi_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | FIRES_AFT | SEEKING_SPECIAL | DONT_CHASE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SPATHI_RACE_STRINGS,
+		SPATHI_ICON_MASK_PMAP_ANIM,
+		SPATHI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			2549, 3600,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SPATHI_BIG_MASK_PMAP_ANIM,
+			SPATHI_MED_MASK_PMAP_ANIM,
+			SPATHI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MISSILE_BIG_MASK_PMAP_ANIM,
+			MISSILE_MED_MASK_PMAP_ANIM,
+			MISSILE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DISCRIM_BIG_MASK_PMAP_ANIM,
+			DISCRIM_MED_MASK_PMAP_ANIM,
+			DISCRIM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPATHI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SPATHI_VICTORY_SONG,
+		SPATHI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 192
+#define THRUST_INCREMENT_4XRES 48
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC spathi_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | FIRES_AFT | SEEKING_SPECIAL | DONT_CHASE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SPATHI_RACE_STRINGS,
+		SPATHI_ICON_MASK_PMAP_ANIM,
+		SPATHI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			2549, 3600,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SPATHI_BIG_MASK_PMAP_ANIM,
+			SPATHI_MED_MASK_PMAP_ANIM,
+			SPATHI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MISSILE_BIG_MASK_PMAP_ANIM,
+			MISSILE_MED_MASK_PMAP_ANIM,
+			MISSILE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DISCRIM_BIG_MASK_PMAP_ANIM,
+			DISCRIM_MED_MASK_PMAP_ANIM,
+			DISCRIM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPATHI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SPATHI_VICTORY_SONG,
+		SPATHI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define DISCRIMINATOR_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 #define TRACK_WAIT 1
 
 static void
@@ -140,11 +296,11 @@ butt_missile_preprocess (ELEMENT *Elemen
 static void
 spawn_butt_missile (ELEMENT *ShipPtr)
 {
-#define SPATHI_REAR_OFFSET 20
+#define SPATHI_REAR_OFFSET (20 << RESOLUTION_FACTOR) // JMS_GFX
 #define DISCRIMINATOR_LIFE 30
 #define DISCRIMINATOR_HITS 1
 #define DISCRIMINATOR_DAMAGE 2
-#define DISCRIMINATOR_OFFSET 4
+#define DISCRIMINATOR_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
 	HELEMENT ButtMissile;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK ButtMissileBlock;
@@ -201,7 +357,7 @@ spathi_intelligence (ELEMENT *ShipPtr, E
 			&& lpEvalDesc->which_turn <= 24)
 	{
 		COUNT travel_facing, direction_facing;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 
 		travel_facing = NORMALIZE_FACING (
 				ANGLE_TO_FACING (GetVelocityTravelAngle (&ShipPtr->velocity)
@@ -239,10 +395,10 @@ spathi_intelligence (ELEMENT *ShipPtr, E
 static COUNT
 initialize_standard_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define SPATHI_FORWARD_OFFSET 16
+#define SPATHI_FORWARD_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -254,7 +410,7 @@ initialize_standard_missile (ELEMENT *Sh
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SPATHI_FORWARD_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -287,11 +443,27 @@ init_spathi (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	spathi_desc.postprocess_func = spathi_postprocess;
-	spathi_desc.init_weapon_func = initialize_standard_missile;
-	spathi_desc.cyborg_control.intelligence_func = spathi_intelligence;
-
-	RaceDescPtr = &spathi_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		spathi_desc.postprocess_func = spathi_postprocess;
+		spathi_desc.init_weapon_func = initialize_standard_missile;
+		spathi_desc.cyborg_control.intelligence_func = spathi_intelligence;
+		RaceDescPtr = &spathi_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		spathi_desc_2xres.postprocess_func = spathi_postprocess;
+		spathi_desc_2xres.init_weapon_func = initialize_standard_missile;
+		spathi_desc_2xres.cyborg_control.intelligence_func = spathi_intelligence;
+		RaceDescPtr = &spathi_desc_2xres;
+	}
+	else
+	{
+		spathi_desc_4xres.postprocess_func = spathi_postprocess;
+		spathi_desc_4xres.init_weapon_func = initialize_standard_missile;
+		spathi_desc_4xres.cyborg_control.intelligence_func = spathi_intelligence;
+		RaceDescPtr = &spathi_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/supox/supox.c ./src/uqm/ships/supox/supox.c
--- ./src.orig/uqm/ships/supox/supox.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/supox/supox.c	2017-10-23 11:41:35 -0700
@@ -111,9 +111,162 @@ static RACE_DESC supox_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 80
+#define THRUST_INCREMENT_2XRES 16
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+
+// JMS_GFX
+static RACE_DESC supox_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SUPOX_RACE_STRINGS,
+		SUPOX_ICON_MASK_PMAP_ANIM,
+		SUPOX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			7468, 9246,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SUPOX_BIG_MASK_PMAP_ANIM,
+			SUPOX_MED_MASK_PMAP_ANIM,
+			SUPOX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GOB_BIG_MASK_PMAP_ANIM,
+			GOB_MED_MASK_PMAP_ANIM,
+			GOB_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SUPOX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SUPOX_VICTORY_SONG,
+		SUPOX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_2XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 160
+#define THRUST_INCREMENT_4XRES 16
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+// JMS_GFX
+static RACE_DESC supox_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SUPOX_RACE_STRINGS,
+		SUPOX_ICON_MASK_PMAP_ANIM,
+		SUPOX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			7468, 9246,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SUPOX_BIG_MASK_PMAP_ANIM,
+			SUPOX_MED_MASK_PMAP_ANIM,
+			SUPOX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GOB_BIG_MASK_PMAP_ANIM,
+			GOB_MED_MASK_PMAP_ANIM,
+			GOB_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SUPOX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SUPOX_VICTORY_SONG,
+		SUPOX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_4XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
-supox_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+supox_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	STARSHIP *StarShipPtr;
 	EVALUATE_DESC *lpEvalDesc;
@@ -127,7 +280,7 @@ supox_intelligence (ELEMENT *ShipPtr, EV
 	{
 		BOOLEAN LinedUp;
 		COUNT direction_angle;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 
 		delta_x = lpEvalDesc->ObjectPtr->next.location.x
 				- ShipPtr->next.location.x;
@@ -182,7 +335,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 2
-#define SUPOX_OFFSET 23
+#define SUPOX_OFFSET (23 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -194,7 +347,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SUPOX_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -272,11 +425,27 @@ init_supox (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	supox_desc.preprocess_func = supox_preprocess;
-	supox_desc.init_weapon_func = initialize_horn;
-	supox_desc.cyborg_control.intelligence_func = supox_intelligence;
-
-	RaceDescPtr = &supox_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		supox_desc.preprocess_func = supox_preprocess;
+		supox_desc.init_weapon_func = initialize_horn;
+		supox_desc.cyborg_control.intelligence_func = supox_intelligence;
+		RaceDescPtr = &supox_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		supox_desc_2xres.preprocess_func = supox_preprocess;
+		supox_desc_2xres.init_weapon_func = initialize_horn;
+		supox_desc_2xres.cyborg_control.intelligence_func = supox_intelligence;
+		RaceDescPtr = &supox_desc_2xres;
+	}
+	else
+	{
+		supox_desc_4xres.preprocess_func = supox_preprocess;
+		supox_desc_4xres.init_weapon_func = initialize_horn;
+		supox_desc_4xres.cyborg_control.intelligence_func = supox_intelligence;
+		RaceDescPtr = &supox_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/syreen/syreen.c ./src/uqm/ships/syreen/syreen.c
--- ./src.orig/uqm/ships/syreen/syreen.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/syreen/syreen.c	2017-10-23 11:41:35 -0700
@@ -112,13 +112,167 @@ static RACE_DESC syreen_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (8) */ 72
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 18
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+
+// JMS_GFX
+static RACE_DESC syreen_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		13, /* Super Melee cost */
+		MAX_CREW, SYREEN_MAX_CREW_SIZE,
+		MAX_ENERGY, MAX_ENERGY,
+		SYREEN_RACE_STRINGS,
+		SYREEN_ICON_MASK_PMAP_ANIM,
+		SYREEN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SYREEN_BIG_MASK_PMAP_ANIM,
+			SYREEN_MED_MASK_PMAP_ANIM,
+			SYREEN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DAGGER_BIG_MASK_PMAP_ANIM,
+			DAGGER_MED_MASK_PMAP_ANIM,
+			DAGGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SYREEN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SYREEN_VICTORY_SONG,
+		SYREEN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_2XRES * MISSILE_LIFE * 2 / 3),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (8) */ 144
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 36
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+// JMS_GFX
+static RACE_DESC syreen_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		13, /* Super Melee cost */
+		MAX_CREW, SYREEN_MAX_CREW_SIZE,
+		MAX_ENERGY, MAX_ENERGY,
+		SYREEN_RACE_STRINGS,
+		SYREEN_ICON_MASK_PMAP_ANIM,
+		SYREEN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SYREEN_BIG_MASK_PMAP_ANIM,
+			SYREEN_MED_MASK_PMAP_ANIM,
+			SYREEN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DAGGER_BIG_MASK_PMAP_ANIM,
+			DAGGER_MED_MASK_PMAP_ANIM,
+			DAGGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SYREEN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SYREEN_VICTORY_SONG,
+		SYREEN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_4XRES * MISSILE_LIFE * 2 / 3),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_dagger (ELEMENT *ShipPtr, HELEMENT DaggerArray[])
 {
-#define SYREEN_OFFSET 30
+#define SYREEN_OFFSET (30 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 2
-#define MISSILE_OFFSET 3
+#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -130,7 +284,7 @@ initialize_dagger (ELEMENT *ShipPtr, HEL
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SYREEN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -182,7 +336,7 @@ spawn_crew (ELEMENT *ElementPtr)
 					&& !elementsOfSamePlayer (ObjPtr, ElementPtr)
 					&& ObjPtr->crew_level > 1)
 			{
-				SIZE dx, dy;
+				SDWORD dx, dy;
 				DWORD d_squared;
 
 				dx = ObjPtr->next.location.x - ElementPtr->next.location.x;
@@ -194,7 +348,7 @@ spawn_crew (ELEMENT *ElementPtr)
 
 				dx = WORLD_TO_DISPLAY (dx);
 				dy = WORLD_TO_DISPLAY (dy);
-#define ABANDONER_RANGE 208 /* originally SPACE_HEIGHT */
+#define ABANDONER_RANGE (208 << RESOLUTION_FACTOR) // JMS_GFX /* originally SPACE_HEIGHT */
 				if (dx <= ABANDONER_RANGE && dy <= ABANDONER_RANGE
 						&& (d_squared = (DWORD)((UWORD)dx * (UWORD)dx)
 						+ (DWORD)((UWORD)dy * (UWORD)dy)) <=
@@ -270,12 +424,28 @@ init_syreen (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	syreen_desc.postprocess_func = syreen_postprocess;
-	syreen_desc.init_weapon_func = initialize_dagger;
-	syreen_desc.cyborg_control.intelligence_func = syreen_intelligence;
-
-	RaceDescPtr = &syreen_desc;
-
+	if (RESOLUTION_FACTOR == 0)
+	{
+		syreen_desc.postprocess_func = syreen_postprocess;
+		syreen_desc.init_weapon_func = initialize_dagger;
+		syreen_desc.cyborg_control.intelligence_func = syreen_intelligence;
+		RaceDescPtr = &syreen_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		syreen_desc_2xres.postprocess_func = syreen_postprocess;
+		syreen_desc_2xres.init_weapon_func = initialize_dagger;
+		syreen_desc_2xres.cyborg_control.intelligence_func = syreen_intelligence;
+		RaceDescPtr = &syreen_desc_2xres;
+	}
+	else
+	{
+		syreen_desc_4xres.postprocess_func = syreen_postprocess;
+		syreen_desc_4xres.init_weapon_func = initialize_dagger;
+		syreen_desc_4xres.cyborg_control.intelligence_func = syreen_intelligence;
+		RaceDescPtr = &syreen_desc_4xres;
+	}
+	
 	return (RaceDescPtr);
 }
 
diff -ruNp ./src.orig/uqm/ships/thradd/thradd.c ./src/uqm/ships/thradd/thradd.c
--- ./src.orig/uqm/ships/thradd/thradd.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/thradd/thradd.c	2017-10-23 11:41:35 -0700
@@ -37,7 +37,7 @@
 #define SPECIAL_WAIT 0
 
 #define SHIP_MASS 7
-#define THRADDASH_OFFSET 9
+#define THRADDASH_OFFSET (9 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 15
 
@@ -112,6 +112,160 @@ static RACE_DESC thraddash_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 56
+#define THRUST_INCREMENT_2XRES 14
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+
+// JMS_GFX
+static RACE_DESC thraddash_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		THRADDASH_RACE_STRINGS,
+		THRADDASH_ICON_MASK_PMAP_ANIM,
+		THRADDASH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			2535, 8358,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			THRADDASH_BIG_MASK_PMAP_ANIM,
+			THRADDASH_MED_MASK_PMAP_ANIM,
+			THRADDASH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HORN_BIG_MASK_PMAP_ANIM,
+			HORN_MED_MASK_PMAP_ANIM,
+			HORN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NAPALM_BIG_MASK_PMAP_ANIM,
+			NAPALM_MED_MASK_PMAP_ANIM,
+			NAPALM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			THRADDASH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		THRADDASH_VICTORY_SONG,
+		THRADDASH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_2XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 112
+#define THRUST_INCREMENT_4XRES 28
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+// JMS_GFX
+static RACE_DESC thraddash_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		THRADDASH_RACE_STRINGS,
+		THRADDASH_ICON_MASK_PMAP_ANIM,
+		THRADDASH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			2535, 8358,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			THRADDASH_BIG_MASK_PMAP_ANIM,
+			THRADDASH_MED_MASK_PMAP_ANIM,
+			THRADDASH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HORN_BIG_MASK_PMAP_ANIM,
+			HORN_MED_MASK_PMAP_ANIM,
+			HORN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NAPALM_BIG_MASK_PMAP_ANIM,
+			NAPALM_MED_MASK_PMAP_ANIM,
+			NAPALM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			THRADDASH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		THRADDASH_VICTORY_SONG,
+		THRADDASH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_4XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 thraddash_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
 		COUNT ConcernCounter)
@@ -123,10 +277,10 @@ thraddash_intelligence (ELEMENT *ShipPtr
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 	if (lpEvalDesc->ObjectPtr)
 	{
-#define STATIONARY_SPEED WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (4))
-		SIZE dx, dy;
+#define STATIONARY_SPEED WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR)) // JMS_GFX
+		SDWORD dx, dy;
 
-		GetCurrentVelocityComponents (
+		GetCurrentVelocityComponentsSdword (
 				&lpEvalDesc->ObjectPtr->velocity, &dx, &dy
 				);
 		if (lpEvalDesc->which_turn > 8
@@ -171,7 +325,7 @@ thraddash_intelligence (ELEMENT *ShipPtr
 			else if (lpEvalDesc->MoveState == ENTICE)
 			{
 				COUNT direction_angle;
-				SIZE delta_x, delta_y;
+				SDWORD delta_x, delta_y;
 
 				delta_x = lpEvalDesc->ObjectPtr->next.location.x
 						- ShipPtr->next.location.x;
@@ -247,7 +401,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 {
 #define MISSILE_HITS 2
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 3
+#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -259,7 +413,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = THRADDASH_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -284,8 +438,8 @@ thraddash_preprocess (ELEMENT *ElementPt
 	}
 	else if (DeltaEnergy (ElementPtr, -SPECIAL_ENERGY_COST))
 	{
-#define SPECIAL_THRUST_INCREMENT 12
-#define SPECIAL_MAX_THRUST 72
+#define SPECIAL_THRUST_INCREMENT (12 << RESOLUTION_FACTOR) // JMS_GFX
+#define SPECIAL_MAX_THRUST (72 << RESOLUTION_FACTOR) // JMS_GFX
 		COUNT max_thrust, thrust_increment;
 		STATUS_FLAGS thrust_status;
 		HELEMENT hTrailElement;
@@ -378,11 +532,27 @@ init_thraddash (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	thraddash_desc.preprocess_func = thraddash_preprocess;
-	thraddash_desc.init_weapon_func = initialize_horn;
-	thraddash_desc.cyborg_control.intelligence_func = thraddash_intelligence;
-
-	RaceDescPtr = &thraddash_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		thraddash_desc.preprocess_func = thraddash_preprocess;
+		thraddash_desc.init_weapon_func = initialize_horn;
+		thraddash_desc.cyborg_control.intelligence_func = thraddash_intelligence;
+		RaceDescPtr = &thraddash_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		thraddash_desc_2xres.preprocess_func = thraddash_preprocess;
+		thraddash_desc_2xres.init_weapon_func = initialize_horn;
+		thraddash_desc_2xres.cyborg_control.intelligence_func = thraddash_intelligence;
+		RaceDescPtr = &thraddash_desc_2xres;
+	}
+	else
+	{
+		thraddash_desc_4xres.preprocess_func = thraddash_preprocess;
+		thraddash_desc_4xres.init_weapon_func = initialize_horn;
+		thraddash_desc_4xres.cyborg_control.intelligence_func = thraddash_intelligence;
+		RaceDescPtr = &thraddash_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/umgah/umgah.c ./src/uqm/ships/umgah/umgah.c
--- ./src.orig/uqm/ships/umgah/umgah.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/umgah/umgah.c	2017-10-23 11:41:35 -0700
@@ -38,7 +38,6 @@
 
 #define SHIP_MASS 1
 
-
 static RACE_DESC umgah_desc =
 {
 	{ /* SHIP_INFO */
@@ -110,6 +109,158 @@ static RACE_DESC umgah_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (5) */ 36
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 12
+
+// JMS_GFX
+static RACE_DESC umgah_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		7, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		UMGAH_RACE_STRINGS,
+		UMGAH_ICON_MASK_PMAP_ANIM,
+		UMGAH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			1798, 6000,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UMGAH_BIG_MASK_PMAP_ANIM,
+			UMGAH_MED_MASK_PMAP_ANIM,
+			UMGAH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPRITZ_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			CONE_BIG_MASK_ANIM,
+			CONE_MED_MASK_ANIM,
+			CONE_SML_MASK_ANIM,
+		},
+		{
+			UMGAH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UMGAH_VICTORY_SONG,
+		UMGAH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(LONG_RANGE_WEAPON_2XRES << 2),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (5) */ 72
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 24
+
+// JMS_GFX
+static RACE_DESC umgah_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		7, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		UMGAH_RACE_STRINGS,
+		UMGAH_ICON_MASK_PMAP_ANIM,
+		UMGAH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			1798, 6000,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UMGAH_BIG_MASK_PMAP_ANIM,
+			UMGAH_MED_MASK_PMAP_ANIM,
+			UMGAH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPRITZ_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			CONE_BIG_MASK_ANIM,
+			CONE_MED_MASK_ANIM,
+			CONE_SML_MASK_ANIM,
+		},
+		{
+			UMGAH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UMGAH_VICTORY_SONG,
+		UMGAH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(LONG_RANGE_WEAPON_4XRES << 2),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 cone_preprocess (ELEMENT *ElementPtr)
 {
@@ -139,7 +290,7 @@ cone_collision (ELEMENT *ElementPtr0, PO
 	}
 }
 
-#define JUMP_DIST DISPLAY_TO_WORLD (40)
+#define JUMP_DIST DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 umgah_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
@@ -178,7 +329,7 @@ umgah_intelligence (ELEMENT *ShipPtr, EV
 	else
 	{
 		BYTE this_turn;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 		BOOLEAN EnemyBehind, EnoughJuice;
 
 		if (lpEvalDesc->which_turn >= 0xFF + 1)
@@ -186,10 +337,10 @@ umgah_intelligence (ELEMENT *ShipPtr, EV
 		else
 			this_turn = (BYTE)lpEvalDesc->which_turn;
 
-		EnoughJuice = (BOOLEAN)(WORLD_TO_TURN (
+		EnoughJuice = (BOOLEAN)((WORLD_TO_TURN (
 				JUMP_DIST * StarShipPtr->RaceDescPtr->ship_info.energy_level
 				/ SPECIAL_ENERGY_COST
-				) > this_turn);
+				) >> RESOLUTION_FACTOR) > this_turn); // JMS_GFX
 		delta_x = lpEvalDesc->ObjectPtr->next.location.x -
 				ShipPtr->next.location.x;
 		delta_y = lpEvalDesc->ObjectPtr->next.location.y -
@@ -207,7 +358,7 @@ umgah_intelligence (ELEMENT *ShipPtr, EV
 				|| (this_turn > 6
 				&& MANEUVERABILITY (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) <= SLOW_SHIP)
+				) <= RESOLUTION_COMPENSATED(SLOW_SHIP)) // JMS_GFX
 				|| (this_turn >= 16 && this_turn <= 24)))
 			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = (LONG_RANGE_WEAPON << 3);
 		else
@@ -309,8 +460,7 @@ initialize_cone (ELEMENT *ShipPtr, HELEM
 		ConePtr->next = ConePtr->current;
 		InitIntersectStartPoint (ConePtr);
 		InitIntersectEndPoint (ConePtr);
-		ConePtr->IntersectControl.IntersectStamp.frame =
-				StarShipPtr->RaceDescPtr->ship_data.special[0];
+		ConePtr->IntersectControl.IntersectStamp.frame = StarShipPtr->RaceDescPtr->ship_data.special[0];
 		UnlockElement (ConeArray[0]);
 	}
 
@@ -371,12 +521,30 @@ init_umgah (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	umgah_desc.preprocess_func = umgah_preprocess;
-	umgah_desc.postprocess_func = umgah_postprocess;
-	umgah_desc.init_weapon_func = initialize_cone;
-	umgah_desc.cyborg_control.intelligence_func = umgah_intelligence;
-
-	RaceDescPtr = &umgah_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		umgah_desc.preprocess_func = umgah_preprocess;
+		umgah_desc.postprocess_func = umgah_postprocess;
+		umgah_desc.init_weapon_func = initialize_cone;
+		umgah_desc.cyborg_control.intelligence_func = umgah_intelligence;
+		RaceDescPtr = &umgah_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		umgah_desc_2xres.preprocess_func = umgah_preprocess;
+		umgah_desc_2xres.postprocess_func = umgah_postprocess;
+		umgah_desc_2xres.init_weapon_func = initialize_cone;
+		umgah_desc_2xres.cyborg_control.intelligence_func = umgah_intelligence;
+		RaceDescPtr = &umgah_desc_2xres;
+	}
+	else
+	{
+		umgah_desc_4xres.preprocess_func = umgah_preprocess;
+		umgah_desc_4xres.postprocess_func = umgah_postprocess;
+		umgah_desc_4xres.init_weapon_func = initialize_cone;
+		umgah_desc_4xres.cyborg_control.intelligence_func = umgah_intelligence;
+		RaceDescPtr = &umgah_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/urquan/urquan.c ./src/uqm/ships/urquan/urquan.c
--- ./src.orig/uqm/ships/urquan/urquan.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/urquan/urquan.c	2017-10-23 11:41:35 -0700
@@ -20,6 +20,7 @@
 #include "urquan.h"
 #include "resinst.h"
 
+#include "uqm/colors.h"
 #include "uqm/globdata.h"
 
 #include <stdlib.h>
@@ -113,13 +114,167 @@ static RACE_DESC urquan_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 60
+#define THRUST_INCREMENT_2XRES 12
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (40)
+
+// JMS_GFX
+static RACE_DESC urquan_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		URQUAN_RACE_STRINGS,
+		URQUAN_ICON_MASK_PMAP_ANIM,
+		URQUAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			5750, 6000,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			URQUAN_BIG_MASK_PMAP_ANIM,
+			URQUAN_MED_MASK_PMAP_ANIM,
+			URQUAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FUSION_BIG_MASK_PMAP_ANIM,
+			FUSION_MED_MASK_PMAP_ANIM,
+			FUSION_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIGHTER_BIG_MASK_PMAP_ANIM,
+			FIGHTER_MED_MASK_PMAP_ANIM,
+			FIGHTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			URQUAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		URQUAN_VICTORY_SONG,
+		URQUAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 120
+#define THRUST_INCREMENT_4XRES 24
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (80)
+
+// JMS_GFX
+static RACE_DESC urquan_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		URQUAN_RACE_STRINGS,
+		URQUAN_ICON_MASK_PMAP_ANIM,
+		URQUAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			5750, 6000,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			URQUAN_BIG_MASK_PMAP_ANIM,
+			URQUAN_MED_MASK_PMAP_ANIM,
+			URQUAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FUSION_BIG_MASK_PMAP_ANIM,
+			FUSION_MED_MASK_PMAP_ANIM,
+			FUSION_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIGHTER_BIG_MASK_PMAP_ANIM,
+			FIGHTER_MED_MASK_PMAP_ANIM,
+			FIGHTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			URQUAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		URQUAN_VICTORY_SONG,
+		URQUAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_fusion (ELEMENT *ShipPtr, HELEMENT FusionArray[])
 {
 #define MISSILE_HITS 10
 #define MISSILE_DAMAGE 6
-#define MISSILE_OFFSET 8
-#define URQUAN_OFFSET 32
+#define MISSILE_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
+#define URQUAN_OFFSET (32 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -131,7 +286,7 @@ initialize_fusion (ELEMENT *ShipPtr, HEL
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = URQUAN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -143,13 +298,13 @@ initialize_fusion (ELEMENT *ShipPtr, HEL
 }
 
 #define TRACK_THRESHOLD 6
-#define FIGHTER_SPEED DISPLAY_TO_WORLD (8)
+#define FIGHTER_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 #define ONE_WAY_FLIGHT 125
 #define FIGHTER_LIFE (ONE_WAY_FLIGHT + ONE_WAY_FLIGHT + 150)
 
 #define FIGHTER_WEAPON_WAIT 8
-#define FIGHTER_OFFSET 4
-#define LASER_RANGE DISPLAY_TO_WORLD (40 + FIGHTER_OFFSET)
+#define FIGHTER_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
+#define LASER_RANGE DISPLAY_TO_WORLD ((40 << RESOLUTION_FACTOR) + FIGHTER_OFFSET) // JMS_GFX
 
 static void
 fighter_postprocess (ELEMENT *ElementPtr)
@@ -201,7 +356,7 @@ fighter_preprocess (ELEMENT *ElementPtr)
 	{
 		BOOLEAN Enroute;
 		COUNT orig_facing, facing;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 		ELEMENT *eptr;
 
 		Enroute = TRUE;
@@ -274,16 +429,16 @@ fighter_preprocess (ELEMENT *ElementPtr)
 				if (ElementPtr->turn_wait & LEFT)
 				{
 					delta_x += COSINE (FACING_TO_ANGLE (facing - 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR)); // JMS_GFX
 					delta_y += SINE (FACING_TO_ANGLE (facing - 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR));
 				}
 				else
 				{
 					delta_x += COSINE (FACING_TO_ANGLE (facing + 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR)); // JMS_GFX
 					delta_y += SINE (FACING_TO_ANGLE (facing + 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR));
 				}
 				facing = NORMALIZE_FACING (
 						ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))
@@ -394,19 +549,19 @@ spawn_fighters (ELEMENT *ElementPtr)
 {
 	SIZE i;
 	COUNT facing;
-	SIZE delta_x, delta_y;
+	SDWORD delta_x, delta_y;
 	HELEMENT hFighterElement;
 	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	facing = StarShipPtr->ShipFacing + ANGLE_TO_FACING (HALF_CIRCLE);
-	delta_x = COSINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14));
-	delta_y = SINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14));
+	delta_x = COSINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14 << RESOLUTION_FACTOR)); // JMS_GFX
+	delta_y = SINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14 << RESOLUTION_FACTOR));
 
 	i = ElementPtr->crew_level > 2 ? 2 : 1;
 	while (i-- && (hFighterElement = AllocElement ()))
 	{
-		SIZE sx, sy;
+		SDWORD sx, sy;
 		COUNT fighter_facing;
 		ELEMENT *FighterElementPtr;
 
@@ -471,16 +626,18 @@ urquan_intelligence (ELEMENT *ShipPtr, E
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 
-	 ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = PURSUE;
+	ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = PURSUE;
+	
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_WEAPON_INDEX];
+	
 	if (lpEvalDesc->ObjectPtr
 			&& lpEvalDesc->MoveState == ENTICE
-			&& (!(lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT)
-			|| lpEvalDesc->which_turn <= 8)
+			&& (!(lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT) || lpEvalDesc->which_turn <= 8)
 			&& (!(lpEvalDesc->ObjectPtr->state_flags & FINITE_LIFE)
-			|| (lpEvalDesc->ObjectPtr->mass_points >= 4
-			&& lpEvalDesc->which_turn == 2
-			&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 16)))
+				|| (lpEvalDesc->ObjectPtr->mass_points >= 4
+				&& lpEvalDesc->which_turn == 2
+				&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 16))
+		)
 		lpEvalDesc->MoveState = PURSUE;
 
 	ship_intelligence (ShipPtr,
@@ -495,18 +652,19 @@ urquan_intelligence (ELEMENT *ShipPtr, E
 		if (StarShipPtr->special_counter == 0
 				&& lpEvalDesc->ObjectPtr
 				&& StarShipPtr->RaceDescPtr->ship_info.crew_level >
-				(StarShipPtr->RaceDescPtr->ship_info.max_crew >> 2)
+					(StarShipPtr->RaceDescPtr->ship_info.max_crew >> 2)
 				&& !(EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags
-				& POINT_DEFENSE)
+					 & POINT_DEFENSE)
 				&& (StarShipPtr->RaceDescPtr->characteristics.special_wait < 6
 				|| (MANEUVERABILITY (
 						&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-						) <= SLOW_SHIP
+						) <= RESOLUTION_COMPENSATED(SLOW_SHIP) // JMS_GFX
 				&& !(EnemyStarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))
 				|| (lpEvalDesc->which_turn <= 12
 				&& (StarShipPtr->ship_input_state & (LEFT | RIGHT))
 				&& StarShipPtr->RaceDescPtr->ship_info.energy_level >=
-				(BYTE)(StarShipPtr->RaceDescPtr->ship_info.max_energy >> 1))))
+				(BYTE)(StarShipPtr->RaceDescPtr->ship_info.max_energy >> 1)))
+				&& !OBJECT_CLOAKED (lpEvalDesc->ObjectPtr)) // JMS
 			StarShipPtr->ship_input_state |= SPECIAL;
 		else
 			StarShipPtr->ship_input_state &= ~SPECIAL;
@@ -540,11 +698,27 @@ init_urquan (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	urquan_desc.postprocess_func = urquan_postprocess;
-	urquan_desc.init_weapon_func = initialize_fusion;
-	urquan_desc.cyborg_control.intelligence_func = urquan_intelligence;
-
-	RaceDescPtr = &urquan_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		urquan_desc.postprocess_func = urquan_postprocess;
+		urquan_desc.init_weapon_func = initialize_fusion;
+		urquan_desc.cyborg_control.intelligence_func = urquan_intelligence;
+		RaceDescPtr = &urquan_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		urquan_desc_2xres.postprocess_func = urquan_postprocess;
+		urquan_desc_2xres.init_weapon_func = initialize_fusion;
+		urquan_desc_2xres.cyborg_control.intelligence_func = urquan_intelligence;
+		RaceDescPtr = &urquan_desc_2xres;
+	}
+	else
+	{
+		urquan_desc_4xres.postprocess_func = urquan_postprocess;
+		urquan_desc_4xres.init_weapon_func = initialize_fusion;
+		urquan_desc_4xres.cyborg_control.intelligence_func = urquan_intelligence;
+		RaceDescPtr = &urquan_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/utwig/utwig.c ./src/uqm/ships/utwig/utwig.c
--- ./src.orig/uqm/ships/utwig/utwig.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/utwig/utwig.c	2017-10-23 11:41:35 -0700
@@ -39,7 +39,7 @@
 
 #define SHIP_MASS 8
 #define UTWIG_OFFSET 9
-#define MISSILE_SPEED DISPLAY_TO_WORLD (30)
+#define MISSILE_SPEED DISPLAY_TO_WORLD (30 << RESOLUTION_FACTOR)
 #define MISSILE_LIFE 10
 
 static RACE_DESC utwig_desc =
@@ -113,18 +113,170 @@ static RACE_DESC utwig_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 72
+#define THRUST_INCREMENT_2XRES 12
+
+// JMS_GFX
+static RACE_DESC utwig_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SHIELD_DEFENSE | LIGHT_POINT_DEFENSE,
+		22, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY >> 1, MAX_ENERGY,
+		UTWIG_RACE_STRINGS,
+		UTWIG_ICON_MASK_PMAP_ANIM,
+		UTWIG_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			8534, 8797,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UTWIG_BIG_MASK_PMAP_ANIM,
+			UTWIG_MED_MASK_PMAP_ANIM,
+			UTWIG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LANCE_BIG_MASK_PMAP_ANIM,
+			LANCE_MED_MASK_PMAP_ANIM,
+			LANCE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			UTWIG_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UTWIG_VICTORY_SONG,
+		UTWIG_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 144
+#define THRUST_INCREMENT_4XRES 24
+
+// JMS_GFX
+static RACE_DESC utwig_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SHIELD_DEFENSE | LIGHT_POINT_DEFENSE,
+		22, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY >> 1, MAX_ENERGY,
+		UTWIG_RACE_STRINGS,
+		UTWIG_ICON_MASK_PMAP_ANIM,
+		UTWIG_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			8534, 8797,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UTWIG_BIG_MASK_PMAP_ANIM,
+			UTWIG_MED_MASK_PMAP_ANIM,
+			UTWIG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LANCE_BIG_MASK_PMAP_ANIM,
+			LANCE_MED_MASK_PMAP_ANIM,
+			LANCE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			UTWIG_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UTWIG_VICTORY_SONG,
+		UTWIG_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_lance (ELEMENT *ShipPtr, HELEMENT WeaponArray[])
 {
-#define LAUNCH_XOFFS0 DISPLAY_TO_WORLD (5)
-#define LAUNCH_YOFFS0 -DISPLAY_TO_WORLD (18)
-#define LAUNCH_XOFFS1 DISPLAY_TO_WORLD (13)
-#define LAUNCH_YOFFS1 -DISPLAY_TO_WORLD (9)
-#define LAUNCH_XOFFS2 DISPLAY_TO_WORLD (17)
-#define LAUNCH_YOFFS2 -DISPLAY_TO_WORLD (4)
+#define LAUNCH_XOFFS0 DISPLAY_TO_WORLD (5 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_YOFFS0 -DISPLAY_TO_WORLD (18 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_XOFFS1 DISPLAY_TO_WORLD (13 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_YOFFS1 -DISPLAY_TO_WORLD (9 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_XOFFS2 DISPLAY_TO_WORLD (17 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_YOFFS2 -DISPLAY_TO_WORLD (4 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
 	COUNT i;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
@@ -311,8 +463,7 @@ utwig_preprocess (ELEMENT *ElementPtr)
 	if (StarShipPtr->special_counter == 0)
 	{
 		// The shield is off.
-		SetPrimColor (lpPrim,
-				BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1C, 0x00), 0x78));
+		SetPrimColor (lpPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1C, 0x00), 0x78));
 		ElementPtr->colorCycleIndex = 0;
 		ElementPtr->life_span = NORMAL_LIFE;
 		SetPrimType (lpPrim, STAMP_PRIM);
@@ -366,11 +517,27 @@ init_utwig (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	utwig_desc.preprocess_func = utwig_preprocess;
-	utwig_desc.init_weapon_func = initialize_lance;
-	utwig_desc.cyborg_control.intelligence_func = utwig_intelligence;
-
-	RaceDescPtr = &utwig_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		utwig_desc.preprocess_func = utwig_preprocess;
+		utwig_desc.init_weapon_func = initialize_lance;
+		utwig_desc.cyborg_control.intelligence_func = utwig_intelligence;
+		RaceDescPtr = &utwig_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		utwig_desc_2xres.preprocess_func = utwig_preprocess;
+		utwig_desc_2xres.init_weapon_func = initialize_lance;
+		utwig_desc_2xres.cyborg_control.intelligence_func = utwig_intelligence;
+		RaceDescPtr = &utwig_desc_2xres;
+	}
+	else
+	{
+		utwig_desc_4xres.preprocess_func = utwig_preprocess;
+		utwig_desc_4xres.init_weapon_func = initialize_lance;
+		utwig_desc_4xres.cyborg_control.intelligence_func = utwig_intelligence;
+		RaceDescPtr = &utwig_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/vux/vux.c ./src/uqm/ships/vux/vux.c
--- ./src.orig/uqm/ships/vux/vux.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/vux/vux.c	2017-10-23 11:41:35 -0700
@@ -38,9 +38,9 @@
 #define SPECIAL_WAIT 7
 
 #define SHIP_MASS 6
-#define WARP_OFFSET 46 /* How far outside of laser-range ship can warp in */
-#define VUX_OFFSET 12
-#define LASER_BASE 150
+#define WARP_OFFSET (46 << RESOLUTION_FACTOR) // JMS_GFX /* How far outside of laser-range ship can warp in */
+#define VUX_OFFSET (12 << RESOLUTION_FACTOR) // JMS_GFX
+#define LASER_BASE (150 << RESOLUTION_FACTOR) // JMS_GFX
 #define LASER_RANGE DISPLAY_TO_WORLD (LASER_BASE + VUX_OFFSET)
 
 static RACE_DESC vux_desc =
@@ -114,7 +114,159 @@ static RACE_DESC vux_desc =
 	0, /* CodeRef */
 };
 
-#define LIMPET_SPEED 25
+// JMS_GFX
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (5) */ 42
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 14
+
+// JMS_GFX
+static RACE_DESC vux_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL | IMMEDIATE_WEAPON,
+		12, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		VUX_RACE_STRINGS,
+		VUX_ICON_MASK_PMAP_ANIM,
+		VUX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		900 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			4412, 1558,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			VUX_BIG_MASK_PMAP_ANIM,
+			VUX_MED_MASK_PMAP_ANIM,
+			VUX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SLIME_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			LIMPETS_BIG_MASK_PMAP_ANIM,
+			LIMPETS_MED_MASK_PMAP_ANIM,
+			LIMPETS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			VUX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		VUX_VICTORY_SONG,
+		VUX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (5) */ 84
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 28
+
+// JMS_GFX
+static RACE_DESC vux_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SEEKING_SPECIAL | IMMEDIATE_WEAPON,
+		12, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		VUX_RACE_STRINGS,
+		VUX_ICON_MASK_PMAP_ANIM,
+		VUX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		900 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			4412, 1558,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			VUX_BIG_MASK_PMAP_ANIM,
+			VUX_MED_MASK_PMAP_ANIM,
+			VUX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SLIME_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			LIMPETS_BIG_MASK_PMAP_ANIM,
+			LIMPETS_MED_MASK_PMAP_ANIM,
+			LIMPETS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			VUX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		VUX_VICTORY_SONG,
+		VUX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define LIMPET_SPEED (25 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 limpet_preprocess (ELEMENT *ElementPtr)
@@ -122,18 +274,15 @@ limpet_preprocess (ELEMENT *ElementPtr)
 	COUNT facing, orig_facing;
 	SIZE delta_facing;
 
-	facing = orig_facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-			GetVelocityTravelAngle (&ElementPtr->velocity)
-			));
+	facing = orig_facing = NORMALIZE_FACING (ANGLE_TO_FACING (GetVelocityTravelAngle (&ElementPtr->velocity)));
+	
 	if ((delta_facing = TrackShip (ElementPtr, &facing)) > 0)
 	{
 		facing = orig_facing + delta_facing;
-		SetVelocityVector (&ElementPtr->velocity,
-				LIMPET_SPEED, facing);
+		SetVelocityVector (&ElementPtr->velocity, LIMPET_SPEED, facing);
 	}
-	ElementPtr->next.image.frame =
-			 IncFrameIndex (ElementPtr->next.image.frame);
-
+	
+	ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->next.image.frame);
 	ElementPtr->state_flags |= CHANGING;
 }
 
@@ -154,7 +303,7 @@ limpet_collision (ELEMENT *ElementPtr0,
 			--RDPtr->characteristics.turn_wait;
 		if (++RDPtr->characteristics.thrust_wait == 0)
 			--RDPtr->characteristics.thrust_wait;
-#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1)
+#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1 << RESOLUTION_FACTOR) // JMS_GFX
 		if (RDPtr->characteristics.thrust_increment <= MIN_THRUST_INCREMENT)
 		{
 			RDPtr->characteristics.max_thrust =
@@ -166,7 +315,7 @@ limpet_collision (ELEMENT *ElementPtr0,
 
 			num_thrusts = RDPtr->characteristics.max_thrust /
 					RDPtr->characteristics.thrust_increment;
-			--RDPtr->characteristics.thrust_increment;
+			RDPtr->characteristics.thrust_increment -= 1 << RESOLUTION_FACTOR; // JMS_GFX
 			RDPtr->characteristics.max_thrust =
 					RDPtr->characteristics.thrust_increment * num_thrusts;
 		}
@@ -193,7 +342,7 @@ limpet_collision (ELEMENT *ElementPtr0,
 static void
 spawn_limpets (ELEMENT *ElementPtr)
 {
-#define LIMPET_OFFSET 8
+#define LIMPET_OFFSET (8 << RESOLUTION_FACTOR) // JMS_GFX
 #define LIMPET_LIFE 80
 #define LIMPET_HITS 1
 #define LIMPET_DAMAGE 0
@@ -333,7 +482,7 @@ vux_preprocess (ELEMENT *ElementPtr)
 				// But in reality this should be relative to the laser-range
 #define MAXX_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
 #define MAXY_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
-				SIZE dx, dy;
+				SDWORD dx, dy;
 
 				ElementPtr->current.location.x =
 						(OtherShipPtr->current.location.x -
@@ -381,12 +530,30 @@ init_vux (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	vux_desc.preprocess_func = vux_preprocess;
-	vux_desc.postprocess_func = vux_postprocess;
-	vux_desc.init_weapon_func = initialize_horrific_laser;
-	vux_desc.cyborg_control.intelligence_func = vux_intelligence;
-
-	RaceDescPtr = &vux_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		vux_desc.preprocess_func = vux_preprocess;
+		vux_desc.postprocess_func = vux_postprocess;
+		vux_desc.init_weapon_func = initialize_horrific_laser;
+		vux_desc.cyborg_control.intelligence_func = vux_intelligence;
+		RaceDescPtr = &vux_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		vux_desc_2xres.preprocess_func = vux_preprocess;
+		vux_desc_2xres.postprocess_func = vux_postprocess;
+		vux_desc_2xres.init_weapon_func = initialize_horrific_laser;
+		vux_desc_2xres.cyborg_control.intelligence_func = vux_intelligence;
+		RaceDescPtr = &vux_desc_2xres;
+	}
+	else
+	{
+		vux_desc_4xres.preprocess_func = vux_preprocess;
+		vux_desc_4xres.postprocess_func = vux_postprocess;
+		vux_desc_4xres.init_weapon_func = initialize_horrific_laser;
+		vux_desc_4xres.cyborg_control.intelligence_func = vux_intelligence;
+		RaceDescPtr = &vux_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/yehat/yehat.c ./src/uqm/ships/yehat/yehat.c
--- ./src.orig/uqm/ships/yehat/yehat.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/yehat/yehat.c	2017-10-23 11:41:35 -0700
@@ -111,15 +111,169 @@ static RACE_DESC yehat_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+#define MAX_THRUST_2XRES 60
+#define THRUST_INCREMENT_2XRES 12
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (40)
+
+// JMS_GFX
+static RACE_DESC yehat_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SHIELD_DEFENSE,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		YEHAT_RACE_STRINGS,
+		YEHAT_ICON_MASK_PMAP_ANIM,
+		YEHAT_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		750 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			4970, 40,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			YEHAT_BIG_MASK_PMAP_ANIM,
+			YEHAT_MED_MASK_PMAP_ANIM,
+			YEHAT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YEHAT_CANNON_BIG_MASK_PMAP_ANIM,
+			YEHAT_CANNON_MED_MASK_PMAP_ANIM,
+			YEHAT_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SHIELD_BIG_MASK_ANIM,
+			SHIELD_MED_MASK_ANIM,
+			SHIELD_SML_MASK_ANIM,
+		},
+		{
+			YEHAT_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		YEHAT_VICTORY_SONG,
+		YEHAT_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE / 3,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 120
+#define THRUST_INCREMENT_4XRES 24
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (80)
+
+// JMS_GFX
+static RACE_DESC yehat_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE | SHIELD_DEFENSE,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		YEHAT_RACE_STRINGS,
+		YEHAT_ICON_MASK_PMAP_ANIM,
+		YEHAT_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		750 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			4970, 40,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			YEHAT_BIG_MASK_PMAP_ANIM,
+			YEHAT_MED_MASK_PMAP_ANIM,
+			YEHAT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YEHAT_CANNON_BIG_MASK_PMAP_ANIM,
+			YEHAT_CANNON_MED_MASK_PMAP_ANIM,
+			YEHAT_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SHIELD_BIG_MASK_ANIM,
+			SHIELD_MED_MASK_ANIM,
+			SHIELD_SML_MASK_ANIM,
+		},
+		{
+			YEHAT_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		YEHAT_VICTORY_SONG,
+		YEHAT_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE / 3,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_standard_missiles (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-#define YEHAT_OFFSET 16
-#define LAUNCH_OFFS DISPLAY_TO_WORLD (8)
+#define YEHAT_OFFSET (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define LAUNCH_OFFS DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR) // JMS_GFX
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
-	SIZE offs_x, offs_y;
+#define MISSILE_OFFSET (1 << RESOLUTION_FACTOR) // JMS_GFX
+	SDWORD offs_x, offs_y;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -129,7 +283,7 @@ initialize_standard_missiles (ELEMENT *S
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = YEHAT_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = MISSILE_SPEED << RESOLUTION_FACTOR; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -151,8 +305,7 @@ initialize_standard_missiles (ELEMENT *S
 }
 
 static void
-yehat_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+yehat_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern, COUNT ConcernCounter)
 {
 	SIZE ShieldStatus;
 	STARSHIP *StarShipPtr;
@@ -314,10 +467,7 @@ yehat_preprocess (ELEMENT *ElementPtr)
 						== StarShipPtr->RaceDescPtr->ship_data.special))
 		{
 #ifdef NEVER
-			SetPrimType (
-					&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex],
-					STAMP_PRIM
-					);
+			SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr->PrimIndex], STAMP_PRIM);
 #endif /* NEVER */
 
 			ElementPtr->next.image.farray = StarShipPtr->RaceDescPtr->ship_data.ship;
@@ -355,12 +505,30 @@ init_yehat (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	yehat_desc.preprocess_func = yehat_preprocess;
-	yehat_desc.postprocess_func = yehat_postprocess;
-	yehat_desc.init_weapon_func = initialize_standard_missiles;
-	yehat_desc.cyborg_control.intelligence_func = yehat_intelligence;
-
-	RaceDescPtr = &yehat_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		yehat_desc.preprocess_func = yehat_preprocess;
+		yehat_desc.postprocess_func = yehat_postprocess;
+		yehat_desc.init_weapon_func = initialize_standard_missiles;
+		yehat_desc.cyborg_control.intelligence_func = yehat_intelligence;
+		RaceDescPtr = &yehat_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		yehat_desc_2xres.preprocess_func = yehat_preprocess;
+		yehat_desc_2xres.postprocess_func = yehat_postprocess;
+		yehat_desc_2xres.init_weapon_func = initialize_standard_missiles;
+		yehat_desc_2xres.cyborg_control.intelligence_func = yehat_intelligence;
+		RaceDescPtr = &yehat_desc_2xres;
+	}
+	else
+	{
+		yehat_desc_4xres.preprocess_func = yehat_preprocess;
+		yehat_desc_4xres.postprocess_func = yehat_postprocess;
+		yehat_desc_4xres.init_weapon_func = initialize_standard_missiles;
+		yehat_desc_4xres.cyborg_control.intelligence_func = yehat_intelligence;
+		RaceDescPtr = &yehat_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/ships/zoqfot/zoqfot.c ./src/uqm/ships/zoqfot/zoqfot.c
--- ./src.orig/uqm/ships/zoqfot/zoqfot.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/ships/zoqfot/zoqfot.c	2017-10-23 11:41:35 -0700
@@ -112,7 +112,163 @@ static RACE_DESC zoqfotpik_desc =
 	0, /* CodeRef */
 };
 
-#define ZOQFOTPIK_OFFSET 13
+// JMS_GFX
+#define MAX_THRUST_2XRES 80
+#define THRUST_INCREMENT_2XRES 20
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (20)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC zoqfotpik_desc_2xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		6, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ZOQFOTPIK_RACE_STRINGS,
+		ZOQFOTPIK_ICON_MASK_PMAP_ANIM,
+		ZOQFOTPIK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		320 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			3761, 5333,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ZOQFOTPIK_BIG_MASK_PMAP_ANIM,
+			ZOQFOTPIK_MED_MASK_PMAP_ANIM,
+			ZOQFOTPIK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPIT_BIG_MASK_PMAP_ANIM,
+			SPIT_MED_MASK_PMAP_ANIM,
+			SPIT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			STINGER_BIG_MASK_PMAP_ANIM,
+			STINGER_MED_MASK_PMAP_ANIM,
+			STINGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ZOQFOTPIK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ZOQFOTPIK_VICTORY_SONG,
+		ZOQFOTPIK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+#define MAX_THRUST_4XRES 160
+#define THRUST_INCREMENT_4XRES 40
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (40)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_4XRES * MISSILE_LIFE)
+
+// JMS_GFX
+static RACE_DESC zoqfotpik_desc_4xres =
+{
+	{ /* SHIP_INFO */
+		FIRES_FORE,
+		6, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ZOQFOTPIK_RACE_STRINGS,
+		ZOQFOTPIK_ICON_MASK_PMAP_ANIM,
+		ZOQFOTPIK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		320 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			3761, 5333,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ZOQFOTPIK_BIG_MASK_PMAP_ANIM,
+			ZOQFOTPIK_MED_MASK_PMAP_ANIM,
+			ZOQFOTPIK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPIT_BIG_MASK_PMAP_ANIM,
+			SPIT_MED_MASK_PMAP_ANIM,
+			SPIT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			STINGER_BIG_MASK_PMAP_ANIM,
+			STINGER_MED_MASK_PMAP_ANIM,
+			STINGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ZOQFOTPIK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ZOQFOTPIK_VICTORY_SONG,
+		ZOQFOTPIK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+#define ZOQFOTPIK_OFFSET (13 << RESOLUTION_FACTOR) // JMS_GFX
 #define SPIT_WAIT 2
 
 static void
@@ -124,17 +280,15 @@ spit_preprocess (ELEMENT *ElementPtr)
 	{
 		COUNT index, angle, speed;
 
-		ElementPtr->next.image.frame =
-				IncFrameIndex (ElementPtr->next.image.frame);
+		ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->next.image.frame);
 		angle = GetVelocityTravelAngle (&ElementPtr->velocity);
+		
 		if ((index = GetFrameIndex (ElementPtr->next.image.frame)) == 1)
 			angle = angle + (((COUNT)TFB_Random () % 3) - 1);
 
-		speed = WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (
-				GetFrameCount (ElementPtr->next.image.frame) - index) << 1);
-		SetVelocityComponents (&ElementPtr->velocity,
-				(SIZE)COSINE (angle, speed),
-				(SIZE)SINE (angle, speed));
+		speed = WORLD_TO_VELOCITY (DISPLAY_TO_WORLD ((GetFrameCount (ElementPtr->next.image.frame) - index) << RESOLUTION_FACTOR) << 1); // JMS_GFX
+		
+		SetVelocityComponents (&ElementPtr->velocity, (SIZE)COSINE (angle, speed), (SIZE)SINE (angle, speed));
 
 		ElementPtr->turn_wait = SPIT_WAIT;
 		ElementPtr->state_flags |= CHANGING;
@@ -159,8 +313,7 @@ initialize_spit (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = ZOQFOTPIK_OFFSET;
-	MissileBlock.speed = DISPLAY_TO_WORLD (
-			GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.weapon[0])) << 1;
+	MissileBlock.speed = DISPLAY_TO_WORLD ((GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.weapon[0])) << RESOLUTION_FACTOR) << 1; // JMS_GFX
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -187,8 +340,7 @@ tongue_collision (ELEMENT *ElementPtr0,
 	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr0, &StarShipPtr);
-	if (StarShipPtr->special_counter ==
-			StarShipPtr->RaceDescPtr->characteristics.special_wait)
+	if (StarShipPtr->special_counter == StarShipPtr->RaceDescPtr->characteristics.special_wait)
 		weapon_collision (ElementPtr0, pPt0, ElementPtr1, pPt1);
 
 	StarShipPtr->special_counter -= ElementPtr0->turn_wait;
@@ -202,7 +354,7 @@ spawn_tongue (ELEMENT *ElementPtr)
 #define TONGUE_SPEED 0
 #define TONGUE_HITS 1
 #define TONGUE_DAMAGE 12
-#define TONGUE_OFFSET 4
+#define TONGUE_OFFSET (4 << RESOLUTION_FACTOR) // JMS_GFX
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK TongueBlock;
 	HELEMENT Tongue;
@@ -235,7 +387,7 @@ spawn_tongue (ELEMENT *ElementPtr)
 		{
 			COUNT angle;
 			RECT r;
-			SIZE x_offs, y_offs;
+			SDWORD x_offs, y_offs;
 
 			TonguePtr->turn_wait = ElementPtr->turn_wait - 1;
 
@@ -284,7 +436,7 @@ zoqfotpik_intelligence (ELEMENT *ShipPtr
 #endif /* NEVER */
 				)
 		{
-			SIZE delta_x, delta_y;
+			SDWORD delta_x, delta_y;
 
 			GiveTongueJob = TRUE;
 
@@ -322,7 +474,7 @@ zoqfotpik_intelligence (ELEMENT *ShipPtr
 #endif /* NEVER */
 						))
 						&& ship_weapons (ShipPtr,
-						ObjectsOfConcern->ObjectPtr, DISPLAY_TO_WORLD (20)))
+						ObjectsOfConcern->ObjectPtr, DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR))) // JMS_GFX
 				{
 					StarShipPtr->ship_input_state |= WEAPON;
 					break;
@@ -346,8 +498,7 @@ zoqfotpik_postprocess (ELEMENT *ElementP
 					/* STICK_OUT_TONGUE */
 				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1), ElementPtr);
 
-		StarShipPtr->special_counter =
-				StarShipPtr->RaceDescPtr->characteristics.special_wait;
+		StarShipPtr->special_counter = StarShipPtr->RaceDescPtr->characteristics.special_wait;
 	}
 
 	if (StarShipPtr->special_counter)
@@ -359,11 +510,27 @@ init_zoqfotpik (void)
 {
 	RACE_DESC *RaceDescPtr;
 
-	zoqfotpik_desc.postprocess_func = zoqfotpik_postprocess;
-	zoqfotpik_desc.init_weapon_func = initialize_spit;
-	zoqfotpik_desc.cyborg_control.intelligence_func = zoqfotpik_intelligence;
-
-	RaceDescPtr = &zoqfotpik_desc;
+	if (RESOLUTION_FACTOR == 0)
+	{
+		zoqfotpik_desc.postprocess_func = zoqfotpik_postprocess;
+		zoqfotpik_desc.init_weapon_func = initialize_spit;
+		zoqfotpik_desc.cyborg_control.intelligence_func = zoqfotpik_intelligence;
+		RaceDescPtr = &zoqfotpik_desc;
+	}
+	else if (RESOLUTION_FACTOR == 1)
+	{
+		zoqfotpik_desc_2xres.postprocess_func = zoqfotpik_postprocess;
+		zoqfotpik_desc_2xres.init_weapon_func = initialize_spit;
+		zoqfotpik_desc_2xres.cyborg_control.intelligence_func = zoqfotpik_intelligence;
+		RaceDescPtr = &zoqfotpik_desc_2xres;
+	}
+	else
+	{
+		zoqfotpik_desc_4xres.postprocess_func = zoqfotpik_postprocess;
+		zoqfotpik_desc_4xres.init_weapon_func = initialize_spit;
+		zoqfotpik_desc_4xres.cyborg_control.intelligence_func = zoqfotpik_intelligence;
+		RaceDescPtr = &zoqfotpik_desc_4xres;
+	}
 
 	return (RaceDescPtr);
 }
diff -ruNp ./src.orig/uqm/shipstat.c ./src/uqm/shipstat.c
--- ./src.orig/uqm/shipstat.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/shipstat.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "colors.h"
 #include "globdata.h"
 #include "options.h"
@@ -29,22 +31,25 @@ DrawCrewFuelString (COORD y, SIZE state)
 {
 	STAMP Stamp;
 
-	Stamp.origin.y = y + GAUGE_YOFFS + STARCON_TEXT_HEIGHT;
+	Stamp.origin.y = y + GAUGE_YOFFS + STARCON_TEXT_HEIGHT - RES_CASE(0,6,12);
+	
 	if (state == 0)
 	{
-		Stamp.origin.x = CREW_XOFFS + (STAT_WIDTH >> 1) + 6;
+		Stamp.origin.x = CREW_XOFFS + (STAT_WIDTH >> 1) + RES_STAT_SCALE(6) - RES_CASE(0,8,8); // JMS_GFX
 		if (optWhichMenu == OPT_PC)
 			Stamp.frame = SetAbsFrameIndex (StatusFrame, 4);
 		else
 			Stamp.frame = SetAbsFrameIndex (StatusFrame, 0);
 		DrawStamp (&Stamp);
 	}
+	
+	Stamp.origin.x = ENERGY_XOFFS + (STAT_WIDTH >> 1) - RES_STAT_SCALE(5) + RES_CASE(0,10,10); // JMS_GFX
 
-	Stamp.origin.x = ENERGY_XOFFS + (STAT_WIDTH >> 1) - 5;
 	if (optWhichMenu == OPT_PC)
 		Stamp.frame = SetAbsFrameIndex (StatusFrame, 5);
 	else
 		Stamp.frame = SetAbsFrameIndex (StatusFrame, 1);
+	
 	if (state >= 0)
 		DrawStamp (&Stamp);
 	else
@@ -67,7 +72,7 @@ DrawShipNameString (UNICODE *pStr, COUNT
 	Text.CharCount = CharCount;
 	Text.align = ALIGN_CENTER;
 
-	Text.baseline.y = STARCON_TEXT_HEIGHT + 3 + y;
+	Text.baseline.y = STARCON_TEXT_HEIGHT + y + (3 << RESOLUTION_FACTOR) - 6 * RESOLUTION_FACTOR; // JMS_GFX
 	Text.baseline.x = STATUS_WIDTH >> 1;
 
 	SetContextForeGroundColor (
@@ -81,73 +86,81 @@ DrawShipNameString (UNICODE *pStr, COUNT
 }
 
 void
-ClearShipStatus (COORD y)
+ClearShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu)
 {
 	RECT r;
-
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+	
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 	r.corner.x = 2;
 	r.corner.y = 3 + y;
-	r.extent.width = STATUS_WIDTH - 4;
-	r.extent.height = SHIP_INFO_HEIGHT - 3;
+	r.extent.width = w - 4;
+	r.extent.height = SHIP_INFO_HEIGHT - (inMeleeMenu ? RES_CASE(3,1,6) : 3); // JMS_GFX
 	DrawFilledRectangle (&r);
 }
 
 void
-OutlineShipStatus (COORD y)
+OutlineShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu)
 {
 	RECT r;
-
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
+	
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 	r.corner.x = 0;
 	r.corner.y = 1 + y;
-	r.extent.width = STATUS_WIDTH;
+	r.extent.width = w;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
 	++r.corner.y;
 	--r.extent.width;
 	DrawFilledRectangle (&r);
 	r.extent.width = 1;
-	r.extent.height = SHIP_INFO_HEIGHT - 2;
+	r.extent.height = SHIP_INFO_HEIGHT - RES_CASE(1,inMeleeMenu?-1:2,inMeleeMenu?5:0);
 	DrawFilledRectangle (&r);
 	++r.corner.x;
 	DrawFilledRectangle (&r);
-
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
-	r.corner.x = STATUS_WIDTH - 1;
+	
+	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
+	r.corner.x = w - 1;
 	DrawFilledRectangle (&r);
-	r.corner.x = STATUS_WIDTH - 2;
+	r.corner.x = w - 2;
 	++r.corner.y;
 	--r.extent.height;
 	DrawFilledRectangle (&r);
-
+	r.corner.x = 1;
+	r.corner.y = SHIP_INFO_HEIGHT + RES_CASE(2,3,-2);
+	r.extent.width = w - 2;
+	r.extent.height = 1;
+	if (inMeleeMenu)
+		DrawFilledRectangle (&r);
+	++r.corner.x;
+	--r.corner.y;
+	if (inMeleeMenu)
+		DrawFilledRectangle (&r);
+	
 	SetContextForeGroundColor (BLACK_COLOR);
 	r.corner.x = 0;
 	r.corner.y = y;
-	r.extent.width = STATUS_WIDTH;
+	r.extent.width = w;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
 }
 
 void
-InitShipStatus (SHIP_INFO *SIPtr, STARSHIP *StarShipPtr, RECT *pClipRect)
+InitShipStatus (SHIP_INFO *SIPtr, STARSHIP *StarShipPtr, RECT *pClipRect, BOOLEAN inMeleeMenu)
 {
 	RECT r;
 	COORD y = 0; // default, for Melee menu
+	COORD width = STATUS_WIDTH; // BW: ShipStatus has less space in 2x and 4x MeleeMenu
 	STAMP Stamp;
 	CONTEXT OldContext;
 	RECT oldClipRect;
 	POINT oldOrigin = {0, 0};
-
+	
 	if (StarShipPtr) // set during battle
 	{
 		assert (StarShipPtr->playerNr >= 0);
 		y = status_y_offsets[StarShipPtr->playerNr];
 	}
-
+	
 	OldContext = SetContext (StatusContext);
 	if (pClipRect)
 	{
@@ -160,29 +173,44 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		SetContextClipRect (&r);
 		// Offset the origin so that we draw into the cliprect
 		oldOrigin = SetContextOrigin (MAKE_POINT (-pClipRect->corner.x,
-				-(pClipRect->corner.y & ~1)));
+												  -(pClipRect->corner.y & ~1)));
 	}
-
+	
 	BatchGraphics ();
 	
-	OutlineShipStatus (y);
-	ClearShipStatus (y);
-
+	OutlineShipStatus (y, width, inMeleeMenu);
+	ClearShipStatus (y, width, inMeleeMenu);
+	
 	Stamp.origin.x = (STATUS_WIDTH >> 1);
-	Stamp.origin.y = 31 + y;
+	Stamp.origin.y = (31 << RESOLUTION_FACTOR) + y;
 	Stamp.frame = IncFrameIndex (SIPtr->icons);
 	DrawStamp (&Stamp);
-
+	
 	{
 		SIZE crew_height, energy_height;
-
+		
 #define MIN(a, b) (((a) <= (b)) ? (a) : (b))
-		crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) & ~1) + 1;
+		// At basic resolution.
+		if (RESOLUTION_FACTOR == 0)
+		{
+			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) & ~1) + 1;
+			energy_height = (((SIPtr->max_energy + 1) >> 1) << 1) + 1;
+		}
+		// At hi-res 2x.
+		else if (RESOLUTION_FACTOR == 1)
+		{
+			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) * 1.5);
+			energy_height = (((SIPtr->max_energy + 1) >> 1) * 3) + 1;
+		}
+		// At hi-res 4x.
+		else
+		{
+			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) * 2.5) - 1;
+			energy_height = (((SIPtr->max_energy + 1) >> 1) * 5) + 1;
+		}
 #undef MIN
-		energy_height = (((SIPtr->max_energy + 1) >> 1) << 1) + 1;
-
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
+		
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 		r.corner.x = CREW_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS + 1 + y;
 		r.extent.width = STAT_WIDTH + 2;
@@ -200,8 +228,7 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		r.extent.width = 1;
 		r.extent.height = crew_height;
 		DrawFilledRectangle (&r);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 		r.corner.x = CREW_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS - crew_height + y;
 		r.extent.width = STAT_WIDTH + 2;
@@ -217,9 +244,9 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		r.corner.y = GAUGE_YOFFS - crew_height + y;
 		r.extent.height = crew_height + 1;
 		DrawFilledRectangle (&r);
-
+		
 		SetContextForeGroundColor (BLACK_COLOR);
-
+		
 		r.extent.width = STAT_WIDTH;
 		r.corner.x = CREW_XOFFS;
 		r.extent.height = crew_height;
@@ -230,26 +257,26 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		r.corner.y = y - r.extent.height + GAUGE_YOFFS + 1;
 		DrawFilledRectangle (&r);
 	}
-
+	
 	if (!StarShipPtr || StarShipPtr->captains_name_index)
 	{	// Any regular ship. SIS and Sa-Matra are separate.
 		// This includes Melee menu.
 		STRING locString;
-
+		
 		DrawCrewFuelString (y, 0);
-
+		
 		locString = SetAbsStringTableIndex (SIPtr->race_strings, 1);
 		DrawShipNameString (
-				(UNICODE *)GetStringAddress (locString),
-				GetStringLength (locString), y);
-
+							(UNICODE *)GetStringAddress (locString),
+							GetStringLength (locString), y);
+		
 		{
 			UNICODE buf[30];
 			TEXT Text;
 			FONT OldFont;
-
+			
 			OldFont = SetContextFont (TinyFont);
-
+			
 			if (!StarShipPtr)
 			{	// In Melee menu
 				sprintf (buf, "%d", SIPtr->ship_cost);
@@ -259,18 +286,18 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 			else
 			{
 				locString = SetAbsStringTableIndex (SIPtr->race_strings,
-						StarShipPtr->captains_name_index);
+													StarShipPtr->captains_name_index);
 				Text.pStr = (UNICODE *)GetStringAddress (locString);
 				Text.CharCount = GetStringLength (locString);
 			}
 			Text.align = ALIGN_CENTER;
-
+			
 			Text.baseline.x = STATUS_WIDTH >> 1;
 			Text.baseline.y = y + GAUGE_YOFFS + 3;
-
+			
 			SetContextForeGroundColor (BLACK_COLOR);
 			font_DrawText (&Text);
-
+			
 			SetContextFont (OldFont);
 		}
 	}
@@ -279,10 +306,10 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		DrawCrewFuelString (y, 0);
 		DrawShipNameString (GLOBAL_SIS (ShipName), (COUNT)~0, y);
 	}
-
+	
 	{
 		SIZE crew_delta, energy_delta;
-
+		
 		crew_delta = SIPtr->crew_level;
 		energy_delta = SIPtr->energy_level;
 		// DeltaStatistics() below will add specified values to these
@@ -290,15 +317,15 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 		SIPtr->energy_level = 0;
 		DeltaStatistics (SIPtr, y, crew_delta, energy_delta);
 	}
-
+	
 	UnbatchGraphics ();
-
+	
 	if (pClipRect)
 	{
 		SetContextOrigin (oldOrigin);
 		SetContextClipRect (&oldClipRect);
 	}
-
+	
 	SetContext (OldContext);
 }
 
diff -ruNp ./src.orig/uqm/shipyard.c ./src/uqm/shipyard.c
--- ./src.orig/uqm/shipyard.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/shipyard.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "build.h"
 #include "colors.h"
 #include "controls.h"
@@ -37,8 +39,10 @@
 #include "sounds.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
+#include "libs/log.h"
 
 
+// Don't worry about the 3DO doors. We never want to use the 3DO hangar view.
 #ifdef USE_3DO_HANGAR
 // 3DO 4x3 hangar layout
 #	define HANGAR_SHIPS_ROW  4
@@ -50,15 +54,31 @@ static const COORD hangar_x_coords[HANGA
 	19, 60, 116, 157
 };
 
+// We always wanna use the PC hangar view.
 #else // use PC hangar
 // modified PC 6x2 hangar layout
-#	define HANGAR_SHIPS_ROW  6
-#	define HANGAR_Y          88
-#	define HANGAR_DY         84
+# define HANGAR_SHIPS_ROW  6
 
-static const COORD hangar_x_coords[HANGAR_SHIPS_ROW] =
+// The Y position of the upper line of hangar bay doors.
+# define HANGAR_Y          ((88 << RESOLUTION_FACTOR) - RES_CASE(0,3,2)) // JMS_GFX
+
+// The Y position of the lower line of hangar bay doors.
+# define HANGAR_DY         ((84 << RESOLUTION_FACTOR) + RES_CASE(0,1,2)) // JMS_GFX
+
+
+// The X positions of the hangar bay doors for each resolution mode.
+// Calculated from the right edge of the left grey border bar on the screen.
+static const COORD hangar_x_coords_1x[HANGAR_SHIPS_ROW] =
+{
+	0, 38, 76, 131, 169, 207
+};
+static const COORD hangar_x_coords_2x[HANGAR_SHIPS_ROW] =
 {
-	0, 38, 76,  131, 169, 207
+	2, 79, 157, 268, 346, 424
+};
+static const COORD hangar_x_coords_4x[HANGAR_SHIPS_ROW] =
+{
+	3, 171, 339, 578, 746, 914
 };
 #endif // USE_3DO_HANGAR
 
@@ -194,9 +214,9 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 	s.origin.x = RADAR_X - r.corner.x;
 	s.origin.y = RADAR_Y - r.corner.y;
 	r.corner.x = s.origin.x - 1;
-	r.corner.y = s.origin.y - 11;
+	r.corner.y = s.origin.y - RES_CASE(11,24,33); // JMS_GFX
 	r.extent.width = RADAR_WIDTH + 2;
-	r.extent.height = 11;
+	r.extent.height = RES_CASE(11,24,33); // JMS_GFX
 	BatchGraphics ();
 	ClearSISRect (CLEAR_SIS_RADAR);
 	SetContextForeGroundColor (
@@ -238,8 +258,15 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 		t.pStr = buf;
 		sprintf (buf, "%u", ShipCost[NewRaceItem]);
 		SetContextFont (TinyFont);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
+
+		if ((ShipCost[NewRaceItem]) <= (GLOBAL_SIS (ResUnits)))
+		{
+			SetContextForeGroundColor (BRIGHT_GREEN_COLOR);
+		} else if ((ShipCost[NewRaceItem]) > (GLOBAL_SIS (ResUnits)))
+		{ /* We don't have enough to purchase this ship. */
+			SetContextForeGroundColor (BRIGHT_RED_COLOR);
+		}
+
 		font_DrawText (&t);
 	}
 	UnbatchGraphics ();
@@ -250,9 +277,16 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 	UnlockMutex (GraphicsLock);
 }
 
-#define SHIP_WIN_WIDTH 34
-#define SHIP_WIN_HEIGHT (SHIP_WIN_WIDTH + 6)
-#define SHIP_WIN_FRAMES ((SHIP_WIN_WIDTH >> 1) + 1)
+// Width of an escort ship window.
+#define SHIP_WIN_WIDTH RES_CASE(34, 72, 156) // JMS_GFX
+
+// Height of an escort ship window.
+#define SHIP_WIN_HEIGHT (SHIP_WIN_WIDTH + RES_CASE(6,6,11)) // JMS_GFX
+
+// For how many animation frames' time the escort ship bay doors
+// are slid left and right when opening them. If this number is not large
+// enough, part of the doors are left visible upon opening.
+#define SHIP_WIN_FRAMES ((SHIP_WIN_WIDTH >> 1) + RES_CASE(1,1,2))
 
 static void
 ShowShipCrew (SHIP_FRAGMENT *StarShipPtr, RECT *pRect)
@@ -279,15 +313,15 @@ ShowShipCrew (SHIP_FRAGMENT *StarShipPtr
 
 	r = *pRect;
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + r.extent.height - 1;
+	t.baseline.y = r.corner.y + r.extent.height - 1 - (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	if (r.corner.y)
 	{
-		r.corner.y = t.baseline.y - 6;
+		r.corner.y = t.baseline.y - (6 << RESOLUTION_FACTOR); //JMS_GFX
 		r.extent.width = SHIP_WIN_WIDTH;
-		r.extent.height = 6;
+		r.extent.height = (6 << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
 	}
@@ -304,6 +338,7 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 	COUNT i, num_ships;
 	HSHIPFRAG hStarShip, hNextShip;
 	SHIP_FRAGMENT *StarShipPtr;
+	static const COORD *hangar_x_coords;
 	struct
 	{
 		SHIP_FRAGMENT *StarShipPtr;
@@ -311,6 +346,20 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 		STAMP ship_s, lfdoor_s, rtdoor_s;
 	} ship_win_info[MAX_BUILT_SHIPS], *pship_win_info;
 
+	switch (RESOLUTION_FACTOR) // JMS_GFX
+	{
+		case 2:
+			hangar_x_coords = hangar_x_coords_4x;
+			break;
+		case 1:
+			hangar_x_coords = hangar_x_coords_2x;
+			break;
+		case 0:
+		default:
+			hangar_x_coords = hangar_x_coords_1x;
+			break;
+	}
+	
 	num_ships = 1;
 	pship_win_info = &ship_win_info[0];
 	if (YankedStarShipPtr)
@@ -329,8 +378,7 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 		pship_win_info->ship_s.origin.y = (SHIP_WIN_WIDTH >> 1);
 		pship_win_info->ship_s.frame = YankedStarShipPtr->melee_icon;
 
-		pship_win_info->finished_s.x = hangar_x_coords[
-				which_window % HANGAR_SHIPS_ROW];
+		pship_win_info->finished_s.x = hangar_x_coords[which_window % HANGAR_SHIPS_ROW];
 		pship_win_info->finished_s.y = HANGAR_Y + (HANGAR_DY *
 				(which_window / HANGAR_SHIPS_ROW));
 	}
@@ -390,8 +438,7 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 			pship_win_info->ship_s.frame = StarShipPtr->melee_icon;
 
 			which_window = StarShipPtr->index;
-			pship_win_info->finished_s.x = hangar_x_coords[
-					which_window % HANGAR_SHIPS_ROW];
+			pship_win_info->finished_s.x = hangar_x_coords[which_window % HANGAR_SHIPS_ROW];
 			pship_win_info->finished_s.y = HANGAR_Y + (HANGAR_DY *
 					(which_window / HANGAR_SHIPS_ROW));
 			++pship_win_info;
@@ -417,7 +464,7 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 		FlushInput ();
 		TimeIn = GetTimeCounter ();
 
-		for (j = 0; (j < SHIP_WIN_FRAMES) && !AllDoorsFinished; j++)
+		for (j = 0; (j < (int)SHIP_WIN_FRAMES) && !AllDoorsFinished; j++)
 		{
 			SleepThreadUntil (TimeIn + ONE_SECOND / 24);
 			TimeIn = GetTimeCounter ();
@@ -545,6 +592,7 @@ DoModifyShips (MENU_STATE *pMS)
 {
 #define MODIFY_CREW_FLAG (1 << 8)
 	BOOLEAN select, cancel;
+	static const COORD *hangar_x_coords;
 #ifdef WANT_SHIP_SPINS
 	BOOLEAN special;
 
@@ -552,6 +600,20 @@ DoModifyShips (MENU_STATE *pMS)
 #endif /* WANT_SHIP_SPINS */
 	select = PulsedInputState.menu[KEY_MENU_SELECT];
 	cancel = PulsedInputState.menu[KEY_MENU_CANCEL];
+	
+	switch (RESOLUTION_FACTOR) // JMS_GFX
+	{
+		case 2:
+			hangar_x_coords = hangar_x_coords_4x;
+			break;
+		case 1:
+			hangar_x_coords = hangar_x_coords_2x;
+			break;
+		case 0:
+		default:
+			hangar_x_coords = hangar_x_coords_1x;
+			break;
+	}
 
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 	{
@@ -752,10 +814,9 @@ DoModifyShips (MENU_STATE *pMS)
 							DeltaSISGauges (UNDEFINED_DELTA, UNDEFINED_DELTA,
 									-((int)ShipCost[Index]));
 							r.corner.x = pMS->flash_rect0.corner.x;
-							r.corner.y = pMS->flash_rect0.corner.y
-									+ pMS->flash_rect0.extent.height - 6;
+							r.corner.y = pMS->flash_rect0.corner.y + pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR); // JMS_GFX
 							r.extent.width = SHIP_WIN_WIDTH;
-							r.extent.height = 5;
+							r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
 							SetContext (SpaceContext);
 							SetFlashRect (&r);
 							UnlockMutex (GraphicsLock);
@@ -845,10 +906,9 @@ DoModifyShips (MENU_STATE *pMS)
 					else
 					{
 						r.corner.x = pMS->flash_rect0.corner.x;
-						r.corner.y = pMS->flash_rect0.corner.y
-								+ pMS->flash_rect0.extent.height - 6;
+						r.corner.y = pMS->flash_rect0.corner.y + pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR);
 						r.extent.width = SHIP_WIN_WIDTH;
-						r.extent.height = 5;
+						r.extent.height = (5 << RESOLUTION_FACTOR); // JMS_GFX
 						SetContext (SpaceContext);
 						SetFlashRect (&r);
 						SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
@@ -876,7 +936,30 @@ DoModifyShips (MENU_STATE *pMS)
 									&& GLOBAL_SIS (ResUnits) >=
 									(DWORD)GLOBAL (CrewCost))
 							{
-								DrawPoint (&r.corner);
+								// Crew dots/rectangles for 1x and 2x resolutions.
+								if (RESOLUTION_FACTOR < 2)
+								{
+									r.extent.width = 1 << RESOLUTION_FACTOR;
+									r.extent.height = r.extent.width;
+									DrawFilledRectangle (&r);
+								}
+								// Crew balls for 4x resolution.
+								else
+								{
+									r.corner.x += 1;
+									r.extent.width = (1 << RESOLUTION_FACTOR) - 2;
+									r.extent.height = 1 << RESOLUTION_FACTOR;
+									DrawFilledRectangle (&r);
+									
+									r.corner.x -= 1;
+									r.corner.y += 1;
+									r.extent.width = 1 << RESOLUTION_FACTOR;
+									r.extent.height = (1 << RESOLUTION_FACTOR) - 2;
+									DrawFilledRectangle (&r);
+									
+									r.corner.y -= 1;
+								}
+								
 								DeltaSISGauges (1, 0, -GLOBAL (CrewCost));
 								crew_delta = 1;
 
@@ -917,9 +1000,9 @@ DoModifyShips (MENU_STATE *pMS)
 								ShowShipCrew (StarShipPtr, &pMS->flash_rect0);
 								r.corner.x = pMS->flash_rect0.corner.x;
 								r.corner.y = pMS->flash_rect0.corner.y
-										+ pMS->flash_rect0.extent.height - 6;
+									+ pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR);
 								r.extent.width = SHIP_WIN_WIDTH;
-								r.extent.height = 5;
+								r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
 								SetContext (SpaceContext);
 								SetFlashRect (&r);
 							}
@@ -946,8 +1029,11 @@ DoModifyShips (MENU_STATE *pMS)
 								crew_delta = -1;
 
 								GetCPodCapacity (&r.corner);
+								r.extent.width = 1 << RESOLUTION_FACTOR;
+								r.extent.height = r.extent.width;
 								SetContextForeGroundColor (BLACK_COLOR);
-								DrawPoint (&r.corner);
+								
+								DrawFilledRectangle (&r);
 
 								SetContext (StatusContext);
 								GetGaugeRect (&r, TRUE);
@@ -980,9 +1066,9 @@ DoModifyShips (MENU_STATE *pMS)
 							ShowShipCrew (StarShipPtr, &pMS->flash_rect0);
 							r.corner.x = pMS->flash_rect0.corner.x;
 							r.corner.y = pMS->flash_rect0.corner.y
-									+ pMS->flash_rect0.extent.height - 6;
+								+ pMS->flash_rect0.extent.height - (6 << RESOLUTION_FACTOR);
 							r.extent.width = SHIP_WIN_WIDTH;
-							r.extent.height = 5;
+							r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
 							SetContext (SpaceContext);
 							SetFlashRect (&r);
 						}
@@ -1022,12 +1108,11 @@ ChangeFlashRect:
 					pMS->flash_rect0.corner.x =
 							pMS->flash_rect0.corner.y = 0;
 					pMS->flash_rect0.extent.width = SIS_SCREEN_WIDTH;
-					pMS->flash_rect0.extent.height = 61;
+					pMS->flash_rect0.extent.height = RES_CASE(61, 122, 295); // JMS_GFX
 				}
 				else
 				{
-					pMS->flash_rect0.corner.x = hangar_x_coords[
-							pMS->CurState % HANGAR_SHIPS_ROW];
+					pMS->flash_rect0.corner.x = hangar_x_coords[pMS->CurState % HANGAR_SHIPS_ROW]; // JMS_GFX
 					pMS->flash_rect0.corner.y = HANGAR_Y + (HANGAR_DY *
 							(pMS->CurState / HANGAR_SHIPS_ROW));
 					pMS->flash_rect0.extent.width = SHIP_WIN_WIDTH;
@@ -1080,8 +1165,12 @@ DrawBluePrint (MENU_STATE *pMS)
 			DrawShipPiece (ModuleFrame, which_piece, num_frames, TRUE);
 	}
 
-	SetContextForeGroundColor (
+	// JMS_GFX: The lo-res crew pod blueprint retains the lighter color scheme.
+	// Normal blue for hi-res.
+	if (RESOLUTION_FACTOR == 0)
+		SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09));
+	
 	for (num_frames = 0; num_frames < NUM_MODULE_SLOTS; ++num_frames)
 	{
 		BYTE which_piece;
@@ -1097,10 +1186,34 @@ DrawBluePrint (MENU_STATE *pMS)
 
 		while (num_frames--)
 		{
-			POINT pt;
-
-			GetCPodCapacity (&pt);
-			DrawPoint (&pt);
+			RECT r;
+			// Crew dots/rectangles for 1x and 2x resolutions.
+			if (RESOLUTION_FACTOR < 2)
+			{
+				r.extent.width = 1 << RESOLUTION_FACTOR;
+				r.extent.height = r.extent.width;
+				
+				GetCPodCapacity (&r.corner);
+				DrawFilledRectangle (&r);
+			}
+			// Crew balls for 4x resolution.
+			else
+			{
+				GetCPodCapacity (&r.corner);
+				
+				r.corner.x += 1;
+				r.extent.width = (1 << RESOLUTION_FACTOR) - 2;
+				r.extent.height = 1 << RESOLUTION_FACTOR;
+				DrawFilledRectangle (&r);
+				
+				r.corner.x -= 1;
+				r.corner.y += 1;
+				r.extent.width = 1 << RESOLUTION_FACTOR;
+				r.extent.height = (1 << RESOLUTION_FACTOR) - 2;
+				DrawFilledRectangle (&r);
+				
+				r.corner.y -= 1;
+			}
 
 			++GLOBAL_SIS (CrewEnlisted);
 		}
@@ -1111,8 +1224,8 @@ DrawBluePrint (MENU_STATE *pMS)
 		num_frames = GLOBAL_SIS (TotalElementMass);
 		GLOBAL_SIS (TotalElementMass) = 0;
 
-		r.extent.width = 9;
-		r.extent.height = 1;
+		r.extent.width = 9 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 1 << RESOLUTION_FACTOR; // JMS_GFX
 		while (num_frames)
 		{
 			COUNT m;
@@ -1133,13 +1246,52 @@ DrawBluePrint (MENU_STATE *pMS)
 		FuelVolume = GLOBAL_SIS (FuelOnBoard) - FUEL_RESERVE;
 		GLOBAL_SIS (FuelOnBoard) = FUEL_RESERVE;
 
-		r.extent.width = 3;
-		r.extent.height = 1;
+		r.extent.width = (3 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 1; // JMS_GFX
+		
 		while (FuelVolume)
 		{
 			COUNT m;
-
+			
+			// JMS_GFX
+			COUNT slotNr = 0;
+			DWORD compartmentNr = 0;
+			BYTE moduleType;
+			DWORD fuelAmount;
+			DWORD volume;
+			
+			// JMS_GFX
+			fuelAmount = GLOBAL_SIS (FuelOnBoard);
+			if (fuelAmount >= FUEL_RESERVE)
+			{
+				COUNT slotI;
+				DWORD capacity = FUEL_RESERVE;
+				
+				slotI = NUM_MODULE_SLOTS;
+				while (slotI--)
+				{
+					BYTE moduleType = GLOBAL_SIS (ModuleSlots[slotI]);
+					
+					capacity += GetModuleFuelCapacity (moduleType);
+					
+					//log_add (log_Debug, "fuelAmount %d, capacity %d, moduletype %d, slotI %d", fuelAmount, capacity, moduleType, slotI);
+					
+					if (fuelAmount < capacity)
+					{
+						slotNr = slotI;
+						compartmentNr = capacity - fuelAmount;
+						break;
+					}
+				}
+				
+				moduleType = GLOBAL_SIS (ModuleSlots[slotNr]);
+				volume = GetModuleFuelCapacity (moduleType);
+			}
+				
 			GetFTankCapacity (&r.corner);
+			//log_add(log_Debug, "volume on %u, hefueltankcapacity %u", volume, HEFUEL_TANK_CAPACITY);
+			r.corner.y -= volume == HEFUEL_TANK_CAPACITY ? RES_CASE(0,11,19) : RES_CASE(0,14,28); // JMS_GFX
+			r.corner.x += volume == HEFUEL_TANK_CAPACITY ? RES_CASE(0,0,2) : RES_CASE(0,0,1); // JMS_GFX
 			DrawPoint (&r.corner);
 			r.corner.x += r.extent.width + 1;
 			DrawPoint (&r.corner);
diff -ruNp ./src.orig/uqm/sis.c ./src/uqm/sis.c
--- ./src.orig/uqm/sis.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/sis.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "sis.h"
 
 #include "colors.h"
@@ -131,16 +133,16 @@ DrawSISTitle (UNICODE *pStr)
 	RECT r;
 
 	t.baseline.x = SIS_TITLE_WIDTH >> 1;
-	t.baseline.y = SIS_TITLE_HEIGHT - 2;
+	t.baseline.y = SIS_TITLE_HEIGHT - RES_CASE(2,6,8); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 
 	OldContext = SetContext (OffScreenContext);
-	r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH + 1;
+	r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH + (1 << RESOLUTION_FACTOR); // JMS_GFX
 	r.corner.y = SIS_ORG_Y - SIS_TITLE_HEIGHT;
 	r.extent.width = SIS_TITLE_WIDTH;
-	r.extent.height = SIS_TITLE_HEIGHT - 1;
+	r.extent.height = SIS_TITLE_HEIGHT - RES_STAT_SCALE(1); // JMS_GFX
 	SetContextFGFrame (Screen);
 	SetContextClipRect (&r);
 	SetContextFont (TinyFont);
@@ -233,7 +235,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 	if (!(flags & DSME_MYCOLOR))
 		SetContextForeGroundColor (SIS_MESSAGE_TEXT_COLOR);
 
-	t.baseline.y = SIS_MESSAGE_HEIGHT - 2;
+	t.baseline.y = SIS_MESSAGE_HEIGHT - RES_CASE(2,6,8); // JMS_GFX
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 	SetContextFont (TinyFont);
@@ -257,7 +259,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 		BYTE char_deltas[128];
 		BYTE *pchar_deltas;
 
-		t.baseline.x = 3;
+		t.baseline.x = RES_STAT_SCALE(3); // JMS_GFX
 		t.align = ALIGN_LEFT;
 
 		TextRect (&t, &text_r, char_deltas);
@@ -356,8 +358,8 @@ DateToString (char *buf, size_t bufLen,
 void
 GetStatusMessageRect (RECT *r)
 {
-	r->corner.x = 2;
-	r->corner.y = 130;
+	r->corner.x = RES_STAT_SCALE(2) - RES_CASE(0,1,2); // JMS_GFX
+	r->corner.y = RES_STAT_SCALE(130) + RES_CASE(0,6,18); // JMS_GFX
 	r->extent.width = STATUS_MESSAGE_WIDTH;
 	r->extent.height = STATUS_MESSAGE_HEIGHT;
 }
@@ -422,13 +424,24 @@ DrawStatusMessage (const UNICODE *pStr)
 	}
 
 	t.baseline.x = STATUS_MESSAGE_WIDTH >> 1;
-	t.baseline.y = STATUS_MESSAGE_HEIGHT - 1;
+	t.baseline.y = STATUS_MESSAGE_HEIGHT - RES_CASE(1,4,6); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 
 	SetContextFont (TinyFont);
-	SetContextForeGroundColor (STATUS_MESSAGE_TEXT_COLOR);
+
+	if (curMsgMode == SMM_WARNING)
+	{
+		SetContextForeGroundColor (STATUS_MESSAGE_WARNING_TEXT_COLOR);
+	} else if (curMsgMode == SMM_ALERT)
+	{
+		SetContextForeGroundColor (STATUS_MESSAGE_ALERT_TEXT_COLOR);
+	} else
+	{
+		SetContextForeGroundColor (STATUS_MESSAGE_TEXT_COLOR);
+	}
+
 	font_DrawText (&t);
 	UnbatchGraphics ();
 
@@ -457,15 +470,15 @@ DrawCaptainsName (void)
 	OldContext = SetContext (StatusContext);
 	OldFont = SetContextFont (TinyFont);
 	OldColor = SetContextForeGroundColor (CAPTAIN_NAME_BACKGROUND_COLOR);
-
-	r.corner.x = 2 + 1;
-	r.corner.y = 10;
-	r.extent.width = SHIP_NAME_WIDTH - 2;
-	r.extent.height = SHIP_NAME_HEIGHT;
+	
+	r.corner.x = RES_STAT_SCALE(3) - RES_CASE(0,3,5);		// JMS_GFX
+	r.corner.y = RES_CASE(10,20,32);						// JMS_GFX
+	r.extent.width = SHIP_NAME_WIDTH - RES_CASE(2,1,0);		// JMS_GFX
+	r.extent.height = SHIP_NAME_HEIGHT + RESOLUTION_FACTOR;	// JMS_GFX
 	DrawFilledRectangle (&r);
 
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = r.corner.y + 6;
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_CASE(1,0,-1);
+	t.baseline.y = r.corner.y + RES_CASE(6,11,16); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GLOBAL_SIS (CommanderName);
 	t.CharCount = (COUNT)~0;
@@ -493,10 +506,10 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 		OldContext = SetContext (StatusContext);
 		OldFont = SetContextFont (StarConFont);
 
-		r.corner.x = 2;
-		r.corner.y = 20;
-		r.extent.width = SHIP_NAME_WIDTH;
-		r.extent.height = SHIP_NAME_HEIGHT;
+		r.corner.x = RES_CASE(2,3,5);		// JMS_GFX
+		r.corner.y = RES_CASE(20,40,63);	// JMS_GFX
+		r.extent.width = SHIP_NAME_WIDTH;	// JMS_GFX
+		r.extent.height = SHIP_NAME_HEIGHT + RES_CASE(0,0,1);
 
 		t.pStr = GLOBAL_SIS (ShipName);
 	}
@@ -505,10 +518,10 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 		OldContext = SetContext (SpaceContext);
 		OldFont = SetContextFont (MicroFont);
 
-		r.corner.x = 0;
+		r.corner.x = RES_CASE(0,24,0);						 // JMS_GFX
 		r.corner.y = 1;
-		r.extent.width = SIS_SCREEN_WIDTH;
-		r.extent.height = SHIP_NAME_HEIGHT;
+		r.extent.width = SIS_SCREEN_WIDTH - RES_CASE(0,24,0); // JMS_GFX
+		r.extent.height = SHIP_NAME_HEIGHT + RES_CASE(0,1,0);// JMS_GFX
 
 		t.pStr = buf;
 		snprintf (buf, sizeof buf, "%s %s",
@@ -521,7 +534,8 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 	DrawFilledRectangle (&r);
 
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + (SHIP_NAME_HEIGHT - InStatusArea);
+	t.baseline.y = r.corner.y + (SHIP_NAME_HEIGHT -
+					(InStatusArea ? RES_CASE(1,4,2) : RES_CASE(0,-4,-8))); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	if (optWhichFonts == OPT_PC)
@@ -601,7 +615,7 @@ DrawFlagshipStats (void)
 
 	/* we need room to play.  full screen width, 4 lines tall */
 	r.corner.x = 0;
-	r.corner.y = SIS_SCREEN_HEIGHT - (4 * leading);
+	r.corner.y = SIS_SCREEN_HEIGHT - (4 * leading) - RES_CASE(0, 30, 60); // JMS_GFX
 	r.extent.width = SIS_SCREEN_WIDTH;
 	r.extent.height = (4 * leading);
 
@@ -612,8 +626,8 @@ DrawFlagshipStats (void)
 	   now that we've cleared out our playground, compensate for the
 	   fact that the leading is way more than is generally needed.
 	*/
-	leading -= 3;
-	t.baseline.x = SIS_SCREEN_WIDTH / 6; //wild-assed guess, but it worked
+	leading -= RES_CASE(3, -3, -6);// JMS_GFX
+	t.baseline.x = SIS_SCREEN_WIDTH / RES_CASE(6, 10, 11); //JMS_GFX
 	t.baseline.y = r.corner.y + leading + 3;
 	t.align = ALIGN_RIGHT;
 	t.CharCount = (COUNT)~0;
@@ -653,7 +667,7 @@ DrawFlagshipStats (void)
 			"%-7.7s", describeWeapon (GLOBAL_SIS (ModuleSlots[0])));
 	font_DrawText (&t);
 
-	t.baseline.x = r.extent.width - 25;
+	t.baseline.x = r.extent.width - 25 - RES_CASE(0,15,60); // JMS_GFX
 	t.baseline.y = r.corner.y + leading + 3;
 	t.align = ALIGN_RIGHT;
 
@@ -671,7 +685,7 @@ DrawFlagshipStats (void)
 	t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 7); // "maximum fuel:"
 	font_DrawText (&t);
 
-	t.baseline.x = r.extent.width - 2;
+	t.baseline.x = r.extent.width - RES_CASE(2, 10, 40); // JMS_GFX
 	t.baseline.y = r.corner.y + leading + 3;
 	t.pStr = buf;
 
@@ -738,12 +752,12 @@ DrawLanders (void)
 
 	i = GLOBAL_SIS (NumLanders);
 	r.corner.x = (STATUS_WIDTH >> 1) - r.corner.x;
-	s.origin.x = r.corner.x - (((r.extent.width * i) + (2 * (i - 1))) >> 1);
-	s.origin.y = 29;
+	s.origin.x = r.corner.x - (((r.extent.width * i) + (2 * (i - 1))) >> 1) + RES_CASE(0,1,0);
+	s.origin.y = RES_STAT_SCALE(29) + RES_CASE(0,0,2); // JMS_GFX
 
 	width = r.extent.width + 2;
-	r.extent.width = (r.extent.width * MAX_LANDERS)
-			+ (2 * (MAX_LANDERS - 1)) + 2;
+	r.extent.width = (r.extent.width * MAX_LANDERS) + 
+		(2 * (MAX_LANDERS - 1)) + RES_CASE (2,2,-14); // JMS_GFX
 	r.corner.x -= r.extent.width >> 1;
 	r.corner.y += s.origin.y;
 	SetContextForeGroundColor (BLACK_COLOR);
@@ -764,76 +778,86 @@ DrawStorageBays (BOOLEAN Refresh)
 	BYTE i;
 	RECT r;
 	CONTEXT OldContext;
+	COUNT StorageBayCapacity = STORAGE_BAY_CAPACITY;
 
 	OldContext = SetContext (StatusContext);
-
-	r.extent.width = 2;
-	r.extent.height = 4;
-	r.corner.y = 123;
+	r.extent.width  = RES_STAT_SCALE(2); // JMS_GFX
+	r.extent.height = RES_STAT_SCALE(4); // JMS_GFX
+	r.corner.y		= RES_STAT_SCALE(123) + RES_CASE(0,8,23); // JMS_GFX
+	
 	if (Refresh)
 	{
 		r.extent.width = NUM_MODULE_SLOTS * (r.extent.width + 1);
-		r.corner.x = (STATUS_WIDTH >> 1) - (r.extent.width >> 1);
-
+		r.corner.x = (STATUS_WIDTH >> 1) - (r.extent.width >> 1) + RES_CASE(0,2,2);
+		
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
-		r.extent.width = 2;
+		r.extent.width = RES_STAT_SCALE(2); // JMS_GFX
 	}
-
+	
 	i = (BYTE)CountSISPieces (STORAGE_BAY);
+	
 	if (i)
 	{
 		COUNT j;
-
-		r.corner.x = (STATUS_WIDTH >> 1)
-				- ((i * (r.extent.width + 1)) >> 1);
+		
+		r.corner.x = (STATUS_WIDTH >> 1) - ((i * (r.extent.width + RES_STAT_SCALE(1))) >> 1) + RES_CASE(0,2,2);
+		
+		// Draw full bays.
 		SetContextForeGroundColor (STORAGE_BAY_FULL_COLOR);
-		for (j = GLOBAL_SIS (TotalElementMass);
-				j >= STORAGE_BAY_CAPACITY; j -= STORAGE_BAY_CAPACITY)
+		for (j = GLOBAL_SIS (TotalElementMass); j >= StorageBayCapacity; j -= StorageBayCapacity)
 		{
 			DrawFilledRectangle (&r);
-			r.corner.x += r.extent.width + 1;
-
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1); // JMS_GFX;
+			
 			--i;
 		}
-
-		r.extent.height = (4 * j + (STORAGE_BAY_CAPACITY - 1)) /
-				STORAGE_BAY_CAPACITY;
+		
+		// This sets how full a partially filled bay is.
+		r.extent.height = (RES_STAT_SCALE (4) * j + (StorageBayCapacity - 1)) / StorageBayCapacity;
+		
 		if (r.extent.height)
 		{
-			r.corner.y += 4 - r.extent.height;
+			// Filled part of the bay.
+			r.corner.y += RES_STAT_SCALE (4) - r.extent.height;
+			//r.corner.y += 4 - r.extent.height;
 			DrawFilledRectangle (&r);
-			r.extent.height = 4 - r.extent.height;
+			
+			//
+			r.extent.height = RES_STAT_SCALE(4) - r.extent.height;
+			// r.extent.height = 4 - r.extent.height;
 			if (r.extent.height)
 			{
-				r.corner.y = 123;
+				r.corner.y = RES_STAT_SCALE(123) + RES_CASE(0,8,23);
 				SetContextForeGroundColor (STORAGE_BAY_EMPTY_COLOR);
 				DrawFilledRectangle (&r);
 			}
-			r.corner.x += r.extent.width + 1;
-
+			
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1);
+			
 			--i;
 		}
-		r.extent.height = 4;
-
+		
+		// Draw totally empty bays.
+		r.extent.height = RES_STAT_SCALE(4);
 		SetContextForeGroundColor (STORAGE_BAY_EMPTY_COLOR);
 		while (i--)
 		{
 			DrawFilledRectangle (&r);
-			r.corner.x += r.extent.width + 1;
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1);
 		}
 	}
-
+	
 	SetContext (OldContext);
 }
 
 void
 GetGaugeRect (RECT *pRect, BOOLEAN IsCrewRect)
 {
-	pRect->extent.width = 24;
-	pRect->corner.x = (STATUS_WIDTH >> 1) - (pRect->extent.width >> 1);
-	pRect->extent.height = 5;
-	pRect->corner.y = IsCrewRect ? 117 : 38;
+	pRect->extent.width = RES_STAT_SCALE(24); // JMS_GFX
+	pRect->corner.x = (STATUS_WIDTH >> 1) - (pRect->extent.width >> 1) + RES_CASE(0,0,4);
+	pRect->extent.height = RES_STAT_SCALE(5); // JMS_GFX
+	pRect->corner.y = IsCrewRect ? RES_CASE(117,244,375) : RES_CASE(38,76,120); // JMS_GFX
 }
 
 static void
@@ -844,23 +868,26 @@ DrawPC_SIS (void)
 
 	GetGaugeRect (&r, FALSE);
 	t.baseline.x = STATUS_WIDTH >> 1;
-	t.baseline.y = r.corner.y - 1;
+	t.baseline.y = r.corner.y - RES_CASE(1,0,2);
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	SetContextFont (TinyFont);
 	SetContextForeGroundColor (BLACK_COLOR);
 
-	r.corner.y -= 6;
-	r.corner.x--;
-	r.extent.width += 2;
+	// Black rectangle behind "FUEL" text and fuel amount.
+	r.corner.y -= RES_STAT_SCALE(6); // JMS_GFX
+	r.corner.x -= RES_STAT_SCALE(1); // JMS_GFX
+	r.extent.width += RES_STAT_SCALE(2);
+	r.extent.height += RES_CASE(0,0,2);
 	DrawFilledRectangle (&r);
 
 	SetContextFontEffect (SetAbsFrameIndex (FontGradFrame, 1));
 	t.pStr = GAME_STRING (STATUS_STRING_BASE + 3); // "FUEL"
 	font_DrawText (&t);
 
-	r.corner.y += 79;
-	t.baseline.y += 79;
+	// Black rectangle behind "CREW" text and crew amount.
+	r.corner.y += RES_STAT_SCALE(79) + RES_CASE(0,12,18); // JMS_GFX
+	t.baseline.y += RES_STAT_SCALE(79) + RES_CASE(0,9,18); // JMS_GFX
 	DrawFilledRectangle (&r);
 
 	SetContextFontEffect (SetAbsFrameIndex (FontGradFrame, 2));
@@ -869,16 +896,16 @@ DrawPC_SIS (void)
 	SetContextFontEffect (NULL);
 
 	// Background of text "CAPTAIN".
-	r.corner.x = 2 + 1;
-	r.corner.y = 3;
-	r.extent.width = 58;
-	r.extent.height = 7;
+	r.corner.x = (2 + 1) << RESOLUTION_FACTOR; // JMS_GFX;
+	r.corner.y = RES_STAT_SCALE(3); // JMS_GFX
+	r.extent.width = RES_STAT_SCALE(58); // JMS_GFX
+	r.extent.height = RES_STAT_SCALE(7); // JMS_GFX
 	SetContextForeGroundColor (PC_CAPTAIN_STRING_BACKGROUND_COLOR);
 	DrawFilledRectangle (&r);
 
 	// Text "CAPTAIN".
 	SetContextForeGroundColor (PC_CAPTAIN_STRING_TEXT_COLOR);
-	t.baseline.y = r.corner.y + 6;
+	t.baseline.y = r.corner.y + RES_CASE(6,10,18); // JMS_GFX
 	t.pStr = GAME_STRING (STATUS_STRING_BASE + 5); // "CAPTAIN"
 	font_DrawText (&t);
 }
@@ -889,7 +916,7 @@ DrawThrusters (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1;
+	s.origin.x = RES_STAT_SCALE(1); // JMS_GFX
 	s.origin.y = 0;
 	for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
 	{
@@ -902,7 +929,7 @@ DrawThrusters (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -912,7 +939,7 @@ DrawTurningJets (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1;
+	s.origin.x = RES_STAT_SCALE(1); // JMS_GFX
 	s.origin.y = 0;
 	for (i = 0; i < NUM_JET_SLOTS; ++i)
 	{
@@ -925,7 +952,7 @@ DrawTurningJets (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -935,7 +962,7 @@ DrawModules (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1; // This properly centers the modules.
+	s.origin.x = RES_STAT_SCALE(1); // JMS_GFX // This properly centers the modules.
 	s.origin.y = 1;
 	for (i = 0; i < NUM_MODULE_SLOTS; ++i)
 	{
@@ -946,7 +973,7 @@ DrawModules (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -972,8 +999,10 @@ DrawSupportShips (void)
 		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 		hNextShip = _GetSuccLink (StarShipPtr);
 
-		s.origin = *pship_pos;
-		s.frame = StarShipPtr->icons;
+		s.origin.x = RES_STAT_SCALE(pship_pos->x) 
+			+ ((pship_pos - ship_pos) % 2 ? RES_CASE(0,3,5) : RES_CASE(0,-2,-2)); // JMS_GFX
+		s.origin.y = RES_STAT_SCALE(pship_pos->y) + RES_CASE(0,5,0); // JMS_GFX
+		s.frame = SetAbsFrameIndex (StarShipPtr->icons, 2);
 		LockMutex (GraphicsLock);
 		DrawStamp (&s);
 		UnlockMutex (GraphicsLock);
@@ -1014,7 +1043,7 @@ DeltaSISGauges_crewDelta (SIZE crew_delt
 		GetGaugeRect (&r, TRUE);
 		
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = r.corner.y + r.extent.height;
+		t.baseline.y = r.corner.y + r.extent.height - (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
@@ -1070,7 +1099,7 @@ DeltaSISGauges_fuelDelta (SIZE fuel_delt
 		GetGaugeRect (&r, FALSE);
 		
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = r.corner.y + r.extent.height;
+		t.baseline.y = r.corner.y + r.extent.height - (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
@@ -1103,10 +1132,7 @@ DeltaSISGauges_resunitDelta (SIZE resuni
 	{
 		RECT r;
 
-		r.corner.x = 2;
-		r.corner.y = 130;
-		r.extent.width = STATUS_MESSAGE_WIDTH;
-		r.extent.height = STATUS_MESSAGE_HEIGHT;
+		GetStatusMessageRect (&r);
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x08, 0x00), 0x6E));
 		DrawFilledRectangle (&r);
@@ -1244,6 +1270,7 @@ GetCPodCapacity (POINT *ppt)
 
 	COUNT rowNr;
 	COUNT colNr;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 				
 	static const Color crewRows[] = PC_CREW_COLOR_TABLE;
 
@@ -1262,8 +1289,9 @@ GetCPodCapacity (POINT *ppt)
 	else
 		SetContextForeGroundColor (THREEDO_CREW_COLOR);
 		
-	ppt->x = 27 + (slotNr * SHIP_PIECE_OFFSET) - (colNr * 2);
-	ppt->y = 34 - (rowNr * 2);
+	ppt->x = (27 << RESOLUTION_FACTOR) + (slotNr * ship_piece_offset_scaled) -
+				((colNr * 2) << RESOLUTION_FACTOR) + RES_CASE(0,19,53); // JMS_GFX
+	ppt->y = ((34 - (rowNr * 2)) << RESOLUTION_FACTOR) + RES_CASE(0,6,20); // JMS_GFX
 
 	return GetCrewPodCapacity ();
 }
@@ -1346,13 +1374,14 @@ GetSBayCapacity (POINT *ppt)
 
 	COUNT rowNr;
 	COUNT colNr;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 				
 	static const Color colorBars[] = STORAGE_BAY_COLOR_TABLE;
 
 	massCount = GetElementMass ();
 	if (!GetStorageCellForMineralUnit (massCount, &slotNr, &cellNr))
 	{
-		// Crew does not fit. *ppt is unchanged.
+		// Mineral does not fit. *ppt is unchanged.
 		return GetStorageBayCapacity ();
 	}
 
@@ -1367,8 +1396,8 @@ GetSBayCapacity (POINT *ppt)
 		SetContextForeGroundColor (colorBars[rowNr]);
 	}
 		
-	ppt->x = 19 + (slotNr * SHIP_PIECE_OFFSET);
-	ppt->y = 34 - (rowNr * 2);
+	ppt->x = (19 << RESOLUTION_FACTOR) + (slotNr * ship_piece_offset_scaled) + RES_CASE(0,19,53); // JMS_GFX
+	ppt->y = ((34 - (rowNr * 2)) << RESOLUTION_FACTOR) - RES_CASE(0,0,9); // JMS_GFX
 
 	return GetStorageBayCapacity ();
 }
@@ -1456,8 +1485,10 @@ GetFTankCapacity (POINT *ppt)
 	DWORD compartmentNr;
 	BYTE moduleType;
 	DWORD volume;
+	DWORD volumehelper;
 
-	COUNT rowNr;
+	DWORD rowNr;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 	
 	static const Color fuelColors[] = FUEL_COLOR_TABLE;
 		
@@ -1478,15 +1509,29 @@ GetFTankCapacity (POINT *ppt)
 
 	moduleType = GLOBAL_SIS (ModuleSlots[slotNr]);
 	volume = GetModuleFuelCapacity (moduleType);
-
-	rowNr = ((volume - compartmentNr) * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY);
-		
-	ppt->x = 21 + (slotNr * SHIP_PIECE_OFFSET);
+	
+	// JMS_GFX
 	if (volume == FUEL_TANK_CAPACITY)
-		ppt->y = 27 - rowNr;
+		volumehelper = (volume * 10) / RES_CASE(10,22,22);
 	else
-		ppt->y = 30 - rowNr;
+		volumehelper = volume;
 
+	rowNr = ((volumehelper - compartmentNr) * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY);
+	ppt->x = (21 << RESOLUTION_FACTOR) + (slotNr * ship_piece_offset_scaled);
+	if (volume == FUEL_TANK_CAPACITY)
+	{
+		ppt->x += RES_CASE(0,20,54); // JMS_GFX
+		ppt->y = (27 << RESOLUTION_FACTOR) - rowNr + RES_CASE(0,11,27); // JMS_GFX
+	}
+	else
+	{
+		ppt->x += RES_CASE(0,20,53); // JMS_GFX
+		ppt->y = (30 << RESOLUTION_FACTOR) - rowNr + RES_CASE(0,21,43); // JMS_GFX
+	}
+	
+	rowNr = ((volume - compartmentNr) * 10 * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY) /
+		MAX_FUEL_BARS;
+	
 	assert (rowNr + 1 < (COUNT) (sizeof fuelColors / sizeof fuelColors[0]));
 	SetContextForeGroundColor (fuelColors[rowNr]);
 	SetContextBackGroundColor (fuelColors[rowNr + 1]);
diff -ruNp ./src.orig/uqm/sis.h ./src/uqm/sis.h
--- ./src.orig/uqm/sis.h	2017-10-23 11:42:17 -0700
+++ ./src/uqm/sis.h	2017-10-23 11:41:35 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef SIS_H_INCL__
 #define SIS_H_INCL__
 
@@ -21,6 +23,8 @@
 #include "libs/gfxlib.h"
 #include "planets/elemdata.h"
 		// for NUM_ELEMENT_CATEGORIES
+#include "units.h"
+                // for RESOLUTION_FACTOR
 
 #define CLEAR_SIS_RADAR (1 << 2)
 #define DRAW_SIS_DISPLAY (1 << 3)
@@ -43,9 +47,11 @@
 #define CREW_PER_ROW 5
 #define SBAY_MASS_PER_ROW 50
 
-#define MAX_FUEL_BARS 10
+#define MAX_FUEL_BARS RES_CASE(10,40,80)
 #define FUEL_VOLUME_PER_ROW (HEFUEL_TANK_CAPACITY / MAX_FUEL_BARS)
-#define FUEL_RESERVE FUEL_VOLUME_PER_ROW
+#define FUEL_RESERVE (10 * FUEL_TANK_SCALE) // JMS_GFX
+
+#define FUEL_COST_RU 20 // JMS
 
 #define IP_SHIP_THRUST_INCREMENT 8
 #define IP_SHIP_TURN_WAIT 17
@@ -88,22 +94,22 @@ enum
 #define EMPTY_SLOT NUM_MODULES
 #define NUM_BOMB_MODULES 10
 
-#define DRIVE_SIDE_X 31
-#define DRIVE_SIDE_Y 56
-#define DRIVE_TOP_X 33
-#define DRIVE_TOP_Y (65 + 21)
-
-#define JET_SIDE_X 71
-#define JET_SIDE_Y 48
-#define JET_TOP_X 70
-#define JET_TOP_Y (73 + 21)
-
-#define MODULE_SIDE_X 17
-#define MODULE_SIDE_Y 14
-#define MODULE_TOP_X 17
-#define MODULE_TOP_Y (96 + 21)
+#define DRIVE_SIDE_X ((31 << RESOLUTION_FACTOR)) // JMS_GFX
+#define DRIVE_SIDE_Y ((56 << RESOLUTION_FACTOR)) // JMS_GFX
+#define DRIVE_TOP_X ((33 << RESOLUTION_FACTOR) + RES_CASE(0,42,100)) // JMS_GFX
+#define DRIVE_TOP_Y ((86 << RESOLUTION_FACTOR) - RES_CASE(0,45,73)) // JMS_GFX
+
+#define JET_SIDE_X ((71 << RESOLUTION_FACTOR)) // JMS_GFX
+#define JET_SIDE_Y ((48 << RESOLUTION_FACTOR)) // JMS_GFX
+#define JET_TOP_X ((70 << RESOLUTION_FACTOR) + RES_CASE(0,32,86)) // JMS_GFX
+#define JET_TOP_Y ((94 << RESOLUTION_FACTOR) - RES_CASE(0,69,120)) // JMS_GFX
+
+#define MODULE_SIDE_X ((17 << RESOLUTION_FACTOR) + RES_CASE(0,21,55)) // JMS_GFX
+#define MODULE_SIDE_Y ((14 << RESOLUTION_FACTOR) - RES_CASE(0,2,5)) // JMS_GFX
+#define MODULE_TOP_X ((17 << RESOLUTION_FACTOR) + RES_CASE(0,22,55)) // JMS_GFX
+#define MODULE_TOP_Y ((117 << RESOLUTION_FACTOR) + RES_CASE(0,14,59)) // JMS_GFX
 
-#define SHIP_PIECE_OFFSET 12
+#define SHIP_PIECE_OFFSET ((12 << RESOLUTION_FACTOR) - RES_CASE(0,3,2)) // JMS_GFX
 
 #define MAX_BUILT_SHIPS 12
 		/* Maximum number of ships escorting the SIS */
@@ -124,6 +130,9 @@ enum
 	{3 + 42, 30 + (5 * 16)},
 
 #define SIS_NAME_SIZE 16
+#define SAVE_NAME_SIZE 32 // JMS
+#define SAVE_NAME_CHECKER "superbutcherX !" // JMS
+#define SAVE_CHECKER_SIZE SIS_NAME_SIZE
 
 typedef struct
 {
@@ -159,6 +168,8 @@ typedef struct
 
 typedef struct
 {
+	UNICODE SaveNameChecker[SAVE_CHECKER_SIZE]; // JMS
+	UNICODE SaveName[SAVE_NAME_SIZE]; // JMS
 	SIS_STATE SS;
 	BYTE Activity;
 	BYTE Flags;
@@ -168,6 +179,7 @@ typedef struct
 	BYTE NumShips, NumDevices;
 	BYTE ShipList[MAX_BUILT_SHIPS];
 	BYTE DeviceList[MAX_EXCLUSIVE_DEVICES];
+	BYTE res_factor;	// JMS: Stores resolution factor to enable saving/loading from different res modes.
 } SUMMARY_DESC;
 
 #define OVERRIDE_LANDER_FLAGS (1 << 7)
@@ -210,6 +222,8 @@ typedef enum
 	SMM_DATE,
 	SMM_RES_UNITS,
 	SMM_CREDITS,
+	SMM_WARNING,
+	SMM_ALERT,
 
 	SMM_DEFAULT = SMM_DATE,
 } StatMsgMode;
diff -ruNp ./src.orig/uqm/starbase.c ./src/uqm/starbase.c
--- ./src.orig/uqm/starbase.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/starbase.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "build.h"
 #include "colors.h"
 #include "controls.h"
@@ -33,6 +35,13 @@
 #include "sounds.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/tasklib.h"
+#include "libs/log.h"
+
+#include "planets/planets.h"
+// JMS: For MIN_MOON_RADIUS
+
+#include <math.h>
+// JMS: For sin and cos
 
 
 static void CleanupAfterStarBase (void);
@@ -41,18 +50,21 @@ static void
 DrawBaseStateStrings (STARBASE_STATE OldState, STARBASE_STATE NewState)
 {
 	TEXT t;
+	RECT r;
+	COUNT text_base_y = 106 + 28 - RES_CASE (0,2,0);
+	COUNT text_spacing_y = 23 - 4;
 	//STRING locString;
 
 	SetContext (ScreenContext);
 	SetContextFont (StarConFont);
 	SetContextForeGroundColor (BLACK_COLOR);
 
-	t.baseline.x = 73 - 4 + SAFE_X;
+	t.baseline.x = (73 - 4 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_CENTER;
 
 	if (OldState == (STARBASE_STATE)~0)
 	{
-		t.baseline.y = 106 + 28 + (SAFE_Y + 4);
+		t.baseline.y = (text_base_y  << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX;
 		for (OldState = TALK_COMMANDER; OldState < DEPART_BASE; ++OldState)
 		{
 			if (OldState != NewState)
@@ -61,18 +73,24 @@ DrawBaseStateStrings (STARBASE_STATE Old
 				t.CharCount = (COUNT)~0;
 				font_DrawText (&t);
 			}
-			t.baseline.y += (23 - 4);
+			t.baseline.y += text_spacing_y << RESOLUTION_FACTOR; // JMS_GFX
 		}
 	}
 
-	t.baseline.y = 106 + 28 + (SAFE_Y + 4) + ((23 - 4) * OldState);
+	t.baseline.y = ((text_base_y + (text_spacing_y * OldState)) << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX
 	t.pStr = GAME_STRING (STARBASE_STRING_BASE + 1 + OldState);
+	// BW: erase previously selected string before redrawing it
+	TextRect(&t, &r, NULL);
+	SetContextForeGroundColor (
+			   BUILD_COLOR_RGBA (0x88, 0x88, 0x88, 0xff));
+	DrawFilledRectangle (&r);
+	SetContextForeGroundColor (BLACK_COLOR);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x0A), 0x0E));
-	t.baseline.y = 106 + 28 + (SAFE_Y + 4) + ((23 - 4) * NewState);
+	t.baseline.y = ((text_base_y + (text_spacing_y * NewState)) << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX
 	t.pStr = GAME_STRING (STARBASE_STRING_BASE + 1 + NewState);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
@@ -87,7 +105,14 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 	RECT r;
 	STAMP Side, Top;
 	SBYTE RepairSlot;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET;
 
+	// JMS_GFX
+	if (RESOLUTION_FACTOR != 0 &&
+		which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+		 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1)
+		ship_piece_offset_scaled += 1;
+	
 	RepairSlot = 0;
 	switch (which_piece)
 	{
@@ -111,9 +136,7 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 				RepairSlot = 1;
 				if (which_piece < EMPTY_SLOT
 						&& (which_slot == 0
-						|| GLOBAL_SIS (ModuleSlots[
-								which_slot - 1
-								]) < EMPTY_SLOT))
+						|| GLOBAL_SIS (ModuleSlots[which_slot - 1]) < EMPTY_SLOT))
 					++RepairSlot;
 			}
 			else if (!DrawBluePrint)
@@ -122,9 +145,7 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 					++which_piece;
 
 				if (which_slot < NUM_MODULE_SLOTS - 1
-						&& GLOBAL_SIS (ModuleSlots[
-								which_slot + 1
-								]) < EMPTY_SLOT)
+						&& GLOBAL_SIS (ModuleSlots[which_slot + 1]) < EMPTY_SLOT)
 				{
 					RepairSlot = -1;
 					if (which_piece == EMPTY_SLOT + 3
@@ -139,54 +160,112 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 			break;
 	}
 
-	Side.origin.x += which_slot * SHIP_PIECE_OFFSET;
+	Side.origin.x += which_slot * ship_piece_offset_scaled;
 	Side.frame = NULL;
 	if (RepairSlot < 0)
 	{
 		Side.frame = SetAbsFrameIndex (ModuleFrame,
 				((NUM_MODULES - 1) + (6 - 2)) + (NUM_MODULES + 6)
 				- (RepairSlot + 1));
-		DrawStamp (&Side);
+		
+		// JMS_GFX:
+		if (RESOLUTION_FACTOR == 0 ||
+			(which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+			 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1))
+			DrawStamp (&Side);
 	}
-	else if (RepairSlot)
+	else if (RepairSlot && !(RESOLUTION_FACTOR > 0 && DrawBluePrint))
 	{
-		r.corner = Side.origin;
-		r.extent.width = SHIP_PIECE_OFFSET;
-		r.extent.height = 1;
 		OldColor = SetContextForeGroundColor (BLACK_COLOR);
+	
+		r.corner = Side.origin;
+		r.corner.y += RES_CASE(0,0,8);
+		r.extent.width = ship_piece_offset_scaled;
+		r.extent.height = 1 << RESOLUTION_FACTOR;
 		DrawFilledRectangle (&r);
-		r.corner.y += 23 - 1;
-		DrawFilledRectangle (&r);
+		
+		r.corner.y += ((23 - 1) << RESOLUTION_FACTOR); // JMS_GFX
+		if (RESOLUTION_FACTOR != 0)
+			r.extent.height += RES_CASE(0,15,30); 
+		
+		if (which_slot == 0 && RESOLUTION_FACTOR !=0)
+			r.corner.x += RES_CASE(0,2,4); // JMS_GFX
+		else if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0)
+			r.extent.width -= RES_CASE(0,4,9); // JMS_GFX
 
-		r.extent.width = 1;
-		r.extent.height = 8;
+		DrawFilledRectangle (&r);
+		
+		r.extent.width = RES_CASE(1,5,12);
+		r.extent.height = (8 << RESOLUTION_FACTOR) + RES_CASE(0,13,30); // JMS_GFX
+		
 		if (RepairSlot == 2)
 		{
 			r.corner = Side.origin;
+			r.corner.y += RES_CASE(0,0,8);
 			DrawFilledRectangle (&r);
-			r.corner.y += 15;
+			if (RESOLUTION_FACTOR > 0)
+			{
+				r.corner.x += ship_piece_offset_scaled - r.extent.width;
+				if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0)
+				{
+					r.extent.height -= RES_CASE(0,8,16); // JMS_GFX
+					r.extent.width += RES_CASE(0,2,4); // JMS_GFX
+					DrawFilledRectangle (&r);
+					r.extent.width -= RES_CASE(0,2,4); // JMS_GFX
+				}
+				else
+					DrawFilledRectangle (&r);
+				
+				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+			}
+			r.corner.y += 15 << RESOLUTION_FACTOR; // JMS_GFX
+			
 			DrawFilledRectangle (&r);
+			if (RESOLUTION_FACTOR > 0)
+			{
+				r.corner.x += ship_piece_offset_scaled - r.extent.width;
+				if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0)
+				{
+					r.corner.y += RES_CASE(0,16,32);
+					r.extent.height -= RES_CASE(0,17,36); // JMS_GFX
+					r.extent.width += RES_CASE(0,1,3); // JMS_GFX
+					DrawFilledRectangle (&r);
+					r.extent.width -= RES_CASE(0,1,3); // JMS_GFX
+					r.extent.height += RES_CASE(0,17,36); // JMS_GFX
+				}
+				else
+					DrawFilledRectangle (&r);
+				
+				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+			}
 		}
 		if (which_slot < (NUM_MODULE_SLOTS - 1))
 		{
 			r.corner = Side.origin;
-			r.corner.x += SHIP_PIECE_OFFSET;
+			r.corner.y += RES_CASE(0,0,8);
+			r.corner.x += ship_piece_offset_scaled;
 			DrawFilledRectangle (&r);
-			r.corner.y += 15;
+			if (RESOLUTION_FACTOR == 2)
+			{
+				r.corner.x += ship_piece_offset_scaled - r.extent.width;
+				DrawFilledRectangle (&r);
+				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+			}
+			r.corner.y += 15 << RESOLUTION_FACTOR; // JMS_GFX
 			DrawFilledRectangle (&r);
 		}
 	}
 
 	if (DrawBluePrint)
 	{
-		if (RepairSlot)
+		if (RepairSlot && !(RESOLUTION_FACTOR > 0 && DrawBluePrint))
 			SetContextForeGroundColor (OldColor);
 		Side.frame = SetAbsFrameIndex (ModuleFrame, which_piece - 1);
 		DrawFilledStamp (&Side);
 	}
 	else
 	{
-		Top.origin.x += which_slot * SHIP_PIECE_OFFSET;
+		Top.origin.x += which_slot * ship_piece_offset_scaled;
 		if (RepairSlot < 0)
 		{
 			Top.frame = SetRelFrameIndex (Side.frame, -((NUM_MODULES - 1) + 6));
@@ -195,28 +274,41 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 		else if (RepairSlot)
 		{
 			r.corner = Top.origin;
-			r.extent.width = SHIP_PIECE_OFFSET;
-			r.extent.height = 1;
+			r.extent.width = ship_piece_offset_scaled;
+			r.extent.height = (1 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR;
 			DrawFilledRectangle (&r);
-			r.corner.y += 32 - 1;
+			r.corner.y += ((32 - 1) << RESOLUTION_FACTOR) + RES_CASE(0,3,16);  // JMS_GFX
 			DrawFilledRectangle (&r);
 
-			r.extent.width = 1;
-			r.extent.height = 12;
+			r.extent.width = (1 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR;
+			r.extent.height = (12 << RESOLUTION_FACTOR) + RES_CASE(0,1,17); // JMS_GFX
+			
 			if (RepairSlot == 2)
 			{
 				r.corner = Top.origin;
 				DrawFilledRectangle (&r);
-				r.corner.y += 20;
+				if (RESOLUTION_FACTOR == 2)
+				{
+					r.corner.x += ship_piece_offset_scaled - r.extent.width;
+					DrawFilledRectangle (&r);
+					r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+				}
+				r.corner.y += 20 << RESOLUTION_FACTOR; // JMS_GFX
 				DrawFilledRectangle (&r);
+				if (RESOLUTION_FACTOR == 2)
+				{
+					r.corner.x += ship_piece_offset_scaled - r.extent.width;
+					DrawFilledRectangle (&r);
+					r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+				}
 			}
 			RepairSlot = (which_slot < NUM_MODULE_SLOTS - 1);
 			if (RepairSlot)
 			{
 				r.corner = Top.origin;
-				r.corner.x += SHIP_PIECE_OFFSET;
+				r.corner.x += ship_piece_offset_scaled;
 				DrawFilledRectangle (&r);
-				r.corner.y += 20;
+				r.corner.y += 20 << RESOLUTION_FACTOR; // JMS_GFX
 				DrawFilledRectangle (&r);
 			}
 		}
@@ -225,26 +317,46 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 		DrawStamp (&Top);
 
 		Side.frame = SetRelFrameIndex (Top.frame, (NUM_MODULES - 1) + 6);
-		DrawStamp (&Side);
+		
+		if (RESOLUTION_FACTOR != 0 
+			&& (which_piece == EMPTY_SLOT + 2 
+				|| which_piece == EMPTY_SLOT + 3))
+		{
+			if (which_slot == 0)
+				Side.frame = SetRelFrameIndex (Side.frame, 8);
+			if (which_slot == 1)
+				Side.frame = SetRelFrameIndex (Side.frame, 10);
+			if (which_slot == NUM_MODULE_SLOTS - 2)
+				Side.frame = SetRelFrameIndex (Side.frame, 10);
+			if (which_slot == NUM_MODULE_SLOTS - 1)
+				Side.frame = SetRelFrameIndex (Side.frame, 11);
+		}
+		
+		// JMS_GFX:
+		if (RESOLUTION_FACTOR == 0 ||
+			(which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+			 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1))
+			DrawStamp (&Side);
 
-		if (which_slot == 1 && which_piece == EMPTY_SLOT + 2)
+		if (which_slot == 1 && which_piece == EMPTY_SLOT + 2 && RESOLUTION_FACTOR == 0)
 		{
 			STAMP s;
 
 			s.origin = Top.origin;
-			s.origin.x -= SHIP_PIECE_OFFSET;
+			s.origin.x -= ship_piece_offset_scaled;
 			s.frame = SetAbsFrameIndex (ModuleFrame, NUM_MODULES + 5);
 			DrawStamp (&s);
 			s.origin = Side.origin;
-			s.origin.x -= SHIP_PIECE_OFFSET;
+			s.origin.x -= ship_piece_offset_scaled;
 			s.frame = SetRelFrameIndex (s.frame, (NUM_MODULES - 1) + 6);
+			
 			DrawStamp (&s);
 		}
 
 		if (RepairSlot)
 		{
-			Top.origin.x += SHIP_PIECE_OFFSET;
-			Side.origin.x += SHIP_PIECE_OFFSET;
+			Top.origin.x += ship_piece_offset_scaled;
+			Side.origin.x += ship_piece_offset_scaled;
 			which_piece = GLOBAL_SIS (ModuleSlots[++which_slot]);
 			if (which_piece == EMPTY_SLOT + 2
 					&& which_slot >= NUM_MODULE_SLOTS - 3)
@@ -254,7 +366,26 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 			DrawStamp (&Top);
 
 			Side.frame = SetRelFrameIndex (Top.frame, (NUM_MODULES - 1) + 6);
-			DrawStamp (&Side);
+			
+			if (RESOLUTION_FACTOR != 0)
+			{
+				if (which_slot == 0 && which_piece == EMPTY_SLOT + 3)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-4);
+				if (which_slot == 1 && which_piece == EMPTY_SLOT + 2)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-3);
+				if (which_slot == NUM_MODULE_SLOTS - 2 
+					&& which_piece == EMPTY_SLOT + 3)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-2);
+				if (which_slot == NUM_MODULE_SLOTS - 1 
+					&& which_piece == EMPTY_SLOT + 3)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-1);
+			}
+			
+			// JMS_GFX:
+			if (RESOLUTION_FACTOR == 0 ||
+				(which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+				 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1))
+				DrawStamp (&Side);
 		}
 	}
 }
@@ -434,6 +565,41 @@ DoTimePassage (void)
 	LockMutex (GraphicsLock);
 	MoveGameClockDays (LOST_DAYS);
 	UnlockMutex (GraphicsLock);
+	
+	// JMS: Calculate flagship location in IP.
+	{
+		double newAngle;
+		POINT starbase_coords;
+		RECT r;
+		COORD dx, dy;
+		
+		// Starbase's radius from earth is MIN_MOON_RADIUS.
+		dx = MIN_MOON_RADIUS;
+		dy = MIN_MOON_RADIUS;
+		
+		// Calculate the starbase position on a circle with the help of sin and cos.
+		newAngle = ((double)(10) + daysElapsed() * (FULL_CIRCLE / 11.46)) * M_PI / 32 - M_PI/2 ; // JMS: Starbase orbit values copied from gensol.c
+		starbase_coords.x = (COORD)(cos(newAngle) * MIN_MOON_RADIUS);
+		starbase_coords.y = (COORD)(sin(newAngle) * MIN_MOON_RADIUS);
+		
+		//log_add (log_Debug, "startangle:%d angle:%f, radius:%d, speed:%f, days:%f X:%d, y:%d", 10, newAngle, MIN_MOON_RADIUS, FULL_CIRCLE / 11.46, daysElapsed(), starbase_coords.x, starbase_coords.y);
+		
+		// Translate the coordinates on a circle to an ellipse.
+		r.corner.x = (SIS_SCREEN_WIDTH >> 1) + (long)-dx;
+		r.corner.y = (SIS_SCREEN_HEIGHT >> 1) + (long)-dy / 2;
+		r.extent.width = (long)MIN_MOON_RADIUS * (2 << 1) / 2;
+		r.extent.height = r.extent.width >> 1;
+		r.corner.x += r.extent.width >> 1;
+		r.corner.y += r.extent.height >> 1;
+		r.corner.x += (long)starbase_coords.x;
+		r.corner.y += (long)starbase_coords.y / 2;
+		
+		//log_add (log_Debug, "X:%d, y:%d", r.corner.x, r.corner.y);
+		
+		// Update the ship's graphics' coordinates on the screen.
+		GLOBAL (ShipStamp.origin.x) = r.corner.x;
+		GLOBAL (ShipStamp.origin.y) = r.corner.y;
+	}
 }
 
 void
@@ -502,7 +668,7 @@ VisitStarBase (void)
 		DoTimePassage ();
 		if (GLOBAL_SIS (CrewEnlisted) == (COUNT)~0)
 			return; // You are now dead! Thank you! (killed by Kohr-Ah)
-
+		
 		SetCommIntroMode (CIM_FADE_IN_SCREEN, ONE_SECOND * 2);
 		InitCommunication (COMMANDER_CONVERSATION);
 		if (GLOBAL (CurrentActivity) & CHECK_ABORT)
diff -ruNp ./src.orig/uqm/starcon.c ./src/uqm/starcon.c
--- ./src.orig/uqm/starcon.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/starcon.c	2017-10-23 11:41:35 -0700
@@ -49,6 +49,8 @@
 #include "uqmversion.h"
 #include "options.h"
 
+#include "gameopt.h" // JMS: For naming captain and ship at game start.
+
 volatile int MainExited = FALSE;
 
 // Open or close the periodically occuring QuasiSpace portal.
@@ -121,6 +123,13 @@ ProcessUtilityKeys (void)
 	if (ImmediateInputState.menu[KEY_FULLSCREEN])
 	{
 		int flags = GfxFlags ^ TFB_GFXFLAGS_FULLSCREEN;
+		
+		// JMS: Force the usage of bilinear scaler in 1280x960 fullscreen.
+		if (resolutionFactor > 0)
+		{
+			flags |= TFB_GFXFLAGS_SCALE_BILINEAR;
+		}
+		
 		// clear ImmediateInputState so we don't repeat this next frame
 		FlushInput ();
 		TFB_DrawScreen_ReinitVideo (GraphicsDriver, flags, ScreenWidthActual,
@@ -134,6 +143,30 @@ ProcessUtilityKeys (void)
 		FlushInput ();
 		debugKeyPressed ();
 	}
+	
+	// JMS: The secondary debug key.
+	if (ImmediateInputState.menu[KEY_DEBUG_2])
+	{
+		// clear ImmediateInputState so we don't repeat this next frame
+		FlushInput ();
+		debugKey2Pressed ();
+	}
+	
+	// JMS: The tertiary debug key.
+	if (ImmediateInputState.menu[KEY_DEBUG_3])
+	{
+		// clear ImmediateInputState so we don't repeat this next frame
+		FlushInput ();
+		debugKey3Pressed ();
+	}
+	
+	// JMS: The quaternary debug key.
+	if (ImmediateInputState.menu[KEY_DEBUG_4])
+	{
+		// clear ImmediateInputState so we don't repeat this next frame
+		FlushInput ();
+		debugKey4Pressed ();
+	}
 #endif  /* DEBUG */
 }
 
@@ -186,7 +219,7 @@ while (--ac > 0)
 		return EXIT_FAILURE;
 	}
 	log_add (log_Info, "We've loaded the Kernel");
-
+	
 	GLOBAL (CurrentActivity) = 0;
 	// show splash and init the kernel in the meantime
 	SplashScreen (BackgroundInitKernel);
@@ -202,6 +235,10 @@ while (--ac > 0)
 		InitGameStructures ();
 		InitGameClock ();
 		AddInitialGameEvents();
+		
+		// JMS: Name Captain & Ship at start (not at loading old game).
+		if (LastActivity == (CHECK_LOAD | CHECK_RESTART))
+			AskNameForCaptainAndShip();
 
 		do
 		{
diff -ruNp ./src.orig/uqm/state.c ./src/uqm/state.c
--- ./src.orig/uqm/state.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/state.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "state.h"
 
 #include "encount.h"
@@ -233,17 +235,25 @@ UninitPlanetInfo (void)
 }
 
 #define OFFSET_SIZE       (sizeof (DWORD))
-#define SCAN_RECORD_SIZE  (sizeof (DWORD) * NUM_SCAN_TYPES)
+
+// JMS: Increased the size of scan record to house partially scavenged minerals.
+#define SCAN_RECORD_SIZE  ((sizeof (DWORD) * NUM_SCAN_TYPES) + (sizeof(BYTE) * NUM_SCAN_TYPES * 32))
 
 void
 GetPlanetInfo (void)
 {
 	void *fp;
+	COUNT k,l;
 
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] = 0;
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[MINERAL_SCAN] = 0;
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN] = 0;
 
+	// JMS: Init also the partially scavenged mineral deposit values.
+	for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+		for (k = 0; k < 32; k++)
+			pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[l][k] = 0;
+	
 	fp = OpenStateFile (STARINFO_FILE, "rb");
 	if (fp)
 	{
@@ -277,6 +287,15 @@ GetPlanetInfo (void)
 			SeekStateFile (fp, offset, SEEK_SET);
 			sread_a32 (fp, pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask,
 					NUM_SCAN_TYPES);
+			
+			{
+				BYTE *ar = &(pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[0][0]); // JMS
+				
+				// JMS: Read which mineral deposits are partially retrieved (and how much).
+				for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+					for (k = 0; k < 32; k++, ar++)
+						sread_8 (fp, ar);
+			}
 		}
 
 		CloseStateFile (fp);
@@ -291,7 +310,7 @@ PutPlanetInfo (void)
 	fp = OpenStateFile (STARINFO_FILE, "r+b");
 	if (fp)
 	{
-		COUNT i;
+		COUNT i, k, l;
 		COUNT star_index, planet_index, moon_index;
 		DWORD offset;
 
@@ -313,6 +332,12 @@ PutPlanetInfo (void)
 			{
 				0, 0, 0,
 			};
+			
+			// JMS: Init also the partially scavenged mineral deposit values.
+			BYTE PartiallyScavengedList[NUM_SCAN_TYPES][32];
+			for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+				for (k = 0; k < 32; k++)
+					PartiallyScavengedList[l][k] = 0;
 
 			offset = LengthStateFile (fp);
 
@@ -325,11 +350,27 @@ PutPlanetInfo (void)
 			for (i = 0; i < pSolarSysState->SunDesc[0].NumPlanets; ++i)
 			{
 				COUNT j;
+				BYTE *ar = &(PartiallyScavengedList[0][0]); // JMS
 
 				swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
+				
+				// JMS: Also init with zeroes the list of partially scavenged mineral amounts.
+				for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+					for (k = 0; k < 32; k++, ar++)
+						swrite_8 (fp, *ar);
+				
 				// init moons
 				for (j = 0; j < pSolarSysState->PlanetDesc[i].NumPlanets; ++j)
+				{
+					BYTE *ar = &(PartiallyScavengedList[0][0]); // JMS
+					
 					swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
+					
+					// JMS: Ditto for the moons.
+					for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+						for (k = 0; k < 32; k++, ar++)
+							swrite_8 (fp, *ar);
+				}
 			}
 		}
 
@@ -342,8 +383,19 @@ PutPlanetInfo (void)
 		offset += moon_index * SCAN_RECORD_SIZE;
 
 		SeekStateFile (fp, offset, SEEK_SET);
+		
+		// Store which mineral deposits we have already retrieved.
 		swrite_a32 (fp, pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask,
-				NUM_SCAN_TYPES);
+					NUM_SCAN_TYPES);
+		
+		{
+			BYTE *ar = &(pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[0][0]); // JMS
+			
+			// JMS: Store which mineral deposits are partially retrieved (and how much).
+			for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+				for (k = 0; k < 32; k++, ar++)
+					swrite_8 (fp, *ar);
+		}
 
 		CloseStateFile (fp);
 	}
diff -ruNp ./src.orig/uqm/status.c ./src/uqm/status.c
--- ./src.orig/uqm/status.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/status.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "status.h"
 #include "colors.h"
 #include "globdata.h"
@@ -137,18 +139,18 @@ DrawBattleCrewAmount (SHIP_INFO *ShipInf
 	TEXT t;
 	UNICODE buf[40];
 
-	t.baseline.x = BATTLE_CREW_X + 2;
+	t.baseline.x = BATTLE_CREW_X + RES_STAT_SCALE(2) - RES_CASE(0,1,2); // JMS_GFX
 	if (optWhichMenu == OPT_PC)
-			t.baseline.x -= 8;
+			t.baseline.x -= RES_STAT_SCALE(8); // JMS_GFX
 	t.baseline.y = BATTLE_CREW_Y + y_offs;
 	t.align = ALIGN_LEFT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
 	r.corner.x = t.baseline.x;
-	r.corner.y = t.baseline.y - 5;
-	r.extent.width = 6 * MAX_CREW_DIGITS + 6;
-	r.extent.height = 5;
+	r.corner.y = t.baseline.y - (5 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.width = 6 * MAX_CREW_DIGITS + (6 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = (5 << RESOLUTION_FACTOR) + RES_CASE(0,2,3); // JMS_GFX
 
 	sprintf (buf, "%u", ShipInfoPtr->crew_level);
 	SetContextFont (StarConFont);
@@ -188,17 +190,18 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 
 	BatchGraphics ();
 	
+	// Grey area under and around captain's window.
 	assert (StarShipPtr->playerNr >= 0);
 	y_offs = status_y_offsets[StarShipPtr->playerNr];
-
-	r.corner.x = CAPTAIN_XOFFS - 2;
+	r.corner.x = CAPTAIN_XOFFS - RES_STAT_SCALE(4); // JMS_GFX
 	r.corner.y = y_offs + SHIP_INFO_HEIGHT;
-	r.extent.width = STATUS_WIDTH - CAPTAIN_XOFFS;
-	r.extent.height = SHIP_STATUS_HEIGHT - CAPTAIN_YOFFS + 2;
+	r.extent.width = STATUS_WIDTH - 2;
+	r.extent.height = SHIP_STATUS_HEIGHT - CAPTAIN_YOFFS + (4 << RESOLUTION_FACTOR); // JMS_GFX
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 	DrawFilledRectangle (&r);
 
+	// Left border of the status panel.
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 	r.corner.x = 1;
@@ -210,6 +213,7 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 	++r.extent.height;
 	DrawFilledRectangle (&r);
 
+	// Lower and right border of the status panel.
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 	r.corner.x = STATUS_WIDTH - 1;
@@ -228,33 +232,35 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 	++r.extent.width;
 	++r.corner.y;
 	DrawFilledRectangle (&r);
-
+	
 	y = y_offs + CAPTAIN_YOFFS;
 
+	// Darker grey rectangle at bottom and right of captain's window
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
-	r.corner.x = 59;
+	r.corner.x = CAPTAIN_WIDTH + CAPTAIN_XOFFS;
 	r.corner.y = y;
 	r.extent.width = 1;
-	r.extent.height = 30;
+	r.extent.height = CAPTAIN_HEIGHT;
 	DrawFilledRectangle (&r);
-	r.corner.x = 3;
-	r.corner.y += 30;
-	r.extent.width = 57;
+	r.corner.x = CAPTAIN_XOFFS - 1;
+	r.corner.y += CAPTAIN_HEIGHT;
+	r.extent.width = CAPTAIN_WIDTH + 2;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
 
+	// Light grey rectangle at top and left of captains window
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
-	r.corner.x = 3;
-	r.extent.width = 57;
+	r.corner.x = CAPTAIN_XOFFS - 1;
+	r.extent.width = CAPTAIN_WIDTH + 2;
 	r.corner.y = y - 1;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
-	r.corner.x = 3;
+	r.corner.x = CAPTAIN_XOFFS - 1;
 	r.extent.width = 1;
 	r.corner.y = y;
-	r.extent.height = 30;
+	r.extent.height = CAPTAIN_HEIGHT;
 	DrawFilledRectangle (&r);
 
 	s.frame = RDPtr->ship_data.captain_control.background;
@@ -268,12 +274,11 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 		TEXT t;
 
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = y + 6;
+		t.baseline.y = y + RES_CASE(6,-22,-44); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.pStr = GLOBAL_SIS (CommanderName);
 		t.CharCount = (COUNT)~0;
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02));
+		SetContextForeGroundColor (RES_CASE(BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02), BLACK_COLOR, BLACK_COLOR));
 		SetContextFont (TinyFont);
 		font_DrawText (&t);
 	}
@@ -421,7 +426,7 @@ PostProcessStatus (ELEMENT *ShipPtr)
 
 			if (StarShipPtr->RaceDescPtr->ship_info.crew_level == 0)
 			{
-				BYTE i;
+				BYTE i, j;
 				Color c;
 				RECT r;
 
@@ -469,49 +474,58 @@ PostProcessStatus (ELEMENT *ShipPtr)
 						};
 
 						c = flash_tab1[i];
-						r.corner.x = CAPTAIN_XOFFS + i;
-						r.corner.y = y + CAPTAIN_YOFFS + i;
-						r.extent.width = CAPTAIN_WIDTH - (i << 1);
-						r.extent.height = CAPTAIN_HEIGHT - (i << 1);
+						
+						// JMS_GFX
+						r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(i);
+						r.corner.y = y + CAPTAIN_YOFFS + RES_STAT_SCALE(i);
+						r.extent.width = CAPTAIN_WIDTH - RES_STAT_SCALE((i << 1));
+						r.extent.height = CAPTAIN_HEIGHT - RES_STAT_SCALE((i << 1));
 						if (r.extent.height == 2)
 							++r.extent.height;
-						DrawRectangle (&r);
-						++r.corner.x;
-						++r.corner.y;
-						r.extent.width -= 2;
-						r.extent.height -= 2;
+						
+						// JMS_GFX
+						for (j=0 ; j<RES_STAT_SCALE(1); j++)
+						{
+							DrawRectangle (&r);
+							++r.corner.x;
+							++r.corner.y;
+							r.extent.width -= 2;
+							r.extent.height -= 2;
+						}
 					}
 					else if ((i -= 15) <= 4)
 					{
-						r.corner.y = y + (CAPTAIN_YOFFS + 15);
-						r.extent.width = i + 1;
+						r.corner.y = y + (CAPTAIN_YOFFS + RES_STAT_SCALE(15)); // JMS_GFX
+						r.extent.width = RES_STAT_SCALE(i + 1); // JMS_GFX
 						r.extent.height = 1;
+						
+						// JMS_GFX
 						switch (i)
 						{
 							case 0:
-								r.corner.x = CAPTAIN_XOFFS + 15;
-								i = CAPTAIN_WIDTH - ((15 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(15);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((15 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x13, 0x00, 0x00), 0x2C);
 								break;
 							case 1:
-								r.corner.x = CAPTAIN_XOFFS + 16;
-								i = CAPTAIN_WIDTH - ((17 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(16);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((17 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x07, 0x00, 0x00), 0x2F);
 								break;
 							case 2:
-								r.corner.x = CAPTAIN_XOFFS + 18;
-								i = CAPTAIN_WIDTH - ((20 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(18);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((20 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x00), 0x2A);
 								break;
 							case 3:
-								r.corner.x = CAPTAIN_XOFFS + 21;
-								i = CAPTAIN_WIDTH - ((24 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(21);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((24 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x00, 0x00), 0x29);
 								break;
 							case 4:
-								r.corner.x = CAPTAIN_XOFFS + 25;
-								i = 1;
-								r.extent.width = 2;
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(25);
+								i = RES_STAT_SCALE(1);
+								r.extent.width = RES_STAT_SCALE(2);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x50, 0x05), 0x28);
 								break;
 							default:
diff -ruNp ./src.orig/uqm/status.h ./src/uqm/status.h
--- ./src.orig/uqm/status.h	2017-10-23 11:42:17 -0700
+++ ./src/uqm/status.h	2017-10-23 11:41:35 -0700
@@ -16,42 +16,42 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef UQM_STATUS_H_INCL_
 #define UQM_STATUS_H_INCL_
 
 #include "races.h"
 #include "libs/compiler.h"
 
-#define CREW_XOFFS 4
-#define ENERGY_XOFFS 52
-#define GAUGE_YOFFS (SHIP_INFO_HEIGHT - 10)
-#define UNIT_WIDTH 2
-#define UNIT_HEIGHT 1
-#define STAT_WIDTH (1 + UNIT_WIDTH + 1 + UNIT_WIDTH + 1)
-
-#define SHIP_INFO_HEIGHT 65
-#define CAPTAIN_XOFFS 4
-#define CAPTAIN_YOFFS (SHIP_INFO_HEIGHT + 4)
-#define CAPTAIN_WIDTH 55
-#define CAPTAIN_HEIGHT 30
+#define CREW_XOFFS RES_STAT_SCALE(4) // JMS_GFX
+#define ENERGY_XOFFS (RES_STAT_SCALE(52) + (3 * RESOLUTION_FACTOR) + (RESOLUTION_FACTOR / 2)) // JMS_GFX
+#define GAUGE_YOFFS (SHIP_INFO_HEIGHT - (10 << RESOLUTION_FACTOR) + 6 * RESOLUTION_FACTOR) // JMS_GFX
+#define UNIT_WIDTH RES_STAT_SCALE(2)
+#define UNIT_HEIGHT (1 << RESOLUTION_FACTOR)
+#define STAT_WIDTH (1 + UNIT_WIDTH + 1 + UNIT_WIDTH + 1) // JMS_GFX
+
+#define SHIP_INFO_HEIGHT (65 << RESOLUTION_FACTOR) // JMS_GFX
+#define CAPTAIN_WIDTH RES_STAT_SCALE(55) // JMS_GFX
+#define CAPTAIN_HEIGHT RES_STAT_SCALE(30) // JMS_GFX
+#define CAPTAIN_XOFFS ((STATUS_WIDTH - CAPTAIN_WIDTH) >> 1) // JMS_GFX
+#define CAPTAIN_YOFFS (SHIP_INFO_HEIGHT + (4 << RESOLUTION_FACTOR)) // JMS_GFX
 #define SHIP_STATUS_HEIGHT (STATUS_HEIGHT >> 1)
 #define BAD_GUY_YOFFS 0
 #define GOOD_GUY_YOFFS SHIP_STATUS_HEIGHT
-#define STARCON_TEXT_HEIGHT 7
-#define TINY_TEXT_HEIGHT 9
-
-#define BATTLE_CREW_X 10
-#define BATTLE_CREW_Y (64 - SAFE_Y)
+#define STARCON_TEXT_HEIGHT (7 << RESOLUTION_FACTOR) // JMS_GFX
+#define TINY_TEXT_HEIGHT (9 << RESOLUTION_FACTOR) // JMS_GFX
+#define BATTLE_CREW_X RES_STAT_SCALE(10) // JMS_GFX
+#define BATTLE_CREW_Y ((64 - SAFE_Y) << RESOLUTION_FACTOR) // JMS_GFX
 
 extern COORD status_y_offsets[];
 
 extern void InitStatusOffsets (void);
 
 extern void DrawCrewFuelString (COORD y, SIZE state);
-extern void ClearShipStatus (COORD y);
-extern void OutlineShipStatus (COORD y);
-extern void InitShipStatus (SHIP_INFO *ShipInfoPtr, STARSHIP *StarShipPtr,
-		RECT *pClipRect);
+extern void ClearShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu);
+extern void OutlineShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu); // JMS: now is needed elsewhere
+extern void InitShipStatus (SHIP_INFO *ShipInfoPtr, STARSHIP *StarShipPtr, RECT *pClipRect, BOOLEAN inMeleeMenu);
 			// StarShipPtr or pClipRect can be NULL
 extern void DeltaStatistics (SHIP_INFO *ShipInfoPtr, COORD y_offs,
 		SIZE crew_delta, SIZE energy_delta);
diff -ruNp ./src.orig/uqm/supermelee/buildpick.c ./src/uqm/supermelee/buildpick.c
--- ./src.orig/uqm/supermelee/buildpick.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/supermelee/buildpick.c	2017-10-23 11:41:35 -0700
@@ -14,6 +14,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "buildpick.h"
 
 #include "../controls.h"
@@ -69,8 +71,8 @@ DrawPickIcon (MeleeShip ship, bool DrawE
 
 	GetFrameRect (BuildPickFrame, &r);
 
-	s.origin.x = r.corner.x + 20 + (ship % NUM_PICK_COLS) * 18;
-	s.origin.y = r.corner.y +  5 + (ship / NUM_PICK_COLS) * 18;
+	s.origin.x = r.corner.x + (20 << RESOLUTION_FACTOR) + (ship % NUM_PICK_COLS) * (18 << RESOLUTION_FACTOR) - RES_CASE(0,0,2); // JMS_GFX
+	s.origin.y = r.corner.y + (5 << RESOLUTION_FACTOR) + (ship / NUM_PICK_COLS) * (18 << RESOLUTION_FACTOR); // JMS_GFX
 	s.frame = GetShipIconsFromIndex (ship);
 	if (DrawErase)
 	{	// draw icon
diff -ruNp ./src.orig/uqm/supermelee/loadmele.c ./src/uqm/supermelee/loadmele.c
--- ./src.orig/uqm/supermelee/loadmele.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/supermelee/loadmele.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 // This file handles loading of teams, but the UI and the actual loading.
 
 #define MELEESETUP_INTERNAL
@@ -41,10 +43,9 @@
 		BUILD_COLOR (MAKE_RGB15 (0x17, 0x18, 0x1D), 0x00)
 
 
-#define LOAD_MELEE_BOX_WIDTH 34
-#define LOAD_MELEE_BOX_HEIGHT 34
-#define LOAD_MELEE_BOX_SPACE 1
-
+#define LOAD_MELEE_BOX_WIDTH (RES_CASE(34,65,131)) // JMS_GFX
+#define LOAD_MELEE_BOX_HEIGHT (34 << RESOLUTION_FACTOR) // JMS_GFX
+#define LOAD_MELEE_BOX_SPACE (1 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void DrawFileStrings (MELEE_STATE *pMS);
 static bool FillFileView (MELEE_STATE *pMS);
@@ -177,7 +178,7 @@ DrawFileString (const MeleeTeam *team, c
 		sprintf (buf, "%u", MeleeTeam_getValue (team));
 		Text.baseline = *origin;
 		Text.baseline.x += NUM_MELEE_COLUMNS *
-				(LOAD_MELEE_BOX_WIDTH + LOAD_MELEE_BOX_SPACE) - 1;
+				(LOAD_MELEE_BOX_WIDTH + LOAD_MELEE_BOX_SPACE) - RES_CASE(1,-5,1);
 		Text.align = ALIGN_RIGHT;
 		Text.pStr = buf;
 		Text.CharCount = (COUNT)~0;
@@ -190,8 +191,9 @@ DrawFileString (const MeleeTeam *team, c
 		STAMP s;
 		FleetShipIndex slotI;
 
-		s.origin.x = origin->x + 1;
-		s.origin.y = origin->y + 4;
+		s.origin.x = origin->x + (1 << RESOLUTION_FACTOR); // JMS_GFX
+		s.origin.y = origin->y + (RES_CASE(4,8,12)); // JMS_GFX
+
 		for (slotI = 0; slotI < MELEE_FLEET_SIZE; slotI++)
 		{
 			BYTE StarShip;
@@ -201,7 +203,7 @@ DrawFileString (const MeleeTeam *team, c
 			{
 				s.frame = GetShipIconsFromIndex (StarShip);
 				DrawStamp (&s);
-				s.origin.x += 17;
+				s.origin.x += 17 << RESOLUTION_FACTOR; // JMS_GFX
 			}
 		}
 	}
@@ -230,9 +232,10 @@ FillFileView (MELEE_STATE *pMS)
 	return true;
 }
 
-#define FILE_STRING_ORIGIN_X  5
-#define FILE_STRING_ORIGIN_Y  34
-#define ENTRY_HEIGHT 32
+#define FILE_STRING_ORIGIN_X (RES_CASE(5,18,45)) // JMS_GFX
+#define FILE_STRING_ORIGIN_Y  ((34 << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR * 23)) // JMS_GFX
+#define ENTRY_HEIGHT (RES_CASE(32,64,132)) // JMS_GFX
+
 
 static void
 SelectFileString (MELEE_STATE *pMS, bool hilite)
diff -ruNp ./src.orig/uqm/supermelee/melee.c ./src/uqm/supermelee/melee.c
--- ./src.orig/uqm/supermelee/melee.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/supermelee/melee.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,14 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
+// JMS: Had to include some stuff that actually shouldn't be here in order to get the
+// melee team saving&loading after restart to work.
+#define MELEESETUP_INTERNAL
+#define MELEETEAM_INTERNAL
+#include "meleesetup.h"
+
 #include "melee.h"
 
 #include "options.h"
@@ -96,28 +104,32 @@ enum
 #define TOP_ENTRY CONTROLS_TOP
 #endif
 
-#define MELEE_X_OFFS 2
-#define MELEE_Y_OFFS 21
-#define MELEE_BOX_WIDTH 34
-#define MELEE_BOX_HEIGHT 34
-#define MELEE_BOX_SPACE 1
-
-#define MENU_X_OFFS 29
-
-#define INFO_ORIGIN_X 4
-#define INFO_WIDTH 58
-#define TEAM_INFO_ORIGIN_Y 3
-#define TEAM_INFO_HEIGHT (SHIP_INFO_HEIGHT + 75)
-#define MODE_INFO_ORIGIN_Y (TEAM_INFO_HEIGHT + 6)
-#define MODE_INFO_HEIGHT ((STATUS_HEIGHT - 3) - MODE_INFO_ORIGIN_Y)
-#define RACE_INFO_ORIGIN_Y (SHIP_INFO_HEIGHT + 6)
-#define RACE_INFO_HEIGHT ((STATUS_HEIGHT - 3) - RACE_INFO_ORIGIN_Y)
+// Start of JMS_GFX
+// Top Melee Menu
+#define MELEE_X_OFFS (2 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_Y_OFFS ((21 << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR * 21)) // JMS_GFX
+#define MELEE_BOX_WIDTH (34 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_BOX_HEIGHT (34 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_BOX_SPACE (1 << RESOLUTION_FACTOR) // JMS_GFX
+
+#define MENU_X_OFFS (29 << RESOLUTION_FACTOR) // JMS_GFX
+
+
+#define INFO_ORIGIN_X (4 << RESOLUTION_FACTOR) // JMS_GFX
+#define INFO_WIDTH (58 << RESOLUTION_FACTOR) // JMS_GFX
+#define TEAM_INFO_ORIGIN_Y (3 << RESOLUTION_FACTOR) // JMS_GFX
+#define TEAM_INFO_HEIGHT (SHIP_INFO_HEIGHT + (75 << RESOLUTION_FACTOR)) // JMS_GFX
+#define MODE_INFO_ORIGIN_Y (TEAM_INFO_HEIGHT + (6 << RESOLUTION_FACTOR)) // JMS_GFX
+#define MODE_INFO_HEIGHT ((STATUS_HEIGHT - (3 << RESOLUTION_FACTOR)) - MODE_INFO_ORIGIN_Y) // JMS_GFX
+#define RACE_INFO_ORIGIN_Y (SHIP_INFO_HEIGHT + (6 << RESOLUTION_FACTOR)) // JMS_GFX
+#define RACE_INFO_HEIGHT ((STATUS_HEIGHT - (3 << RESOLUTION_FACTOR)) - RACE_INFO_ORIGIN_Y) // JMS_GFX
 
-#define MELEE_STATUS_X_OFFS 1
-#define MELEE_STATUS_Y_OFFS 201
+#define MELEE_STATUS_X_OFFS ((1 << RESOLUTION_FACTOR)) // JMS_GFX
+#define MELEE_STATUS_Y_OFFS (201 << RESOLUTION_FACTOR) // JMS_GFX
 #define MELEE_STATUS_WIDTH  (NUM_MELEE_COLUMNS * \
 		(MELEE_BOX_WIDTH + MELEE_BOX_SPACE))
-#define MELEE_STATUS_HEIGHT 38
+#define MELEE_STATUS_HEIGHT (38 << RESOLUTION_FACTOR) // JMS_GFX
+//End JMS_GFX
 
 #define MELEE_BACKGROUND_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x14, 0x00, 0x00), 0x04)
@@ -427,23 +439,21 @@ RedrawMeleeFrame (void)
 static void
 GetTeamStringRect (COUNT side, RECT *r)
 {
-	r->corner.x = MELEE_X_OFFS - 1;
+	r->corner.x = MELEE_X_OFFS - 1; // JMS_GFX
 	r->corner.y = (side + 1) * (MELEE_Y_OFFS
-			+ ((MELEE_BOX_HEIGHT + MELEE_BOX_SPACE) * NUM_MELEE_ROWS + 2));
-	r->extent.width = NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE)
-			- 29;
-	r->extent.height = 13;
+			+ ((MELEE_BOX_HEIGHT + MELEE_BOX_SPACE) * NUM_MELEE_ROWS + 2)); // JMS_GFX
+	r->extent.width = NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE) - (29 << RESOLUTION_FACTOR); // JMS_GFX
+	r->extent.height = RES_CASE(13,16,32); // JMS_GFX
 }
 
 static void
 GetFleetValueRect (COUNT side, RECT *r)
 {
-	r->corner.x = MELEE_X_OFFS
-			+ NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE) - 30;
+	r->corner.x = MELEE_X_OFFS + NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE) - (30 << RESOLUTION_FACTOR); // JMS_GFX
 	r->corner.y = (side + 1) * (MELEE_Y_OFFS
 			+ ((MELEE_BOX_HEIGHT + MELEE_BOX_SPACE) * NUM_MELEE_ROWS + 2));
-	r->extent.width = 29;
-	r->extent.height = 13;
+	r->extent.width = 29 << RESOLUTION_FACTOR; // JMS_GFX
+	r->extent.height = RES_CASE(13,16,32);  // JMS_GFX
 }
 
 static void
@@ -497,7 +507,7 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 	lfText.pStr = (teamName != NULL) ? teamName :
 			MeleeSetup_getTeamName (pMS->meleeSetup, side);
 	lfText.baseline.y = r.corner.y + r.extent.height - 3;
-	lfText.baseline.x = r.corner.x + 1;
+	lfText.baseline.x = r.corner.x + (1 << RESOLUTION_FACTOR); // JMS_GFX
 	lfText.align = ALIGN_LEFT;
 	lfText.CharCount = strlen (lfText.pStr);
 
@@ -516,7 +526,7 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 		BYTE *pchar_deltas;
 
 		TextRect (&lfText, &text_r, char_deltas);
-		if ((text_r.extent.width + 2) >= r.extent.width)
+		if ((text_r.extent.width + (2 << RESOLUTION_FACTOR)) >= r.extent.width) // JMS_GFX
 		{	// the text does not fit the input box size and so
 			// will not fit when displayed later
 			UnbatchGraphics ();
@@ -538,25 +548,25 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 		{	// Use block cursor for keyboardless systems
 			if (pMS->CurIndex == lfText.CharCount)
 			{	// cursor at end-line -- use insertion point
-				text_r.extent.width = 1;
+				text_r.extent.width = (1 << RESOLUTION_FACTOR); // JMS_GFX
 			}
 			else if (pMS->CurIndex + 1 == lfText.CharCount)
 			{	// extra pixel for last char margin
-				text_r.extent.width = (SIZE)*pchar_deltas + 2;
+				text_r.extent.width = (SIZE)*pchar_deltas + (2 << RESOLUTION_FACTOR); // JMS_GFX
 			}
 			else
 			{	// normal mid-line char
-				text_r.extent.width = (SIZE)*pchar_deltas + 1;
+				text_r.extent.width = (SIZE)*pchar_deltas + (1 << RESOLUTION_FACTOR); // JMS_GFX
 			}
 		}
 		else
 		{	// Insertion point cursor
-			text_r.extent.width = 1;
+			text_r.extent.width = 1 << RESOLUTION_FACTOR; // JMS_GFX;
 		}
 		// position cursor within input field rect
 		++text_r.corner.x;
 		++text_r.corner.y;
-		text_r.extent.height -= 2;
+		text_r.extent.height -= 2 << RESOLUTION_FACTOR; // JMS_GFX
 		SetContextForeGroundColor (TEAM_NAME_EDIT_CURS_COLOR);
 		DrawFilledRectangle (&text_r);
 
@@ -880,9 +890,9 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 	OldContext = SetContext (StatusContext);
 	GetContextClipRect (&OldRect);
 	r = OldRect;
-	r.corner.x += ((SAFE_X << 1) - 32) + MENU_X_OFFS;
-	r.corner.y += 76;
-	r.extent.height = SHIP_INFO_HEIGHT;
+	r.corner.x += ((SAFE_X << 1) - (32 << RESOLUTION_FACTOR)) + MENU_X_OFFS - RES_CASE(0,0,3); // JMS_GFX
+	r.corner.y += (76 << RESOLUTION_FACTOR) + RES_CASE(0,2,6); // JMS_GFX
+	r.extent.height = SHIP_INFO_HEIGHT + RES_CASE(3,6,3); // JMS_GFX
 	SetContextClipRect (&r);
 	BatchGraphics ();
 
@@ -891,16 +901,21 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 		RECT r;
 		TEXT t;
 
-		ClearShipStatus (0);
+		ClearShipStatus (0, STATUS_WIDTH, TRUE);
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR > 0)
+			OutlineShipStatus (0, STATUS_WIDTH, TRUE);
+		
 		SetContextFont (StarConFont);
-		r.corner.x = 3;
-		r.corner.y = 4;
-		r.extent.width = 57;
-		r.extent.height = 60;
+		r.corner.x = RES_STAT_SCALE(3); // JMS_GFX;
+		r.corner.y = RES_STAT_SCALE(4); // JMS_GFX;
+		r.extent.width = RES_STAT_SCALE(57) + RESOLUTION_FACTOR; // JMS_GFX;
+		r.extent.height = (60 << RESOLUTION_FACTOR) - RES_CASE(0,0,6); // JMS_GFX;
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawRectangle (&r);
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = 32;
+		t.baseline.y = 32 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_CENTER;
 		if (pMS->row < NUM_MELEE_ROWS)
 		{
@@ -930,7 +945,7 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 		hMasterShip = GetStarShipFromIndex (&master_q, NewStarShip);
 		MasterPtr = LockMasterShip (&master_q, hMasterShip);
 
-		InitShipStatus (&MasterPtr->ShipInfo, NULL, NULL);
+		InitShipStatus (&MasterPtr->ShipInfo, NULL, NULL, TRUE);
 
 		UnlockMasterShip (&master_q, hMasterShip);
 	}
@@ -1141,9 +1156,11 @@ DoEdit (MELEE_STATE *pMS)
 		UnlockMutex (GraphicsLock);
 	}
 	else if (pMS->row < NUM_MELEE_ROWS &&
-			PulsedInputState.menu[KEY_MENU_DELETE])
+			(PulsedInputState.menu[KEY_MENU_BACKSPACE]
+			 || PulsedInputState.menu[KEY_MENU_DELETE]))
 	{
 		// Remove the currently selected ship from the current team.
+		// JMS: Due to wishes from OSX community, KEY_MENU_BACKSPACE was added here.
 		Deselect (EDIT_MELEE);
 		DeleteCurrentShip (pMS);
 		AdvanceCursor (pMS);
@@ -1642,12 +1659,11 @@ DoConnectingDialog (MELEE_STATE *pMS)
 		oldfont = SetContextFont (StarConFont);
 		oldcolor = SetContextForeGroundColor (BLACK_COLOR);
 		BatchGraphics ();
-		r.extent.width = 200;
-		r.extent.height = 30;
+		r.extent.width = 200 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 30 << RESOLUTION_FACTOR; // JMS_GFX
 		r.corner.x = (SCREEN_WIDTH - r.extent.width) >> 1;
 		r.corner.y = (SCREEN_HEIGHT - r.extent.height) >> 1;
-		DrawShadowedBox (&r, SHADOWBOX_BACKGROUND_COLOR, 
-				SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
+		DrawShadowedBox (&r, SHADOWBOX_BACKGROUND_COLOR, SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
 
 		if (NetConnection_getPeerOptions (conn)->isServer)
 		{
@@ -1659,7 +1675,7 @@ DoConnectingDialog (MELEE_STATE *pMS)
 			t.pStr = GAME_STRING (NETMELEE_STRING_BASE + 2);
 					/* "Awaiting outgoing connection */
 		}
-		t.baseline.y = r.corner.y + 10;
+		t.baseline.y = r.corner.y + (10 << RESOLUTION_FACTOR); // JMS_GFX
 		t.baseline.x = SCREEN_WIDTH >> 1;
 		t.align = ALIGN_CENTER;
 		t.CharCount = ~0;
@@ -1667,7 +1683,7 @@ DoConnectingDialog (MELEE_STATE *pMS)
 
 		t.pStr = GAME_STRING (NETMELEE_STRING_BASE + 18);
 				/* "Press SPACE to cancel" */
-		t.baseline.y += 16;
+		t.baseline.y += 16 << RESOLUTION_FACTOR; // JMS_GFX
 		font_DrawText (&t);
 
 		// Restore original graphics
diff -ruNp ./src.orig/uqm/supermelee/melee.h ./src/uqm/supermelee/melee.h
--- ./src.orig/uqm/supermelee/melee.h	2017-10-23 11:42:17 -0700
+++ ./src/uqm/supermelee/melee.h	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef _MELEE_H
 #define _MELEE_H
 
@@ -34,8 +36,8 @@ typedef struct melee_state MELEE_STATE;
 #define NUM_MELEE_COLUMNS 7
 //#define NUM_MELEE_COLUMNS 6
 #define MELEE_FLEET_SIZE (NUM_MELEE_ROWS * NUM_MELEE_COLUMNS)
-#define ICON_WIDTH 16
-#define ICON_HEIGHT 16
+#define ICON_WIDTH (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define ICON_HEIGHT (16 << RESOLUTION_FACTOR) // JMS_GFX
 
 extern FRAME PickMeleeFrame;
 
diff -ruNp ./src.orig/uqm/supermelee/netplay/packethandlers.c ./src/uqm/supermelee/netplay/packethandlers.c
--- ./src.orig/uqm/supermelee/netplay/packethandlers.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/supermelee/netplay/packethandlers.c	2017-10-23 11:41:35 -0700
@@ -199,8 +199,8 @@ PacketHandler_Fleet(NetConnection *conn,
 	if (sizeof packet + numShips * sizeof(packet->ships[0]) > len) {
 		// There is not enough room in the packet to contain all
 		// the ships it says it contains.
-		log_add(log_Warning, "Invalid fleet size. Specified size is %d, "
-				"actual size = %d",
+		log_add(log_Warning, "Invalid fleet size. Specified size is %u, "
+				"actual size = %lu",
 				numShips, (len - sizeof packet) / sizeof(packet->ships[0]));
 		errno = EBADMSG;
 		return -1;
@@ -577,7 +577,7 @@ PacketHandler_Checksum(NetConnection *co
 	if (frameNr % interval != 0) {
 		log_add(log_Warning, "NETPLAY: [%d] <== Received checksum "
 				"for frame %u, while we only expect checksums on frames "
-				"divisable by %u -- discarding.", conn->player,
+				"divisable by %lu -- discarding.", conn->player,
 				(unsigned int) frameNr, interval);
 		return 0;
 				// No need to close the connection; checksums are not
@@ -592,7 +592,7 @@ PacketHandler_Checksum(NetConnection *co
 	if (frameNr > battleFrameCount + delay + 1) {
 		log_add(log_Warning, "NETPLAY: [%d] <== Received checksum "
 				"for a frame too far in the future (frame %u, current "
-				"is %u, input delay is %u) -- discarding.", conn->player,
+				"is %u, input delay is %lu) -- discarding.", conn->player,
 				(unsigned int) frameNr, battleFrameCount, delay);
 		return 0;
 				// No need to close the connection; checksums are not
@@ -609,7 +609,7 @@ PacketHandler_Checksum(NetConnection *co
 	if (frameNr + delay < battleFrameCount) {
 		log_add(log_Warning, "NETPLAY: [%d] <== Received checksum "
 				"for a frame too far in the past (frame %u, current "
-				"is %u, input delay is %u) -- discarding.", conn->player,
+				"is %u, input delay is %lu) -- discarding.", conn->player,
 				(unsigned int) frameNr, battleFrameCount, delay);
 		return 0;
 				// No need to close the connection; checksums are not
diff -ruNp ./src.orig/uqm/supermelee/pickmele.c ./src/uqm/supermelee/pickmele.c
--- ./src.orig/uqm/supermelee/pickmele.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/supermelee/pickmele.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #define PICKMELE_INTERNAL
 #include "pickmele.h"
 
@@ -44,13 +46,14 @@
 #define NUM_PICKMELEE_ROWS 2
 #define NUM_PICKMELEE_COLUMNS 7
 
-#define PICK_X_OFFS 57
-#define PICK_Y_OFFS 24
-#define PICK_SIDE_OFFS 100
-
-#define NAME_AREA_HEIGHT 7
-#define MELEE_WIDTH 149
-#define MELEE_HEIGHT (48 + NAME_AREA_HEIGHT)
+#define PICK_X_OFFS (57 << RESOLUTION_FACTOR) // JMS_GFX
+#define PICK_Y_OFFS (24 << RESOLUTION_FACTOR) // JMS_GFX
+#define PICK_SIDE_OFFS (100 << RESOLUTION_FACTOR) // JMS_GFX
+
+
+#define NAME_AREA_HEIGHT (7 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_WIDTH (149 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_HEIGHT ((48 << RESOLUTION_FACTOR) + NAME_AREA_HEIGHT)
 
 #define PICKSHIP_TEAM_NAME_TEXT_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09)
@@ -147,11 +150,11 @@ static void
 PickMelee_ChangedSelection (GETMELEE_STATE *gms, COUNT playerI)
 {
 	RECT r;
-	r.corner.x = PICK_X_OFFS + ((ICON_WIDTH + 2) * gms->player[playerI].col);
-	r.corner.y = PICK_Y_OFFS + ((ICON_HEIGHT + 2) * gms->player[playerI].row)
+	r.corner.x = PICK_X_OFFS + ((ICON_WIDTH + (2 << RESOLUTION_FACTOR)) * gms->player[playerI].col); // JMS_GFX
+	r.corner.y = PICK_Y_OFFS + ((ICON_HEIGHT + (2 << RESOLUTION_FACTOR)) * gms->player[playerI].row) // JMS_GFX
 			+ ((1 - playerI) * PICK_SIDE_OFFS);
-	r.extent.width = (ICON_WIDTH + 2);
-	r.extent.height = (ICON_HEIGHT + 2);
+	r.extent.width = (ICON_WIDTH + (2 << RESOLUTION_FACTOR)); // JMS_GFX
+	r.extent.height = (ICON_HEIGHT + (2 << RESOLUTION_FACTOR)); // JMS_GFX
 	Flash_setRect (gms->player[playerI].flashContext, &r);
 }
 
@@ -423,8 +426,8 @@ CrossOutShip (FRAME frame, COUNT shipNr)
 	
 	SetContextFGFrame (frame);
 
-	s.origin.x = 3 + ((ICON_WIDTH + 2) * col);
-	s.origin.y = 9 + ((ICON_HEIGHT + 2) * row);
+	s.origin.x = (3 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (2 << RESOLUTION_FACTOR)) * col); // JMS_GFX
+	s.origin.y = (9 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (2 << RESOLUTION_FACTOR)) * row); // JMS_GFX
 	s.frame = SetAbsFrameIndex (StatusFrame, 3);
 			// Cross for through the ship image.
 	DrawStamp (&s);
@@ -450,18 +453,18 @@ UpdatePickMeleeFleetValue (FRAME frame,
 
 	// Erase the old value text.
 	GetFrameRect (frame, &r);
-	r.extent.width -= 4;
+	r.extent.width -= (4 << RESOLUTION_FACTOR); // JMS_GFX
 	t.baseline.x = r.extent.width;
-	r.corner.x = r.extent.width - (6 * 3);
-	r.corner.y = 2;
-	r.extent.width = (6 * 3);
-	r.extent.height = 7 - 2;
+	r.corner.x = r.extent.width - ((6 * 3) << RESOLUTION_FACTOR); // JMS_GFX
+	r.corner.y = 2 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.width = ((6 * 3) << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.height = ((7 - 2) << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR); // JMS_GFX
 	SetContextForeGroundColor (PICK_BG_COLOR);
 	DrawFilledRectangle (&r);
 
 	// Draw the new value text.
 	sprintf (buf, "%d", value);
-	t.baseline.y = 7;
+	t.baseline.y = 7 << RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
@@ -512,17 +515,17 @@ FillPickMeleeFrame (MeleeSetup *setup)
 
 	OldContext = SetContext (OffScreenContext);
 
-	for (i = 0; i < NUM_SIDES; ++i)
+        for (i = 0; i < NUM_SIDES; ++i)
 	{
 		COUNT side;
-		COUNT sideI;
+                COUNT sideI;
 		RECT r;
 		TEXT t;
 		STAMP s;
 		UNICODE buf[30];
 		FleetShipIndex index;
 
-		sideI = GetPlayerOrder (i);
+                sideI = GetPlayerOrder (i);
 		side = !sideI;
 
 		s.frame = SetAbsFrameIndex (PickMeleeFrame, side);
@@ -530,17 +533,17 @@ FillPickMeleeFrame (MeleeSetup *setup)
 
 		GetFrameRect (s.frame, &r);
 		t.baseline.x = r.extent.width >> 1;
-		t.baseline.y = r.extent.height - NAME_AREA_HEIGHT + 4;
+		t.baseline.y = r.extent.height - NAME_AREA_HEIGHT + (4 << RESOLUTION_FACTOR); // JMS_GFX
 
-		r.corner.x += 2;
-		r.corner.y += 2;
-		r.extent.width -= (2 * 2) + (ICON_WIDTH + 2) + 1;
-		r.extent.height -= (2 * 2) + NAME_AREA_HEIGHT;
+		r.corner.x += 2 << RESOLUTION_FACTOR;
+		r.corner.y += 2 << RESOLUTION_FACTOR;
+		r.extent.width -= ( (2 * 2) + ((ICON_WIDTH >> RESOLUTION_FACTOR) + 2) + 1) << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height -= ((2 * 2) << RESOLUTION_FACTOR) + NAME_AREA_HEIGHT; // JMS_GFX
 		SetContextForeGroundColor (PICK_BG_COLOR);
 		DrawFilledRectangle (&r);
 
-		r.corner.x += 2;
-		r.extent.width += (ICON_WIDTH + 2) - (2 * 2);
+		r.corner.x += 2 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.width += (((ICON_WIDTH >> RESOLUTION_FACTOR) + 2) - (2 * 2)) << RESOLUTION_FACTOR; // JMS_GFX
 		r.corner.y += r.extent.height;
 		r.extent.height = NAME_AREA_HEIGHT;
 		DrawFilledRectangle (&r);
@@ -555,8 +558,8 @@ FillPickMeleeFrame (MeleeSetup *setup)
 
 		// Total team value of the starting team:
 		sprintf (buf, "%u", MeleeSetup_getFleetValue (setup, sideI));
-		t.baseline.x = 4;
-		t.baseline.y = 7;
+		t.baseline.x = 4 << RESOLUTION_FACTOR; // JMS_GFX
+		t.baseline.y = 7 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_LEFT;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
@@ -592,8 +595,8 @@ FillPickMeleeFrame (MeleeSetup *setup)
 				// Draw the icon.
 				row = PickMelee_GetShipRow (index);
 				col = PickMelee_GetShipColumn (index);
-				s.origin.x = 4 + ((ICON_WIDTH + 2) * col);
-				s.origin.y = 10 + ((ICON_HEIGHT + 2) * row);
+				s.origin.x = (4 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (2 << RESOLUTION_FACTOR)) * col); // JMS_GFX
+				s.origin.y = (10 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (2 << RESOLUTION_FACTOR)) * row); // JMS_GFX
 				s.frame = MasterPtr->ShipInfo.icons;
 				DrawStamp (&s);
 
@@ -635,8 +638,8 @@ DrawPickMeleeFrame (COUNT which_player)
 
 	oldContext = SetContext (SpaceContext);
 	s.frame = SetAbsFrameIndex (PickMeleeFrame, which_player);
-	s.origin.x = PICK_X_OFFS - 3;
-	s.origin.y = PICK_Y_OFFS - 9 + ((1 - which_player) * PICK_SIDE_OFFS);
+	s.origin.x = PICK_X_OFFS - (3 << RESOLUTION_FACTOR); // JMS_GFX
+	s.origin.y = PICK_Y_OFFS - (9 << RESOLUTION_FACTOR) + ((1 - which_player) * PICK_SIDE_OFFS); // JMS_GFX
 	DrawStamp (&s);
 			// Draw the selection box to screen.
 	
diff -ruNp ./src.orig/uqm/tactrans.c ./src/uqm/tactrans.c
--- ./src.orig/uqm/tactrans.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/tactrans.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "tactrans.h"
 
 #include "battlecontrols.h"
@@ -860,7 +862,7 @@ ship_transition (ELEMENT *ElementPtr)
 		}
 		else if ((hShipImage = AllocElement ()))
 		{
-#define TRANSITION_SPEED DISPLAY_TO_WORLD (40)
+#define TRANSITION_SPEED DISPLAY_TO_WORLD ((40 << RESOLUTION_FACTOR)) // JMS_GFX
 #define TRANSITION_LIFE 1
 			COUNT angle;
 
diff -ruNp ./src.orig/uqm/tactrans.h ./src/uqm/tactrans.h
--- ./src.orig/uqm/tactrans.h	2017-10-23 11:42:17 -0700
+++ ./src/uqm/tactrans.h	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef _TACTRANS_H
 #define _TACTRANS_H
 
diff -ruNp ./src.orig/uqm/trans.c ./src/uqm/trans.c
--- ./src.orig/uqm/trans.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/trans.c	2017-10-23 11:41:35 -0700
@@ -89,9 +89,9 @@ SIZE sinetab[] =
 };
 
 COUNT
-ARCTAN (SIZE delta_x, SIZE delta_y)
+ARCTAN (SDWORD delta_x, SDWORD delta_y)
 {
-	SIZE v1, v2;
+	SDWORD v1, v2;
 	static COUNT atantab[] =
 	{
 		0,
diff -ruNp ./src.orig/uqm/units.h ./src/uqm/units.h
--- ./src.orig/uqm/units.h	2017-10-23 11:42:17 -0700
+++ ./src/uqm/units.h	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifndef _UNITS_H
 #define _UNITS_H
 
@@ -23,47 +25,66 @@
 
 extern int ScreenWidth;
 extern int ScreenHeight;
+extern unsigned int resolutionFactor; // JMS_GFX
 
+		/* Most basic resolution units. */
 #define SCREEN_WIDTH ScreenWidth
 #define SCREEN_HEIGHT ScreenHeight
+#define RESOLUTION_FACTOR resolutionFactor														// JMS_GFX
+#define RES_CASE(a,b,c) (RESOLUTION_FACTOR == 0 ? (a) : (RESOLUTION_FACTOR == 1 ? (b) : (c)))	// JMS_GFX
+#define RES_STAT_SCALE(a) (RESOLUTION_FACTOR < 2 ? ((a) << RESOLUTION_FACTOR) : ((a) * 3))		// JMS_GFX
+
+		/* Margins. */
 #define SAFE_X 0
-		/* Left and right screen margin to be left unused */
+/* Left and right screen margin to be left unused */
 #define SAFE_Y 0
-		/* Top and bottom screen margin to be left unused */
-#define SIS_ORG_X (7 + SAFE_X)
-#define SIS_ORG_Y (10 + SAFE_Y)
-#define STATUS_WIDTH 64
-		/* Width of the status "window" (the right part of the screen) */
+/* Top and bottom screen margin to be left unused */
+#define SIS_ORG_X (7 + SAFE_X)								// JMS_GFX
+//#define SIS_ORG_X (7 * RESOLUTION_FACTOR + SAFE_X)	// JMS_GFX
+#define SIS_ORG_Y RES_CASE(10, 20, 30)						// DC: top status window. Manually entered in for 4x mode.
+//#define SIS_ORG_Y (10 * RESOLUTION_FACTOR + SAFE_Y)	// JMS_GFX
+
+/* Status bar & play area sizes. */
+#define STATUS_WIDTH RES_STAT_SCALE(64)
+/* Width of the status "window" (the right part of the screen) */
 #define STATUS_HEIGHT (SCREEN_HEIGHT - (SAFE_Y * 2))
-		/* Height of the status "window" (the right part of the screen) */
+/* Height of the status "window" (the right part of the screen) */
 #define SPACE_WIDTH (SCREEN_WIDTH - STATUS_WIDTH - (SAFE_X * 2))
-		/* Width of the space "window" (the left part of the screen) */
+/* Width of the space "window" (the left part of the screen) */
 #define SPACE_HEIGHT (SCREEN_HEIGHT - (SAFE_Y * 2))
-		/* Height of the space "window" (the left part of the screen) */
-#define SIS_SCREEN_WIDTH (SPACE_WIDTH - 14)
-		/* Width of the usable part of the space "window" */
-#define SIS_SCREEN_HEIGHT (SPACE_HEIGHT - 13)
-		/* Height of the usable part of the space "window" */
-#define RADAR_X (4 + (SCREEN_WIDTH - STATUS_WIDTH - SAFE_X))
-#define RADAR_WIDTH (STATUS_WIDTH - 8)
-#define RADAR_HEIGHT 53
-#define RADAR_Y (SIS_ORG_Y + SIS_SCREEN_HEIGHT - RADAR_HEIGHT)
-
-#define SIS_TITLE_BOX_WIDTH    57
-#define SIS_TITLE_WIDTH        (SIS_TITLE_BOX_WIDTH - 2)
-#define SIS_TITLE_HEIGHT       8
-#define SIS_SPACER_BOX_WIDTH   12
-#define SIS_MESSAGE_BOX_WIDTH  (SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH \
-			- SIS_SPACER_BOX_WIDTH)
+/* Height of the space "window" (the left part of the screen) */
+#define SIS_SCREEN_WIDTH (SPACE_WIDTH - 2 * SIS_ORG_X) // DC: Gray area on the right. just a spacer box
+/* Width of the usable part of the space "window" */
+#define SIS_SCREEN_HEIGHT (SPACE_HEIGHT - RES_CASE(3,6,6) - RES_CASE(10,20,30)) // JMS_GFX
+/* Height of the usable part of the space "window": 3, 6, 6 for the grey bottom border and 10, 20, 30 for the title */
+#define RES_SIS_SCALE(a) ((SIZE)(a) * SIS_SCREEN_WIDTH / 242) // JMS_GFX
+
+
+
+
+		/* Radar. */
+#define RADAR_X (RES_STAT_SCALE(4) + (SCREEN_WIDTH - STATUS_WIDTH - SAFE_X))	// JMS_GFX
+#define RADAR_WIDTH (STATUS_WIDTH - RES_STAT_SCALE(8))							// JMS_GFX
+#define RADAR_HEIGHT RES_STAT_SCALE(53)											// JMS_GFX
+#define RADAR_Y (SIS_ORG_Y + SIS_SCREEN_HEIGHT - (53 << RESOLUTION_FACTOR))		// JMS_GFX
+
+		/* Blue boxes which display messages and the green date box. */
+#define SIS_TITLE_BOX_WIDTH    (57 << RESOLUTION_FACTOR)						// JMS_GFX
+#define SIS_TITLE_WIDTH        (SIS_TITLE_BOX_WIDTH - (2 << RESOLUTION_FACTOR)) // JMS_GFX
+#define SIS_TITLE_HEIGHT       RES_CASE(8,19,29)								// JMS_GFX
+#define SIS_SPACER_BOX_WIDTH   (12 << RESOLUTION_FACTOR)						// JMS_GFX
+
+#define SIS_MESSAGE_BOX_WIDTH  (SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - SIS_SPACER_BOX_WIDTH)
 #define SIS_MESSAGE_WIDTH      (SIS_MESSAGE_BOX_WIDTH - 2)
 #define SIS_MESSAGE_HEIGHT     SIS_TITLE_HEIGHT
 
-#define STATUS_MESSAGE_WIDTH   (STATUS_WIDTH - 4)
-#define STATUS_MESSAGE_HEIGHT  7
+#define STATUS_MESSAGE_WIDTH   (STATUS_WIDTH - RES_CASE(4,6,7))	 // JMS_GFX
+#define STATUS_MESSAGE_HEIGHT  RES_CASE(7,14,24) // JMS_GFX
 
-#define SHIP_NAME_WIDTH        (STATUS_WIDTH - 4)
-#define SHIP_NAME_HEIGHT       7
+#define SHIP_NAME_WIDTH        (STATUS_WIDTH - RES_CASE(4,6,9))// JMS_GFX
+#define SHIP_NAME_HEIGHT       (RES_STAT_SCALE(7) - RES_CASE(0,0,4)) // JMS_GFX
 
+		/* A lot of other shit. */
 #define MAX_REDUCTION 3
 #define MAX_VIS_REDUCTION 2
 #define REDUCTION_SHIFT 1
@@ -81,37 +102,29 @@ extern int ScreenHeight;
 #define DISPLAY_ALIGN_X(x) ((COORD)((COUNT)(x)%LOG_SPACE_WIDTH)&~(SCALED_ONE-1))
 #define DISPLAY_ALIGN_Y(y) ((COORD)((COUNT)(y)%LOG_SPACE_HEIGHT)&~(SCALED_ONE-1))
 
-#define LOG_SPACE_WIDTH \
-		(DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_REDUCTION)
-#define LOG_SPACE_HEIGHT \
-		(DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_REDUCTION)
-#define TRANSITION_WIDTH \
-		(DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_VIS_REDUCTION)
-#define TRANSITION_HEIGHT \
-		(DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_VIS_REDUCTION)
-		
+#define LOG_SPACE_WIDTH   (DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_REDUCTION)
+#define LOG_SPACE_HEIGHT  (DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_REDUCTION)
+#define TRANSITION_WIDTH  (DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_VIS_REDUCTION)
+#define TRANSITION_HEIGHT (DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_VIS_REDUCTION)
+
 #define MAX_X_UNIVERSE 9999
 #define MAX_Y_UNIVERSE 9999
-// Due to the added rounding error correction, the maximum logical X and Y
-// in Hyperspace cannot go past 999.94999, otherwise the values will be
-// rounded up to 1000.0. We do not want that so we subtract half a unit.
 #define MAX_X_LOGICAL \
-		(UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) - (UNIVERSE_TO_LOGX (1) >> 1) \
-			- 1L)
-// The Y axis is inverted with respect to the screen Y axis.
-// (MAX_Y_UNIVERSE - 1) is really 1 for our purposes.
+((UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) > UNIVERSE_TO_LOGX (-1) ? \
+UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) : UNIVERSE_TO_LOGX (-1)) - 1L)
 #define MAX_Y_LOGICAL \
-		(UNIVERSE_TO_LOGY (-1) - (UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE - 1) >> 1) \
-			- 1L)
+((UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE + 1) > UNIVERSE_TO_LOGY (-1) ? \
+UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE + 1) : UNIVERSE_TO_LOGY (-1)) - 1L)
 
 #define SPHERE_RADIUS_INCREMENT 11
-
 #define MAX_FLEET_STRENGTH (254 * SPHERE_RADIUS_INCREMENT)
 
 // XXX: These corrected for the weird screen aspect ratio on DOS
 //   In part because of them, hyperflight is slower vertically
-#define UNIT_SCREEN_WIDTH 63
-#define UNIT_SCREEN_HEIGHT 50
+#define UNIT_SCREEN_WIDTH ((63 << (COUNT)RESOLUTION_FACTOR) + (COUNT)RESOLUTION_FACTOR * 10) // JMS_GFX
+#define UNIT_SCREEN_HEIGHT ((50 << (COUNT)RESOLUTION_FACTOR) + (COUNT)RESOLUTION_FACTOR * 10) // JMS_GFX
+
+#define NORMALIZED_HYPERSPACE_SPEED // JMS_GFX
 
 // Bug #945: Simplified, these set the speed of SIS in Hyperspace and
 //   Quasispace. The ratio between UNIVERSE_UNITS_ and LOG_UNITS_ is
@@ -121,14 +134,12 @@ extern int ScreenHeight;
 //   on the screen resolution when it should not.
 //   Using the new math will break old savegames.
 #ifdef NORMALIZED_HYPERSPACE_SPEED
-#define LOG_UNITS_X      ((SDWORD)(UNIVERSE_UNITS_X * 16))
-#define LOG_UNITS_Y      ((SDWORD)(UNIVERSE_UNITS_Y * 16))
+#define LOG_UNITS_X      ((SDWORD)(UNIVERSE_UNITS_X * (16 << RESOLUTION_FACTOR))) // JMS_GFX
+#define LOG_UNITS_Y      ((SDWORD)(UNIVERSE_UNITS_Y * (16 << RESOLUTION_FACTOR))) // JMS_GFX 
 #define UNIVERSE_UNITS_X (((MAX_X_UNIVERSE + 1) >> 4))
 #define UNIVERSE_UNITS_Y (((MAX_Y_UNIVERSE + 1) >> 4))
 #else
 // Original (and now broken) Hyperspace speed factors
-#define SECTOR_WIDTH 195
-#define SECTOR_HEIGHT 25
 
 #define LOG_UNITS_X      ((SDWORD)(LOG_SPACE_WIDTH >> 4) * SECTOR_WIDTH)
 #define LOG_UNITS_Y      ((SDWORD)(LOG_SPACE_HEIGHT >> 4) * SECTOR_HEIGHT)
@@ -138,40 +149,110 @@ extern int ScreenHeight;
 
 #define ROUNDING_ERROR(div)  ((div) >> 1)
 
-static inline COORD
+static inline SDWORD
 logxToUniverse (SDWORD lx)
 {
-	return (COORD) ((lx * UNIVERSE_UNITS_X + ROUNDING_ERROR(LOG_UNITS_X))
-			/ LOG_UNITS_X);
+	return (SDWORD) ((lx * UNIVERSE_UNITS_X + ROUNDING_ERROR(LOG_UNITS_X))
+					 / LOG_UNITS_X);
 }
 #define LOGX_TO_UNIVERSE(lx) \
-		logxToUniverse (lx)
-static inline COORD
+logxToUniverse (lx)
+static inline SDWORD
 logyToUniverse (SDWORD ly)
 {
-	return (COORD) (MAX_Y_UNIVERSE -
-			((ly * UNIVERSE_UNITS_Y + ROUNDING_ERROR(LOG_UNITS_Y))
-			/ LOG_UNITS_Y));
+	return (SDWORD) (MAX_Y_UNIVERSE -
+					 ((ly * UNIVERSE_UNITS_Y + ROUNDING_ERROR(LOG_UNITS_Y))
+					  / LOG_UNITS_Y));
 }
 #define LOGY_TO_UNIVERSE(ly) \
-		logyToUniverse (ly)
+logyToUniverse (ly)
 static inline SDWORD
 universeToLogx (COORD ux)
 {
 	return (ux * LOG_UNITS_X + ROUNDING_ERROR(UNIVERSE_UNITS_X))
-			/ UNIVERSE_UNITS_X;
+	/ UNIVERSE_UNITS_X;
 }
 #define UNIVERSE_TO_LOGX(ux) \
-		universeToLogx (ux)
+universeToLogx (ux)
 static inline SDWORD
 universeToLogy (COORD uy)
 {
 	return ((MAX_Y_UNIVERSE - uy) * LOG_UNITS_Y
 			+ ROUNDING_ERROR(UNIVERSE_UNITS_Y))
-			/ UNIVERSE_UNITS_Y;
+	/ UNIVERSE_UNITS_Y;
 }
 #define UNIVERSE_TO_LOGY(uy) \
-		universeToLogy (uy)
+universeToLogy (uy)
+
+/* Here be old junk. */
+/*
+ // Hyperspace speed factors (JMS: unused??)
+ #define SECTOR_WIDTH (195)
+ #define SECTOR_HEIGHT (25)
+ 
+ #define UNIT_SCREEN_WIDTH 63
+ #define UNIT_SCREEN_HEIGHT 50
+ 
+ // Bug #945: Simplified, these set the speed of SIS in Hyperspace and
+ //   Quasispace. The ratio between UNIVERSE_UNITS_ and LOG_UNITS_ is
+ //   what sets the speed, and it should be 1:16 to match the original.
+ //   The unit factors are reduced to keep the translation math within
+ //   32 bits. The original math is unnecessarily complex and depends
+ //   on the screen resolution when it should not.
+ //   Using the new math will break old savegames.
+ #ifdef NORMALIZED_HYPERSPACE_SPEED
+ #define LOG_UNITS_X      ((SDWORD)(UNIVERSE_UNITS_X * 16))
+ #define LOG_UNITS_Y      ((SDWORD)(UNIVERSE_UNITS_Y * 16))
+ #define UNIVERSE_UNITS_X (((MAX_X_UNIVERSE + 1) >> 4))
+ #define UNIVERSE_UNITS_Y (((MAX_Y_UNIVERSE + 1) >> 4))
+ #else
+ // Original (and now broken) Hyperspace speed factors
+ #define SECTOR_WIDTH 195
+ #define SECTOR_HEIGHT 25
+ 
+ #define LOG_UNITS_X      ((SDWORD)(LOG_SPACE_WIDTH >> 4) * SECTOR_WIDTH)
+ #define LOG_UNITS_Y      ((SDWORD)(LOG_SPACE_HEIGHT >> 4) * SECTOR_HEIGHT)
+ #define UNIVERSE_UNITS_X (((MAX_X_UNIVERSE + 1) >> 4) * 10)
+ #define UNIVERSE_UNITS_Y (((MAX_Y_UNIVERSE + 1) >> 4))
+ #endif
+ 
+ #define ROUNDING_ERROR(div)  ((div) >> 1)
+ 
+ static inline COORD
+ logxToUniverse (SDWORD lx)
+ {
+ return (COORD) ((lx * UNIVERSE_UNITS_X + ROUNDING_ERROR(LOG_UNITS_X))
+ / LOG_UNITS_X);
+ }
+ #define LOGX_TO_UNIVERSE(lx) \
+ logxToUniverse (lx)
+ static inline COORD
+ logyToUniverse (SDWORD ly)
+ {
+ return (COORD) (MAX_Y_UNIVERSE -
+ ((ly * UNIVERSE_UNITS_Y + ROUNDING_ERROR(LOG_UNITS_Y))
+ / LOG_UNITS_Y));
+ }
+ #define LOGY_TO_UNIVERSE(ly) \
+ logyToUniverse (ly)
+ static inline SDWORD
+ universeToLogx (COORD ux)
+ {
+ return (ux * LOG_UNITS_X + ROUNDING_ERROR(UNIVERSE_UNITS_X))
+ / UNIVERSE_UNITS_X;
+ }
+ #define UNIVERSE_TO_LOGX(ux) \
+ universeToLogx (ux)
+ static inline SDWORD
+ universeToLogy (COORD uy)
+ {
+ return ((MAX_Y_UNIVERSE - uy) * LOG_UNITS_Y
+ + ROUNDING_ERROR(UNIVERSE_UNITS_Y))
+ / UNIVERSE_UNITS_Y;
+ }
+ #define UNIVERSE_TO_LOGY(uy) \
+ universeToLogy (uy)
+ */
 
 #define CIRCLE_SHIFT 6
 #define FULL_CIRCLE (1 << CIRCLE_SHIFT)
@@ -183,14 +264,14 @@ universeToLogy (COORD uy)
 #define FACING_SHIFT 4
 
 #define ANGLE_TO_FACING(a) (((a)+(1<<(CIRCLE_SHIFT-FACING_SHIFT-1))) \
-										>>(CIRCLE_SHIFT-FACING_SHIFT))
+>>(CIRCLE_SHIFT-FACING_SHIFT))
 #define FACING_TO_ANGLE(f) ((f)<<(CIRCLE_SHIFT-FACING_SHIFT))
 
 #define NORMALIZE_ANGLE(a) ((COUNT)((a)&(FULL_CIRCLE-1)))
 #define NORMALIZE_FACING(f) ((COUNT)((f)&((1 << FACING_SHIFT)-1)))
 
 #define DEGREES_TO_ANGLE(d) NORMALIZE_ANGLE((((d) % 360) * FULL_CIRCLE \
-				+ HALF_CIRCLE) / 360)
++ HALF_CIRCLE) / 360)
 #define ANGLE_TO_DEGREES(d) (NORMALIZE_ANGLE(d) * 360 / FULL_CIRCLE)
 
 #define SIN_SHIFT 14
@@ -203,18 +284,17 @@ universeToLogy (COORD uy)
 extern SIZE sinetab[];
 #define SINVAL(a) sinetab[NORMALIZE_ANGLE(a)]
 #define COSVAL(a) SINVAL((a)+QUADRANT)
-#define SINE(a,m) ((SIZE)((((long)SINVAL(a))*(long)(m))>>SIN_SHIFT))
+#define SINE(a,m) ((SDWORD)((((long)SINVAL(a))*(long)(m))>>SIN_SHIFT)) // JMS: SDWORD was SIZE. Changed to avoid overflows in hires.
 #define COSINE(a,m) SINE((a)+QUADRANT,m)
-extern COUNT ARCTAN (SIZE delta_x, SIZE delta_y);
+extern COUNT ARCTAN (SDWORD delta_x, SDWORD delta_y); // JMS: SDWORD was SIZE. Changed to avoid overflows in hires.
 
-#define WRAP_VAL(v,w) ((COUNT)((v)<0?((v)+(w)):((v)>=(w)?((v)-(w)):(v))))
+#define WRAP_VAL(v,w) ((DWORD)((v)<0?((v)+(w)):((v)>=(w)?((v)-(w)):(v)))) // JMS: DWORD was COUNT. Changed to avoid overflows in hires.
 #define WRAP_X(x) WRAP_VAL(x,LOG_SPACE_WIDTH)
 #define WRAP_Y(y) WRAP_VAL(y,LOG_SPACE_HEIGHT)
 #define WRAP_DELTA_X(dx) ((dx)<0 ? \
-				((-(dx)<=LOG_SPACE_WIDTH>>1)?(dx):(LOG_SPACE_WIDTH+(dx))) : \
-				(((dx)<=LOG_SPACE_WIDTH>>1)?(dx):((dx)-LOG_SPACE_WIDTH)))
+((-(dx)<=LOG_SPACE_WIDTH>>1)?(dx):(LOG_SPACE_WIDTH+(dx))) : \
+(((dx)<=LOG_SPACE_WIDTH>>1)?(dx):((dx)-LOG_SPACE_WIDTH)))
 #define WRAP_DELTA_Y(dy) ((dy)<0 ? \
-				((-(dy)<=LOG_SPACE_HEIGHT>>1)?(dy):(LOG_SPACE_HEIGHT+(dy))) : \
-				(((dy)<=LOG_SPACE_HEIGHT>>1)?(dy):((dy)-LOG_SPACE_HEIGHT)))
-#endif /* _UNITS_H */
-
+((-(dy)<=LOG_SPACE_HEIGHT>>1)?(dy):(LOG_SPACE_HEIGHT+(dy))) : \
+(((dy)<=LOG_SPACE_HEIGHT>>1)?(dy):((dy)-LOG_SPACE_HEIGHT)))
+#endif /* _UNITS_H */
\ No newline at end of file
diff -ruNp ./src.orig/uqm/uqmdebug.c ./src/uqm/uqmdebug.c
--- ./src.orig/uqm/uqmdebug.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/uqmdebug.c	2017-10-23 11:41:35 -0700
@@ -70,6 +70,7 @@ static void dumpPlanetTypeCallback (int
 
 
 BOOLEAN instantMove = FALSE;
+BOOLEAN invincibility = FALSE; // JMS
 BOOLEAN disableInteractivity = FALSE;
 void (* volatile debugHook) (void) = NULL;
 void (* volatile doInputDebugHook) (void) = NULL;
@@ -78,7 +79,7 @@ void (* volatile doInputDebugHook) (void
 void
 debugKeyPressed (void)
 {
-	// State modifying:
+	// State modifying.
 	equipShip ();
 	giveDevices ();
 
@@ -86,26 +87,29 @@ debugKeyPressed (void)
 	// conditions.
 	clearEscorts ();
 	ActivateStarShip (ARILOU_SHIP, 1);
+	ActivateStarShip (HUMAN_SHIP, 1);
 	ActivateStarShip (PKUNK_SHIP, 1);
-	ActivateStarShip (VUX_SHIP, 1);
 	ActivateStarShip (YEHAT_SHIP, 1);
-	ActivateStarShip (MELNORME_SHIP, 1);
+	ActivateStarShip (PKUNK_SHIP, 1);
 	ActivateStarShip (DRUUGE_SHIP, 1);
-	ActivateStarShip (ILWRATH_SHIP, 1);
-	ActivateStarShip (MYCON_SHIP, 1);
+	ActivateStarShip (CHMMR_SHIP, 1);
+	ActivateStarShip (UTWIG_SHIP, 1);
 	ActivateStarShip (SLYLANDRO_SHIP, 1);
-	ActivateStarShip (UMGAH_SHIP, 1);
-	ActivateStarShip (URQUAN_SHIP, 1);
+	ActivateStarShip (VUX_SHIP, 1);
+	ActivateStarShip (UTWIG_SHIP, 1);
 	ActivateStarShip (BLACK_URQUAN_SHIP, 1);
 
 	resetCrewBattle ();
 	resetEnergyBattle ();
-	instantMove = !instantMove;
 	showSpheres ();
 	activateAllShips ();
+	
+	//instantMove = !instantMove;
+
+  	//SET_GAME_STATE (MELNORME_CREDIT1, 100);
+	//GLOBAL_SIS (ResUnits) += 1000;
+
 //	forwardToNextEvent (TRUE);
-//	SET_GAME_STATE (MELNORME_CREDIT1, 100);
-//	GLOBAL_SIS (ResUnits) = 100000;
 
 	// Tests
 //	Scale_PerfTest ();
@@ -133,6 +137,35 @@ debugKeyPressed (void)
 //	uio_debugInteractive(stdin, stdout, stderr);
 }
 
+void
+debugKey2Pressed (void)
+{
+	invincibility = !invincibility;
+}
+
+void
+debugKey3Pressed (void)
+{
+	instantMove = !instantMove;
+}
+
+void
+debugKey4Pressed (void)
+{
+	SET_GAME_STATE (MELNORME_CREDIT1, 0); 
+	SET_GAME_STATE (MELNORME_CREDIT0, 255);
+	GLOBAL_SIS (ResUnits) += 1000;
+	
+	// Make sure the RU/credit amount is redrawn:
+	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE ||
+			LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
+	{
+		LockMutex (GraphicsLock);
+		DrawStatusMessage (NULL);
+		UnlockMutex (GraphicsLock);
+	}
+}
+
 ////////////////////////////////////////////////////////////////////////////
 
 // Fast forwards to the next event.
@@ -291,10 +324,11 @@ equipShip (void)
 	{
 		// The Precursor bomb has not been installed.
 		// This is the original TFB testing layout.
+		// JMS: Ha ha, not anymore!
 		i = 0;
 		GLOBAL_SIS (ModuleSlots[i++]) = HIGHEFF_FUELSYS;
-		GLOBAL_SIS (ModuleSlots[i++]) = HIGHEFF_FUELSYS;
-		GLOBAL_SIS (ModuleSlots[i++]) = CREW_POD;
+		GLOBAL_SIS (ModuleSlots[i++]) = FUEL_TANK;
+		GLOBAL_SIS (ModuleSlots[i++]) = ANTIMISSILE_DEFENSE;
 		GLOBAL_SIS (ModuleSlots[i++]) = CREW_POD;
 		GLOBAL_SIS (ModuleSlots[i++]) = CREW_POD;
 		GLOBAL_SIS (ModuleSlots[i++]) = CREW_POD;
@@ -306,7 +340,7 @@ equipShip (void)
 		GLOBAL_SIS (ModuleSlots[i++]) = TRACKING_SYSTEM;
 		GLOBAL_SIS (ModuleSlots[i++]) = TRACKING_SYSTEM;
 		GLOBAL_SIS (ModuleSlots[i++]) = SHIVA_FURNACE;
-		GLOBAL_SIS (ModuleSlots[i++]) = CANNON_WEAPON;
+		GLOBAL_SIS (ModuleSlots[i++]) = BLASTER_WEAPON;
 		GLOBAL_SIS (ModuleSlots[i++]) = CANNON_WEAPON;
 		
 		// Landers:
@@ -1604,7 +1638,7 @@ dumpStrings (FILE *out)
 	
 	if (GAMESTR_COUNT != numStrings) {
 		fprintf(stderr, "Warning: GAMESTR_COUNT is %d, but GameStrings "
-				"contains %d strings.\n", GAMESTR_COUNT, numStrings);
+				"contains %lu strings.\n", GAMESTR_COUNT, numStrings);
 	}
 
 	categoryI = 0;
@@ -1612,7 +1646,7 @@ dumpStrings (FILE *out)
 		while (categoryI < numCategories &&
 				stringI >= categories[categoryI + 1].base)
 			categoryI++;
-		fprintf(out, "[ %s + %d ]  %s\n", categories[categoryI].name,
+		fprintf(out, "[ %s + %lu ]  %s\n", categories[categoryI].name,
 				stringI - categories[categoryI].base, GAME_STRING(stringI));
 	}
 }
diff -ruNp ./src.orig/uqm/uqmdebug.h ./src/uqm/uqmdebug.h
--- ./src.orig/uqm/uqmdebug.h	2017-10-23 11:42:17 -0700
+++ ./src/uqm/uqmdebug.h	2017-10-23 11:41:35 -0700
@@ -41,6 +41,15 @@ extern void (* volatile doInputDebugHook
 // Called when the debug key (symbol 'Debug' in the keys.cfg) is pressed.
 void debugKeyPressed (void);
 
+// JMS: Called when the debug key (symbol 'Debug_2' in the keys.cfg) is pressed.
+void debugKey2Pressed (void);
+
+// JMS: Called when the debug key (symbol 'Debug_3' in the keys.cfg) is pressed.
+void debugKey3Pressed (void);
+
+// JMS: Called when the debug key (symbol 'Debug_4' in the keys.cfg) is pressed.
+void debugKey4Pressed (void);
+
 // Forward time to the next event. If skipHEE is set, the event named
 // HYPERSPACE_ENCOUNTER_EVENT, which normally occurs every game day,
 // is skipped.
@@ -181,6 +190,9 @@ void resetEnergyBattle(void);
 extern BOOLEAN instantMove;
 
 
+// IDDQD.
+extern BOOLEAN invincibility;
+
 // Dump all game strings.
 void dumpStrings(FILE *out);
 
diff -ruNp ./src.orig/uqm/util.c ./src/uqm/util.c
--- ./src.orig/uqm/util.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/util.c	2017-10-23 11:41:35 -0700
@@ -21,6 +21,10 @@
 #include "setup.h"
 #include "units.h"
 #include "settings.h"
+
+/* For SOL_X and SOL_Y */
+#include "hyper.h"
+
 #include "libs/inplib.h"
 #include "libs/sound/trackplayer.h"
 #include "libs/mathlib.h"
@@ -318,3 +322,24 @@ SleepGame (void)
 
 	TaskSwitch ();
 }
+
+/* Returns the fuel requirement to get to Sol (in fuel units * 100)
+ */
+DWORD
+get_fuel_to_sol (void)
+{
+	POINT pt;
+	DWORD f;
+
+	pt.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+	pt.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+	
+	pt.x -= SOL_X;
+	pt.y -= SOL_Y;
+
+	f = (DWORD)((long)pt.x * pt.x + (long)pt.y * pt.y);
+	if (f == 0 || GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1)
+		return 0;
+	else
+		return (square_root (f) + (FUEL_TANK_SCALE / 20));
+}
diff -ruNp ./src.orig/uqm/util.h ./src/uqm/util.h
--- ./src.orig/uqm/util.h	2017-10-23 11:42:17 -0700
+++ ./src/uqm/util.h	2017-10-23 11:41:35 -0700
@@ -28,5 +28,7 @@ extern DWORD SeedRandomNumbers (void);
 // saveRect can be NULL to save the entire context frame
 extern STAMP SaveContextFrame (const RECT *saveRect);
 
+extern DWORD get_fuel_to_sol (void);
+
 #endif  /* _UTIL_H */
 
diff -ruNp ./src.orig/uqm/velocity.c ./src/uqm/velocity.c
--- ./src.orig/uqm/velocity.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/velocity.c	2017-10-23 11:41:35 -0700
@@ -16,10 +16,13 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #include "velocity.h"
 
 #include "units.h"
 #include "libs/compiler.h"
+#include "libs/log.h"
 
 
 #define VELOCITY_REMAINDER(v) ((v) & (VELOCITY_SCALE - 1))
@@ -28,40 +31,78 @@ void
 GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy)
 {
 	*pdx = WORLD_TO_VELOCITY (velocityptr->vector.width)
-			+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
+	+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
 	*pdy = WORLD_TO_VELOCITY (velocityptr->vector.height)
-			+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
+	+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
 }
 
 void
-GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy,
-		COUNT num_frames)
+GetCurrentVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy)
 {
-	COUNT e;
+	*pdx = WORLD_TO_VELOCITY (velocityptr->vector.width)
+	+ ((SDWORD)velocityptr->fract.width - (SDWORD)HIBYTE (velocityptr->incr.width));
+	*pdy = WORLD_TO_VELOCITY (velocityptr->vector.height)
+	+ ((SDWORD)velocityptr->fract.height - (SDWORD)HIBYTE (velocityptr->incr.height));
+}
 
+void
+GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy, COUNT num_frames)
+{
+	COUNT e;
+	
 	e = (COUNT)((COUNT)velocityptr->error.width +
-			((COUNT)velocityptr->fract.width * num_frames));
+				((COUNT)velocityptr->fract.width * num_frames));
+	
 	*pdx = (velocityptr->vector.width * num_frames)
-			+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.width))
-			* (e >> VELOCITY_SHIFT));
+	+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.width))
+	   * (e >> VELOCITY_SHIFT));
+	
 	velocityptr->error.width = VELOCITY_REMAINDER (e);
-
+	
 	e = (COUNT)((COUNT)velocityptr->error.height +
-			((COUNT)velocityptr->fract.height * num_frames));
+				((COUNT)velocityptr->fract.height * num_frames));
+	
 	*pdy = (velocityptr->vector.height * num_frames)
-			+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.height))
-			* (e >> VELOCITY_SHIFT));
+	+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.height))
+	   * (e >> VELOCITY_SHIFT));
+	
 	velocityptr->error.height = VELOCITY_REMAINDER (e);
 }
 
+// JMS_GFX: New function to prevent overflows in hi-res.
+void
+GetNextVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy, DWORD num_frames)
+{
+	DWORD e;
+	
+	e = (DWORD)((DWORD)velocityptr->error.width +
+				((DWORD)velocityptr->fract.width * num_frames));
+	
+	*pdx = ((SDWORD)velocityptr->vector.width * num_frames)
+	+ ((SDWORD)((SBYTE)LOBYTE (velocityptr->incr.width))
+	   * (e >> VELOCITY_SHIFT));
+	
+	velocityptr->error.width = (COUNT)(VELOCITY_REMAINDER (e));
+	
+	e = (DWORD)((DWORD)velocityptr->error.height +
+				((DWORD)velocityptr->fract.height * num_frames));
+	
+	*pdy = ((SDWORD)velocityptr->vector.height * num_frames)
+	+ ((SDWORD)((SBYTE)LOBYTE (velocityptr->incr.height))
+	   * (e >> VELOCITY_SHIFT));
+	
+	velocityptr->error.height = (COUNT)(VELOCITY_REMAINDER (e));
+}
+
+// JMS_GFX: Preventing overflows in hi-res: The SDWORD in this function's parameters was SIZE.
 void
-SetVelocityVector (VELOCITY_DESC *velocityptr, SIZE magnitude, COUNT facing)
+SetVelocityVector (VELOCITY_DESC *velocityptr, SDWORD magnitude, COUNT facing)
 {
 	COUNT angle;
 	SIZE dx, dy;
-
+	
 	angle = velocityptr->TravelAngle =
-			FACING_TO_ANGLE (NORMALIZE_FACING (facing));
+	FACING_TO_ANGLE (NORMALIZE_FACING (facing));
 	magnitude = WORLD_TO_VELOCITY (magnitude);
 	dx = COSINE (angle, magnitude);
 	dy = SINE (angle, magnitude);
@@ -75,7 +116,7 @@ SetVelocityVector (VELOCITY_DESC *veloci
 		dx = -dx;
 		velocityptr->vector.width = -VELOCITY_TO_WORLD (dx);
 		velocityptr->incr.width =
-				MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
+		MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
 	}
 	if (dy >= 0)
 	{
@@ -87,19 +128,20 @@ SetVelocityVector (VELOCITY_DESC *veloci
 		dy = -dy;
 		velocityptr->vector.height = -VELOCITY_TO_WORLD (dy);
 		velocityptr->incr.height =
-				MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
+		MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
 	}
-
+	
 	velocityptr->fract.width = VELOCITY_REMAINDER (dx);
 	velocityptr->fract.height = VELOCITY_REMAINDER (dy);
 	velocityptr->error.width = velocityptr->error.height = 0;
 }
 
+// JMS_GFX: Preventing overflows in hi-res: The SDWORDs in this function's parameters were SIZEs.
 void
-SetVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx, SIZE dy)
+SetVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy)
 {
 	COUNT angle;
-
+	
 	if ((angle = ARCTAN (dx, dy)) == FULL_CIRCLE)
 	{
 		ZeroVelocityComponents (velocityptr);
@@ -115,8 +157,7 @@ SetVelocityComponents (VELOCITY_DESC *ve
 		{
 			dx = -dx;
 			velocityptr->vector.width = -VELOCITY_TO_WORLD (dx);
-			velocityptr->incr.width =
-					MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
+			velocityptr->incr.width = MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
 		}
 		if (dy >= 0)
 		{
@@ -127,27 +168,27 @@ SetVelocityComponents (VELOCITY_DESC *ve
 		{
 			dy = -dy;
 			velocityptr->vector.height = -VELOCITY_TO_WORLD (dy);
-			velocityptr->incr.height =
-					MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
+			velocityptr->incr.height = MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
 		}
-
+		
 		velocityptr->fract.width = VELOCITY_REMAINDER (dx);
 		velocityptr->fract.height = VELOCITY_REMAINDER (dy);
 		velocityptr->error.width = velocityptr->error.height = 0;
 	}
-
+	
 	velocityptr->TravelAngle = angle;
 }
 
+// JMS_GFX: Preventing overflows in hi-res: The SDWORDs in this function's parameters were SIZEs.
 void
-DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx, SIZE dy)
+DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy)
 {
-
+	
 	dx += WORLD_TO_VELOCITY (velocityptr->vector.width)
-			+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
+	+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
 	dy += WORLD_TO_VELOCITY (velocityptr->vector.height)
-			+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
-
+	+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
+	
 	SetVelocityComponents (velocityptr, dx, dy);
 }
 
diff -ruNp ./src.orig/uqm/velocity.h ./src/uqm/velocity.h
--- ./src.orig/uqm/velocity.h	2017-10-23 11:42:17 -0700
+++ ./src/uqm/velocity.h	2017-10-23 11:41:35 -0700
@@ -34,16 +34,21 @@ typedef struct velocity_desc
 #define ZeroVelocityComponents(pv) memset(pv,0,sizeof (*(pv)))
 #define GetVelocityTravelAngle(pv) (pv)->TravelAngle
 
-extern void GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr,
-		SIZE *pdx, SIZE *pdy);
-extern void GetNextVelocityComponents (VELOCITY_DESC *velocityptr,
-		SIZE *pdx, SIZE *pdy, COUNT num_frames);
-extern void SetVelocityVector (VELOCITY_DESC *velocityptr, SIZE magnitude,
-		COUNT facing);
-extern void SetVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx,
-		SIZE dy);
-extern void DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx,
-		SIZE dy);
+extern void GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy);
+
+// JMS_GFX: New function to prevent overflows in hi-res.
+extern void GetCurrentVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy);
+
+extern void GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy, COUNT num_frames);
+
+// JMS_GFX: New function to prevent overflows in hi-res.
+extern void GetNextVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy, DWORD num_frames);
+
+extern void SetVelocityVector (VELOCITY_DESC *velocityptr, SDWORD magnitude, COUNT facing); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
+
+extern void SetVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
+
+extern void DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
 
 static inline BOOLEAN
 IsVelocityZero (VELOCITY_DESC *vptr)
diff -ruNp ./src.orig/uqm/weapon.c ./src/uqm/weapon.c
--- ./src.orig/uqm/weapon.c	2017-10-23 11:42:17 -0700
+++ ./src/uqm/weapon.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
+
 #include "weapon.h"
 
 #include "colors.h"
@@ -47,8 +50,7 @@ initialize_laser (LASER_BLOCK *pLaserBlo
 		LaserElementPtr->playerNr = pLaserBlock->sender;
 		LaserElementPtr->hit_points = 1;
 		LaserElementPtr->mass_points = 1;
-		LaserElementPtr->state_flags = APPEARING | FINITE_LIFE
-				| pLaserBlock->flags;
+		LaserElementPtr->state_flags = APPEARING | FINITE_LIFE | pLaserBlock->flags;
 		LaserElementPtr->life_span = LASER_LIFE;
 		LaserElementPtr->collision_func = (CollisionFunc*)weapon_collision;
 		LaserElementPtr->blast_offset = 1;
@@ -60,15 +62,12 @@ initialize_laser (LASER_BLOCK *pLaserBlo
 				+ SINE (FACING_TO_ANGLE (pLaserBlock->face),
 				DISPLAY_TO_WORLD (pLaserBlock->pixoffs));
 		SetPrimType (&DisplayArray[LaserElementPtr->PrimIndex], LINE_PRIM);
-		SetPrimColor (&DisplayArray[LaserElementPtr->PrimIndex],
-				pLaserBlock->color);
+		SetPrimColor (&DisplayArray[LaserElementPtr->PrimIndex], pLaserBlock->color);
 		LaserElementPtr->current.image.frame = DecFrameIndex (stars_in_space);
 		LaserElementPtr->current.image.farray = &stars_in_space;
-		SetVelocityComponents (&LaserElementPtr->velocity,
-				WORLD_TO_VELOCITY ((pLaserBlock->cx + pLaserBlock->ex)
-				- LaserElementPtr->current.location.x),
-				WORLD_TO_VELOCITY ((pLaserBlock->cy + pLaserBlock->ey)
-				- LaserElementPtr->current.location.y));
+		SetVelocityComponents (&LaserElementPtr->velocity, 
+			WORLD_TO_VELOCITY ((pLaserBlock->cx + pLaserBlock->ex) - LaserElementPtr->current.location.x),
+			WORLD_TO_VELOCITY ((pLaserBlock->cy + pLaserBlock->ey) - LaserElementPtr->current.location.y));
 		UnlockElement (hLaserElement);
 	}
 
@@ -123,8 +122,7 @@ initialize_missile (MISSILE_BLOCK *pMiss
 }
 
 HELEMENT
-weapon_collision (ELEMENT *WeaponElementPtr, POINT *pWPt,
-		ELEMENT *HitElementPtr, POINT *pHPt)
+weapon_collision (ELEMENT *WeaponElementPtr, POINT *pWPt, ELEMENT *HitElementPtr, POINT *pHPt)
 {
 	SIZE damage;
 	HELEMENT hBlastElement;
@@ -133,6 +131,7 @@ weapon_collision (ELEMENT *WeaponElement
 		return ((HELEMENT)0);
 
 	damage = (SIZE)WeaponElementPtr->mass_points;
+	
 	if (damage
 			&& ((HitElementPtr->state_flags & FINITE_LIFE)
 			|| HitElementPtr->life_span == NORMAL_LIFE))
@@ -159,12 +158,10 @@ weapon_collision (ELEMENT *WeaponElement
 			damage = TARGET_DAMAGED_FOR_1_PT + (damage >> 1);
 			if (damage > TARGET_DAMAGED_FOR_6_PLUS_PT)
 				damage = TARGET_DAMAGED_FOR_6_PLUS_PT;
-			ProcessSound (SetAbsSoundIndex (GameSounds, damage),
-					HitElementPtr);
+			ProcessSound (SetAbsSoundIndex (GameSounds, damage), HitElementPtr);
 		}
 
-		if (GetPrimType (&DisplayArray[WeaponElementPtr->PrimIndex])
-				!= LINE_PRIM)
+		if (GetPrimType (&DisplayArray[WeaponElementPtr->PrimIndex]) != LINE_PRIM)
 			WeaponElementPtr->state_flags |= DISAPPEARING;
 
 		WeaponElementPtr->hit_points = 0;
@@ -209,21 +206,16 @@ weapon_collision (ELEMENT *WeaponElement
 			{
 				BlastElementPtr->life_span = 2;
 				BlastElementPtr->current.image.farray = blast;
-				BlastElementPtr->current.image.frame =
-						SetAbsFrameIndex (blast[0], blast_index);
+				BlastElementPtr->current.image.frame = SetAbsFrameIndex (blast[0], blast_index);
 			}
 			else
 			{
-				BlastElementPtr->life_span = num_blast_frames
-						- ANGLE_TO_FACING (FULL_CIRCLE);
+				BlastElementPtr->life_span = num_blast_frames - ANGLE_TO_FACING (FULL_CIRCLE);
 				BlastElementPtr->turn_wait = BlastElementPtr->next_turn = 0;
 				BlastElementPtr->preprocess_func = animation_preprocess;
-				BlastElementPtr->current.image.farray =
-						WeaponElementPtr->next.image.farray;
+				BlastElementPtr->current.image.farray = WeaponElementPtr->next.image.farray;
 				BlastElementPtr->current.image.frame =
-						SetAbsFrameIndex (
-						BlastElementPtr->current.image.farray[0],
-						ANGLE_TO_FACING (FULL_CIRCLE));
+						SetAbsFrameIndex (BlastElementPtr->current.image.farray[0], ANGLE_TO_FACING (FULL_CIRCLE));
 			}
 
 			UnlockElement (hBlastElement);
@@ -253,8 +245,8 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (modify_flags & MODIFY_IMAGE)
 	{
-		ShipIntersect.IntersectStamp.frame = SetAbsFrameIndex (
-				StarShipPtr->RaceDescPtr->ship_info.icons, 1);
+		ShipIntersect.IntersectStamp.frame = SetAbsFrameIndex ( StarShipPtr->RaceDescPtr->ship_info.icons, 1);
+		
 		if (ShipIntersect.IntersectStamp.frame == 0)
 			return (0);
 
@@ -263,6 +255,7 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 		ShipIntersect.IntersectStamp.origin.x = 0;
 		ShipIntersect.IntersectStamp.origin.y = 0;
 		ShipIntersect.EndPoint = ShipIntersect.IntersectStamp.origin;
+		
 		do
 		{
 			ObjectIntersect.IntersectStamp.origin.x = ((COUNT)TFB_Random ()
@@ -276,7 +269,7 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 				&ShipIntersect, MAX_TIME_VALUE));
 
 		ObjectIntersect.IntersectStamp.origin.x += STATUS_WIDTH >> 1;
-		ObjectIntersect.IntersectStamp.origin.y += 31;
+		ObjectIntersect.IntersectStamp.origin.y += (31 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 
 	ObjectIntersect.IntersectStamp.origin.y +=
@@ -286,8 +279,7 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 	{
 		or.corner.x += ObjectIntersect.IntersectStamp.origin.x;
 		or.corner.y += ObjectIntersect.IntersectStamp.origin.y;
-		InitShipStatus (&StarShipPtr->RaceDescPtr->ship_info,
-				StarShipPtr, &or);
+		InitShipStatus (&StarShipPtr->RaceDescPtr->ship_info, StarShipPtr, &or, FALSE);
 	}
 	else
 	{
diff -ruNp ./src.orig/uqm.c ./src/uqm.c
--- ./src.orig/uqm.c	2017-10-23 11:42:18 -0700
+++ ./src/uqm.c	2017-10-23 11:41:35 -0700
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS_GFX 2012: Merged the resolution Factor stuff from P6014.
+
 #ifdef HAVE_UNISTD_H
 #	include <unistd.h>
 #endif
@@ -127,6 +129,15 @@ struct options_struct
 	DECL_CONFIG_OPTION(float, sfxVolumeScale);
 	DECL_CONFIG_OPTION(float, speechVolumeScale);
 	DECL_CONFIG_OPTION(bool, safeMode);
+	DECL_CONFIG_OPTION(int, resolutionFactor); // JMS_GFX
+	DECL_CONFIG_OPTION(bool, forceAspectRatio); // JMS_GFX
+	DECL_CONFIG_OPTION(int, loresBlowupScale); // JMS_GFX
+	DECL_CONFIG_OPTION(bool, mainmenuMusic); // JMS
+	DECL_CONFIG_OPTION(bool, mineralSubmenu); // JMS
+	DECL_CONFIG_OPTION(bool, nebulae); // JMS
+	DECL_CONFIG_OPTION(bool, rotatingIpPlanets); // JMS
+	DECL_CONFIG_OPTION(bool, texturedIpPlanets); // JMS
+	DECL_CONFIG_OPTION(bool, cheatMode); // JMS
 
 #define INIT_CONFIG_OPTION(name, val) \
 	{ val, false }
@@ -155,8 +166,8 @@ static const struct option_list_value sc
 
 static const struct option_list_value meleeScaleList[] = 
 {
-	{"smooth",   TFB_SCALE_TRILINEAR},
-	{"3do",      TFB_SCALE_TRILINEAR},
+	{"smooth",   TFB_SCALE_BILINEAR}, // JMS: Replaced trilinear with bilinear because of performance problems.
+	{"3do",      TFB_SCALE_BILINEAR}, // JMS: Replaced trilinear with bilinear because of performance problems.
 	{"step",     TFB_SCALE_STEP},
 	{"pc",       TFB_SCALE_STEP},
 	{"bilinear", TFB_SCALE_BILINEAR},
@@ -235,13 +246,13 @@ main (int argc, char *argv[])
 		/* .addons = */             NULL,
 		/* .numAddons = */          0,
 
-		INIT_CONFIG_OPTION(  opengl,            false ),
-		INIT_CONFIG_OPTION2( resolution,        640, 480 ),
-		INIT_CONFIG_OPTION(  fullscreen,        false ),
+		INIT_CONFIG_OPTION(  opengl,            true ),
+		INIT_CONFIG_OPTION2( resolution,        1280, 960 ),
+		INIT_CONFIG_OPTION(  fullscreen,        true ),
 		INIT_CONFIG_OPTION(  scanlines,         false ),
-		INIT_CONFIG_OPTION(  scaler,            0 ),
+		INIT_CONFIG_OPTION(  scaler,            TFB_GFXFLAGS_SCALE_BILINEAR),
 		INIT_CONFIG_OPTION(  showFps,           false ),
-		INIT_CONFIG_OPTION(  keepAspectRatio,   false ),
+		INIT_CONFIG_OPTION(  keepAspectRatio,   true ),
 		INIT_CONFIG_OPTION(  gamma,             0.0f ),
 		INIT_CONFIG_OPTION(  soundDriver,       audio_DRIVER_MIXSDL ),
 		INIT_CONFIG_OPTION(  soundQuality,      audio_QUALITY_MEDIUM ),
@@ -253,13 +264,22 @@ main (int argc, char *argv[])
 		INIT_CONFIG_OPTION(  whichIntro,        OPT_PC ),
 		INIT_CONFIG_OPTION(  whichShield,       OPT_PC ),
 		INIT_CONFIG_OPTION(  smoothScroll,      OPT_PC ),
-		INIT_CONFIG_OPTION(  meleeScale,        TFB_SCALE_TRILINEAR ),
+		INIT_CONFIG_OPTION(  meleeScale,        TFB_SCALE_BILINEAR ), // JMS: Replaced trilinear with bilinear because of performance problems.
 		INIT_CONFIG_OPTION(  subtitles,         true ),
 		INIT_CONFIG_OPTION(  stereoSFX,         false ),
 		INIT_CONFIG_OPTION(  musicVolumeScale,  1.0f ),
 		INIT_CONFIG_OPTION(  sfxVolumeScale,    1.0f ),
-		INIT_CONFIG_OPTION(  speechVolumeScale, 1.0f ),
+		INIT_CONFIG_OPTION(  speechVolumeScale, 0.3f ),
 		INIT_CONFIG_OPTION(  safeMode,          false ),
+		INIT_CONFIG_OPTION(  resolutionFactor,  2 ),
+		INIT_CONFIG_OPTION(  forceAspectRatio,  false ),
+		INIT_CONFIG_OPTION(  loresBlowupScale,  0 ),
+		INIT_CONFIG_OPTION(  mainmenuMusic,     true ),
+		INIT_CONFIG_OPTION(  mineralSubmenu,    true ),
+		INIT_CONFIG_OPTION(  nebulae,			true ),
+		INIT_CONFIG_OPTION(  rotatingIpPlanets,	true),
+		INIT_CONFIG_OPTION(  texturedIpPlanets,	true),
+		INIT_CONFIG_OPTION(  cheatMode,			false ),
 	};
 	struct options_struct defaults = options;
 	int optionsResult;
@@ -382,7 +402,18 @@ main (int argc, char *argv[])
 	sfxVolumeScale = options.sfxVolumeScale.value;
 	speechVolumeScale = options.speechVolumeScale.value;
 	optAddons = options.addons;
-
+	
+	resolutionFactor = (unsigned int) options.resolutionFactor.value; // JMS_GFX
+	forceAspectRatio = options.forceAspectRatio.value; // JMS_GFX
+	loresBlowupScale = (unsigned int) options.loresBlowupScale.value; // JMS_GFX
+	resFactorWasChanged = FALSE; // JMS_GFX
+	optMainmenuMusic = options.mainmenuMusic.value; // JMS
+	optMineralSubmenu = options.mineralSubmenu.value; // JMS
+	optNebulae = options.nebulae.value; // JMS
+	optRotatingIpPlanets = options.rotatingIpPlanets.value; // JMS
+	optTexturedIpPlanets = options.texturedIpPlanets.value || optRotatingIpPlanets; // JMS
+	optCheatMode = options.cheatMode.value; // JMS
+	
 	prepareContentDir (options.contentDir, options.addonDir, argv[0]);
 	prepareMeleeDir ();
 	prepareSaveDir ();
@@ -413,8 +444,7 @@ main (int argc, char *argv[])
 		gfxFlags |= TFB_GFXFLAGS_SCANLINES;
 	if (options.showFps.value)
 		gfxFlags |= TFB_GFXFLAGS_SHOWFPS;
-	TFB_InitGraphics (gfxDriver, gfxFlags, options.resolution.width,
-			options.resolution.height);
+	TFB_InitGraphics (gfxDriver, gfxFlags, options.resolution.width, options.resolution.height, resolutionFactor, forceAspectRatio); // JMS_GFX: added resolutionFactor
 	if (options.gamma.set)
 		TFB_SetGamma (options.gamma.value);
 	InitColorMaps ();
@@ -621,8 +651,11 @@ getUserConfigOptions (struct options_str
 	getBoolConfigValue (&options->use3doMusic, "config.3domusic");
 	getBoolConfigValue (&options->useRemixMusic, "config.remixmusic");
 
+	// JMS: Originally, the smooth zoom was TFB_SCALE_TRILINEAR instead of bilinear.
+	// Using bilinear alleviates the smooth zoom performance choppiness problems in 2x and 4x, but
+	// is kinda hacky solution...
 	getBoolConfigValueXlat (&options->meleeScale, "config.smoothmelee",
-			TFB_SCALE_TRILINEAR, TFB_SCALE_STEP);
+							TFB_SCALE_BILINEAR, TFB_SCALE_STEP);
 
 	if (getListConfigValue (&options->soundDriver, "config.audiodriver",
 			audioDriverList))
@@ -640,6 +673,30 @@ getUserConfigOptions (struct options_str
 	getVolumeConfigValue (&options->sfxVolumeScale, "config.sfxvol");
 	getVolumeConfigValue (&options->speechVolumeScale, "config.speechvol");
 	
+	// JMS_GFX
+	if (res_IsInteger ("config.resolutionfactor") && !options->resolutionFactor.set)
+	{
+		options->resolutionFactor.value = res_GetInteger ("config.resolutionfactor");
+		options->resolutionFactor.set = true;
+	}
+	
+	// JMS_GFX
+	getBoolConfigValue (&options->forceAspectRatio, "config.forceaspectratio");
+	
+	// JMS_GFX
+	if (res_IsInteger ("config.loresBlowupScale"))
+	{
+		options->loresBlowupScale.value = res_GetInteger ("config.loresBlowupScale");
+	}
+	
+	// JMS
+	getBoolConfigValue (&options->mainmenuMusic, "config.mainmenuMusic");
+	getBoolConfigValue (&options->mineralSubmenu, "config.mineralSubmenu");
+	getBoolConfigValue (&options->nebulae, "config.nebulae");
+	getBoolConfigValue (&options->rotatingIpPlanets, "config.rotatingIpPlanets");
+	getBoolConfigValue (&options->texturedIpPlanets, "config.texturedIpPlanets");
+	getBoolConfigValue (&options->cheatMode, "config.cheatMode");
+	
 	if (res_IsInteger ("config.player1control"))
 	{
 		PlayerControls[0] = res_GetInteger ("config.player1control");
@@ -685,6 +742,7 @@ enum
 	NETPORT2_OPT,
 	NETDELAY_OPT,
 #endif
+	RESFACTOR_OPT, // JMS_GFX
 };
 
 static const char *optString = "+r:foc:b:spC:n:?hM:S:T:m:q:ug:l:i:vwxk";
@@ -732,6 +790,7 @@ static struct option longOptions[] =
 	{"netport2", 1, NULL, NETPORT2_OPT},
 	{"netdelay", 1, NULL, NETDELAY_OPT},
 #endif
+	{"resfactor", 1, NULL, RESFACTOR_OPT}, // JMS_GFX
 	{0, 0, 0, 0}
 };
 
@@ -1050,6 +1109,26 @@ parseOptions (int argc, char *argv[], st
 				break;
 			}
 #endif
+			// JMS_GFX: Added the whole following case. It checks whether the resolutionfactor value is sane.
+			case RESFACTOR_OPT:
+			{
+				int temp;
+				if (parseIntOption (optarg, &temp, "resolution factor")
+						== -1)
+				{
+					badArg = true;
+					break;
+				}
+				options->resolutionFactor.value = temp;
+
+				if (options->resolutionFactor.value > 2)
+				{
+					saveError ("Resolution factor has to be 0, 1 or 2.");
+					badArg = true;
+				}
+				options->resolutionFactor.set = true;
+				break;
+			}
 			default:
 				saveError ("Error: Unknown option '%s'",
 						optionIndex < 0 ? "<unknown>" :
diff -ruNp ./src.orig/uqmversion.h ./src/uqmversion.h
--- ./src.orig/uqmversion.h	2017-10-23 11:42:18 -0700
+++ ./src/uqmversion.h	2017-10-23 11:41:35 -0700
@@ -23,7 +23,7 @@
 #define UQM_MINOR_VERSION_S  "7"
 #define UQM_PATCH_VERSION     0
 #define UQM_PATCH_VERSION_S  "0"
-#define UQM_EXTRA_VERSION    ""
+#define UQM_EXTRA_VERSION    "  + HD Mod BETA"
 /* The final version is interpreted as:
  * printf ("%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
  * 		UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
