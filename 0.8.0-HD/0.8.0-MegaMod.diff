diff -ruNp src.orig/libs/gfxlib.h src/libs/gfxlib.h
--- src.orig/libs/gfxlib.h	2017-11-21 16:07:02 -0600
+++ src/libs/gfxlib.h	2017-11-22 08:52:04 -0600
@@ -423,7 +423,7 @@ extern FRAME DecFrameIndex (FRAME Frame)
 extern DRAWABLE CopyFrameRect (FRAME Frame, const RECT *area);
 extern DRAWABLE CloneFrame (FRAME Frame);
 extern DRAWABLE RotateFrame (FRAME Frame, int angle_deg);
-extern DRAWABLE RescaleFrame (FRAME, int width, int height);
+extern DRAWABLE RescaleFrame (FRAME, int width, int height, BOOLEAN eight_to_32);
 // This pair works for both paletted and trucolor frames
 extern BOOLEAN ReadFramePixelColors (FRAME frame, Color *pixels,
 		int width, int height);
@@ -431,7 +431,7 @@ extern BOOLEAN WriteFramePixelColors (FR
 		int width, int height);
 // This pair only works for paletted frames
 extern BOOLEAN ReadFramePixelIndexes (FRAME frame, BYTE *pixels,
-		int width, int height);
+		int width, int height, BOOLEAN paletted);
 extern BOOLEAN WriteFramePixelIndexes (FRAME frame, const BYTE *pixels,
 		int width, int height);
 extern void SetFrameTransparentColor (FRAME, Color);
diff -ruNp src.orig/libs/graphics/drawable.c src/libs/graphics/drawable.c
--- src.orig/libs/graphics/drawable.c	2017-11-21 16:07:02 -0600
+++ src/libs/graphics/drawable.c	2017-11-22 08:52:04 -0600
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+
+#include "libs/graphics/sdl/sdl_common.h"
+#include "libs/graphics/gfx_common.h"
 #include "libs/gfxlib.h"
 #include "libs/graphics/context.h"
 #include "libs/graphics/drawable.h"
@@ -23,6 +26,7 @@
 #include "libs/memlib.h"
 #include "tfb_draw.h"
 #include <math.h>
+#include "libs/log.h"
 
 #ifndef M_PI
 #	define M_PI 3.14159265358979323846
@@ -402,7 +406,7 @@ CloneFrame (FRAME frame)
 // Creates a new DRAWABLE of specified size and scales the passed
 // frame onto it. The aspect ratio is not preserved.
 DRAWABLE
-RescaleFrame (FRAME frame, int width, int height)
+RescaleFrame (FRAME frame, int width, int height, BOOLEAN eight_to_32)
 {
 	FRAME newFrame;
 	TFB_Image *img;
@@ -426,7 +430,21 @@ RescaleFrame (FRAME frame, int width, in
 	// NOTE: We do not lock the target image because nothing has a
 	//   reference to it yet!
 	src = img->NormalImg;
-	dst = newFrame->image->NormalImg;
+	dst = newFrame->image->NormalImg;	
+	
+	// JMS_GFX
+	if (eight_to_32)
+	{
+		SDL_Surface *src_sdl = src;
+		SDL_Surface *dst_sdl = dst;
+		
+		if (src_sdl->format->BytesPerPixel == 1)
+		{
+			dst_sdl->format->BytesPerPixel = src_sdl->format->BytesPerPixel;
+			dst_sdl->format->BitsPerPixel = 8 * (src_sdl->format->BytesPerPixel);
+		}
+	}
+
 	TFB_DrawCanvas_Rescale_Nearest (src, dst, -1, NULL, NULL, NULL);
 	
 	UnlockMutex (img->mutex);
@@ -468,7 +486,7 @@ WriteFramePixelColors (FRAME frame, cons
 }
 
 BOOLEAN
-ReadFramePixelIndexes (FRAME frame, BYTE *pixels, int width, int height)
+ReadFramePixelIndexes (FRAME frame, BYTE *pixels, int width, int height, BOOLEAN paletted)
 {
 	TFB_Image *img;
 
@@ -479,8 +497,13 @@ ReadFramePixelIndexes (FRAME frame, BYTE
 
 	// TODO: Do we need to lock the img->mutex here?
 	img = frame->image;
-	return TFB_DrawCanvas_GetPixelIndexes (img->NormalImg, pixels,
+	
+	// JMS_GFX: Don't try to read pixel indexes for non-indexed images.
+	if (paletted)
+		return TFB_DrawCanvas_GetPixelIndexes (img->NormalImg, pixels,
 			width, height);
+	else
+		return FALSE;
 }
 
 // Warning: this functions bypasses DCQ, which is why it is not a DrawXXX
diff -ruNp src.orig/libs/graphics/sdl/opengl.c src/libs/graphics/sdl/opengl.c
--- src.orig/libs/graphics/sdl/opengl.c	2017-11-21 16:07:03 -0600
+++ src/libs/graphics/sdl/opengl.c	2017-11-22 08:52:04 -0600
@@ -300,7 +300,8 @@ TFB_GL_ScanLines (void)
 	glDisable (GL_TEXTURE_2D);
 	glEnable (GL_BLEND);
 	glBlendFunc (GL_DST_COLOR, GL_ZERO);
-	glColor3f (0.85f, 0.85f, 0.85f);
+	// glColor3f (0.85f, 0.85f, 0.85f);
+	glColor3f (0.4f, 0.4f, 0.4f); // Darkened scanlines
 	for (y = 0; y < ScreenHeightActual; y += 2)
 	{
 		glBegin (GL_LINES);
@@ -310,7 +311,7 @@ TFB_GL_ScanLines (void)
 	}
 
 	glBlendFunc (GL_DST_COLOR, GL_ONE);
-	glColor3f (0.2f, 0.2f, 0.2f);
+	glColor3f (0.3f, 0.3f, 0.3f);
 	for (y = 1; y < ScreenHeightActual; y += 2)
 	{
 		glBegin (GL_LINES);
diff -ruNp src.orig/libs/graphics/widgets.c src/libs/graphics/widgets.c
--- src.orig/libs/graphics/widgets.c	2017-11-21 16:07:03 -0600
+++ src/libs/graphics/widgets.c	2017-11-22 08:52:04 -0600
@@ -17,22 +17,26 @@
 #include "gfx_common.h"
 #include "widgets.h"
 #include "libs/strlib.h"
+#include "uqm/colors.h"
 
 WIDGET *widget_focus = NULL;
 
 /* Some basic color defines */
 #define WIDGET_ACTIVE_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x00), 0x0E)
+		MENU_HIGHLIGHT_COLOR
 #define WIDGET_INACTIVE_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x18, 0x18, 0x1F), 0x00)
 #define WIDGET_INACTIVE_SELECTED_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), 0x0F)
+		WHITE_COLOR
 #define WIDGET_CURSOR_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00)
+		BLACK_COLOR
 #define WIDGET_DIALOG_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x07)
+		LTGRAY_COLOR
 #define WIDGET_DIALOG_TEXT_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00)
+		WIDGET_CURSOR_COLOR
+
+#define WIDGET_ENABLED_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x00, 0xC8, 0x00), 0x00)
 
 static Color win_bg_clr =
 		BUILD_COLOR (MAKE_RGB15_INIT (0x18, 0x18, 0x1F), 0x00);
@@ -168,7 +172,7 @@ Widget_DrawToolTips (int numlines, const
 	RECT r;
 	FONT  oldfont = 0;
 	FRAME oldFontEffect = SetContextFontEffect (NULL);
-	Color oldtext = SetContextForeGroundColor (WIDGET_INACTIVE_SELECTED_COLOR);
+	Color oldtext = SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x00, 0x18, 0x00), 0x0E));
 	TEXT t;
 	int i;
 
@@ -178,7 +182,7 @@ Widget_DrawToolTips (int numlines, const
 	r.corner.x = 2;
 	r.corner.y = 2;
 	r.extent.width = ScreenWidth - 4;
-	r.extent.height = ScreenHeight - 4;
+	r.extent.height = ScreenHeight + 2; // was '- 4'
 
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -269,7 +273,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 {
 	WIDGET_CHOICE *self = (WIDGET_CHOICE *)_self;
 	Color oldtext;
-	Color inactive, default_color, selected;
+	Color default_color, selected, enabled, disabled;
 	FONT  oldfont = 0;
 	FRAME oldFontEffect = SetContextFontEffect (NULL);
 	TEXT t;
@@ -279,10 +283,11 @@ Widget_DrawChoice (WIDGET *_self, int x,
 		oldfont = SetContextFont (cur_font);
 	
 	default_color = WIDGET_INACTIVE_SELECTED_COLOR;
+	enabled = WIDGET_ENABLED_COLOR;
+	disabled = DKGRAY_COLOR;
 	selected = WIDGET_ACTIVE_COLOR;
-	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = 2; // Was 'x'.
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -304,7 +309,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 	{
 		t.baseline.x = home_x + ((i % 3) *
 				(ScreenWidth / (self->maxcolumns + 1)));
-		t.baseline.y = home_y + (8 * (i / 3));
+		t.baseline.y = home_y + (10 * (i / 3)); // Was 8*(i/3): Changed for readability
 		t.pStr = self->options[i].optname;
 		if ((widget_focus == _self) &&
 		    (self->highlighted == i))
@@ -314,11 +319,11 @@ Widget_DrawChoice (WIDGET *_self, int x,
 		}
 		else if (i == self->selected)
 		{
-			SetContextForeGroundColor (default_color);
+			SetContextForeGroundColor (enabled);
 		}
 		else
 		{
-			SetContextForeGroundColor (inactive);
+			SetContextForeGroundColor (disabled);
 		}
 		font_DrawText (&t);
 	}
@@ -416,7 +421,7 @@ Widget_DrawSlider(WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = 2; // Was 'x'.
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -489,7 +494,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 
 	BatchGraphics ();
 
-	t.baseline.x = x;
+	t.baseline.x = 2; // Was 'x'.
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -625,7 +630,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = 2; // Was 'x'.
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
diff -ruNp src.orig/libs/input/sdl/input.c src/libs/input/sdl/input.c
--- src.orig/libs/input/sdl/input.c	2017-11-21 16:07:03 -0600
+++ src/libs/input/sdl/input.c	2017-11-22 08:52:04 -0600
@@ -75,6 +75,7 @@ static const char *menu_res_names[] = {
 	"editcancel",
 	"search",
 	"next",
+	"togglemap", // JMS: For showing SC1-era starmap.
 	NULL
 };
 
@@ -250,11 +251,13 @@ initJoystick (void)
 int 
 TFB_InitInput (int driver, int flags)
 {
+	int signed_num_keys; // JMS: New variable to silence warnings
 	(void)driver;
 	(void)flags;
 
 	SDL_EnableUNICODE(1);
-	(void)SDL_GetKeyState (&num_keys);
+	(void)SDL_GetKeyState (&signed_num_keys);
+	num_keys = (unsigned int) signed_num_keys;
 	kbdstate = (int *)HMalloc (sizeof (int) * (num_keys + 1));
 	
 
diff -ruNp src.orig/libs/input/sdl/vcontrol.c src/libs/input/sdl/vcontrol.c
--- src.orig/libs/input/sdl/vcontrol.c	2017-11-21 16:07:03 -0600
+++ src/libs/input/sdl/vcontrol.c	2017-11-22 08:52:04 -0600
@@ -184,10 +184,12 @@ static void
 key_init (void)
 {
 	unsigned int i;
+	int signed_num_sdl_keys; // JMS: New variable to silence warnings
 	int num_keys; // Temp to match type of param for SDL_GetKeyState().
+
 	pool = allocate_key_chunk ();
-	(void)SDL_GetKeyState (&num_keys);
-	num_sdl_keys = num_keys;
+	(void)SDL_GetKeyState (&signed_num_sdl_keys); // JMS: was num_sdl_keys
+	num_sdl_keys = (unsigned int) signed_num_sdl_keys; // JMS: new line
 	bindings = (keybinding **) HMalloc (sizeof (keybinding *) * num_sdl_keys);
 	for (i = 0; i < num_sdl_keys; i++)
 		bindings[i] = NULL;
diff -ruNp src.orig/libs/network/wspiapiwrap.h src/libs/network/wspiapiwrap.h
--- src.orig/libs/network/wspiapiwrap.h	2017-11-21 16:07:06 -0600
+++ src/libs/network/wspiapiwrap.h	2017-11-22 08:52:06 -0600
@@ -19,7 +19,10 @@
 #ifndef _WSPIAPIWRAP_H
 #define _WSPIAPIWRAP_H
 
-// HACK. See wspiapiwrap.c
+/* ************
+   DC: This whole section commented out due to VSC compiling issues. Found here: http://forum.uqm.stack.nl/index.php?topic=4353.0
+
+   // HACK. See wspiapiwrap.c
 #	define getaddrinfo WspiapiGetAddrInfo
 #	define getnameinfo WspiapiGetNameInfo
 #	define freeaddrinfo WspiapiFreeAddrInfo
@@ -28,6 +31,8 @@ int WINAPI WspiapiGetAddrInfo(const char
 		const struct addrinfo *hints, struct addrinfo **res);
 int WINAPI WspiapiGetNameInfo (const struct sockaddr *sa, socklen_t salen,
 		char *host, size_t hostlen, char *serv, size_t servlen, int flags);
+*/
+#include <wspiapi.h>  //DC: replaced upper section with this part to (hopefully) compile.
 
 #endif  /* _WSPIAPIWRAP_H */
 
diff -ruNp src.orig/options.c src/options.c
--- src.orig/options.c	2017-11-21 16:07:09 -0600
+++ src/options.c	2017-11-22 08:52:08 -0600
@@ -52,6 +52,32 @@ int optSmoothScroll;
 int optMeleeScale;
 const char **optAddons;
 
+BOOLEAN optCheatMode; // JMS
+// Serosis
+BOOLEAN optGodMode;
+int timeDilationScale;
+BOOLEAN optBubbleWarp;
+BOOLEAN optUnlockShips;
+BOOLEAN optHeadStart;
+BOOLEAN optUnlockUpgrades;
+BOOLEAN optInfiniteRU;
+DWORD oldRU;
+BOOLEAN optSkipIntro;
+BOOLEAN optFMV;
+// JMS
+BOOLEAN optMainMenuMusic;
+BOOLEAN optNebulae;
+BOOLEAN optOrbitingPlanets;
+BOOLEAN optTexturedPlanets;
+// Nic
+int optDateFormat;
+// Serosis
+BOOLEAN optInfiniteFuel;
+DWORD loadFuel;
+BOOLEAN optThraddStory;
+BOOLEAN optPartialPickup;
+BOOLEAN optSubmenu;
+
 BOOLEAN opt3doMusic;
 BOOLEAN optRemixMusic;
 BOOLEAN optSpeech;
diff -ruNp src.orig/options.h src/options.h
--- src.orig/options.h	2017-11-21 16:07:09 -0600
+++ src/options.h	2017-11-22 08:52:08 -0600
@@ -42,6 +42,33 @@ extern int optWhichShield;
 extern int optSmoothScroll;
 extern int optMeleeScale;
 
+extern BOOLEAN optCheatMode; // JMS
+// Serosis
+extern BOOLEAN optGodMode;
+extern int timeDilationScale;
+extern BOOLEAN optBubbleWarp;
+extern BOOLEAN optRoseBud;
+extern BOOLEAN optUnlockShips;
+extern BOOLEAN optHeadStart;
+extern BOOLEAN optUnlockUpgrades;
+extern BOOLEAN optInfiniteRU;
+extern DWORD oldRU;
+extern BOOLEAN optSkipIntro;
+extern BOOLEAN optFMV;
+// JMS
+extern BOOLEAN optMainMenuMusic;
+extern BOOLEAN optNebulae;
+extern BOOLEAN optOrbitingPlanets;
+extern BOOLEAN optTexturedPlanets;
+// Nic
+extern int optDateFormat;
+// Serosis
+extern BOOLEAN optInfiniteFuel;
+extern DWORD loadFuel;
+extern BOOLEAN optThraddStory;
+extern BOOLEAN optPartialPickup;
+extern BOOLEAN optSubmenu;
+
 extern BOOLEAN opt3doMusic;
 extern BOOLEAN optRemixMusic;
 extern BOOLEAN optSpeech;
diff -ruNp src.orig/port.h src/port.h
--- src.orig/port.h	2017-11-21 16:07:09 -0600
+++ src/port.h	2017-11-22 08:52:08 -0600
@@ -177,7 +177,7 @@ typedef unsigned short mode_t;
 extern "C" {
 #endif
 int snprintf(char *str, size_t size, const char *format, ...);
-int vsnprintf(char *str, size_t size, const char *format, va_list args);
+// int vsnprintf(char *str, size_t size, const char *format, va_list args);
 #if defined(__cplusplus)
 }
 #endif
diff -ruNp src.orig/regex/regex_internal.h src/regex/regex_internal.h
--- src.orig/regex/regex_internal.h	2017-11-21 16:07:09 -0600
+++ src/regex/regex_internal.h	2017-11-22 08:52:08 -0600
@@ -80,7 +80,11 @@
 # define BE(expr, val) __builtin_expect (expr, val)
 #else
 # define BE(expr, val) (expr)
-# define inline
+#ifdef _MSC_VER
+	#define inline __inline
+#else
+	#define inline
+#endif
 #endif
 
 /* Number of bits in a byte.  */
diff -ruNp src.orig/res/UrQuanMasters.rc src/res/UrQuanMasters.rc
--- src.orig/res/UrQuanMasters.rc	2017-11-21 16:07:09 -0600
+++ src/res/UrQuanMasters.rc	2017-11-22 08:52:08 -0600
@@ -67,10 +67,10 @@ END
 
 // Icon with lowest ID value placed first to ensure application icon
 // remains consistent on all systems.
-SDL_app            ICON    PRELOAD DISCARDABLE "ur-quan-icon-alpha.ico"
+SDL_app            ICON    PRELOAD DISCARDABLE "kohr-ah1.ico"
 102                ICON    DISCARDABLE     "ur-quan-icon-std.ico"
 103                ICON    DISCARDABLE     "ur-quan1.ico"
 104                ICON    DISCARDABLE     "sis1.ico"
 105                ICON    DISCARDABLE     "ur-quan2.ico"
-106                ICON    DISCARDABLE     "kohr-ah1.ico"
+106                ICON    DISCARDABLE     "ur-quan-icon-alpha.ico"
 107                ICON    DISCARDABLE     "starcon2.ico"
diff -ruNp src.orig/res/darwin/Info.plist src/res/darwin/Info.plist
--- src.orig/res/darwin/Info.plist	2017-11-21 16:07:09 -0600
+++ src/res/darwin/Info.plist	2017-11-22 08:52:08 -0600
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 <plist version="1.0">
 <dict>
 	<key>CFBundleDevelopmentRegion</key>
 	<string>English</string>
 	<key>CFBundleExecutable</key>
-	<string>The Ur-Quan Masters</string>
+	<string>The Ur-Quan Masters MegaMod</string>
 	<key>CFBundleIconFile</key>
 	<string>The Ur-Quan Masters.icns</string>
 	<key>CFBundleInfoDictionaryVersion</key>
diff -ruNp src.orig/uqm/build.c src/uqm/build.c
--- src.orig/uqm/build.c	2017-11-21 16:07:10 -0600
+++ src/uqm/build.c	2017-11-22 08:52:08 -0600
@@ -17,14 +17,14 @@
  */
 
 #include "build.h"
-
+#include "options.h"
 #include "races.h"
 #include "master.h"
 #include "sis.h"
 #include "setup.h"
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
-
+#include "planets/planets.h"
 #include <stdlib.h>
 
 
@@ -317,6 +317,30 @@ SetRaceAllied (RACE_ID race, BOOLEAN fla
 }
 
 /*
+ * Allows the building of ships regardless of alliance state
+ * flag == TRUE: Allow to build ship
+ * flag == FALSE: Normal, not allowed to build ships if not allied.
+ */
+BOOLEAN
+SetRaceAllowBuild (RACE_ID race) {
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return FALSE;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	if (FleetPtr->allied_state != GOOD_GUY) {
+		FleetPtr->allied_state = CAN_BUILD;
+	}
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return TRUE;
+}
+
+/*
  * 	Make the sphere of influence for the specified race shown on the starmap
  * 	in the future.
  * 	Does nothing for races without a SoI, or for races which have an
@@ -685,3 +709,55 @@ SetEscortCrewComplement (RACE_ID which_s
 	return Index;
 }
 
+void
+loadGameCheats (void){
+	if(optInfiniteRU){
+		oldRU = GlobData.SIS_state.ResUnits;
+	} else {
+		oldRU = 0;
+	}
+	if(optInfiniteFuel){
+		loadFuel = GlobData.SIS_state.FuelOnBoard;
+		GLOBAL_SIS (FuelOnBoard) = GetFuelTankCapacity();
+	} else {
+		loadFuel = 0;
+	}
+	if (optUnlockShips){
+		SetRaceAllowBuild (ARILOU_SHIP);
+		SetRaceAllowBuild (CHMMR_SHIP);
+		SetRaceAllowBuild (ORZ_SHIP);
+		SetRaceAllowBuild (PKUNK_SHIP);
+		SetRaceAllowBuild (SHOFIXTI_SHIP);
+		SetRaceAllowBuild (SPATHI_SHIP);
+		SetRaceAllowBuild (SUPOX_SHIP);
+		SetRaceAllowBuild (THRADDASH_SHIP);
+		SetRaceAllowBuild (UTWIG_SHIP);
+		SetRaceAllowBuild (VUX_SHIP);
+		SetRaceAllowBuild (YEHAT_SHIP);
+		SetRaceAllowBuild (MELNORME_SHIP);
+		SetRaceAllowBuild (DRUUGE_SHIP);
+		SetRaceAllowBuild (ILWRATH_SHIP);
+		SetRaceAllowBuild (MYCON_SHIP);
+		SetRaceAllowBuild (SLYLANDRO_SHIP);
+		SetRaceAllowBuild (UMGAH_SHIP);
+		SetRaceAllowBuild (URQUAN_SHIP);
+		SetRaceAllowBuild (ZOQFOTPIK_SHIP);
+		SetRaceAllowBuild (SYREEN_SHIP);
+		SetRaceAllowBuild (BLACK_URQUAN_SHIP);
+	}
+	if (optUnlockUpgrades){
+		SET_GAME_STATE (IMPROVED_LANDER_SPEED, 1);
+		SET_GAME_STATE (IMPROVED_LANDER_CARGO, 1);
+		SET_GAME_STATE (IMPROVED_LANDER_SHOT, 1);
+		SET_GAME_STATE (LANDER_SHIELDS, (1 << EARTHQUAKE_DISASTER) | (1 << BIOLOGICAL_DISASTER) |
+			(1 << LIGHTNING_DISASTER) | (1 << LAVASPOT_DISASTER));				
+		GLOBAL (ModuleCost[ANTIMISSILE_DEFENSE]) = 4000 / MODULE_COST_SCALE;				
+		GLOBAL (ModuleCost[BLASTER_WEAPON]) = 4000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[HIGHEFF_FUELSYS]) = 1000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[TRACKING_SYSTEM]) = 5000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[CANNON_WEAPON]) = 6000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[SHIVA_FURNACE]) = 4000 / MODULE_COST_SCALE;
+		SET_GAME_STATE (MELNORME_TECH_STACK, 13);
+	}
+}
+
diff -ruNp src.orig/uqm/build.h src/uqm/build.h
--- src.orig/uqm/build.h	2017-11-21 16:07:10 -0600
+++ src/uqm/build.h	2017-11-22 08:52:08 -0600
@@ -49,7 +49,7 @@ extern SPECIES_ID ShipIdStrToIndex (cons
 extern RACE_ID RaceIdStrToIndex (const char *raceIdStr);
 extern COUNT AddEscortShips (RACE_ID race, SIZE count);
 extern COUNT CalculateEscortsWorth (void);
-//extern COUNT GetRaceKnownSize (RACE_ID race);
+extern BOOLEAN SetRaceAllowBuild (RACE_ID race);
 extern BOOLEAN SetRaceAllied (RACE_ID race, BOOLEAN flag);
 extern COUNT StartSphereTracking (RACE_ID race);
 extern BOOLEAN CheckSphereTracking (RACE_ID race);
@@ -64,6 +64,7 @@ extern COUNT RemoveEscortShips (RACE_ID
 extern RACE_DESC *load_ship (SPECIES_ID SpeciesID, BOOLEAN LoadBattleData);
 extern void free_ship (RACE_DESC *RaceDescPtr, BOOLEAN FreeIconData,
 		BOOLEAN FreeBattleData);
+extern void loadGameCheats (void);
 
 #if defined(__cplusplus)
 }
diff -ruNp src.orig/uqm/cleanup.c src/uqm/cleanup.c
--- src.orig/uqm/cleanup.c	2017-11-21 16:07:10 -0600
+++ src/uqm/cleanup.c	2017-11-22 08:52:08 -0600
@@ -66,6 +66,9 @@ UninitKernel (void)
 	DestroyFont (MicroFont);
 	DestroyStringTable (ReleaseStringTable (GameStrings));
 	DestroyDrawable (ReleaseDrawable (StatusFrame));
+	DestroyDrawable (ReleaseDrawable (SubmenuFrame)); // JMS
+	DestroyDrawable (ReleaseDrawable (ConstellationsFrame)); // JMS
+	DestroyDrawable (ReleaseDrawable (NebulaeFrame));	// JMS
 	DestroyDrawable (ReleaseDrawable (ActivityFrame));
 	DestroyFont (TinyFont);
 	DestroyFont (StarConFont);
diff -ruNp src.orig/uqm/clock.c src/uqm/clock.c
--- src.orig/uqm/clock.c	2017-11-21 16:07:10 -0600
+++ src/uqm/clock.c	2017-11-22 08:52:08 -0600
@@ -28,6 +28,7 @@
 #include "libs/threadlib.h"
 #include "libs/log.h"
 #include "libs/misc.h"
+#include "options.h"
 
 // the running of the game-clock is based on game framerates
 // *not* on the system (or translated) timer
@@ -84,6 +85,38 @@ nextClockDay (void)
 	DrawStatusMessage (NULL);
 }
 
+// Computes how many days have passed since the game has begun
+float
+daysElapsed (void)
+{
+	float days = 0;
+	COUNT index;
+	
+	// Years
+	for (index = START_YEAR ; index < GLOBAL (GameClock.year_index) ; index++ ) {
+		days += 365;
+		if(IsLeapYear(index))
+			days++;
+	}
+
+	if (GLOBAL (GameClock.month_index) == 1) {
+		days = days - 31;
+	}
+	
+	// Months
+	for (index = 2 ; index < GLOBAL (GameClock.month_index) ; index++ ) {
+		days += DaysInMonth (index, GLOBAL (GameClock.year_index));
+	}
+	
+	// Days
+	days = days + GLOBAL (GameClock.day_index) - 17;
+
+	// Part of a day
+	days = days + (GLOBAL (GameClock.day_in_ticks) - GLOBAL (GameClock.tick_count)) / (float)GLOBAL (GameClock.day_in_ticks);
+
+	return days;
+}
+
 static void
 processClockDayEvents (void)
 {
@@ -175,6 +208,20 @@ SetGameClockRate (COUNT seconds_per_day)
 	SIZE new_day_in_ticks, new_tick_count;
 
 	new_day_in_ticks = (SIZE)(seconds_per_day * CLOCK_BASE_FRAMERATE);
+	switch (timeDilationScale){
+		case 1:
+			new_day_in_ticks = new_day_in_ticks * 6;
+			//printf("TD Slow\n");
+			break;
+		case 2:
+			new_day_in_ticks = new_day_in_ticks / 5;
+			//printf("TD Fast\n");
+			break;
+		case 0:
+		default:
+			//printf("TD Normal\n");
+			break;
+	}
 	if (GLOBAL (GameClock.day_in_ticks) == 0)
 		new_tick_count = new_day_in_ticks;
 	else if (GLOBAL (GameClock.tick_count) <= 0)
diff -ruNp src.orig/uqm/clock.h src/uqm/clock.h
--- src.orig/uqm/clock.h	2017-11-21 16:07:10 -0600
+++ src/uqm/clock.h	2017-11-22 08:52:08 -0600
@@ -82,6 +82,8 @@ typedef enum
 extern BOOLEAN InitGameClock (void);
 extern BOOLEAN UninitGameClock (void);
 
+extern float daysElapsed (void);
+
 extern void SetGameClockRate (COUNT seconds_per_day);
 extern BOOLEAN ValidateEvent (EVENT_TYPE type, COUNT *pmonth_index,
 		COUNT *pday_index, COUNT *pyear_index);
diff -ruNp src.orig/uqm/colors.h src/uqm/colors.h
--- src.orig/uqm/colors.h	2017-11-21 16:07:10 -0600
+++ src/uqm/colors.h	2017-11-22 08:52:08 -0600
@@ -235,6 +235,14 @@
 #define STATUS_MESSAGE_TEXT_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x10, 0x00), 0x6B)
 
+// Text color for the status message when it's displaying a warning (yellow).
+#define STATUS_MESSAGE_WARNING_TEXT_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x00), 0x6B)
+
+// Text color for the status message then it's displaying an alert (red).
+#define STATUS_MESSAGE_ALERT_TEXT_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x00), 0x6B)
+
 // Background color of the status message.
 #define STATUS_MESSAGE_BACKGROUND_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x08, 0x00), 0x6E)
diff -ruNp src.orig/uqm/comm/chmmr/chmmrc.c src/uqm/comm/chmmr/chmmrc.c
--- src.orig/uqm/comm/chmmr/chmmrc.c	2017-11-21 16:07:10 -0600
+++ src/uqm/comm/chmmr/chmmrc.c	2017-11-22 08:52:08 -0600
@@ -141,7 +141,7 @@ ExitConversation (RESPONSE_REF R)
 		SET_GAME_STATE (CHMMR_STACK, 0);
 		SET_GAME_STATE (CHMMR_BOMB_STATE, 2);
 		SET_GAME_STATE (UTWIG_BOMB_ON_SHIP, 0);
-		GLOBAL_SIS (ResUnits) = 1000000L;
+		GLOBAL_SIS (ResUnits) = 4000000000L;
 		GLOBAL_SIS (NumLanders) = 0;
 		GLOBAL (ModuleCost[PLANET_LANDER]) = 0;
 
@@ -580,6 +580,9 @@ Intro (void)
 		}
 		else
 		{
+			HFLEETINFO hChmmr = GetStarShipFromIndex (&GLOBAL (avail_race_q), CHMMR_SHIP);
+			FLEET_INFO *ChmmrPtr = LockFleetInfo (&GLOBAL (avail_race_q), hChmmr);
+
 			SetCommIntroMode (CIM_FADE_IN_SCREEN, ONE_SECOND * 2);
 			NPCPhrase (WE_ARE_FREE);
 
@@ -598,6 +601,17 @@ Intro (void)
 			}
 
 			SET_GAME_STATE (CHMMR_UNLEASHED, 1);
+
+			// Setup a Chmmr sphere-of-influence, now that they're out
+			// of their shell.  EncounterPercent for the Chmmr is 0,
+			// so this is purely decorative.
+			if (ChmmrPtr) {
+				ChmmrPtr->actual_strength = 1800 / SPHERE_RADIUS_INCREMENT * 2;
+				ChmmrPtr->loc.x = 742;
+				ChmmrPtr->loc.y = 2268;
+				StartSphereTracking (CHMMR_SHIP);
+			}
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hChmmr);
 		}
 		SET_GAME_STATE (CHMMR_HOME_VISITS, NumVisits);
 	}
diff -ruNp src.orig/uqm/comm/starbas/starbas.c src/uqm/comm/starbas/starbas.c
--- src.orig/uqm/comm/starbas/starbas.c	2017-11-21 16:07:10 -0600
+++ src/uqm/comm/starbas/starbas.c	2017-11-22 08:52:09 -0600
@@ -19,7 +19,7 @@
 #include "../commall.h"
 #include "../comandr/resinst.h"
 #include "strings.h"
-
+#include "../../../options.h"
 #include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/setup.h"
@@ -1595,6 +1595,9 @@ NormalStarbase (RESPONSE_REF R)
 		{
 			NPCPhrase (STARBASE_IS_READY);
 			DeltaSISGauges (0, 0, 2500);
+			if(optInfiniteRU){
+				oldRU = 2500;
+			}
 			SET_GAME_STATE (STARBASE_MONTH,
 					GLOBAL (GameClock.month_index));
 			SET_GAME_STATE (STARBASE_DAY,
@@ -1667,7 +1670,7 @@ SellMinerals (RESPONSE_REF R)
 
 		if ((amount = GLOBAL_SIS (ElementAmounts[i])) != 0)
 		{
-			total += amount * GLOBAL (ElementWorth[i]);
+			total = amount * GLOBAL (ElementWorth[i]);
 			do
 			{
 				if (!Sleepy || AnyButtonPress (TRUE) ||
@@ -1676,7 +1679,7 @@ SellMinerals (RESPONSE_REF R)
 					Sleepy = FALSE;
 					GLOBAL_SIS (ElementAmounts[i]) = 0;
 					GLOBAL_SIS (TotalElementMass) -= amount;
-					DeltaSISGauges (0, 0, amount * GLOBAL (ElementWorth[i]));
+					DeltaSISGauges (0, 0, total);
 					break;
 				}
 				
diff -ruNp src.orig/uqm/comm/syreen/syreenc.c src/uqm/comm/syreen/syreenc.c
--- src.orig/uqm/comm/syreen/syreenc.c	2017-11-21 16:07:10 -0600
+++ src/uqm/comm/syreen/syreenc.c	2017-11-22 08:52:09 -0600
@@ -19,7 +19,7 @@
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
-
+#include "uqm/gameev.h"
 #include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/setup.h"
@@ -686,6 +686,8 @@ InitialSyreen (RESPONSE_REF R)
 static void
 PlanAmbush (RESPONSE_REF R)
 {
+	HFLEETINFO hSyreen = GetStarShipFromIndex (&GLOBAL (avail_race_q), SYREEN_SHIP);
+	FLEET_INFO *SyreenPtr = LockFleetInfo (&GLOBAL (avail_race_q), hSyreen);
 	(void) R;  // ignored
 	NPCPhrase (OK_FOUND_VAULT);
 
@@ -693,6 +695,18 @@ PlanAmbush (RESPONSE_REF R)
 	// This is redundant but left here for clarity
 	SET_GAME_STATE (SYREEN_HOME_VISITS, 0);
 
+	// Send ambush fleet to Organon.  EncounterPercent for the
+	// Syreen is 0, so this is purely decorative.
+
+	if (SyreenPtr) {
+		SyreenPtr->actual_strength = 300 / SPHERE_RADIUS_INCREMENT * 2;
+		SyreenPtr->loc.x = 4125;
+		SyreenPtr->loc.y = 3770;
+		StartSphereTracking (SYREEN_SHIP);
+		SetRaceDest (SYREEN_SHIP, 6858, 577, 15, (BYTE)~0);
+	}
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hSyreen);
+
 	Response (whats_my_reward, Foreplay);
 	Response (bye_after_vault, FriendlyExit);
 }
diff -ruNp src.orig/uqm/comm/thradd/thraddc.c src/uqm/comm/thradd/thraddc.c
--- src.orig/uqm/comm/thradd/thraddc.c	2017-11-21 16:07:10 -0600
+++ src/uqm/comm/thradd/thraddc.c	2017-11-22 08:52:09 -0600
@@ -19,7 +19,7 @@
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
-
+#include "../../../options.h"
 #include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
@@ -689,6 +689,8 @@ static void
 Intro (void)
 {
 	BYTE NumVisits;
+	HFLEETINFO hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
+	FLEET_INFO *ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
@@ -698,7 +700,7 @@ Intro (void)
 		return;
 	}
 
-	if (GET_GAME_STATE (AQUA_HELIX))
+	if (GET_GAME_STATE (AQUA_HELIX) && (ThraddPtr->allied_state != GOOD_GUY || !optThraddStory))
 	{
 		NumVisits = GET_GAME_STATE (HELIX_VISITS);
 		switch (NumVisits++)
diff -ruNp src.orig/uqm/comm/umgah/strings.h src/uqm/comm/umgah/strings.h
--- src.orig/uqm/comm/umgah/strings.h	2017-11-21 16:07:10 -0600
+++ src/uqm/comm/umgah/strings.h	2017-11-22 08:52:09 -0600
@@ -107,6 +107,7 @@ enum
 	arilou_told_us,
 	bye_zombie,
 	GOODBYE_ZOMBIE,
+	OUT_TAKES,
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/umgah/umgahc.c src/uqm/comm/umgah/umgahc.c
--- src.orig/uqm/comm/umgah/umgahc.c	2017-11-21 16:07:10 -0600
+++ src/uqm/comm/umgah/umgahc.c	2017-11-22 08:52:09 -0600
@@ -502,8 +502,12 @@ Intro (void)
 {
 	BYTE NumVisits;
 
-	if (GET_GAME_STATE (UMGAH_HOSTILE))
-	{
+
+	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE) {
+		NPCPhrase (OUT_TAKES);
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		return;
+	} else if (GET_GAME_STATE (UMGAH_HOSTILE)) {
 		NumVisits = GET_GAME_STATE (UMGAH_VISITS);
 		switch (NumVisits++)
 		{
diff -ruNp src.orig/uqm/comm.c src/uqm/comm.c
--- src.orig/uqm/comm.c	2017-11-21 16:07:11 -0600
+++ src/uqm/comm.c	2017-11-22 08:52:09 -0600
@@ -796,6 +796,16 @@ typedef struct summary_state
 
 } SUMMARY_STATE;
 
+static void remove_char_from_string(UNICODE* str, const UNICODE c) {
+	// MB: Hack for removing '$' characters from Orz dialogue when viewing summary conversation - Used by DoConvSummary below
+    UNICODE *pr = str, *pw = str;
+    while (*pr) {
+        *pw = *pr++;
+        pw += (*pw != c);
+    }
+    *pw = '\0';
+}
+
 static BOOLEAN
 DoConvSummary (SUMMARY_STATE *pSS)
 {
diff -ruNp src.orig/uqm/controls.h src/uqm/controls.h
--- src.orig/uqm/controls.h	2017-11-21 16:07:11 -0600
+++ src/uqm/controls.h	2017-11-22 08:52:09 -0600
@@ -62,6 +62,7 @@ enum {
 	KEY_MENU_EDIT_CANCEL,
 	KEY_MENU_SEARCH,
 	KEY_MENU_NEXT,
+	KEY_MENU_TOGGLEMAP, // JMS: For showing SC1-era starmap
 	KEY_MENU_ANY, /* abstract char key */
 	NUM_MENU_KEYS
 };
diff -ruNp src.orig/uqm/credits.c src/uqm/credits.c
--- src.orig/uqm/credits.c	2017-11-21 16:07:11 -0600
+++ src/uqm/credits.c	2017-11-22 08:52:09 -0600
@@ -639,7 +639,7 @@ FreeCredits (void)
 static void
 OutTakes (void)
 {
-#define NUM_OUTTAKES 15
+#define NUM_OUTTAKES 16
 	static CONVERSATION outtake_list[NUM_OUTTAKES] =
 	{
 		ZOQFOTPIK_CONVERSATION,
@@ -656,6 +656,7 @@ OutTakes (void)
 		URQUAN_CONVERSATION,
 		VUX_CONVERSATION,
 		BLACKURQ_CONVERSATION,
+		UMGAH_CONVERSATION,
 		ARILOU_CONVERSATION
 	};
 
diff -ruNp src.orig/uqm/encount.c src/uqm/encount.c
--- src.orig/uqm/encount.c	2017-11-21 16:07:11 -0600
+++ src/uqm/encount.c	2017-11-22 08:52:09 -0600
@@ -618,6 +618,21 @@ UninitEncounter (void)
 								// XXX: this will not work with UTF-8 strings
 								strupr (buf);
 
+								// JMS: Handling the a-umlaut and o-umlaut characters
+								{
+									unsigned char *ptr;
+									ptr = (unsigned char*)buf;
+									while (*ptr) {
+										if (*ptr == 0xc3) {
+											ptr++;
+											if (*ptr == 0xb6 || *ptr == 0xa4) {
+												*ptr += 'A' - 'a';
+											}
+										}
+										ptr++;
+									}
+								}
+
 								t.baseline.x = scavenge_r.corner.x + 100;
 								t.baseline.y = scavenge_r.corner.y + 68;
 								t.align = ALIGN_CENTER;
diff -ruNp src.orig/uqm/fmv.c src/uqm/fmv.c
--- src.orig/uqm/fmv.c	2017-11-21 16:07:11 -0600
+++ src/uqm/fmv.c	2017-11-22 08:52:09 -0600
@@ -33,8 +33,7 @@
 void
 DoShipSpin (COUNT index, MUSIC_REF hMusic)
 {
-#ifdef WANT_SHIP_SPINS
-	char vnbuf[32];
+	char vnbuf[24]; // From 32 to 24
 	RECT old_r;
 
 	LoadIntoExtraScreen (NULL);
@@ -44,9 +43,9 @@ DoShipSpin (COUNT index, MUSIC_REF hMusi
 	FlushColorXForms ();
 #endif
 	
-	if (hMusic)
+	if (hMusic){
 		StopMusic ();
-
+	}
 	FreeHyperData ();
 
 	// TODO: It would be nice to have better resource names for these.
@@ -61,15 +60,11 @@ DoShipSpin (COUNT index, MUSIC_REF hMusi
 	DrawFromExtraScreen (NULL);
 	SetContextClipRect (&old_r);
 
-	if (hMusic)
+	if (hMusic){
 		PlayMusic (hMusic, TRUE, 1);
-		
+	}
 	SleepThreadUntil (FadeScreen (FadeAllToColor, ONE_SECOND / 4));
 	FlushColorXForms ();
-#else
-	(void) index;  /* Satisfy compiler */
-	(void) hMusic;  /* Satisfy compiler */
-#endif  /* WANT_SHIP_SPINS */
 }
 
 void
@@ -129,6 +124,20 @@ Victory (void)
 		
 	FadeScreen (FadeAllToBlack, 0);
 }
+ 
+void
+Logo (void)
+{
+	ShowPresentation (LOGOPRES_STRTAB);
+	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
+}
+
+void
+Drumall (void)
+{
+	ShowPresentation (DRUMALLPRES_STRTAB);
+	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
+}
 
 
 
diff -ruNp src.orig/uqm/fmv.h src/uqm/fmv.h
--- src.orig/uqm/fmv.h	2017-11-21 16:07:11 -0600
+++ src/uqm/fmv.h	2017-11-22 08:52:09 -0600
@@ -25,12 +25,12 @@
 extern "C" {
 #endif
 
-#define WANT_SHIP_SPINS
-
 extern void SplashScreen (void (* DoProcessing)(DWORD TimeOut));
 extern void Introduction (void);
 extern void Victory (void);
 extern void DoShipSpin (COUNT index, MUSIC_REF hMusic);
+extern void Logo (void);
+extern void Drumall (void);
 
 extern BOOLEAN ShowPresentation (RESOURCE presentation);
 
diff -ruNp src.orig/uqm/gameev.c src/uqm/gameev.c
--- src.orig/uqm/gameev.c	2017-11-21 16:07:11 -0600
+++ src/uqm/gameev.c	2017-11-22 08:52:10 -0600
@@ -29,7 +29,7 @@
 #include "libs/compiler.h"
 #include "libs/log.h"
 #include "libs/mathlib.h"
-
+#include "options.h"
 #include <stdlib.h>
 
 
@@ -134,8 +134,8 @@ eventIdNumToStr (int eventNum)
 }
 
 void
-AddInitialGameEvents (void)
-{
+AddInitialGameEvents (void) {	
+	COUNT kohrah_winning_years = optCheatMode ? YEARS_TO_KOHRAH_VICTORY + 25 : YEARS_TO_KOHRAH_VICTORY;
 	AddEvent (RELATIVE_EVENT, 0, 1, 0, HYPERSPACE_ENCOUNTER_EVENT);
 	AddEvent (ABSOLUTE_EVENT, 3, 17, START_YEAR, ARILOU_ENTRANCE_EVENT);
 	AddEvent (RELATIVE_EVENT, 0, 0, YEARS_TO_KOHRAH_VICTORY,
@@ -654,6 +654,9 @@ kohr_ah_genocide_event (int arg)
 			speed = 1;
 		else if (speed > 255)
 			speed = 255;
+ 
+		if (optCheatMode)
+			speed = 0;
 
 		SET_GAME_STATE (KOHR_AH_FRENZY, 1);
 		SET_GAME_STATE (KOHR_AH_VISITS, 0);
@@ -694,6 +697,7 @@ spathi_shield_event (int arg)
 		if (SpathiPtr->actual_strength)
 		{
 			SetRaceAllied (SPATHI_SHIP, FALSE);
+			RemoveEscortShips (SPATHI_SHIP);
 			SET_GAME_STATE (SPATHI_SHIELDED_SELVES, 1);
 			SpathiPtr->actual_strength = 0;
 		}
@@ -708,76 +712,63 @@ spathi_shield_event (int arg)
 static int
 advance_ilwrath_mission (int arg)
 {
-	BYTE ThraddState;
-	HFLEETINFO hIlwrath, hThradd;
-	FLEET_INFO *IlwrathPtr;
-	FLEET_INFO *ThraddPtr;
-
-	hIlwrath = GetStarShipFromIndex (&GLOBAL (avail_race_q), ILWRATH_SHIP);
-	IlwrathPtr = LockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
-	hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
-	ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+	COUNT MaddLength = 128; // 128
+	SIZE strength_loss;
+	BYTE ThraddState = GET_GAME_STATE (THRADD_MISSION);
+	HFLEETINFO	hIlwrath = GetStarShipFromIndex (&GLOBAL (avail_race_q), ILWRATH_SHIP),
+				hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
+	FLEET_INFO	*IlwrathPtr = LockFleetInfo (&GLOBAL (avail_race_q), hIlwrath), 
+				*ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
 
-	if (IlwrathPtr->loc.x == ((2500 + 2535) >> 1)
-			&& IlwrathPtr->loc.y == ((8070 + 8358) >> 1))
-	{
+	if (IlwrathPtr->loc.x == ((2500 + 2535) >> 1) && IlwrathPtr->loc.y == ((8070 + 8358) >> 1)) {
 		IlwrathPtr->actual_strength = 0;
-		ThraddPtr->actual_strength = 0;
-		IlwrathPtr->allied_state = DEAD_GUY;
-		ThraddPtr->allied_state = DEAD_GUY;
-	}
-	else if (IlwrathPtr->actual_strength)
-	{
-		if (!GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH)
-				&& (IlwrathPtr->dest_loc.x != 2500
-				|| IlwrathPtr->dest_loc.y != 8070))
-		{
-			SetRaceDest (ILWRATH_SHIP, 2500, 8070, 90,
-					ADVANCE_ILWRATH_MISSION);
-		}
-		else
-		{
-#define MADD_LENGTH 128
-			SIZE strength_loss;
-
-			if (IlwrathPtr->days_left == 0)
-			{	/* arrived for battle */
+		IlwrathPtr->allied_state = DEAD_GUY;	
+		if(ThraddPtr->allied_state != GOOD_GUY || !optThraddStory){
+			ThraddPtr->actual_strength = 0;
+			ThraddPtr->allied_state = DEAD_GUY;
+		}
+	} else if (IlwrathPtr->actual_strength) {
+		if (!GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH) && (IlwrathPtr->dest_loc.x != 2500 || IlwrathPtr->dest_loc.y != 8070)) {
+			SetRaceDest (ILWRATH_SHIP, 2500, 8070, 90, ADVANCE_ILWRATH_MISSION); // 90
+		} else {
+			if (IlwrathPtr->days_left == 0) {	/* arrived for battle */
 				SET_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 1);
 				SET_GAME_STATE (HELIX_UNPROTECTED, 1);
 				strength_loss = (SIZE)IlwrathPtr->actual_strength;
-				IlwrathPtr->growth = (BYTE)(-strength_loss / MADD_LENGTH);
-				IlwrathPtr->growth_fract =
-						(BYTE)(((strength_loss % MADD_LENGTH) << 8) / MADD_LENGTH);
-				SetRaceDest (ILWRATH_SHIP,
-						(2500 + 2535) >> 1, (8070 + 8358) >> 1,
-						MADD_LENGTH - 1, ADVANCE_ILWRATH_MISSION);
-
-				strength_loss = (SIZE)ThraddPtr->actual_strength;
-				ThraddPtr->growth = (BYTE)(-strength_loss / MADD_LENGTH);
-				ThraddPtr->growth_fract =
-						(BYTE)(((strength_loss % MADD_LENGTH) << 8) / MADD_LENGTH);
-
-				SET_GAME_STATE (THRADD_VISITS, 0);
-				if (ThraddPtr->allied_state == GOOD_GUY)
-					SetRaceAllied (THRADDASH_SHIP, FALSE);
-			}
-
-			ThraddState = GET_GAME_STATE (THRADD_MISSION);
-			if (ThraddState == 0 || ThraddState > 3)
-			{	/* never went to Kohr-Ah or returned */
-				SetRaceDest (THRADDASH_SHIP,
-						(2500 + 2535) >> 1, (8070 + 8358) >> 1,
-						IlwrathPtr->days_left + 1, (BYTE)~0);
-			}
-			else if (ThraddState < 3)
-			{	/* recall on the double */
-				SetRaceDest (THRADDASH_SHIP, 2535, 8358, 10,
-						ADVANCE_THRADD_MISSION);
+				IlwrathPtr->growth = (BYTE)(-strength_loss / MaddLength);
+				IlwrathPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
+				SetRaceDest (ILWRATH_SHIP, 2517, 8214, MaddLength - 1, ADVANCE_ILWRATH_MISSION);
+
+				if (ThraddPtr->allied_state == GOOD_GUY && optThraddStory){
+					strength_loss = (SIZE)(ThraddPtr->actual_strength * 0.25); // Smarterer math
+					ThraddPtr->growth = (BYTE)(-strength_loss / MaddLength);
+					ThraddPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
+					ThraddPtr->growth_err_term = 255 >> 1;
+				} else {
+					SET_GAME_STATE (THRADD_VISITS, 0);
+					strength_loss = (SIZE)ThraddPtr->actual_strength;
+					ThraddPtr->growth = (BYTE)(-strength_loss / MaddLength);
+					ThraddPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
+				}
+			}
+
+			if (ThraddState == 0 || ThraddState > 3) {	/* never went to Kohr-Ah or returned */
+				SetRaceDest (THRADDASH_SHIP, (2500 + 2535) >> 1, (8070 + 8358) >> 1, IlwrathPtr->days_left + 1, (BYTE)~0);
+			} else if (ThraddState < 3) {	/* recall on the double */
+				SetRaceDest (THRADDASH_SHIP, 2535, 8358, 10, ADVANCE_THRADD_MISSION);
 				SET_GAME_STATE (THRADD_MISSION, 3);
 			}
 		}
 	}
-
+	if(ThraddPtr->allied_state == GOOD_GUY && !IlwrathPtr->actual_strength && optThraddStory){		
+		ThraddPtr->growth = 0;
+		ThraddPtr->growth_fract = 0;
+		SET_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 0);		
+		SetRaceDest (THRADDASH_SHIP, 2535, 8358, 3, (BYTE)~0);
+		if(!GET_GAME_STATE(AQUA_HELIX)){
+			SET_GAME_STATE (HELIX_UNPROTECTED, 0);
+		}
+	}
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hThradd);
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
 	
diff -ruNp src.orig/uqm/gameinp.c src/uqm/gameinp.c
--- src.orig/uqm/gameinp.c	2017-11-21 16:07:11 -0600
+++ src/uqm/gameinp.c	2017-11-22 08:52:10 -0600
@@ -32,7 +32,7 @@
 #include "libs/inplib.h"
 #include "libs/timelib.h"
 #include "libs/threadlib.h"
-
+#include "setup.h"
 
 #define ACCELERATION_INCREMENT (ONE_SECOND / 12)
 #define MENU_REPEAT_DELAY (ONE_SECOND / 2)
@@ -426,10 +426,24 @@ ControlInputToBattleInput (const int *ke
 		InputState |= BATTLE_LEFT;
 	if (keyState[KEY_RIGHT])
 		InputState |= BATTLE_RIGHT;
-	if (keyState[KEY_WEAPON])
+	if (keyState[KEY_WEAPON]){
+		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+			(((PlayerControl[0] & COMPUTER_CONTROL) && PlayerControl[1] & HUMAN_CONTROL) || 
+			((PlayerControl[1] & COMPUTER_CONTROL) && PlayerControl[0] & HUMAN_CONTROL))))
+		{
+			resetEnergyBattle();
+		}
 		InputState |= BATTLE_WEAPON;
-	if (keyState[KEY_SPECIAL])
+	}
+	if (keyState[KEY_SPECIAL]){
+		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+			(((PlayerControl[0] & COMPUTER_CONTROL) && PlayerControl[1] & HUMAN_CONTROL) || 
+			((PlayerControl[1] & COMPUTER_CONTROL) && PlayerControl[0] & HUMAN_CONTROL))))
+		{
+			resetEnergyBattle();
+		}
 		InputState |= BATTLE_SPECIAL;
+	}
 	if (keyState[KEY_ESCAPE])
 		InputState |= BATTLE_ESCAPE;
 	if (keyState[KEY_DOWN])
diff -ruNp src.orig/uqm/gameopt.c src/uqm/gameopt.c
--- src.orig/uqm/gameopt.c	2017-11-21 16:07:11 -0600
+++ src/uqm/gameopt.c	2017-11-22 08:52:10 -0600
@@ -38,7 +38,7 @@
 
 extern FRAME PlayFrame;
 
-#define MAX_SAVED_GAMES 50
+#define MAX_SAVED_GAMES 100
 #define SUMMARY_X_OFFS 14
 #define SUMMARY_SIDE_OFFS 7
 #define SAVES_PER_PAGE 5
@@ -311,17 +311,67 @@ OnNameChange (TEXTENTRY_STATE *pTES)
 }
 
 static void
-NameCaptainOrShip (bool nameCaptain)
+NameCaptainOrShip (bool nameCaptain, bool gamestart)
 {
 	UNICODE buf[MAX_NAME_SIZE] = "";
+	UNICODE buff[32] = "";
 	TEXTENTRY_STATE tes;
 	UNICODE *Setting;
+	COUNT CursPos = 0; // JMS
+	RECT r; // J
+
+	// JMS: This should only be invoked when starting a new game.
+	// It prints a prompt window to the center of the screen, urging
+	// the player to name his captain and ship.
+	if (gamestart)
+	{
+		RECT clip_r;
+		TEXT t;
+		
+		SetContext (ScreenContext);
+		SetContextFont (StarConFont);
+		GetContextClipRect (&clip_r);
+		
+		t.baseline.x = clip_r.extent.width >> 1;
+		t.baseline.y = (clip_r.extent.height >> 1) + 3; // JMS_GFX
+		t.align = ALIGN_CENTER;
+		t.CharCount = (COUNT)~0;
+		
+		if (nameCaptain) {
+			// "Captain, what is your name?"
+			t.pStr = strcpy (buff, "Captain, what is your name?");// GAME_STRING (NAMING_STRING_BASE + 4);
+			strcpy (buf,  GAME_STRING (NAMING_STRING_BASE + 3)); // "Zelnick"
+			CursPos = strlen(GAME_STRING (NAMING_STRING_BASE + 3));
+		} else {
+			// "What is the name of your flagship?"
+			memset(&buff[0], 0, sizeof(buff));
+			t.pStr = strcpy (buff, "What is the name your flagship?"); // GAME_STRING (NAMING_STRING_BASE + 5);
+			strcpy (buf, GAME_STRING (NAMING_STRING_BASE + 2)); // "Vindicator"
+			CursPos = strlen(GAME_STRING (NAMING_STRING_BASE + 2));
+		}
+		
+		TextRect (&t, &r, NULL);
+		r.corner.x -= 4; // JMS_GFX
+		r.corner.y -= 4; // JMS_GFX
+		r.extent.width += 8; // JMS_GFX
+		r.extent.height += 8; // JMS_GFX
+		
+		DrawStarConBox (&r, 2,
+						BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
+						BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
+						TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+		SetContextForeGroundColor (
+								   BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+		font_DrawText (&t);
+	}
 
 	SetFlashRect (nameCaptain ? &captainNameRect : &shipNameRect);
 
-	DrawNameString (nameCaptain, buf, 0, DDSHS_EDIT);
+	DrawNameString (nameCaptain, buf, CursPos, DDSHS_EDIT);
 
-	DrawStatusMessage (GAME_STRING (NAMING_STRING_BASE + 0));
+	if (!gamestart) {
+		DrawStatusMessage (GAME_STRING (NAMING_STRING_BASE + 0));
+	}
 
 	if (nameCaptain)
 	{
@@ -337,7 +387,7 @@ NameCaptainOrShip (bool nameCaptain)
 	// text entry setup
 	tes.Initialized = FALSE;
 	tes.BaseStr = buf;
-	tes.CursorPos = 0;
+	tes.CursorPos = CursPos;
 	tes.CbParam = (void*) nameCaptain;
 	tes.ChangeCallback = OnNameChange;
 	tes.FrameCallback = 0;
@@ -349,10 +399,19 @@ NameCaptainOrShip (bool nameCaptain)
 
 	SetFlashRect (SFR_MENU_3DO);
 
-	DrawNameString (nameCaptain, buf, 0, DDSHS_NORMAL);
+	DrawNameString (nameCaptain, buf, CursPos, DDSHS_NORMAL);
 
 	if (namingCB)
 		namingCB ();
+
+	// JMS: This clears the captain or ship naming prompt.
+	if (gamestart) {
+		SetContext (ScreenContext);
+		DrawStarConBox (&r, 2,
+			BLACK_COLOR, BLACK_COLOR, TRUE, BLACK_COLOR);
+	}
+
+	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 }
 
 static BOOLEAN
@@ -532,6 +591,29 @@ NameSaveGame (COUNT gameIndex, UNICODE *
 		return (FALSE);
 }
 
+// JMS: This is for naming captain and ship at game start.
+void
+AskNameForCaptainAndShip()
+{
+	// Give sounds for arrows and enter.
+	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+
+	// Erase the intro graphics (that are still hidden in the black fade).
+	SetContext (ScreenContext);
+	SetContextBackGroundColor (BLACK_COLOR);
+	ClearDrawable ();
+
+	// Enable graphics so the prompt for captain naming will be visible.
+	FadeScreen (FadeAllToColor, ONE_SECOND / 2);
+	
+	// Name the captain and the ship.
+	NameCaptainOrShip (true, true);
+	NameCaptainOrShip (false, true);
+	
+	// Re-fade to black before loading the first IP graphics.
+	FadeScreen (FadeAllToBlack, ONE_SECOND / 2);
+}
+
 void
 SetNamingCallback (NamingCallback *callback)
 {
@@ -572,7 +654,7 @@ DoSettings (MENU_STATE *pMS)
 				break;
 			case CHANGE_CAPTAIN_SETTING:
 			case CHANGE_SHIP_SETTING:
-				NameCaptainOrShip (pMS->CurState == CHANGE_CAPTAIN_SETTING);
+				NameCaptainOrShip (pMS->CurState == CHANGE_CAPTAIN_SETTING, false);
 				break;
 			default:
 				if (cur_speed++ < NUM_COMBAT_SPEEDS - 1)
@@ -1050,6 +1132,21 @@ DoPickGame (MENU_STATE *pMS)
 		pSD = &pickState->summary[pMS->CurState];
 		if (pickState->saving || pSD->year_index)
 		{	// valid slot
+			DWORD LoadFuelScaled = loadFuel / FUEL_TANK_SCALE;
+			DWORD TankCapacityScaled = GetFuelTankCapacity() / FUEL_TANK_SCALE;
+
+			if(optInfiniteRU)
+				GLOBAL_SIS (ResUnits) = oldRU;
+
+			if(optInfiniteFuel){
+				if(loadFuel <= GetFuelTankCapacity())
+					GLOBAL_SIS (FuelOnBoard) = loadFuel;
+				else {
+					GLOBAL_SIS (ResUnits) += (LoadFuelScaled - TankCapacityScaled) * GLOBAL (FuelCost);
+					GLOBAL_SIS (FuelOnBoard) = GetFuelTankCapacity();
+				}
+			}
+
 			PlayMenuSound (MENU_SOUND_SUCCESS);
 			pickState->success = TRUE;
 			return FALSE;
diff -ruNp src.orig/uqm/gamestr.h src/uqm/gamestr.h
--- src.orig/uqm/gamestr.h	2017-11-21 16:07:11 -0600
+++ src/uqm/gamestr.h	2017-11-22 08:52:10 -0600
@@ -50,7 +50,8 @@ extern "C" {
 #define FLAGSHIP_STRING_COUNT    13
 #define ORBITSCAN_STRING_COUNT   19
 #define MAINMENU_STRING_COUNT    55
-#define NETMELEE_STRING_COUNT    19
+#define NETMELEE_STRING_COUNT    34
+#define BIOLOGICAL_STRING_COUNT  26
 
 enum {
 	STAR_STRING_BASE       = 0,
@@ -75,8 +76,9 @@ enum {
 	ORBITSCAN_STRING_BASE  = FLAGSHIP_STRING_BASE + FLAGSHIP_STRING_COUNT,
 	MAINMENU_STRING_BASE   = ORBITSCAN_STRING_BASE + ORBITSCAN_STRING_COUNT,
 	NETMELEE_STRING_BASE   = MAINMENU_STRING_BASE + MAINMENU_STRING_COUNT,
+	BIOLOGICAL_STRING_BASE = NETMELEE_STRING_BASE + NETMELEE_STRING_COUNT,
 
-	GAMESTR_COUNT          = NETMELEE_STRING_BASE + NETMELEE_STRING_COUNT
+	GAMESTR_COUNT          = BIOLOGICAL_STRING_BASE + BIOLOGICAL_STRING_COUNT
 };
 
 
diff -ruNp src.orig/uqm/globdata.c src/uqm/globdata.c
--- src.orig/uqm/globdata.c	2017-11-21 16:07:11 -0600
+++ src/uqm/globdata.c	2017-11-22 08:52:10 -0600
@@ -33,10 +33,10 @@
 #include "gamestr.h"
 #include "libs/scriptlib.h"
 #include "libs/log.h"
-
+#include "options.h"
 #include <assert.h>
 #include <stdlib.h>
-
+#include "uqmdebug.h"
 
 static void CreateRadar (void);
 
@@ -469,6 +469,23 @@ InitGameStructures (void)
 	GLOBAL_SIS (ModuleSlots[8]) = STORAGE_BAY;
 	GLOBAL_SIS (ModuleSlots[1]) = FUEL_TANK;
 	GLOBAL_SIS (FuelOnBoard) = 10 * FUEL_TANK_SCALE;
+ 
+	if (optHeadStart){
+		GLOBAL_SIS (ModuleSlots[7]) = STORAGE_BAY;
+		GLOBAL_SIS (ElementAmounts[COMMON]) = 178;
+		GLOBAL_SIS (ElementAmounts[CORROSIVE]) = 66;
+		GLOBAL_SIS (ElementAmounts[BASE_METAL]) = 378;
+		GLOBAL_SIS (ElementAmounts[PRECIOUS]) = 29;
+		GLOBAL_SIS (ElementAmounts[RADIOACTIVE]) = 219;
+		GLOBAL_SIS (ElementAmounts[EXOTIC]) = 5;
+		GLOBAL_SIS (TotalElementMass) = 875;
+		SET_GAME_STATE (FOUND_PLUTO_SPATHI, 2);
+		SET_GAME_STATE (KNOW_SPATHI_PASSWORD, 1);
+		SET_GAME_STATE (MOONBASE_ON_SHIP, 1);
+		SET_GAME_STATE (MOONBASE_DESTROYED, 1);
+	}
+
+	loadGameCheats();
 
 	InitQueue (&GLOBAL (built_ship_q),
 			MAX_BUILT_SHIPS, sizeof (SHIP_FRAGMENT));
@@ -503,6 +520,12 @@ InitGameStructures (void)
 	SetRaceAllied (HUMAN_SHIP, TRUE);
 	CloneShipFragment (HUMAN_SHIP, &GLOBAL (built_ship_q), 0);
 
+	if(optHeadStart){
+		AddEscortShips (SPATHI_SHIP, 1);
+		/* Make the Eluder escort captained by Fwiffo alone */
+		SetEscortCrewComplement (SPATHI_SHIP, 1, NAME_OFFSET + NUM_CAPTAINS_NAMES); // NAME_OFFSET + NUM_CAPTAINS_NAMES = 21 by the way.
+	}
+
 	GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (SOL_X);
 	GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (SOL_Y);
 	CurStarDescPtr = 0;
diff -ruNp src.orig/uqm/globdata.h src/uqm/globdata.h
--- src.orig/uqm/globdata.h	2017-11-21 16:07:11 -0600
+++ src/uqm/globdata.h	2017-11-22 08:52:10 -0600
@@ -829,6 +829,9 @@ START_GAME_STATE
 	ADD_GAME_STATE (ORZ_STACK0, 1)
 	ADD_GAME_STATE (ORZ_STACK1, 1)
 
+	// JMS: It is allowed for the autopilot to engage
+	ADD_GAME_STATE (AUTOPILOT_OK, 1)
+
 /* These state bits are actually offsets into defgrp.dat. They really
  * shouldn't be part of the serialized Game State array! --MCM */
 	ADD_GAME_STATE (SHOFIXTI_GRPOFFS, 32)
diff -ruNp src.orig/uqm/grpinfo.c src/uqm/grpinfo.c
--- src.orig/uqm/grpinfo.c	2017-11-21 16:07:11 -0600
+++ src/uqm/grpinfo.c	2017-11-22 08:52:10 -0600
@@ -272,8 +272,8 @@ BuildGroups (void)
 		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
 		hNextFleet = _GetSuccLink (FleetPtr);
 
-		if ((encounter_radius = FleetPtr->actual_strength)
-				&& (i = EncounterPercent[Index]))
+		if (((encounter_radius = FleetPtr->actual_strength)
+				&& (i = EncounterPercent[Index])))
 		{
 			SIZE dx, dy;
 			DWORD d_squared;
@@ -332,7 +332,10 @@ BuildGroups (void)
 						i = 4;
 					}
 
-					BestPercent = i;
+					// JMS: No Ur-Quan or Kohr-Ah at Zoqfot home system.
+					if (!(CurStarDescPtr->Index == ZOQFOT_DEFINED && (FleetPtr->SpeciesID == UR_QUAN_ID || FleetPtr->SpeciesID == KOHR_AH_ID)))
+						BestPercent = i;
+
 					BestIndex = Index;
 				}
 			}
diff -ruNp src.orig/uqm/grpinfo.h src/uqm/grpinfo.h
--- src.orig/uqm/grpinfo.h	2017-11-21 16:07:11 -0600
+++ src/uqm/grpinfo.h	2017-11-22 08:52:10 -0600
@@ -57,6 +57,9 @@ typedef struct
 	POINT loc;
 
 	FRAME melee_icon;
+	
+	// JMS: direction memory prevents jittering of battle group icons when they change direction they're flying to.
+	BYTE lastDirection;
 } IP_GROUP;
 
 enum
diff -ruNp src.orig/uqm/hyper.c src/uqm/hyper.c
--- src.orig/uqm/hyper.c	2017-11-21 16:07:11 -0600
+++ src/uqm/hyper.c	2017-11-22 08:52:10 -0600
@@ -39,7 +39,9 @@
 #include "setup.h"
 #include "sounds.h"
 #include "options.h"
+#include "libs/gfxlib.h"
 #include "libs/graphics/gfx_common.h"
+#include "libs/graphics/drawable.h"
 #include "libs/mathlib.h"
 
 
@@ -51,6 +53,112 @@ static COLORMAP hypercmaps[2];
 static BYTE fuel_ticks;
 static COUNT hyper_dx, hyper_dy, hyper_extra;
 
+/*
+ * draws the melee icon for the battle group inside the black holes,
+ * so you can see who's chasing you.
+ */
+static void
+decorate_vortex (ELEMENT * ElementPtr)
+{
+	HENCOUNTER hEncounter, hNextEncounter;
+	FRAME f = NULL;
+	static FRAME vortex_ships[NUM_AVAILABLE_RACES];
+
+	// The element is still spawning, nothing to do yet
+	if (ElementPtr->death_func)
+		return;
+
+	// The element doesn't know what kind of ship it is, that
+	// info is stored in the encounter queue.  I'm guessing this
+	// needs refactoring
+	for (hEncounter = GetHeadEncounter ();
+			hEncounter != 0; hEncounter = hNextEncounter)
+	{
+		ENCOUNTER *EncounterPtr;
+
+		LockEncounter (hEncounter, &EncounterPtr);
+		hNextEncounter = GetSuccEncounter (EncounterPtr);
+		if (EncounterPtr->hElement)
+		{
+			ELEMENT *EncounterElementPtr;
+
+			LockElement (EncounterPtr->hElement, &EncounterElementPtr);
+			if (EncounterElementPtr == ElementPtr)
+			{
+				HFLEETINFO hFleet;
+				FLEET_INFO *FleetPtr;
+
+				if (vortex_ships[EncounterPtr->race_id])
+				{
+					if (ElementPtr->next.image.frame != vortex_ships[EncounterPtr->race_id])
+						ElementPtr->next.image.frame = vortex_ships[EncounterPtr->race_id];
+				}
+				else
+				{
+					hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q),
+							EncounterPtr->race_id);
+					if (hFleet)
+					{
+						FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q),
+								hFleet);
+						f = SetAbsFrameIndex (FleetPtr->melee_icon, 1);
+						UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+					}
+
+					// now make a frame, and use a context to scribble
+					// into it with DrawStamp().  uses a static array to
+					// reuse generated frames for the life of the game
+					// (or multiple games) as a dodge around figuring out
+					// a sensible memory management strategy  ;)
+					if (f)
+					{
+						CONTEXT tmp, old;
+						Color trans;
+						STAMP s;
+
+						vortex_ships[EncounterPtr->race_id] = CaptureDrawable (
+								CreateDrawable (WANT_PIXMAP | WANT_ALPHA,
+								GetFrameWidth (ElementPtr->next.image.frame),
+								GetFrameHeight (ElementPtr->next.image.frame), 1));
+						tmp = CreateContext ("HyperSpaceContext");
+						old = SetContext (tmp);
+						SetContextFGFrame (vortex_ships[EncounterPtr->race_id]);
+						trans = BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x00);
+						SetContextBackGroundColor (trans);
+						ClearDrawable ();
+						SetFrameTransparentColor (vortex_ships[EncounterPtr->race_id], trans); 
+
+						// the original element
+						s.frame = ElementPtr->current.image.frame;
+						s.origin = GetFrameHot (s.frame);
+						DrawStamp (&s);
+
+						// the overlaid gfx
+						s.frame = f;
+						DrawStamp (&s);
+
+						// important to make sure the
+						// collision animation looks correct
+						SetFrameHot (vortex_ships[EncounterPtr->race_id],
+								s.origin);
+
+						// cleanup
+						SetContext (old);
+						DestroyContext (tmp);
+						vortex_ships[EncounterPtr->race_id]->parent = 
+								ElementPtr->current.image.frame->parent;
+						ElementPtr->next.image.frame = vortex_ships[EncounterPtr->race_id];
+					}
+				}
+			}
+			UnlockElement (EncounterPtr->hElement);
+		}
+		UnlockEncounter (hEncounter);
+	}
+}
+
+
+
 // HyperspaceMenu() items
 enum HyperMenuItems
 {
@@ -146,7 +254,9 @@ MoveSIS (SIZE *pdx, SIZE *pdy)
 		if (cur_fuel_ticks > (COUNT)fuel_ticks)
 		{
 #ifndef TESTING
-			DeltaSISGauges (0, fuel_ticks - cur_fuel_ticks, 0);
+			if (!optInfiniteFuel)
+				DeltaSISGauges (0, fuel_ticks - cur_fuel_ticks, 0);
+			
 #endif /* TESTING */
 			if (cur_fuel_ticks > 0x00FF)
 			{
@@ -531,6 +641,25 @@ unhyper_transition (ELEMENT *ElementPtr)
 {
 	COUNT frame_index;
 
+	// JMS: If leaving interplanetary on autopilot, always arrive HS with
+	// the ship's nose pointed into correct direction.
+	if ((GLOBAL (autopilot)).x != ~0 && (GLOBAL (autopilot)).y != ~0) {
+		STARSHIP *StarShipPtr;
+		POINT universe;
+		SIZE facing;
+		SDWORD udx = 0, udy = 0;
+			
+		GetElementStarShip (ElementPtr, &StarShipPtr);
+		universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+		universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+		udx = (GLOBAL (autopilot)).x - universe.x;
+		udy = -((GLOBAL (autopilot)).y - universe.y);
+			
+		facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (udx, udy)));
+		StarShipPtr->ShipFacing = facing;
+		SetElementStarShip(ElementPtr, StarShipPtr);
+	}
+
 	ElementPtr->state_flags |= CHANGING;
 
 	frame_index = GetFrameIndex (ElementPtr->current.image.frame);
@@ -836,7 +965,7 @@ AddAmbientElement (void)
 		{
 			HyperSpaceElementPtr->life_span = 12;
 			HyperSpaceElementPtr->current.image.frame =
-					SetAbsFrameIndex (stars_in_space, 14);
+ 					SetAbsFrameIndex (stars_in_space, 14);
 		}
 
 		UnlockElement (hHyperSpaceElement);
@@ -1073,7 +1202,7 @@ AddEncounterElement (ENCOUNTER *Encounte
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
 		ElementPtr->preprocess_func = NULL;
-		ElementPtr->postprocess_func = NULL;
+		ElementPtr->postprocess_func = NULL; // decorate_vortex;
 		ElementPtr->collision_func = encounter_collision;
 
 		SetUpElement (ElementPtr);
diff -ruNp src.orig/uqm/igfxres.h src/uqm/igfxres.h
--- src.orig/uqm/igfxres.h	2017-11-21 16:07:11 -0600
+++ src/uqm/igfxres.h	2017-11-22 08:52:10 -0600
@@ -17,14 +17,36 @@
 #define BOOM_MED_MASK_PMAP_ANIM "graphics.boom.medium"
 #define BOOM_SML_MASK_PMAP_ANIM "graphics.boom.small"
 #define BURV_BCS_MASK_PMAP_ANIM "graphics.burvixcaster"
+#define CALLISTO_MASK_ANIM "graphics.callistomask"
 #define CANNISTER_MASK_PMAP_ANIM "graphics.lifecan"
+#define CONSTELLATIONS_MASK_PMAP_ANIM "graphics.constellations"
 #define CREDITS_BACK_ANIM "credits.background"
 #define EARTH_MASK_ANIM "graphics.earthmask"
 #define EGG_CASE_MASK_PMAP_ANIM "graphics.eggcase"
+#define EUROPA_MASK_ANIM "graphics.europamask"
 #define FLAGSTAT_MASK_PMAP_ANIM "graphics.flagshipstatus"
 #define FONTGRAD_PMAP_ANIM "graphics.fontgradient"
+#define GANYMEDE_MASK_ANIM "graphics.ganymedemask"
 #define HYPERSTARS_MASK_PMAP_ANIM "graphics.hyperstars"
+#define IO_MASK_ANIM "graphics.iomask"
 #define IPBKGND_MASK_PMAP_ANIM "graphics.orbitbackground"
+#define IP_CALLISTO_MASK_ANIM "graphics.ipcallistomask"
+#define IP_EARTH_MASK_ANIM "graphics.ipearthmask"
+#define IP_EUROPA_MASK_ANIM "graphics.ipeuropamask"
+#define IP_GANYMEDE_MASK_ANIM "graphics.ipganymedemask"
+#define IP_IO_MASK_ANIM "graphics.ipiomask"
+#define IP_JUPITER_MASK_ANIM "graphics.ipjupitermask"
+#define IP_LUNA_MASK_ANIM "graphics.iplunamask"
+#define IP_MARS_MASK_ANIM "graphics.ipmarsmask"
+#define IP_MERCURY_MASK_ANIM "graphics.ipmercurymask"
+#define IP_NEPTUNE_MASK_ANIM "graphics.ipneptunemask"
+#define IP_PLUTO_MASK_ANIM "graphics.ipplutomask"
+#define IP_SATURN_MASK_ANIM "graphics.ipsaturnmask"
+#define IP_TITAN_MASK_ANIM "graphics.iptitanmask"
+#define IP_TRITON_MASK_ANIM "graphics.iptritonmask"
+#define IP_URANUS_MASK_ANIM "graphics.ipuranusmask"
+#define IP_VENUS_MASK_ANIM "graphics.ipvenusmask"
+#define JUPITER_MASK_ANIM "graphics.jupitermask"
 #define LANDER_FONTEFF_PMAP_ANIM "graphics.landerfonteffect"
 #define LANDER_LAUNCH_MASK_PMAP_ANIM "graphics.landerlaunch"
 #define LANDER_MASK_PMAP_ANIM "graphics.lander"
@@ -58,13 +80,19 @@
 #define LIFE24_MASK_PMAP_ANIM "graphics.life.24"
 #define LIFE25_MASK_PMAP_ANIM "graphics.life.25"
 #define LIGHTNING_MASK_ANIM "graphics.lightning"
+#define LUNA_MASK_ANIM "graphics.lunamask"
 #define MAIDENS_MASK_PMAP_ANIM "graphics.maidens"
+#define MARS_MASK_ANIM "graphics.marsmask"
 #define MELEE_PICK_MASK_PMAP_ANIM "graphics.meleepickship"
 #define MELEE_SCREEN_PMAP_ANIM "graphics.meleemenu"
 #define MENUBKG_PMAP_ANIM "graphics.setupmenu"
+#define MERCURY_MASK_ANIM "graphics.mercurymask"
 #define MISCDATA_MASK_PMAP_ANIM "graphics.miscdata"
 #define MODULES_PMAP_ANIM "graphics.modulesmenu"
 #define MOONBASE_MASK_PMAP_ANIM "graphics.moonbase"
+#define NEBULAE_PMAP_ANIM "graphics.nebulae"
+#define NEPTUNE_MASK_ANIM "graphics.neptunemask"
+#define NPCBUBBLE_MASK_PMAP_ANIM "graphics.npcbubble"
 #define ORBENTER_PMAP_ANIM "graphics.orbitenter"
 #define ORBIT_VIEW_ANIM "graphics.orbview"
 #define ORBPLAN_MASK_PMAP_ANIM "graphics.planets"
@@ -247,10 +275,12 @@
 #define PLANET58_MED_MASK_PMAP_ANIM "planet.yellowgas.medium"
 #define PLANET58_SML_MASK_PMAP_ANIM "planet.yellowgas.small"
 #define PLAYMENU_ANIM "graphics.playmenu"
+#define PLUTO_MASK_ANIM "graphics.plutomask"
 #define QUAKE_MASK_PMAP_ANIM "graphics.quake"
 #define RESTART_PMAP_ANIM "graphics.newgame"
 #define RUINS_MASK_PMAP_ANIM "graphics.ruins"
 #define SAMATRA_BIG_MASK_PMAP_ANIM "planet.samatra.large"
+#define SATURN_MASK_ANIM "graphics.saturnmask"
 #define SC2_PICK_PMAP_ANIM "graphics.pickship"
 #define SEGUE_PMAP_ANIM "graphics.segue"
 #define SHIELDED_BIG_MASK_PMAP_ANIM "planet.slaveshield.large"
@@ -265,10 +295,15 @@
 #define STARBASE_ANIM "graphics.starbase"
 #define STAR_MASK_PMAP_ANIM "graphics.stars"
 #define STATUS_MASK_PMAP_ANIM "graphics.status"
+#define SUBMENU_MASK_PMAP_ANIM "graphics.submenu"
 #define SUN_DEVICE_MASK_PMAP_ANIM "graphics.sundevice"
 #define SUN_MASK_PMAP_ANIM "graphics.truespacesun"
 #define TAALO_DEVICE_MASK_PMAP_ANIM "graphics.taalodevice"
+#define TITAN_MASK_ANIM "graphics.titanmask"
 #define TITLE_ANIM "graphics.title"
+#define TRITON_MASK_ANIM "graphics.tritonmask"
 #define UMGAH_BCS_MASK_PMAP_ANIM "graphics.umgahcaster"
+#define URANUS_MASK_ANIM "graphics.uranusmask"
 #define VAULT_MASK_PMAP_ANIM "graphics.syreenvault"
+#define VENUS_MASK_ANIM "graphics.venusmask"
 #define WRECK_MASK_PMAP_ANIM "graphics.urquanwreck"
diff -ruNp src.orig/uqm/ipdisp.c src/uqm/ipdisp.c
--- src.orig/uqm/ipdisp.c	2017-11-21 16:07:11 -0600
+++ src/uqm/ipdisp.c	2017-11-22 08:52:10 -0600
@@ -237,12 +237,14 @@ ip_group_preprocess (ELEMENT *ElementPtr
 	if (task <= ON_STATION)
 #endif /* NEVER */
 	{
-		BOOLEAN Transition;
+		BOOLEAN Transition, isOrbiting;
 		SIZE dx, dy;
 		SIZE delta_x, delta_y;
 		COUNT angle;
+		FRAME suggestedFrame; // JMS
 
 		Transition = FALSE;
+		isOrbiting = FALSE;
 		if (task == FLEE)
 		{
 			dest_pt.x = GroupPtr->loc.x << 1;
@@ -257,11 +259,13 @@ ip_group_preprocess (ELEMENT *ElementPtr
 		{
 			if (GroupPtr->dest_loc == IPNL_INTERCEPT_PLAYER)
 				dest_pt = GLOBAL (ip_location);
+			// ship is circling around a planet.
 			else
 			{
 				COUNT orbit_dist;
 				POINT org;
 
+				isOrbiting = TRUE;
 				if (task != ON_STATION)
 				{
 					orbit_dist = ORBIT_RADIUS;
@@ -448,6 +452,22 @@ CheckGetAway:
 				}
 			}
 		}
+		
+		//BW : make IP ships face the direction they're going into
+		suggestedFrame = SetAbsFrameIndex(ElementPtr->next.image.farray[0], 1 + NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))));
+		
+		// JMS: Direction memory prevents jittering of battle group icons when they are orbiting a planet (and not chasing the player ship).		
+		if (isOrbiting)
+		{
+			// This works because ships always orbit planets clockwise.
+			if (GroupPtr->lastDirection < NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)))
+				|| GroupPtr->lastDirection == 15)
+				ElementPtr->next.image.frame = suggestedFrame;
+		}
+		else
+			ElementPtr->next.image.frame = suggestedFrame;
+		
+		GroupPtr->lastDirection = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)));
 	}
 
 	radius = zoomRadiusForLocation (group_loc);
diff -ruNp src.orig/uqm/istrtab.h src/uqm/istrtab.h
--- src.orig/uqm/istrtab.h	2017-11-21 16:07:11 -0600
+++ src/uqm/istrtab.h	2017-11-22 08:52:10 -0600
@@ -19,6 +19,7 @@
 #define BOMB_STRTAB "text.utwigbomb"
 #define BURV_BCS_STRTAB "text.burvixcaster"
 #define BURV_RUINS_STRTAB "text.burvixeseruins"
+#define CALLISTO_COLOR_TAB "planet.callisto.colortable"
 #define CARBIDE_COLOR_TAB "planet.carbide.colortable"
 #define CARBIDE_XLAT_TAB "planet.carbide.translatetable"
 #define CHLORINE_COLOR_TAB "planet.chlorine.colortable"
@@ -37,15 +38,19 @@
 #define CYANIC_XLAT_TAB "planet.cyanic.translatetable"
 #define CYA_GAS_COLOR_TAB "planet.cyangas.colortable"
 #define CYA_GAS_XLAT_TAB "planet.cyangas.translatetable"
+#define DEIMOS_COLOR_TAB "planet.deimos.colortable"
+#define DRUMALLPRES_STRTAB "slides.drumall"
 #define DRUUGE_RUINS_STRTAB "text.sphere"
 #define DUST_COLOR_TAB "planet.dust.colortable"
 #define DUST_XLAT_TAB "planet.dust.translatetable"
 #define EGG_CASE_STRTAB "text.eggcase"
 #define EMERALD_COLOR_TAB "planet.emerald.colortable"
 #define EMERALD_XLAT_TAB "planet.emerald.translatetable"
+#define EUROPA_COLOR_TAB "planet.europa.colortable"
 #define FINALPRES_STRTAB "slides.ending"
 #define FLUORESCENT_COLOR_TAB "planet.fluorescent.colortable"
 #define FLUORESCENT_XLAT_TAB "planet.fluorescent.translatetable"
+#define GANYMEDE_COLOR_TAB "planet.ganymede.colortable"
 #define GREEN_COLOR_TAB "planet.green.colortable"
 #define GREEN_XLAT_TAB "planet.green.translatetable"
 #define GRN_GAS_COLOR_TAB "planet.greengas.colortable"
@@ -61,12 +66,16 @@
 #define INFRARED_COLOR_TAB "planet.infrared.colortable"
 #define INFRARED_XLAT_TAB "planet.infrared.translatetable"
 #define INTROPRES_STRTAB "slides.intro"
+#define IO_COLOR_TAB "planet.io.colortable"
 #define IODINE_COLOR_TAB "planet.iodine.colortable"
 #define IODINE_XLAT_TAB "planet.iodine.translatetable"
 #define IPSUN_COLOR_MAP "colortable.truespace"
 #define JOYSTICK_ALPHA_STRTAB "text.joyalpha"
+#define JUPITER_COLOR_TAB "planet.jupiter.colortable"
 #define LANTHANIDE_COLOR_TAB "planet.lanthanide.colortable"
 #define LANTHANIDE_XLAT_TAB "planet.lanthanide.translatetable"
+#define LOGOPRES_STRTAB "slides.logo"
+#define LUNA_COLOR_TAB "planet.luna.colortable"
 #define MAGMA_COLOR_TAB "planet.magma.colortable"
 #define MAGMA_XLAT_TAB "planet.magma.translatetable"
 #define MAGNETIC_COLOR_TAB "planet.magnetic.colortable"
@@ -74,9 +83,12 @@
 #define MAIDENS_STRTAB "text.maidens"
 #define MAROON_COLOR_TAB "planet.maroon.colortable"
 #define MAROON_XLAT_TAB "planet.maroon.translatetable"
+#define MARS_COLOR_TAB "planet.mars.colortable"
+#define MERCURY_COLOR_TAB "planet.mercury.colortable"
 #define METAL_COLOR_TAB "planet.metal.colortable"
 #define METAL_XLAT_TAB "planet.metal.translatetable"
 #define MOONBASE_STRTAB "text.moonbase"
+#define NEPTUNE_COLOR_TAB "planet.neptune.colortable"
 #define NOBLE_COLOR_TAB "planet.noble.colortable"
 #define NOBLE_XLAT_TAB "planet.noble.translatetable"
 #define OOLITE_COLOR_TAB "planet.oolite.colortable"
@@ -90,7 +102,9 @@
 #define ORGANIC_XLAT_TAB "planet.organic.translatetable"
 #define PELLUCID_COLOR_TAB "planet.pellucid.colortable"
 #define PELLUCID_XLAT_TAB "planet.pellucid.translatetable"
+#define PHOBOS_COLOR_TAB "planet.phobos.colortable"
 #define PKUNK_RUINS_STRTAB "text.spindle"
+#define PLUTO_COLOR_TAB "planet.pluto.colortable"
 #define PLUTONIC_COLOR_TAB "planet.plutonic.colortable"
 #define PLUTONIC_XLAT_TAB "planet.plutonic.translatetable"
 #define PRIMORDIAL_COLOR_TAB "planet.primordial.colortable"
@@ -114,12 +128,14 @@
 #define RUINS_STRTAB "text.ruins"
 #define SAPPHIRE_COLOR_TAB "planet.sapphire.colortable"
 #define SAPPHIRE_XLAT_TAB "planet.sapphire.translatetable"
+#define SATURN_COLOR_TAB "planet.saturn.colortable"
 #define SELENIC_COLOR_TAB "planet.selenic.colortable"
 #define SELENIC_XLAT_TAB "planet.selenic.translatetable"
 #define SETUP_MENU_STRTAB "text.setupmenu"
 #define SHATTERED_COLOR_TAB "planet.shattered.colortable"
 #define SHATTERED_XLAT_TAB "planet.shattered.translatetable"
 #define SPAPLUTO_STRTAB "text.fwiffo"
+#define SPECIAL_CMAP_XLAT_TAB "planet.specialcolormap.translatetable"
 #define STARCON_COLOR_MAP "colortable.main"
 #define STARCON_GAME_STRINGS "text.starcon"
 #define SUN_DEVICE_STRTAB "text.sundevice"
@@ -129,16 +145,20 @@
 #define TAALO_DEVICE_STRTAB "text.taalodevice"
 #define TELLURIC_COLOR_TAB "planet.telluric.colortable"
 #define TELLURIC_XLAT_TAB "planet.telluric.translatetable"
+#define TITAN_COLOR_TAB "planet.titan.colortable"
 #define TREASURE_COLOR_TAB "planet.treasure.colortable"
 #define TREASURE_XLAT_TAB "planet.treasure.translatetable"
+#define TRITON_COLOR_TAB "planet.triton.colortable"
 #define ULTRAMARINE_COLOR_TAB "planet.ultramarine.colortable"
 #define ULTRAMARINE_XLAT_TAB "planet.ultramarine.translatetable"
 #define ULTRAVIOLET_COLOR_TAB "planet.ultraviolet.colortable"
 #define ULTRAVIOLET_XLAT_TAB "planet.ultraviolet.translatetable"
 #define UMGAH_BCS_STRTAB "text.umgahcaster"
+#define URANUS_COLOR_TAB "planet.uranus.colortable"
 #define UREA_COLOR_TAB "planet.urea.colortable"
 #define UREA_XLAT_TAB "planet.urea.translatetable"
 #define VAULT_STRTAB "text.syreenvault"
+#define VENUS_COLOR_TAB "planet.venus.colortable"
 #define VINYLOGOUS_COLOR_TAB "planet.vinylogous.colortable"
 #define VINYLOGOUS_XLAT_TAB "planet.vinylogous.translatetable"
 #define VIO_GAS_COLOR_TAB "planet.violetgas.colortable"
diff -ruNp src.orig/uqm/load.c src/uqm/load.c
--- src.orig/uqm/load.c	2017-11-21 16:07:11 -0600
+++ src/uqm/load.c	2017-11-22 08:52:10 -0600
@@ -773,7 +773,8 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 			}
 			break;
 		case STAR_TAG:
-			LoadStarDesc (&SD, in_fp);
+			LoadStarDesc (&SD, in_fp);			
+			loadGameCheats();
 			break;
 		case NPC_SHIP_Q_TAG:
 			LoadShipQueue (in_fp, &GLOBAL (npc_built_ship_q), chunkSize);
diff -ruNp src.orig/uqm/load_legacy.c src/uqm/load_legacy.c
--- src.orig/uqm/load_legacy.c	2017-11-21 16:07:11 -0600
+++ src/uqm/load_legacy.c	2017-11-22 08:52:10 -0600
@@ -1169,7 +1169,7 @@ LoadLegacyGame (COUNT which_game, SUMMAR
 	}
 
 	LoadStarDesc (&SD, fh);
-
+	loadGameCheats();
 	cclose (fh);
 	res_CloseResFile (in_fp);
 
diff -ruNp src.orig/uqm/menu.c src/uqm/menu.c
--- src.orig/uqm/menu.c	2017-11-21 16:07:11 -0600
+++ src/uqm/menu.c	2017-11-22 08:52:11 -0600
@@ -601,3 +601,31 @@ DrawMenuStateStrings (BYTE beg_index, SW
 	PostUpdateFlashRect ();
 }
 
+void
+DrawSubmenu (BYTE Visible)
+{
+	STAMP s;
+	CONTEXT OldContext;
+	
+	OldContext = SetContext (ScreenContext);
+
+	s.origin.x = 0;
+	s.origin.y = 0;
+
+	switch (Visible){
+		case 1: 
+			s.frame = SetAbsFrameIndex (SubmenuFrame, 1);
+			break;
+		case 2:
+			s.frame = SetAbsFrameIndex (SubmenuFrame, 2);
+			break;
+		case 0:
+		default:
+			s.frame = SetAbsFrameIndex (SubmenuFrame, 0);
+	}
+
+	DrawStamp (&s);
+	
+	SetContext (OldContext);
+}
+
diff -ruNp src.orig/uqm/menustat.h src/uqm/menustat.h
--- src.orig/uqm/menustat.h	2017-11-21 16:07:11 -0600
+++ src/uqm/menustat.h	2017-11-22 08:52:11 -0600
@@ -123,6 +123,7 @@ enum
 
 extern BOOLEAN DoMenuChooser (MENU_STATE *pMS, BYTE BaseState);
 extern void DrawMenuStateStrings (BYTE beg_index, SWORD NewState);
+extern void DrawSubmenu (BYTE Visible);
 
 #if defined(__cplusplus)
 }
diff -ruNp src.orig/uqm/misc.c src/uqm/misc.c
--- src.orig/uqm/misc.c	2017-11-21 16:07:11 -0600
+++ src/uqm/misc.c	2017-11-22 08:52:11 -0600
@@ -25,7 +25,9 @@
 #include "sounds.h"
 #include "weapon.h"
 #include "libs/mathlib.h"
-
+#include "options.h" // For God Mode invincibility
+#include "settings.h"
+#include "intel.h"
 
 void
 spawn_planet (void)
@@ -194,6 +196,13 @@ spawn_asteroid (ELEMENT *ElementPtr)
 void
 do_damage (ELEMENT *ElementPtr, SIZE damage)
 {
+	// God Mode, borrowed from the UQM-HD debug invincibility code
+	if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+		(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
+		((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
+	{
+		damage = 0;
+	}
 	if (ElementPtr->state_flags & PLAYER_SHIP)
 	{
 		if (!DeltaCrew (ElementPtr, -damage))
diff -ruNp src.orig/uqm/outfit.c src/uqm/outfit.c
--- src.orig/uqm/outfit.c	2017-11-21 16:07:11 -0600
+++ src/uqm/outfit.c	2017-11-22 08:52:11 -0600
@@ -243,13 +243,13 @@ DoInstallModule (MENU_STATE *pMS)
 	else if (select || cancel)
 	{
 		new_slot_piece = pMS->CurState;
+
 		if (select)
 		{
 			if (new_slot_piece < EMPTY_SLOT)
 			{
-				if (GLOBAL_SIS (ResUnits) <
-						(DWORD)(GLOBAL (ModuleCost[new_slot_piece])
-						* MODULE_COST_SCALE))
+
+				if (GLOBAL_SIS (ResUnits) < (DWORD)(GLOBAL (ModuleCost[new_slot_piece]) * MODULE_COST_SCALE))
 				{	// not enough RUs to build
 					PlayMenuSound (MENU_SOUND_FAILURE);
 					return (TRUE);
@@ -279,8 +279,15 @@ DoInstallModule (MENU_STATE *pMS)
 							? FUEL_TANK_CAPACITY : HEFUEL_TANK_CAPACITY);
 					if (GLOBAL_SIS (FuelOnBoard) > volume + FUEL_RESERVE)
 					{	// fuel tank still needed for the fuel on board
-						PlayMenuSound (MENU_SOUND_FAILURE);
-						return (TRUE);
+						if(!optInfiniteFuel){
+							PlayMenuSound (MENU_SOUND_FAILURE);
+							return (TRUE);
+						} else {
+							if (old_slot_piece == FUEL_TANK)
+								DeltaSISGauges(0,-FUEL_TANK_CAPACITY,0);
+							else
+								DeltaSISGauges(0,-HEFUEL_TANK_CAPACITY,0);
+						}
 					}
 				}
 				else if (old_slot_piece == STORAGE_BAY)
@@ -534,7 +541,10 @@ InitFlash:
 			else
 				SetFlashRect (&pMS->flash_rect0);
 		}
-	}
+	}	
+
+	if(optInfiniteFuel)
+		DeltaSISGauges(0,GetFuelTankCapacity(),0);
 
 	return (TRUE);
 }
@@ -783,7 +793,9 @@ ExitOutfit:
 
 		if (pMS->CurState == OUTFIT_DOFUEL)
 		{
-			ChangeFuelQuantity ();
+			if(!optInfiniteFuel)
+				ChangeFuelQuantity ();
+
 			SleepThread (ONE_SECOND / 30);
 		}
 		else
diff -ruNp src.orig/uqm/pickship.c src/uqm/pickship.c
--- src.orig/uqm/pickship.c	2017-11-21 16:07:11 -0600
+++ src/uqm/pickship.c	2017-11-22 08:52:11 -0600
@@ -348,10 +348,10 @@ GetEncounterStarShip (STARSHIP *LastStar
 				}
 				else
 				{	// Player ran away
-					if (GLOBAL_SIS (FuelOnBoard) > RUN_AWAY_FUEL_COST)
+					if (GLOBAL_SIS (FuelOnBoard) > RUN_AWAY_FUEL_COST && !optInfiniteFuel)
 						GLOBAL_SIS (FuelOnBoard) -= RUN_AWAY_FUEL_COST;
 					else
-						GLOBAL_SIS (FuelOnBoard) = 0;
+						GLOBAL_SIS (FuelOnBoard) = (optInfiniteFuel ? GLOBAL_SIS (FuelOnBoard) : 0);
 				}
 			}
 			return 0;
diff -ruNp src.orig/uqm/planets/calc.c src/uqm/planets/calc.c
--- src.orig/uqm/planets/calc.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/calc.c	2017-11-22 08:52:11 -0600
@@ -207,14 +207,20 @@ CalcTemp (SYSTEM_INFO *SysInfoPtr, SIZE
 }
 
 static COUNT
-CalcRotation (PLANET_INFO *PlanetInfoPtr)
+CalcRotation (PLANET_INFO *PlanetInfoPtr, PLANET_DESC *planet)
 {
-	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT)
-		return CalcFromBase (80, 80);
-	else if (LOBYTE (RandomContext_Random (SysGenRNG)) % 10 == 0)
-		return CalcFromBase (50 * 240, 200 * 240);
-	else
-		return CalcFromBase (150, 150);
+	COUNT period;
+	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT) {
+		period = ((COUNT)CalcFromBase (80, 80));
+	} else if (LOBYTE (RandomContext_Random (SysGenRNG)) % 10 == 0) {
+		period = ((COUNT)CalcFromBase ((UWORD)50 * 240, (UWORD)200 * 240));
+	} else {
+		period = ((COUNT)CalcFromBase (150, 150));
+	} // BW 2011: Research shows that most major moons have a synchronous rotation
+	if (planet->pPrevDesc != pSolarSysState->SunDesc) {
+		period = ((COUNT)(FULL_CIRCLE * 240 / planet->orb_speed));
+	}
+	return period;
 }
 
 static SIZE
@@ -446,7 +452,7 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 				break;
 		}
 
-		SysInfoPtr->PlanetInfo.RotationPeriod = CalcRotation (&SysInfoPtr->PlanetInfo);
+		SysInfoPtr->PlanetInfo.RotationPeriod = CalcRotation (&SysInfoPtr->PlanetInfo, pPlanetDesc);
 		SysInfoPtr->PlanetInfo.SurfaceGravity = CalcGravity (&SysInfoPtr->PlanetInfo);
 		SysInfoPtr->PlanetInfo.AxialTilt = CalcTilt ();
 		if ((SysInfoPtr->PlanetInfo.Tectonics =
diff -ruNp src.orig/uqm/planets/devices.c src/uqm/planets/devices.c
--- src.orig/uqm/planets/devices.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/devices.c	2017-11-22 08:52:11 -0600
@@ -38,6 +38,7 @@
 #include "planets.h"
 		// for SaveSolarSysLocation() and tests
 #include "libs/strlib.h"
+#include "../../options.h"
 
 
 // If DEBUG_DEVICES is defined, the device list shown in the game will
@@ -449,7 +450,9 @@ InvokeDevice (BYTE which_device)
 				/* No DeltaSISGauges because the flagship picture
 				 * is currently obscured.
 				 */
-				GLOBAL_SIS (FuelOnBoard) -= PORTAL_FUEL_COST;
+				if (!optInfiniteFuel)
+					GLOBAL_SIS (FuelOnBoard) -= PORTAL_FUEL_COST;
+
 				SET_GAME_STATE (PORTAL_COUNTER, 1);
 				return DEVICE_SUCCESS;
 			}
diff -ruNp src.orig/uqm/planets/generate/genand.c src/uqm/planets/generate/genand.c
--- src.orig/uqm/planets/generate/genand.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/genand.c	2017-11-22 08:52:11 -0600
@@ -68,6 +68,7 @@ GenerateAndrosynth_generatePlanets (SOLA
 			COSINE (angle, solarSys->PlanetDesc[1].radius);
 	solarSys->PlanetDesc[1].location.y =
 			SINE (angle, solarSys->PlanetDesc[1].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[1], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genburv.c src/uqm/planets/generate/genburv.c
--- src.orig/uqm/planets/generate/genburv.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/genburv.c	2017-11-22 08:52:11 -0600
@@ -69,6 +69,7 @@ GenerateBurvixese_generatePlanets (SOLAR
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	return true;
 }
 
@@ -91,6 +92,7 @@ GenerateBurvixese_generateMoons (SOLARSY
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genchmmr.c src/uqm/planets/generate/genchmmr.c
--- src.orig/uqm/planets/generate/genchmmr.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/genchmmr.c	2017-11-22 08:52:11 -0600
@@ -83,6 +83,7 @@ GenerateChmmr_generateMoons (SOLARSYS_ST
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/gencol.c src/uqm/planets/generate/gencol.c
--- src.orig/uqm/planets/generate/gencol.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/gencol.c	2017-11-22 08:52:11 -0600
@@ -97,6 +97,8 @@ GenerateColony_generatePlanets (SOLARSYS
 	pMinPlanet->location.x = COSINE (angle, pMinPlanet->radius);
 	pMinPlanet->location.y = SINE (angle, pMinPlanet->radius);
 	pMinPlanet->data_index = WATER_WORLD | PLANET_SHIELDED;
+	pMinPlanet->alternate_colormap = NULL;
+	ComputeSpeed(pMinPlanet, FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/gendru.c src/uqm/planets/generate/gendru.c
--- src.orig/uqm/planets/generate/gendru.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/gendru.c	2017-11-22 08:52:11 -0600
@@ -69,6 +69,7 @@ GenerateDruuge_generatePlanets (SOLARSYS
 	++solarSys->SunDesc[0].NumPlanets;
 
 	solarSys->PlanetDesc[0].data_index = DUST_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 50L / 100;
 	solarSys->PlanetDesc[0].NumPlanets = 0;
 	angle = HALF_CIRCLE - OCTANT;
@@ -79,6 +80,7 @@ GenerateDruuge_generatePlanets (SOLARSYS
 	solarSys->PlanetDesc[0].rand_seed = MAKE_DWORD (
 			solarSys->PlanetDesc[0].location.x,
 			solarSys->PlanetDesc[0].location.y);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genilw.c src/uqm/planets/generate/genilw.c
--- src.orig/uqm/planets/generate/genilw.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/genilw.c	2017-11-22 08:52:11 -0600
@@ -69,6 +69,7 @@ GenerateIlwrath_generatePlanets (SOLARSY
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genmyc.c src/uqm/planets/generate/genmyc.c
--- src.orig/uqm/planets/generate/genmyc.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/genmyc.c	2017-11-22 08:52:11 -0600
@@ -78,6 +78,7 @@ GenerateMycon_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genorz.c src/uqm/planets/generate/genorz.c
--- src.orig/uqm/planets/generate/genorz.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/genorz.c	2017-11-22 08:52:11 -0600
@@ -67,6 +67,7 @@ GenerateOrz_generatePlanets (SOLARSYS_ST
 	if (CurStarDescPtr->Index == ORZ_DEFINED)
 	{
 		solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 156L / 100;
 		solarSys->PlanetDesc[0].NumPlanets = 0;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -75,6 +76,7 @@ GenerateOrz_generatePlanets (SOLARSYS_ST
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/genpet.c src/uqm/planets/generate/genpet.c
--- src.orig/uqm/planets/generate/genpet.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/genpet.c	2017-11-22 08:52:11 -0600
@@ -28,6 +28,7 @@
 #include "../../setup.h"
 #include "../../state.h"
 #include "libs/mathlib.h"
+#include "../../../options.h"
 
 
 static bool GenerateTalkingPet_generatePlanets (SOLARSYS_STATE *solarSys);
@@ -73,6 +74,7 @@ GenerateTalkingPet_generatePlanets (SOLA
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
@@ -241,7 +243,9 @@ ZapToUrquanEncounter (void)
 		dx = (SIZE)square_root ((long)dx * dx + (long)dy * dy)
 				+ (FUEL_TANK_SCALE >> 1);
 
-		DeltaSISGauges (0, -dx, 0);
+		if (!optInfiniteFuel)
+			DeltaSISGauges (0, -dx, 0);
+
 		if (GLOBAL_SIS (FuelOnBoard) < 5 * FUEL_TANK_SCALE)
 		{
 			dx = ((5 + ((COUNT)TFB_Random () % 5)) * FUEL_TANK_SCALE)
diff -ruNp src.orig/uqm/planets/generate/genpku.c src/uqm/planets/generate/genpku.c
--- src.orig/uqm/planets/generate/genpku.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/genpku.c	2017-11-22 08:52:11 -0600
@@ -62,6 +62,7 @@ GeneratePkunk_generatePlanets (SOLARSYS_
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 104L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -70,6 +71,7 @@ GeneratePkunk_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genrain.c src/uqm/planets/generate/genrain.c
--- src.orig/uqm/planets/generate/genrain.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/genrain.c	2017-11-22 08:52:11 -0600
@@ -54,6 +54,7 @@ GenerateRainbowWorld_generatePlanets (SO
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = RAINBOW_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 0;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 50L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -66,6 +67,7 @@ GenerateRainbowWorld_generatePlanets (SO
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/gensam.c src/uqm/planets/generate/gensam.c
--- src.orig/uqm/planets/generate/gensam.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/gensam.c	2017-11-22 08:52:11 -0600
@@ -156,6 +156,7 @@ GenerateSaMatra_generateMoons (SOLARSYS_
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/gensly.c src/uqm/planets/generate/gensly.c
--- src.orig/uqm/planets/generate/gensly.c	2017-11-21 16:07:11 -0600
+++ src/uqm/planets/generate/gensly.c	2017-11-22 08:52:11 -0600
@@ -49,6 +49,7 @@ GenerateSlylandro_generatePlanets (SOLAR
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[3].data_index = RED_GAS_GIANT;
+	solarSys->PlanetDesc[3].alternate_colormap = NULL;
 	solarSys->PlanetDesc[3].NumPlanets = 1;
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/gensol.c src/uqm/planets/generate/gensol.c
--- src.orig/uqm/planets/generate/gensol.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/generate/gensol.c	2017-11-22 08:52:11 -0600
@@ -28,7 +28,9 @@
 #include "../../nameref.h"
 #include "../../state.h"
 #include "libs/mathlib.h"
-
+#include "options.h"
+#include "../../setup.h"
+#include <math.h>
 
 static bool GenerateSol_initNpcs (SOLARSYS_STATE *solarSys);
 static bool GenerateSol_reinitNpcs (SOLARSYS_STATE *solarSys);
@@ -113,7 +115,7 @@ GenerateSol_generatePlanets (SOLARSYS_ST
 	solarSys->SunDesc[0].NumPlanets = 9;
 	for (planetI = 0; planetI < 9; ++planetI)
 	{
-		COUNT angle;
+		//COUNT angle;
 		DWORD rand_val;
 		UWORD word_val;
 		PLANET_DESC *pCurDesc = &solarSys->PlanetDesc[planetI];
@@ -121,61 +123,74 @@ GenerateSol_generatePlanets (SOLARSYS_ST
 		pCurDesc->rand_seed = RandomContext_Random (SysGenRNG);
 		rand_val = pCurDesc->rand_seed;
 		word_val = LOWORD (rand_val);
-		angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
+		//angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
+		pCurDesc->angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
 
 		switch (planetI)
 		{
 			case 0: /* MERCURY */
 				pCurDesc->data_index = METAL_WORLD;
+				pCurDesc->alternate_colormap = !solTexturesPresent ? NULL : MERCURY_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 39L / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 1: /* VENUS */
 				pCurDesc->data_index = PRIMORDIAL_WORLD;
+				pCurDesc->alternate_colormap = !solTexturesPresent ? NULL : VENUS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 72L / 100;
 				pCurDesc->NumPlanets = 0;
-				angle = NORMALIZE_ANGLE (FULL_CIRCLE - angle);
+				// angle = NORMALIZE_ANGLE (FULL_CIRCLE - angle);
+				pCurDesc->angle = NORMALIZE_ANGLE (FULL_CIRCLE - pCurDesc->angle);
 				break;
 			case 2: /* EARTH */
 				pCurDesc->data_index = WATER_WORLD | PLANET_SHIELDED;
+				pCurDesc->alternate_colormap = NULL;
 				pCurDesc->radius = EARTH_RADIUS;
 				pCurDesc->NumPlanets = 2;
 				break;
 			case 3: /* MARS */
 				pCurDesc->data_index = DUST_WORLD;
+				pCurDesc->alternate_colormap = !solTexturesPresent ? NULL : MARS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 152L / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 4: /* JUPITER */
 				pCurDesc->data_index = RED_GAS_GIANT;
+				pCurDesc->alternate_colormap = !solTexturesPresent ? NULL : JUPITER_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 500L /* 520L */ / 100;
 				pCurDesc->NumPlanets = 4;
 				break;
 			case 5: /* SATURN */
 				pCurDesc->data_index = ORA_GAS_GIANT;
+				pCurDesc->alternate_colormap = !solTexturesPresent ? NULL : SATURN_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 750L /* 952L */ / 100;
 				pCurDesc->NumPlanets = 1;
 				break;
 			case 6: /* URANUS */
 				pCurDesc->data_index = GRN_GAS_GIANT;
+				pCurDesc->alternate_colormap = !solTexturesPresent ? NULL : URANUS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1000L /* 1916L */ / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 7: /* NEPTUNE */
 				pCurDesc->data_index = BLU_GAS_GIANT;
+				pCurDesc->alternate_colormap = !solTexturesPresent ? NULL : NEPTUNE_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1250L /* 2999L */ / 100;
 				pCurDesc->NumPlanets = 1;
 				break;
 			case 8: /* PLUTO */
 				pCurDesc->data_index = PELLUCID_WORLD;
+				pCurDesc->alternate_colormap = !solTexturesPresent ? NULL : PLUTO_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1550L /* 3937L */ / 100;
 				pCurDesc->NumPlanets = 0;
-				angle = FULL_CIRCLE - OCTANT;
+				// angle = FULL_CIRCLE - OCTANT;
+				pCurDesc->angle = FULL_CIRCLE - OCTANT;
 				break;
 		}
 
-		pCurDesc->location.x = COSINE (angle, pCurDesc->radius);
-		pCurDesc->location.y = SINE (angle, pCurDesc->radius);
+		pCurDesc->orb_speed = FULL_CIRCLE / (365.25 * pow((float)pCurDesc->radius / EARTH_RADIUS, 1.5));
+		pCurDesc->location.x = COSINE (pCurDesc->angle, pCurDesc->radius);
+		pCurDesc->location.y = SINE (pCurDesc->angle, pCurDesc->radius);
 	}
 
 	return true;
@@ -204,9 +219,11 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 					COSINE (angle, solarSys->MoonDesc[0].radius);
 			solarSys->MoonDesc[0].location.y =
 					SINE (angle, solarSys->MoonDesc[0].radius);
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 11.46;
 
 			/* Luna: */
 			solarSys->MoonDesc[1].data_index = SELENIC_WORLD;
+			solarSys->MoonDesc[1].alternate_colormap = !solTexturesPresent ? NULL : LUNA_COLOR_TAB;
 			solarSys->MoonDesc[1].radius = MIN_MOON_RADIUS
 					+ (MAX_MOONS - 1) * MOON_DELTA;
 			rand_val = RandomContext_Random (SysGenRNG);
@@ -215,24 +232,39 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 					COSINE (angle, solarSys->MoonDesc[1].radius);
 			solarSys->MoonDesc[1].location.y =
 					SINE (angle, solarSys->MoonDesc[1].radius);
+			solarSys->MoonDesc[1].orb_speed = FULL_CIRCLE / 29;
 			break;
 		}
 		case 4: /* moons of JUPITER */
 			solarSys->MoonDesc[0].data_index = RADIOACTIVE_WORLD;
+			solarSys->MoonDesc[0].alternate_colormap = !solTexturesPresent ? NULL : IO_COLOR_TAB;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 1.77;
 					/* Io */
 			solarSys->MoonDesc[1].data_index = HALIDE_WORLD;
+			solarSys->MoonDesc[1].alternate_colormap = !solTexturesPresent ? NULL : EUROPA_COLOR_TAB;
+			solarSys->MoonDesc[1].orb_speed = FULL_CIRCLE / 3.55;
 					/* Europa */
 			solarSys->MoonDesc[2].data_index = CYANIC_WORLD;
+			solarSys->MoonDesc[2].alternate_colormap = !solTexturesPresent ? NULL : GANYMEDE_COLOR_TAB;
+			solarSys->MoonDesc[2].orb_speed = FULL_CIRCLE / 7.16;
 					/* Ganymede */
 			solarSys->MoonDesc[3].data_index = PELLUCID_WORLD;
+			solarSys->MoonDesc[3].alternate_colormap = !solTexturesPresent ? NULL : CALLISTO_COLOR_TAB;
+			solarSys->MoonDesc[3].orb_speed = FULL_CIRCLE / 16.69;
 					/* Callisto */
 			break;
 		case 5: /* moons of SATURN */
 			solarSys->MoonDesc[0].data_index = ALKALI_WORLD;
+			solarSys->MoonDesc[0].alternate_colormap = !solTexturesPresent ? NULL : TITAN_COLOR_TAB;
+			solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS
+					+ (MAX_MOONS - 1) * MOON_DELTA;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 15.95;
 					/* Titan */
 			break;
 		case 7: /* moons of NEPTUNE */
 			solarSys->MoonDesc[0].data_index = VINYLOGOUS_WORLD;
+			solarSys->MoonDesc[0].alternate_colormap = !solTexturesPresent ? NULL : TRITON_COLOR_TAB;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / -5.88;
 					/* Triton */
 			break;
 	}
@@ -405,8 +437,43 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
 				CalcGravity (&solarSys->SysInfo.PlanetInfo);
-		LoadPlanet (planetNr == 2 ?
-				CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)) : NULL);
+		if (!solTexturesPresent){
+			LoadPlanet (planetNr == 2 ?
+					CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)) : NULL);
+		} else {
+			switch (planetNr) {
+				case 0: /* MERCURY */
+					LoadPlanet (CaptureDrawable (LoadGraphic (MERCURY_MASK_ANIM)));
+					break;
+				case 1: /* VENUS */
+					LoadPlanet (CaptureDrawable (LoadGraphic (VENUS_MASK_ANIM)));
+					break;
+				case 2: /* EARTH */
+					LoadPlanet (CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)));
+					break;
+				case 3: /* MARS */
+					LoadPlanet (CaptureDrawable (LoadGraphic (MARS_MASK_ANIM)));
+					break;
+				case 4: /* JUPITER*/
+					LoadPlanet (CaptureDrawable (LoadGraphic (JUPITER_MASK_ANIM)));
+					break;
+				case 5: /* SATURN*/
+					LoadPlanet (CaptureDrawable (LoadGraphic (SATURN_MASK_ANIM)));
+					break;
+				case 6: /* URANUS */
+					LoadPlanet (CaptureDrawable (LoadGraphic (URANUS_MASK_ANIM)));
+					break;
+				case 7: /* NEPTUNE */
+					LoadPlanet (CaptureDrawable (LoadGraphic (NEPTUNE_MASK_ANIM)));
+					break;
+				case 8: /* PLUTO */
+					LoadPlanet (CaptureDrawable (LoadGraphic (PLUTO_MASK_ANIM)));
+					break;
+				default:
+					LoadPlanet (NULL);
+					break;
+			}
+		}
 	}
 	else
 	{
@@ -508,7 +575,37 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
 				CalcGravity (&solarSys->SysInfo.PlanetInfo);
-		LoadPlanet (NULL);
+		switch (planetNr) {
+			case 2: /* moons of EARTH */
+				if (moonNr == 1)
+					LoadPlanet (CaptureDrawable (LoadGraphic (!solTexturesPresent ?  NULL : LUNA_MASK_ANIM)));
+				else
+					LoadPlanet (NULL);
+				break;
+			case 4: /* moons of JUPITER */
+				switch (moonNr) {
+					case 0: /* Io */
+						LoadPlanet (CaptureDrawable (LoadGraphic (!solTexturesPresent ?  NULL : IO_MASK_ANIM)));
+						break;
+					case 1: /* Europa */
+						LoadPlanet (CaptureDrawable (LoadGraphic (!solTexturesPresent ?  NULL : EUROPA_MASK_ANIM)));
+						break;
+					case 2: /* Ganymede */
+						LoadPlanet (CaptureDrawable (LoadGraphic (!solTexturesPresent ?  NULL : GANYMEDE_MASK_ANIM)));
+						break;
+					case 3: /* Callisto */
+						LoadPlanet (CaptureDrawable (LoadGraphic (!solTexturesPresent ?  NULL : CALLISTO_MASK_ANIM)));
+						break;
+				}
+				break;
+			case 5: /* moon of Saturn: Titan */
+				LoadPlanet (CaptureDrawable (LoadGraphic (!solTexturesPresent ?  NULL : TITAN_MASK_ANIM)));
+				break;
+			case 7: /* moon of NEPTUNE: Triton */
+			default:
+				LoadPlanet (CaptureDrawable (LoadGraphic (!solTexturesPresent ?  NULL : TRITON_MASK_ANIM)));
+				break;
+		}
 	}
 
 	return true;
@@ -623,8 +720,7 @@ init_probe (void)
 
 	if (!GET_GAME_STATE (PROBE_MESSAGE_DELIVERED)
 			&& GetGroupInfo (GLOBAL (BattleGroupRef), GROUP_INIT_IP)
-			&& (hGroup = GetHeadLink (&GLOBAL (ip_group_q))))
-	{
+			&& (hGroup = GetHeadLink (&GLOBAL (ip_group_q)))) {
 		IP_GROUP *GroupPtr;
 
 		GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
@@ -637,9 +733,9 @@ init_probe (void)
 		UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 
 		return 1;
-	}
-	else
+	} else {
 		return 0;
+	}
 }
 
 static void
diff -ruNp src.orig/uqm/planets/generate/genspa.c src/uqm/planets/generate/genspa.c
--- src.orig/uqm/planets/generate/genspa.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/generate/genspa.c	2017-11-22 08:52:11 -0600
@@ -78,10 +78,11 @@ GenerateSpathi_generatePlanets (SOLARSYS
 	pMinPlanet->location.x = COSINE (angle, pMinPlanet->radius);
 	pMinPlanet->location.y = SINE (angle, pMinPlanet->radius);
 	pMinPlanet->data_index = WATER_WORLD;
+	pMinPlanet->alternate_colormap = NULL;
 	if (GET_GAME_STATE (SPATHI_SHIELDED_SELVES))
 		pMinPlanet->data_index |= PLANET_SHIELDED;
 	pMinPlanet->NumPlanets = 1;
-
+	ComputeSpeed(pMinPlanet, FALSE, 1);
 	return true;
 }
 
@@ -101,12 +102,14 @@ GenerateSpathi_generateMoons (SOLARSYS_S
 #endif /* NOTYET */
 
 		solarSys->MoonDesc[0].data_index = PELLUCID_WORLD;
+		solarSys->MoonDesc[0].alternate_colormap = NULL;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS + MOON_DELTA;
 		angle = NORMALIZE_ANGLE (LOWORD (RandomContext_Random (SysGenRNG)));
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/gensup.c src/uqm/planets/generate/gensup.c
--- src.orig/uqm/planets/generate/gensup.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/generate/gensup.c	2017-11-22 08:52:11 -0600
@@ -62,6 +62,7 @@ GenerateSupox_generatePlanets (SOLARSYS_
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 2;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 152L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -70,6 +71,7 @@ GenerateSupox_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/gensyr.c src/uqm/planets/generate/gensyr.c
--- src.orig/uqm/planets/generate/gensyr.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/generate/gensyr.c	2017-11-22 08:52:12 -0600
@@ -50,6 +50,7 @@ GenerateSyreen_generatePlanets (SOLARSYS
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = WATER_WORLD | PLANET_SHIELDED;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 
 	return true;
@@ -63,11 +64,13 @@ GenerateSyreen_generateMoons (SOLARSYS_S
 	if (matchWorld (solarSys, planet, 0, MATCH_PLANET))
 	{
 		solarSys->MoonDesc[0].data_index = HIERARCHY_STARBASE;
+		solarSys->MoonDesc[0].alternate_colormap = NULL;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS;
 		solarSys->MoonDesc[0].location.x =
 				COSINE (QUADRANT, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (QUADRANT, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/genthrad.c src/uqm/planets/generate/genthrad.c
--- src.orig/uqm/planets/generate/genthrad.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/generate/genthrad.c	2017-11-22 08:52:12 -0600
@@ -29,6 +29,7 @@
 #include "../../setup.h"
 #include "../../state.h"
 #include "libs/mathlib.h"
+#include "../../../options.h"
 
 
 static bool GenerateThraddash_generatePlanets (SOLARSYS_STATE *solarSys);
@@ -67,6 +68,7 @@ GenerateThraddash_generatePlanets (SOLAR
 	if (CurStarDescPtr->Index == AQUA_HELIX_DEFINED)
 	{
 		solarSys->PlanetDesc[0].data_index = PRIMORDIAL_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 65L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
 				solarSys->PlanetDesc[0].location.y);
@@ -74,10 +76,12 @@ GenerateThraddash_generatePlanets (SOLAR
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	else  /* CurStarDescPtr->Index == THRADD_DEFINED */
 	{
 		solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].NumPlanets = 0;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 98L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -86,6 +90,7 @@ GenerateThraddash_generatePlanets (SOLAR
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	return true;
 }
@@ -188,6 +193,10 @@ static bool
 GenerateThraddash_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
 		COUNT whichNode)
 {
+	HFLEETINFO hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
+	FLEET_INFO *ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+	SIZE strength_loss;
+
 	if (CurStarDescPtr->Index == THRADD_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
@@ -208,6 +217,14 @@ GenerateThraddash_pickupEnergy (SOLARSYS
 		SET_GAME_STATE (AQUA_HELIX, 1);
 		SET_GAME_STATE (AQUA_HELIX_ON_SHIP, 1);
 		SET_GAME_STATE (HELIX_UNPROTECTED, 1);
+		if (GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH) && optThraddStory){
+			SetRaceAllied (THRADDASH_SHIP, FALSE);
+			RemoveEscortShips (THRADDASH_SHIP);
+			strength_loss = (SIZE)(ThraddPtr->actual_strength);
+			ThraddPtr->growth = (BYTE)(-strength_loss / ThraddPtr->days_left);
+			ThraddPtr->growth_fract = (BYTE)(((strength_loss % ThraddPtr->days_left) << 8) / ThraddPtr->days_left);
+			SET_GAME_STATE (THRADD_VISITS, 0);
+		}
 
 		return true; // picked up
 	}
diff -ruNp src.orig/uqm/planets/generate/gentrap.c src/uqm/planets/generate/gentrap.c
--- src.orig/uqm/planets/generate/gentrap.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/generate/gentrap.c	2017-11-22 08:52:12 -0600
@@ -50,6 +50,7 @@ GenerateTrap_generatePlanets (SOLARSYS_S
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = TELLURIC_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 203L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -58,6 +59,7 @@ GenerateTrap_generatePlanets (SOLARSYS_S
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genutw.c src/uqm/planets/generate/genutw.c
--- src.orig/uqm/planets/generate/genutw.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/generate/genutw.c	2017-11-22 08:52:12 -0600
@@ -85,6 +85,7 @@ GenerateUtwig_generatePlanets (SOLARSYS_
 	if (CurStarDescPtr->Index == UTWIG_DEFINED)
 	{
 		solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].NumPlanets = 1;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 174L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -93,6 +94,7 @@ GenerateUtwig_generatePlanets (SOLARSYS_
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/genvux.c src/uqm/planets/generate/genvux.c
--- src.orig/uqm/planets/generate/genvux.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/generate/genvux.c	2017-11-22 08:52:12 -0600
@@ -77,6 +77,7 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 				// called. Is it safe to remove one, or does this change
 				// the RNG so that the outcome is different?
 		solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 212L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
 				solarSys->PlanetDesc[0].location.y);
@@ -84,15 +85,18 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	else
 	{
 		if (CurStarDescPtr->Index == VUX_DEFINED)
 		{
 			solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
+			solarSys->PlanetDesc[0].alternate_colormap = NULL;
 			solarSys->PlanetDesc[0].NumPlanets = 1;
 			solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 42L / 100;
 			angle = HALF_CIRCLE + OCTANT;
+			ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 		}
 		else /* if (CurStarDescPtr->Index == VUX_BEAST_DEFINED) */
 		{
@@ -103,8 +107,10 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 
 			angle = HALF_CIRCLE - OCTANT;
 			solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+			solarSys->PlanetDesc[0].alternate_colormap = NULL;
 			solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 110L / 100;
 			solarSys->PlanetDesc[0].NumPlanets = 0;
+			ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 		}
 
 		solarSys->PlanetDesc[0].location.x =
diff -ruNp src.orig/uqm/planets/generate/genyeh.c src/uqm/planets/generate/genyeh.c
--- src.orig/uqm/planets/generate/genyeh.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/generate/genyeh.c	2017-11-22 08:52:12 -0600
@@ -68,6 +68,7 @@ GenerateYehat_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genzoq.c src/uqm/planets/generate/genzoq.c
--- src.orig/uqm/planets/generate/genzoq.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/generate/genzoq.c	2017-11-22 08:52:12 -0600
@@ -70,6 +70,7 @@ GenerateZoqFotPik_generatePlanets (SOLAR
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 138L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -78,6 +79,7 @@ GenerateZoqFotPik_generatePlanets (SOLAR
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/gentopo.c src/uqm/planets/gentopo.c
--- src.orig/uqm/planets/gentopo.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/gentopo.c	2017-11-22 08:52:12 -0600
@@ -50,8 +50,8 @@ DeltaTopography (COUNT num_iterations, S
 		w1 = LOWORD (rand_val);
 		w2 = HIWORD (rand_val);
 
-		LineDDA0.x_top = LOBYTE (w1) % width;
-		LineDDA0.x_bot = HIBYTE (w1) % width;
+		LineDDA0.x_top = (LOBYTE (w1) % MAP_WIDTH) * width / MAP_WIDTH;
+		LineDDA0.x_bot = (HIBYTE (w1) % MAP_WIDTH) * width / MAP_WIDTH;
 		LineDDA0.delta_x = (LineDDA0.x_bot - LineDDA0.x_top) << 1;
 		if (LineDDA0.delta_x >= 0)
 			LineDDA0.x_incr = 1;
@@ -65,8 +65,8 @@ DeltaTopography (COUNT num_iterations, S
 		else
 			LineDDA0.error_term = -(delta_y >> 1);
 
-		LineDDA1.x_top = (LOBYTE (w2) % (width - 1)) + LineDDA0.x_top + 1;
-		LineDDA1.x_bot = (HIBYTE (w2) % (width - 1)) + LineDDA0.x_bot + 1;
+		LineDDA1.x_top = (LOBYTE (w2) % (MAP_WIDTH - 1)) * width / MAP_WIDTH + LineDDA0.x_top + 1;
+		LineDDA1.x_bot = (HIBYTE (w2) % (MAP_WIDTH - 1)) * width / MAP_WIDTH + LineDDA0.x_bot + 1;
 		LineDDA1.delta_x = (LineDDA1.x_bot - LineDDA1.x_top) << 1;
 		if (LineDDA1.delta_x >= 0)
 			LineDDA1.x_incr = 1;
diff -ruNp src.orig/uqm/planets/lander.c src/uqm/planets/lander.c
--- src.orig/uqm/planets/lander.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/lander.c	2017-11-22 08:52:12 -0600
@@ -34,7 +34,8 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
-
+#include "options.h"
+#include "uqm/menustat.h"
 
 //define SPIN_ON_LAUNCH to let the planet spin while
 // the lander animation is playing
@@ -114,10 +115,9 @@ const LIFEFORM_DESC CreatureData[] =
 			// Bug-Eyed Bait
 	{SPEED_MOTIONLESS | DANGER_WEAK, MAKE_BYTE (8, 5)},
 			// Goo Burger
-
 	{SPEED_MOTIONLESS | DANGER_MONSTROUS, MAKE_BYTE (1, 1)},
 			// Evil One
-	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (0, 1)},
+	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (1, 1)}, // ? was 0, 1
 			// Brainbox Bulldozers
 	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_FAST | DANGER_MONSTROUS, MAKE_BYTE (15, 15)},
 			// Zex's Beauty
@@ -451,8 +451,12 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 		shieldHit &= 1 << which_disaster;
 		if (!shieldHit || TFB_Random () % 100 >= 95)
 		{	// No shield, or it did not help
-			shieldHit = 0;
-			--crew_left;
+			if (!optGodMode) {
+				shieldHit = 0; 
+				--crew_left; 
+			}
+			else 
+				shieldHit = 1; 
 		}
 
 		damage_index = DAMAGE_CYCLE;
@@ -477,7 +481,7 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 static void
 FillLanderHold (PLANETSIDE_DESC *pPSD, COUNT scan, COUNT NumRetrieved)
 {
-	COUNT start_count;
+	COUNT start_count, tmpholdint;
 	STAMP s;
 	CONTEXT OldContext;
 
@@ -505,6 +509,12 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 		s.frame = SetAbsFrameIndex (LanderFrame[0], 43);
 	}
 
+	tmpholdint = ((start_count + NumRetrieved) * MAX_HOLD_BARS / MAX_SCROUNGED)
+			- ((start_count * MAX_HOLD_BARS / MAX_SCROUNGED) + (NumRetrieved *
+			MAX_HOLD_BARS / MAX_SCROUNGED));
+	start_count = start_count * MAX_HOLD_BARS / MAX_SCROUNGED;
+	NumRetrieved = (NumRetrieved * MAX_HOLD_BARS / MAX_SCROUNGED) + tmpholdint;
+
 	s.origin.x = 0;
 	s.origin.y = -(int)start_count;
 	if (!(start_count & 1))
@@ -525,36 +535,92 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 
 // returns true iff the node was picked up.
 static bool
-pickupMineralNode (PLANETSIDE_DESC *pPSD, COUNT NumRetrieved,
+pickupNode (PLANETSIDE_DESC *pPSD, COUNT NumRetrieved,
 		ELEMENT *ElementPtr, const INTERSECT_CONTROL *LanderControl,
-		const INTERSECT_CONTROL *ElementControl)
+		const INTERSECT_CONTROL *ElementControl, COUNT Scan)
 {
 	BYTE EType;
-	UNICODE ch;
-	UNICODE *pStr;
+	UNICODE ch, *pStr;
+	COUNT *Amount, Max, Offset;
+	BOOLEAN PartialPickup;
+
+	Amount = &pPSD->BiologicalLevel;
+	Max = MAX_SCROUNGED;
+	EType = ElementPtr->thrust_wait;
+	Offset = BIOLOGICAL_STRING_BASE;
+
+	if (Scan != BIOLOGICAL_SCAN){
+		Amount = &pPSD->ElementLevel;
+		Max = pPSD->MaxElementLevel;
+		EType = ElementPtr->turn_wait;
+		Offset = ELEMENTS_STRING_BASE;
+	}
 
-	if (pPSD->ElementLevel >= pPSD->MaxElementLevel)
-	{
+	// JMS: The rest of partially scavenged minerals stay on the surface.
+	PartialPickup = FALSE;
+
+	if (*Amount >= Max) {
 		// Lander full
 		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_FULL),
 				NotPositional (), NULL, GAME_SOUND_PRIORITY);
 		return false;
 	}
 
-	if (pPSD->ElementLevel + NumRetrieved > pPSD->MaxElementLevel)
-	{
+	if (*Amount + NumRetrieved > Max) {
+		SIZE which_node;
+		COUNT oldsize = ElementPtr->mass_points;
+
 		// Deposit could only be picked up partially.
-		NumRetrieved = (COUNT)(pPSD->MaxElementLevel - pPSD->ElementLevel);
+		NumRetrieved = (COUNT)(Max - *Amount);
+
+		if (Scan != BIOLOGICAL_SCAN && optPartialPickup){
+			// JMS: Subtract the scavenged kilotons from the mineral deposit.
+			// The rest will stay on the surface.
+			ElementPtr->mass_points -= NumRetrieved;
+		
+			// JMS: This makes the mineral deposit subtraction keep  
+			// in effect even after leaving & re-entering the planet.
+			which_node = HIBYTE (ElementPtr->scan_node) - 1;
+			pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[MINERAL_SCAN][which_node] = NumRetrieved;
+		
+			// JMS: If the deposit was large and its amount now equates to a smaller
+			// deposit, change its graphics.
+			if ((oldsize > 22 && ElementPtr->mass_points <= 22)
+				|| (oldsize > 15 && ElementPtr->mass_points <= 15))
+			{
+				PRIMITIVE *pPrim = &DisplayArray[ElementPtr->PrimIndex];
+				BYTE gfx_index_change = 0;
+			
+				if (oldsize > 22 && ElementPtr->mass_points <= 15)
+					gfx_index_change = 2;
+				else
+					gfx_index_change = 1;
+			
+				// Change the scan screen gfx.
+				ElementPtr->current.image.frame = SetRelFrameIndex (
+					ElementPtr->current.image.frame, (2 - gfx_index_change));
+				ElementPtr->next.image.frame = ElementPtr->current.image.frame;
+
+				// Notify the engine that the scan screen gfx should be updated.
+				ElementPtr->state_flags |= CHANGING;
+				SET_GAME_STATE (PLANETARY_CHANGE, 1);
+			
+				// Change the surface screen gfx.
+				pPrim->Object.Stamp.frame = SetRelFrameIndex (pPrim->Object.Stamp.frame, -gfx_index_change);
+			}
+		
+			PartialPickup = TRUE;
+		}
 	}
 
-	FillLanderHold (pPSD, MINERAL_SCAN, NumRetrieved);
+	FillLanderHold (pPSD, Scan, NumRetrieved);
 
-	EType = ElementPtr->turn_wait;
-	pPSD->ElementAmounts[ElementCategory (EType)] += NumRetrieved;
+	if (Scan != BIOLOGICAL_SCAN)
+		pPSD->ElementAmounts[ElementCategory (EType)] += NumRetrieved;
 
 	pPSD->NumFrames = NUM_TEXT_FRAMES;
 	sprintf (pPSD->AmountBuf, "%u", NumRetrieved);
-	pStr = GAME_STRING (EType + ELEMENTS_STRING_BASE);
+	pStr = GAME_STRING (EType + Offset);
 
 	pPSD->MineralText[0].baseline.x = (SURFACE_WIDTH >> 1)
 			+ (ElementControl->EndPoint.x - LanderControl->EndPoint.x);
@@ -565,13 +631,10 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 
 	while ((ch = *pStr++) && ch != ' ')
 		;
-	if (ch == '\0')
-	{
+	if (ch == '\0') {
 		pPSD->MineralText[1].CharCount = (COUNT)~0;
 		pPSD->MineralText[2].CharCount = 0;
-	}
-	else  /* ch == ' ' */
-	{
+	} else {  /* ch == ' ' */
 		// Name contains a space. Print over
 		// two lines.
 		pPSD->MineralText[1].CharCount = utf8StringCountN(
@@ -580,29 +643,54 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 		pPSD->MineralText[2].CharCount = (COUNT)~0;
 	}
 
-	return true;
+	// JMS
+	return (PartialPickup ? false : true);
 }
 
-static bool
-pickupBioNode (PLANETSIDE_DESC *pPSD, COUNT NumRetrieved)
+static void
+ExplodeCritter (ELEMENT *ElementPtr)
 {
-	if (pPSD->BiologicalLevel >= MAX_SCROUNGED)
-	{
-		// Lander is full.
-		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_FULL),
-				NotPositional (), NULL, GAME_SOUND_PRIORITY);
-		return false;
-	}
-
-	if (pPSD->BiologicalLevel + NumRetrieved > MAX_SCROUNGED)
+	HELEMENT hExplosionElement;
+	SIZE temp_which_node;
+				
+	hExplosionElement = AllocElement ();
+	if (hExplosionElement)
 	{
-		// Node could only be picked up partially.
-		NumRetrieved = (COUNT)(MAX_SCROUNGED - pPSD->BiologicalLevel);
+		ELEMENT *ExplosionElementPtr;
+		LockElement (hExplosionElement, &ExplosionElementPtr);
+					
+		ExplosionElementPtr->mass_points = DEATH_EXPLOSION;
+		ExplosionElementPtr->state_flags = FINITE_LIFE;
+		ExplosionElementPtr->playerNr = PS_NON_PLAYER;
+		ExplosionElementPtr->next.location = ElementPtr->next.location;
+		ExplosionElementPtr->preprocess_func = object_animation;
+		ExplosionElementPtr->turn_wait = MAKE_BYTE (2, 2);
+		ExplosionElementPtr->life_span = EXPLOSION_LIFE * (LONIBBLE (ExplosionElementPtr->turn_wait));
+					
+		SetPrimType (&DisplayArray[ExplosionElementPtr->PrimIndex], STAMP_PRIM);
+		DisplayArray[ExplosionElementPtr->PrimIndex].Object.Stamp.frame = SetAbsFrameIndex (LanderFrame[0], 46);
+
+		// JMS: This keeps track of the explosion frames. Normally explosion occurs only once (lander explodes).
+		// If we don't zero this variable here, the explosion anim can run only once properly and would
+		// get stuck in the last frame after that on all the subsequent explosions.
+		explosion_index = 0;
+					
+		UnlockElement (hExplosionElement);
+		InsertElement (hExplosionElement, GetHeadElement ());
+					
+		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_DESTROYED), NotPositional (), NULL, GAME_SOUND_PRIORITY + 1);
+					
+		ElementPtr->state_flags |= DISAPPEARING; // JMS: Delete the critter frame
+		ElementPtr->mass_points = 0;			 // JMS: Make sure critter/explosion doesn't give biodata.
+					
+		// JMS: This marks the exploded critter "collected". (even though there was no biodata to collect).
+		// This ensures the critter isn't resurrected when visiting the planet next time.
+		temp_which_node = HIBYTE (ElementPtr->scan_node) - 1;
+		pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] |= (1L << temp_which_node); // Mark this bio blip's state as "collected".
+		//pSolarSysState->CurNode = (COUNT)~0; // GenerateLifeForms will update the states of ALL bio-blips when run.
+		//callGenerateForScanType (pSolarSysState, pSolarSysState->pOrbitalDesc, &pSolarSysState->CurNode, BIOLOGICAL_SCAN); // Re-run GenerateLifeForms so the changed state takes effect
+		SET_GAME_STATE (PLANETARY_CHANGE, 1); // Save the changes to the file containing the states of all lifeforms.
 	}
-
-	FillLanderHold (pPSD, BIOLOGICAL_SCAN, NumRetrieved);
-
-	return true;
 }
 
 static void
@@ -618,10 +706,22 @@ shotCreature (ELEMENT *ElementPtr, BYTE
 	--ElementPtr->hit_points;
 	if (ElementPtr->hit_points == 0)
 	{
-		// Can creature.
-		ElementPtr->mass_points = value;
-		DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
-				pSolarSysState->PlanetSideFrame[0];
+		// Brainbox bulldozers (Tractors at moon) explode.
+		if ((ElementPtr->mass_points & ~CREATURE_AWARE) == 24)
+		{
+			ExplodeCritter (ElementPtr);
+		}
+		// Can other creatures.
+		else
+		{
+			// stash the type of creature in the
+			// thrust_wait field.  It seems to be unused
+			// by the game for anything at this point
+			ElementPtr->thrust_wait = ElementPtr->mass_points & ~CREATURE_AWARE;
+			ElementPtr->mass_points = value;
+			DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
+			pSolarSysState->PlanetSideFrame[0];
+		}
 	}
 	else if (CreatureData[ElementPtr->mass_points & ~CREATURE_AWARE]
 			.Attributes & SPEED_MASK)
@@ -810,13 +910,8 @@ CheckObjectCollision (COUNT index)
 						case ENERGY_SCAN:
 							break;
 						case MINERAL_SCAN:
-							if (!pickupMineralNode (pPSD, NumRetrieved,
-									ElementPtr, &LanderControl,
-									&ElementControl))
-								continue;
-							break;
 						case BIOLOGICAL_SCAN:
-							if (!pickupBioNode (pPSD, NumRetrieved))
+							if (!pickupNode (pPSD, NumRetrieved, ElementPtr, &LanderControl, &ElementControl, scan))
 								continue;
 							break;
 					}
@@ -860,16 +955,23 @@ lightning_process (ELEMENT *ElementPtr)
 		else
 		{
 			SIZE s;
-			
-			// XXX: Color cycling is largely unused, because the color
-			//   never actually changes RGB values (see MAKE_RGB15 below).
-			//   This did, however, work in DOS SC2 version (fade effect).
-			s = 7 - ((SIZE)ElementPtr->cycle - (SIZE)ElementPtr->life_span);
-			if (s < 0)
-				s = 0;
-			// XXX: Was 0x8000 the background flag on 3DO?
-			//SetPrimColor (pPrim, BUILD_COLOR (0x8000 | MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
-			SetPrimColor (pPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
+#define NUM_CYCLES 8
+			static const Color color_tab[] =
+			{
+				BUILD_COLOR (MAKE_RGB15_INIT (0x11, 0x11, 0x11), 0x18),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x13, 0x13, 0x13), 0x17),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x15, 0x15, 0x15), 0x15),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x17, 0x17, 0x17), 0x14),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x19, 0x19, 0x19), 0x13),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x1B, 0x1B, 0x1B), 0x12),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x1D, 0x1D, 0x1D), 0x10),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x1F, 0x1F), 0x0f),
+			};
+
+			s = ElementPtr->life_span;
+			if (s > NUM_CYCLES - 1)
+				s = NUM_CYCLES - 1;
+			SetPrimColor (pPrim, color_tab[s]);
 
 			if (ElementPtr->mass_points == LIGHTNING_DISASTER)
 			{
@@ -1380,15 +1482,20 @@ InitPlanetSide (POINT pt)
 {
 	// Adjust landing location by a random jitter.
 #define RANDOM_MISS 64
+	if(!optGodMode){
+		pt.x -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
+		pt.y -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
+	} else { 
+		pt.x -= 0;
+		pt.y -= 0;
+	}
 	// Jitter the X landing point.
-	pt.x -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
 	if (pt.x < 0)
 		pt.x += (MAP_WIDTH << MAG_SHIFT);
 	else if (pt.x >= (MAP_WIDTH << MAG_SHIFT))
 		pt.x -= (MAP_WIDTH << MAG_SHIFT);
 
 	// Jitter the Y landing point.
-	pt.y -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
 	if (pt.y < 0)
 		pt.y = 0;
 	else if (pt.y >= (MAP_HEIGHT << MAG_SHIFT))
@@ -1729,6 +1836,11 @@ ReturnToOrbit (void)
 
 	SetTransitionSource (&r);
 	BatchGraphics ();
+	
+	// JMS: This will hide the table of mineral values on the status bar.
+	if (optSubmenu)
+		DrawSubmenu (0);
+
 	DrawStarBackGround ();
 	DrawPlanetSurfaceBorder ();
 	RedrawSurfaceScan (NULL);
@@ -1929,6 +2041,10 @@ PlanetSide (POINT planetLoc)
 
 	AnimateLanderWarmup ();
 	AnimateLaunch (LanderFrame[5]);
+
+	if (optSubmenu)
+		DrawSubmenu (1);
+
 	InitPlanetSide (planetLoc);
 
 	landerInputState.NextTime = GetTimeCounter () + PLANET_SIDE_RATE;
@@ -2077,8 +2193,8 @@ InitLander (BYTE LanderFlags)
 		{
 			r.corner.x = 1;
 			r.extent.width = 4;
-			r.extent.height = MAX_SCROUNGED
-					- (free_space >> capacity_shift) + 1;
+			r.extent.height = MAX_HOLD_BARS - ((free_space >> capacity_shift)
+					* MAX_HOLD_BARS / MAX_SCROUNGED) + 2;
 			SetContextForeGroundColor (BLACK_COLOR);
 			DrawFilledRectangle (&r);
 		}
diff -ruNp src.orig/uqm/planets/orbits.c src/uqm/planets/orbits.c
--- src.orig/uqm/planets/orbits.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/orbits.c	2017-11-22 08:52:12 -0600
@@ -21,7 +21,8 @@
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
-
+#include "../clock.h"
+#include <math.h>
 
 //#define DEBUG_ORBITS
 
@@ -469,6 +470,24 @@ YellowDistribution (BYTE which_world)
 #define SUPERGIANT_ROCK_DIST SCALE_RADIUS (16)
 #define SUPERGIANT_GASG_DIST SCALE_RADIUS (33)
 
+void ComputeSpeed(PLANET_DESC *planet, BOOLEAN GeneratingMoons, UWORD rand_val)
+{
+	//BW : empiric values, which would give roughly correct
+	// rotation periods for most moons in the solar system
+	if (GeneratingMoons)
+		{
+			planet->orb_speed = FULL_CIRCLE / (29 * pow((double)planet->radius / (MIN_MOON_RADIUS + (MAX_MOONS - 1) * MOON_DELTA), 1.5));
+			if ((planet->pPrevDesc->data_index & ~PLANET_SHIELDED) >= FIRST_GAS_GIANT)
+				planet->orb_speed *= 2;
+			if (!(rand_val % 7))
+				planet->orb_speed = - planet->orb_speed;
+		}
+		else
+		{
+			planet->orb_speed = FULL_CIRCLE / (ONE_YEAR * pow((double)planet->radius / EARTH_RADIUS, 1.5));
+		}
+}
+
 void
 FillOrbits (SOLARSYS_STATE *system, BYTE NumPlanets,
 		PLANET_DESC *pBaseDesc, BOOLEAN TypesDefined)
@@ -539,6 +558,9 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 				pPD->data_index =
 						(BYTE)(HIBYTE (LOWORD (rand_val)) % MaxPlanet);
 
+			// JMS: This exists for special colormaps of Sol system planets.
+			pPD->alternate_colormap = NULL;
+
 			chance = PLANET_NEVER;
 			switch (StarColor)
 			{
@@ -597,10 +619,25 @@ RelocatePlanet:
 		}
 
 		rand_val = RandomContext_Random (SysGenRNG);
-		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
-		pPD->location.x = COSINE (angle, pPD->radius);
-		pPD->location.y = SINE (angle, pPD->radius);
-		pPD->rand_seed = MAKE_DWORD (pPD->location.x, pPD->location.y);
+		// Initial angle & coordinates as in Vanilla UQM
+		// Still used to compute rand_seed and the position
+		// of the planet at the start of the game
+		pPD->angle = NORMALIZE_ANGLE (LOWORD (rand_val));
+		pPD->location.x = COSINE (pPD->angle, pPD->radius);
+		pPD->location.y = SINE (pPD->angle, pPD->radius);
+		if (GeneratingMoons)
+		{
+		pPD->rand_seed = MAKE_DWORD (
+		     COSINE (pPD->angle, pPD->radius),
+		     SINE (pPD->angle, pPD->radius));
+		}
+		else
+		{
+			pPD->rand_seed = MAKE_DWORD (pPD->location.x, pPD->location.y);
+		}
+		// Angle is kept for reference but location will be adjusted
+		// to take orbiting into account
+		ComputeSpeed(pPD, GeneratingMoons, HIWORD (rand_val));
 
 		++pPD;
 	}
diff -ruNp src.orig/uqm/planets/pl_stuff.c src/uqm/planets/pl_stuff.c
--- src.orig/uqm/planets/pl_stuff.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/pl_stuff.c	2017-11-22 08:52:12 -0600
@@ -24,7 +24,7 @@
 #include "libs/mathlib.h"
 #include "scan.h"
 #include "options.h"
-
+#include "libs/log.h"
 #include <math.h>
 
 
@@ -38,6 +38,9 @@ static int rotDirection;
 static bool throbShield;
 static int rotPointIndex;
 
+static int rotwidth;
+static int rotheight;
+
 // Draw the planet sphere and any extra graphic (like a shield) if present
 void
 DrawPlanetSphere (int x, int y)
@@ -70,10 +73,13 @@ DrawDefaultPlanetSphere (void)
 }
 
 void
-InitSphereRotation (int direction, BOOLEAN shielded)
+InitSphereRotation (int direction, BOOLEAN shielded, COUNT width, COUNT height)
 {
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 
+	rotwidth = width;
+	rotheight = height;
+
 	rotDirection = direction;
 	rotPointIndex = 0;
 	throbShield = shielded && optWhichShield == OPT_3DO;
@@ -93,7 +99,7 @@ InitSphereRotation (int direction, BOOLE
 	// Render the first sphere/shield frame
 	// Prepare will set the next one
 	rotFrameIndex = 1;
-	PrepareNextRotationFrame ();
+	PrepareNextRotationFrame (NULL, NULL, TRUE);
 }
 
 void
@@ -110,33 +116,80 @@ UninitSphereRotation (void)
 }
 
 void
-PrepareNextRotationFrame (void)
-{
-	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-
+PrepareNextRotationFrame (PLANET_DESC *pPlanetDesc, SIZE frameCounter, BOOLEAN inOrbit)
+{		
+	PLANET_ORBIT *Orbit = inOrbit ? &pSolarSysState->Orbit : &pPlanetDesc->orbit;
+
+	if (!inOrbit){
+		COUNT framerate;
+		int oldPointIndex = pPlanetDesc->rotPointIndex;
+		// Go to next point, taking care of wraparounds
+
+		// No need to rotate planets that are off screen
+		if (pPlanetDesc->radius > 4 * pSolarSysState->SunDesc[0].radius)
+			return;
+
+		// Optimization : the smallest worlds are rotated only once in a while
+		// The framerate is fine-tuned so that the planet is updated
+		// when the landscape has moved 1 pixel approximately
+		switch (pPlanetDesc->size) {
+			case 3: framerate = 15;
+				break;
+			case 4: framerate = 10;
+				break;
+			case 7: framerate = 4;
+				break;
+			case 11: framerate = 2;
+				break;
+			default: framerate = 1;
+				break;
+		}
+		if ((frameCounter % framerate) != 0)
+			return;
+
+		// BW: account for rotation period
+		pPlanetDesc->rotPointIndex = (int)(fmod(pPlanetDesc->rot_speed * daysElapsed(), pPlanetDesc->rotwidth));
+		if (pPlanetDesc->rotPointIndex < 0)
+			pPlanetDesc->rotPointIndex += pPlanetDesc->rotwidth;
+
+		// Nothing to do if there has been no visible rotation
+		if (pPlanetDesc->rotPointIndex == oldPointIndex)
+			return;
+	}
 	// Generate the next rotation frame
 	// We alternate between the frames because we do not call FlushGraphics()
 	// The frame we just drew may not have made it to the screen yet
-	rotFrameIndex ^= 1;
-
-	// Go to next point, taking care of wraparounds
-	rotPointIndex += rotDirection;
-	if (rotPointIndex < 0)
-		rotPointIndex = MAP_WIDTH - 1;
-	else if (rotPointIndex >= MAP_WIDTH)
-		rotPointIndex = 0;
+	if (inOrbit){
+		rotFrameIndex ^= 1;
+		rotPointIndex += rotDirection;
+		if (rotPointIndex < 0)
+			rotPointIndex = rotwidth - 1;
+		else if (rotPointIndex >= rotwidth)
+			rotPointIndex = 0;
+	} else {
+		pPlanetDesc->rotFrameIndex ^= 1;
+	}
 
 	// prepare the next sphere frame
-	Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, rotFrameIndex);
-	RenderPlanetSphere (Orbit->SphereFrame, rotPointIndex, throbShield);
+	if(inOrbit){
+		Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, rotFrameIndex);
+		//RenderPlanetSphere (Orbit->SphereFrame, rotPointIndex, throbShield);
+		RenderPlanetSphere (Orbit, Orbit->SphereFrame, rotPointIndex, pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED, throbShield, rotwidth, rotheight, rotheight >> 1); // RADIUS
 	
-	if (throbShield)
-	{	// prepare the next shield throb frame
-		Orbit->ObjectFrame = SetAbsFrameIndex (Orbit->ObjectFrame,
-				rotFrameIndex);
-		SetShieldThrobEffect (Orbit->WorkFrame, rotPointIndex,
-				Orbit->ObjectFrame);
+		if (throbShield)
+		{	// prepare the next shield throb frame
+			Orbit->ObjectFrame = SetAbsFrameIndex (Orbit->ObjectFrame,
+					rotFrameIndex);
+			SetShieldThrobEffect (Orbit->WorkFrame, rotPointIndex,
+					Orbit->ObjectFrame);
+		}	
+	} else {
+		Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, pPlanetDesc->rotFrameIndex);
+		RenderPlanetSphere (Orbit, Orbit->SphereFrame, pPlanetDesc->rotPointIndex, pPlanetDesc->data_index & PLANET_SHIELDED, FALSE, pPlanetDesc->rotwidth, pPlanetDesc->rotheight, pPlanetDesc->rotheight >> 1); // RADIUS
+		Orbit->SphereFrame->image->dirty = TRUE;
 	}
+	// BW: slightly hacky but, in DrawTexturedBody, the call
+	// to DrawStamp won't re-blit the frame unless scale has changed.
 }
 
 #define ZOOM_RATE  24
@@ -209,7 +262,7 @@ ZoomInPlanetSphere (void)
 		repairRect.corner.x = pt.x + frameRect.corner.x;
 		repairRect.corner.y = pt.y + frameRect.corner.y;
 
-		PrepareNextRotationFrame ();
+		PrepareNextRotationFrame (NULL, NULL, TRUE);
 
 		SleepThreadUntil (NextTime);
 	}
@@ -227,7 +280,7 @@ RotatePlanetSphere (BOOLEAN keepRate)
 	NextTime = Now + PLANET_ROTATION_RATE;
 	DrawDefaultPlanetSphere ();
 
-	PrepareNextRotationFrame ();
+	PrepareNextRotationFrame (NULL, NULL, TRUE);
 }
 
 static void
diff -ruNp src.orig/uqm/planets/plandata.h src/uqm/planets/plandata.h
--- src.orig/uqm/planets/plandata.h	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/plandata.h	2017-11-22 08:52:12 -0600
@@ -279,6 +279,16 @@ typedef struct
 	DWORD ScanSeed[NUM_SCAN_TYPES];
 	DWORD ScanRetrieveMask[NUM_SCAN_TYPES];
 
+	// JMS: This stores the amount of partially scavenged minerals.
+	//
+	// How it works: When the mineral deposits are generated in scan.c, first the deposit
+	// is given its normal kiloton-size (decided by pseudo-random number). Then, the value
+	// stored in this list is subtracted from the initial value.
+	// There can be max DWORD = 32 mineral deposits on the planet, thus the 32.
+	//
+	// This can be later made to support also partially scavenged biodata.
+	BYTE  PartiallyScavengedList[NUM_SCAN_TYPES][32];
+
 	STRING DiscoveryString;
 	FONT LanderFont;
 	FRAME LanderFontEff;
@@ -301,6 +311,17 @@ extern UWORD CalcGravity (const PLANET_I
 #define COLD_THRESHOLD -40
 #define HOT_THRESHOLD 100
 
+#define SOL_COLOR_TABS \
+	MERCURY_COLOR_TAB, \
+	VENUS_COLOR_TAB, \
+	EARTH_COLOR_TAB, \
+	MARS_COLOR_TAB, \
+	JUPITER_COLOR_TAB, \
+	SATURN_COLOR_TAB, \
+	URANUS_COLOR_TAB, \
+	NEPTUNE_COLOR_TAB, \
+	PLUTO_COLOR_TAB
+
 /*------------------------------ Global Data ------------------------------ */
 
 #define NO_TECTONICS 0
diff -ruNp src.orig/uqm/planets/planets.c src/uqm/planets/planets.c
--- src.orig/uqm/planets/planets.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/planets.c	2017-11-22 08:52:12 -0600
@@ -266,7 +266,7 @@ LoadPlanet (FRAME SurfDefFrame)
 	StopMusic ();
 
 	pPlanetDesc = pSolarSysState->pOrbitalDesc;
-	GeneratePlanetSurface (pPlanetDesc, SurfDefFrame);
+	GeneratePlanetSurface (pPlanetDesc, SurfDefFrame, MAP_WIDTH, MAP_HEIGHT, TRUE);
 	SetPlanetMusic (pPlanetDesc->data_index & ~PLANET_SHIELDED);
 	GeneratePlanetSide ();
 
@@ -287,7 +287,7 @@ LoadPlanet (FRAME SurfDefFrame)
 void
 FreePlanet (void)
 {
-	COUNT i;
+	COUNT i, j;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 
 	UninitSphereRotation ();
@@ -330,6 +330,19 @@ FreePlanet (void)
 	Orbit->TopoColors = NULL;
 	HFree (Orbit->ScratchArray);
 	Orbit->ScratchArray = NULL;
+	if (Orbit->map_rotate && Orbit->light_diff)
+	{
+		for (j=0 ; j < MAP_HEIGHT+1 ; j++)
+		{
+			HFree (Orbit->map_rotate[j]);
+			HFree (Orbit->light_diff[j]);
+		}
+	}
+
+	HFree (Orbit->map_rotate);
+	Orbit->map_rotate = NULL;
+	HFree (Orbit->light_diff);
+	Orbit->light_diff = NULL;
 
 	DestroyStringTable (ReleaseStringTable (
 			pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
diff -ruNp src.orig/uqm/planets/planets.h src/uqm/planets/planets.h
--- src.orig/uqm/planets/planets.h	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/planets.h	2017-11-22 08:52:12 -0600
@@ -23,6 +23,15 @@
 
 #define END_INTERPLANETARY START_INTERPLANETARY
 
+#define ORBITING_PLANETS optOrbitingPlanets
+#define TEXTURED_PLANETS optTexturedPlanets
+#define ROTATING_PLANETS TEXTURED_PLANETS
+// ROTATING_PLANETS should always be defined TRUE if TEXTURED_PLANETS is.
+#define ONE_YEAR 365.25
+#ifndef M_PI
+#define M_PI 3.141592653589
+#endif
+
 enum PlanetScanTypes
 {
 	MINERAL_SCAN = 0,
@@ -54,7 +63,8 @@ enum
 	LANDER_DESTROYED
 };
 
-#define MAX_SCROUNGED 50 /* max lander can hold */
+#define MAX_SCROUNGED 64 /* max units lander can hold (was 64 in SC2 DOS) */
+#define MAX_HOLD_BARS 50 /* number of bars on the lander screen */
 
 #define SCALE_RADIUS(r) ((r) << 6)
 #define UNSCALE_RADIUS(r) ((r) >> 6)
@@ -101,6 +111,41 @@ typedef struct solarsys_state SOLARSYS_S
 #include "lifeform.h"
 #include "plandata.h"
 #include "sundata.h"
+ 
+typedef struct 
+{
+	POINT p[4];
+	DWORD m[4];
+} MAP3D_POINT;
+
+struct planet_orbit
+{
+	FRAME TopoZoomFrame;
+			// 4x scaled topo image for planet-side
+	SBYTE  *lpTopoData;
+			// normal topo data; expressed in elevation levels
+			// data is signed for planets other than gas giants
+			// transformed to light variance map for 3d planet
+	FRAME SphereFrame;
+			// rotating 3d planet frames (current and next)
+	FRAME ObjectFrame;
+			// any extra planetary object (shield, atmo, rings)
+			// automatically drawn if present
+	FRAME TintFrame;
+			// tinted topo images for current scan type (dynamic)
+	Color TintColor;
+			// the color of the last used tint
+	Color *TopoColors;
+			// RGBA version of topo image; for 3d planet
+	Color *ScratchArray;
+			// temp RGBA data for whatever transforms (nuked often)
+	FRAME WorkFrame;
+			// any extra frame workspace (for dynamic objects)
+	// BW: extra stuff for animated IP
+	DWORD **light_diff;
+	MAP3D_POINT **map_rotate;
+	// doubly dynamically allocated depending on map size
+};
 
 #if defined(__cplusplus)
 extern "C" {
@@ -113,7 +158,10 @@ struct planet_desc
 	BYTE data_index;
 	BYTE NumPlanets;
 	SIZE radius;
+	COUNT angle;
 	POINT location;
+	double orb_speed;
+	double rot_speed;
 
 	Color temp_color;
 	COUNT NextIndex;
@@ -121,6 +169,12 @@ struct planet_desc
 
 	PLANET_DESC *pPrevDesc;
 			// The Sun or planet that this world is orbiting around.
+	// BW : new stuff for animated solar systems
+	PLANET_ORBIT orbit;
+	COUNT size;
+	int rotFrameIndex, rotPointIndex, rotDirection, rotwidth, rotheight;
+	
+	RESOURCE alternate_colormap; // JMS: Special color maps for Sol system planets
 };
 
 struct star_desc
@@ -153,31 +207,6 @@ struct node_info
 			// For energy: undefined
 };
 
-struct planet_orbit
-{
-	FRAME TopoZoomFrame;
-			// 4x scaled topo image for planet-side
-	SBYTE  *lpTopoData;
-			// normal topo data; expressed in elevation levels
-			// data is signed for planets other than gas giants
-			// transformed to light variance map for 3d planet
-	FRAME SphereFrame;
-			// rotating 3d planet frames (current and next)
-	FRAME ObjectFrame;
-			// any extra planetary object (shield, atmo, rings)
-			// automatically drawn if present
-	FRAME TintFrame;
-			// tinted topo images for current scan type (dynamic)
-	Color TintColor;
-			// the color of the last used tint
-	Color *TopoColors;
-			// RGBA version of topo image; for 3d planet
-	Color *ScratchArray;
-			// temp RGBA data for whatever transforms (nuked often)
-	FRAME WorkFrame;
-			// any extra frame workspace (for dynamic objects)
-};
-
 // See doc/devel/generate for information on how this structure is
 // filled.
 struct solarsys_state
@@ -286,16 +315,17 @@ extern void DrawStarBackGround (void);
 extern void XFormIPLoc (POINT *pIn, POINT *pOut, BOOLEAN ToDisplay);
 extern void DrawOval (RECT *pRect, BYTE num_off_pixels);
 extern void DrawFilledOval (RECT *pRect);
+extern void ComputeSpeed(PLANET_DESC *planet, BOOLEAN GeneratingMoons, UWORD rand_val);
 extern void FillOrbits (SOLARSYS_STATE *system, BYTE NumPlanets,
 		PLANET_DESC *pBaseDesc, BOOLEAN TypesDefined);
 extern void InitLander (BYTE LanderFlags);
 
-extern void InitSphereRotation (int direction, BOOLEAN shielded);
+extern void InitSphereRotation (int direction, BOOLEAN shielded, COUNT width, COUNT height);
 extern void UninitSphereRotation (void);
-extern void PrepareNextRotationFrame (void);
+extern void PrepareNextRotationFrame (PLANET_DESC *pPlanetDesc, SIZE frameCounter, BOOLEAN inOrbit);
 extern void DrawPlanetSphere (int x, int y);
 extern void DrawDefaultPlanetSphere (void);
-extern void RenderPlanetSphere (FRAME Frame, int offset, BOOLEAN doThrob);
+extern void RenderPlanetSphere (PLANET_ORBIT *Orbit, FRAME Frame, int offset, BOOLEAN shielded, BOOLEAN doThrob, COUNT width, COUNT height, COUNT radius);
 extern void SetShieldThrobEffect (FRAME FromFrame, int offset, FRAME ToFrame);
 
 extern void ZoomInPlanetSphere (void);
@@ -303,7 +333,7 @@ extern void RotatePlanetSphere (BOOLEAN
 
 extern void DrawScannedObjects (BOOLEAN Reversed);
 extern void GeneratePlanetSurface (PLANET_DESC *pPlanetDesc,
-		FRAME SurfDefFrame);
+		FRAME SurfDefFrame, COUNT width, COUNT height, BOOLEAN inOrbit);
 extern void DeltaTopography (COUNT num_iterations, SBYTE *DepthArray,
 		RECT *pRect, SIZE depth_delta);
 
diff -ruNp src.orig/uqm/planets/plangen.c src/uqm/planets/plangen.c
--- src.orig/uqm/planets/plangen.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/plangen.c	2017-11-22 08:52:12 -0600
@@ -16,6 +16,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// BW 2011: fixed using pixmaps to define planet surfaces so it actually works
+// on planets you can land on. The second frame of planetmask.ani has to be a
+// (Black & White) indexed pic with 128 colors top. Lesser indices (black)
+// will correspond to lower altitudes.
+
 #include "planets.h"
 #include "scan.h"
 #include "../nameref.h"
@@ -72,15 +77,22 @@
 #define M_DEG2RAD (M_TWOPI / 360.0)
 #endif
 
-DWORD light_diff[DIAMETER][DIAMETER];
-
-typedef struct 
-{
-	POINT p[4];
-	DWORD m[4];
-} MAP3D_POINT;
-
-MAP3D_POINT map_rotate[DIAMETER][DIAMETER];
+// BW: dynamically allocated in the orbit structure
+// JMS_GFX: Changed initialization to constant numbers since DIAMETER is now variably defined
+// The value 330 is the value that's reached at the biggest resolution, 4x.
+// DWORD light_diff[330][330]; //DWORD light_diff[DIAMETER][DIAMETER];
+
+// BW: Moved to planets.h
+// typedef struct 
+// {
+// 	POINT p[4];
+// 	DWORD m[4];
+// } MAP3D_POINT;
+
+// BW: dynamically allocated in the orbit structure
+// JMS_GFX: Changed initialization to constant numbers since DIAMETER is now variably defined
+// The value 330 is the value that's reached at the biggest resolution, 4x.
+// MAP3D_POINT map_rotate[330][330];//MAP3D_POINT map_rotate[DIAMETER][DIAMETER];
 
 typedef struct
 {
@@ -88,109 +100,76 @@ typedef struct
 } POINT3;
 
 static void
-RenderTopography (FRAME DstFrame, SBYTE *pTopoData, int w, int h)
+RenderTopography (FRAME DstFrame, SBYTE *pTopoData, int w, int h, BOOLEAN SurfDef)
 {
-	FRAME OldFrame;
-
-	OldFrame = SetContextFGFrame (DstFrame);
-
-	if (pSolarSysState->XlatRef == 0)
-	{
+	if (pSolarSysState->XlatRef == 0) {
 		// There is currently nothing we can do w/o an xlat table
 		// This is still called for Earth for 4x scaled topo, but we
 		// do not need it because we cannot land on Earth.
-	}
-	else
-	{
-		COUNT i;
+		log_add(log_Warning, "No xlat table -- could not generate surface.\n");
+	} else {
 		BYTE AlgoType;
 		SIZE base, d;
 		const XLAT_DESC *xlatDesc;
 		POINT pt;
 		const PlanetFrame *PlanDataPtr;
-		PRIMITIVE BatchArray[NUM_BATCH_POINTS];
-		PRIMITIVE *pBatch;
 		SBYTE *pSrc;
 		const BYTE *xlat_tab;
 		BYTE *cbase;
-		POINT oldOrigin;
-		RECT ClipRect;
-
-		oldOrigin = SetContextOrigin (MAKE_POINT (0, 0));
-		GetContextClipRect (&ClipRect);
-		SetContextClipRect (NULL);
+		Color *pix;
+		Color *map;
+		BYTE ColorShift; // JMS
 
-		pBatch = &BatchArray[0];
-		for (i = 0; i < NUM_BATCH_POINTS; ++i, ++pBatch)
-		{
-			SetPrimNextLink (pBatch, i + 1);
-			SetPrimType (pBatch, POINT_PRIM);
-		}
-		SetPrimNextLink (&pBatch[-1], END_OF_LIST);
+		map = HMalloc (sizeof (Color) * w * h);
+		pix = map;
 
-		PlanDataPtr = &PlanData[
-				pSolarSysState->pOrbitalDesc->data_index & ~PLANET_SHIELDED
-				];
+		PlanDataPtr = &PlanData[pSolarSysState->pOrbitalDesc->data_index & ~PLANET_SHIELDED];
 		AlgoType = PLANALGO (PlanDataPtr->Type);
-		base = PlanDataPtr->base_elevation;
+		if (SurfDef) {
+			// Planets given by a pixmap have elevations between -128 and +128
+			base = 256;
+		} else {
+			base = PlanDataPtr->base_elevation;
+		}
 		xlatDesc = (const XLAT_DESC *) pSolarSysState->XlatPtr;
 		xlat_tab = (const BYTE *) xlatDesc->xlat_tab;
 		cbase = GetColorMapAddress (pSolarSysState->OrbitalCMap);
 
-		i = NUM_BATCH_POINTS;
-		pBatch = &BatchArray[i];
+		// JMS: This is for using 8-bits per color channel .ct files for e.g. Mars.
+		if (SurfDef){
+			ColorShift = 3;
+		} else {
+			ColorShift = 1;
+		}
 		pSrc = pTopoData;
-		for (pt.y = 0; pt.y < h; ++pt.y)
-		{
-			for (pt.x = 0; pt.x < w; ++pt.x, ++pSrc)
-			{
+		for (pt.y = 0; pt.y < h; ++pt.y) {
+			for (pt.x = 0; pt.x < w; ++pt.x, ++pSrc, ++pix) {
 				BYTE *ctab;
 
 				d = *pSrc;
-				if (AlgoType == GAS_GIANT_ALGO)
-				{	// make elevation value non-negative
+				if (AlgoType == GAS_GIANT_ALGO) {	
+					// make elevation value non-negative
 					d &= 255;
-				}
-				else
-				{
+				} else {
 					d += base;
-					if (d < 0)
+					if (d < 0){
 						d = 0;
-					else if (d > 255)
+					} else if (d > 255) {
 						d = 255;
+					}
 				}
 
-				--pBatch;
-				pBatch->Object.Point.x = pt.x;
-				pBatch->Object.Point.y = pt.y;
-
 				d = xlat_tab[d] - cbase[0];
 				ctab = (cbase + 2) + d * 3;
 
 				// fixed planet surfaces being too dark
 				// ctab shifts were previously >> 3 .. -Mika
-				SetPrimColor (pBatch, BUILD_COLOR (MAKE_RGB15 (ctab[0] >> 1,
-								ctab[1] >> 1, ctab[2] >> 1), d));
-				
-				if (--i == 0)
-				{	// flush the batch and start the next one
-					DrawBatch (BatchArray, 0, 0);
-					i = NUM_BATCH_POINTS;
-					pBatch = &BatchArray[i];
-				}
+				*pix = BUILD_COLOR (MAKE_RGB15 (ctab[0] >> ColorShift, ctab[1] >> ColorShift, ctab[2] >> ColorShift), d);	
 			}
 		}
-
-		if (i < NUM_BATCH_POINTS)
-		{
-			DrawBatch (BatchArray, i, 0);
-		}
-
-		SetContextClipRect (&ClipRect);
-		SetContextOrigin (oldOrigin);
+		WriteFramePixelColors (DstFrame, map, w, h);
+		HFree(map);
 	}
-
-	SetContextFGFrame (OldFrame);
 }
 
 static inline void
@@ -225,13 +204,16 @@ P3norm (POINT3 *res, POINT3 *vec)
 // GenerateSphereMask builds a shadow map for the rotating planet
 //  loc indicates the planet's position relative to the sun
 static void
-GenerateSphereMask (POINT loc)
+GenerateSphereMask (POINT loc, COUNT radius)
 {
 	POINT pt;
 	POINT3 light;
 	double lrad;
 	const DWORD step = 1 << DIFFUSE_BITS;
 	int y, x;
+	COUNT tworadius = radius << 1;
+	COUNT radius_thres = (radius + 1) * (radius + 1);
+	COUNT radius_2 = radius * radius;
 
 #define AMBIENT_LIGHT 0.1
 #define LIGHT_Z       1.2
@@ -244,11 +226,11 @@ GenerateSphereMask (POINT loc)
 	light.z = LIGHT_Z * lrad;
 	P3norm (&light, &light);
 	
-	for (pt.y = 0, y = -RADIUS; pt.y <= TWORADIUS; ++pt.y, y++)
+	for (pt.y = 0, y = -radius; pt.y <= tworadius; ++pt.y, y++)
 	{
 		DWORD y_2 = y * y;
 
-		for (pt.x = 0, x = -RADIUS; pt.x <= TWORADIUS; ++pt.x, x++)
+		for (pt.x = 0, x = -radius; pt.x <= tworadius; ++pt.x, x++)
 		{
 			DWORD x_2 = x * x;
 			DWORD rad_2 = x_2 + y_2;
@@ -256,13 +238,13 @@ GenerateSphereMask (POINT loc)
 			POINT3 norm;
 			double diff;
 			
-			if (rad_2 < RADIUS_THRES) 
+			if (rad_2 < radius_thres)
 			{
 				// norm is the sphere's surface normal.
 				norm.x = (double)x;
 				norm.y = (double)y;
-				norm.z = (sqrt (RADIUS_2 - x_2) * sqrt (RADIUS_2 - y_2)) /
-						RADIUS;
+				norm.z = (sqrt (radius_2 - x_2) * sqrt (radius_2 - y_2)) /
+						radius;
 				P3norm (&norm, &norm);
 				// diffuse component is norm dot light
 				diff = P3dot (&norm, &light);
@@ -305,9 +287,9 @@ GenerateSphereMask (POINT loc)
 				if (diff < AMBIENT_LIGHT)
 					diff = AMBIENT_LIGHT;
 				// Now we antialias the edge of the spere to look nice
-				if (rad_2 > RADIUS_2) 
+				if (rad_2 > radius_2)
 				{
-					diff *= 1 - (sqrt(rad_2) - RADIUS);
+					diff *= 1 - (sqrt(rad_2) - radius);
 					if (diff < 0) 
 						diff = 0;
 				}
@@ -315,8 +297,7 @@ GenerateSphereMask (POINT loc)
 				// floating-point.
 				diff_int = (DWORD)(diff * step);
 			}
-
-			light_diff[pt.y][pt.x] = diff_int;
+			pSolarSysState->Orbit.light_diff[pt.y][pt.x] = diff_int;
 		}
 	}
 }
@@ -326,21 +307,22 @@ GenerateSphereMask (POINT loc)
 //  the concept is to compute the weight based on the
 //  distance from the integer location points to the ideal point
 static void
-create_aa_points (MAP3D_POINT *ppt, double x, double y)
+create_aa_points (MAP3D_POINT *ppt, double x, double y, COUNT height)
 {
 	double deltax, deltay, inv_deltax, inv_deltay;
 	COORD nextx, nexty;
 	COUNT i;
 	double d1, d2, d3, d4, m[4];
+	COUNT spherespanx = height;
 
 	if (x < 0)
 		x = 0;
-	else if (x >= SPHERE_SPAN_X)
-		x = SPHERE_SPAN_X - 1;
+	else if (x >= spherespanx)
+		x = spherespanx - 1;
 	if (y < 0)
 		y = 0;
-	else if (y >= MAP_HEIGHT)
-		y = MAP_HEIGHT - 1;
+	else if (y >= height)
+		y = height - 1;
 
 	// get  the integer value of this point
 	ppt->p[0].x = (COORD)x;
@@ -437,30 +419,32 @@ get_avg_channel (Color p[4], DWORD mult[
 // CreateSphereTiltMap creates 'map_rotate' to map the topo data
 //  for a tilted planet.  It also does the sphere->plane mapping
 static void
-CreateSphereTiltMap (int angle)
+CreateSphereTiltMap (int angle, COUNT height, COUNT radius)
 {
 	int x, y;
-	const double multx = ((double)SPHERE_SPAN_X / M_PI);
-	const double multy = ((double)MAP_HEIGHT / M_PI);
-	const double xadj = ((double)SPHERE_SPAN_X / 2.0);
+	COUNT spherespanx = height;
+	COUNT radius_thres = (radius + 1) * (radius + 1);
+	const double multx = ((double)spherespanx / M_PI);
+	const double multy = ((double)height / M_PI);
+	const double xadj = ((double)spherespanx / 2.0);
 
-	for (y = -RADIUS; y <= RADIUS; y++)
+	for (y = -radius; y <= radius; y++)
 	{
 		int y_2 = y * y;
 
-		for (x = -RADIUS; x <= RADIUS; x++)
+		for (x = -radius; x <= radius; x++)
 		{
 			double dx, dy, newx, newy;
 			double da, rad, rad_2;
 			double xa, ya;
-			MAP3D_POINT *ppt = &map_rotate[y + RADIUS][x + RADIUS];
+			MAP3D_POINT *ppt = &pSolarSysState->Orbit.map_rotate[y + radius][x + radius];
 			
 			rad_2 = x * x + y_2;
 
-			if (rad_2 >= RADIUS_THRES)
+			if (rad_2 >= radius_thres)
 			{	// pixel won't be present
-				ppt->p[0].x = x + RADIUS;
-				ppt->p[0].y = y + RADIUS;
+				ppt->p[0].x = x + radius;
+				ppt->p[0].y = y + radius;
 				ppt->m[0] = 0;
 
 				continue;
@@ -468,8 +452,8 @@ CreateSphereTiltMap (int angle)
 			
 			rad = sqrt (rad_2);
 			// antialiasing goes beyond the actual radius
-			if (rad >= RADIUS)
-				rad = (double)RADIUS - 0.1;
+			if (rad >= radius)
+				rad = (double)radius - 0.1;
 			
 			da = atan2 ((double)y, (double)x);
 			// compute the planet-tilt
@@ -478,8 +462,8 @@ CreateSphereTiltMap (int angle)
 			dy = rad * sin (da);
 
 			// Map the sphere onto a plane
-			xa = acos (-dx / RADIUS);
-			ya = acos (-dy / RADIUS);
+			xa = acos (-dx / radius);
+			ya = acos (-dy / radius);
 			newx = multx * xa;
 			newy = multy * ya;
 			// Adjust for vertical curvature
@@ -488,7 +472,7 @@ CreateSphereTiltMap (int angle)
 			else
 				newx = xadj + ((newx - xadj) / sin (ya));
 
-			create_aa_points (ppt, newx, newy);
+			create_aa_points (ppt, newx, newy, height);
 		}
 	}
 }
@@ -501,34 +485,44 @@ CreateSphereTiltMap (int angle)
 // this routine, but a filter can be applied if desired too.
 
 // HALO rim size
-#define SHIELD_HALO          7
+#define SHIELD_HALO          6
 #define SHIELD_RADIUS        (RADIUS + SHIELD_HALO)
-#define SHIELD_DIAM          ((SHIELD_RADIUS << 1) + 1)
-#define SHIELD_RADIUS_2      (SHIELD_RADIUS * SHIELD_RADIUS)
-#define SHIELD_RADIUS_THRES  ((SHIELD_RADIUS + 1) * (SHIELD_RADIUS + 1))
 #define SHIELD_HALO_GLOW     (SHIELD_GLOW_COMP + SHIELD_REFLECT_COMP)
 #define SHIELD_HALO_GLOW_MIN (SHIELD_HALO_GLOW >> 2)
 
 static FRAME
-CreateShieldMask (void)
+CreateShieldMask (COUNT Radius, BOOLEAN forOrbit)
 {
-	Color clear;
-	Color *pix;
+	Color clear, *pix;
 	int x, y;
 	FRAME ShieldFrame;
+	COUNT ShieldHalo, ShieldRadius, ShieldDiam, RadiusSquared, ShieldRadiusThreshold;
+
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 
+	if (forOrbit){
+		ShieldHalo = SHIELD_HALO;
+		ShieldRadius = (Radius + ShieldHalo) * Radius / RADIUS;
+		RadiusSquared = pow((double)Radius, 2); // Radius * Radius;
+	} else {
+		ShieldHalo = SHIELD_HALO << 1;
+		ShieldRadius = (RADIUS + ShieldHalo) * Radius / RADIUS;
+		RadiusSquared = pow((double)RADIUS, 2); // RADIUS * RADIUS;
+	}	
+	ShieldDiam = (ShieldRadius << 1) + 1;
+	ShieldRadiusThreshold = pow((double)(ShieldRadius + 1), 2); // (ShieldRadius + 1) * (ShieldRadius + 1);
+
 	ShieldFrame = CaptureDrawable (
 			CreateDrawable (WANT_PIXMAP | WANT_ALPHA,
-				SHIELD_DIAM, SHIELD_DIAM, 1));
+				ShieldDiam, ShieldDiam, 1));
 
 	pix = Orbit->ScratchArray;
 	//  This is 100% transparent.
 	clear = BUILD_COLOR_RGBA (0, 0, 0, 0);
 
-	for (y = -SHIELD_RADIUS; y <= SHIELD_RADIUS; y++)
+	for (y = -ShieldRadius; y <= ShieldRadius; y++)
 	{
-		for (x = -SHIELD_RADIUS; x <= SHIELD_RADIUS; ++x, ++pix)
+		for (x = -ShieldRadius; x <= ShieldRadius; ++x, ++pix)
 		{
 			int rad_2 = x * x + y * y;
 			// This is a non-transparent red for the halo
@@ -536,13 +530,13 @@ CreateShieldMask (void)
 			int alpha = 255;
 			double rad;
 			
-			if (rad_2 >= SHIELD_RADIUS_THRES)
+			if (rad_2 >= ShieldRadiusThreshold)
 			{	// outside all bounds
 				*pix = clear;
 				continue;
 			}
 			// Inside the halo
-			if (rad_2 <= RADIUS_2)
+			if (rad_2 <= RadiusSquared)
 			{	// planet's pixels, ours transparent
 				*pix = clear;
 				continue;
@@ -551,16 +545,16 @@ CreateShieldMask (void)
 			// The halo itself
 			rad = sqrt (rad_2);
 
-			if (rad <= RADIUS + 0.8)
+			if (rad <= Radius + 0.8)
 			{	// pixels common between the shield and planet
 				// do antialiasing using alpha
-				alpha = (int) (red * (rad - RADIUS));
+				alpha = (int) (red * (rad - Radius));
 				red = 255;
 			}
 			else
 			{	// shield pixels
-				red -= (int) ((red - SHIELD_HALO_GLOW_MIN) * (rad - RADIUS)
-						/ SHIELD_HALO);
+				red -= (int) ((red - SHIELD_HALO_GLOW_MIN) * (rad - Radius) / (ShieldHalo * Radius / RADIUS));
+				
 				if (red < 0)
 					red = 0;
 			}
@@ -570,9 +564,9 @@ CreateShieldMask (void)
 	}
 	
 	WriteFramePixelColors (ShieldFrame, Orbit->ScratchArray,
-			SHIELD_DIAM, SHIELD_DIAM);
-	SetFrameHot (ShieldFrame, MAKE_HOT_SPOT (SHIELD_RADIUS + 1,
-				SHIELD_RADIUS + 1));
+			ShieldDiam, ShieldDiam);
+	SetFrameHot (ShieldFrame, MAKE_HOT_SPOT (ShieldRadius + 1,
+				ShieldRadius + 1));
 	
 	return ShieldFrame;
 }
@@ -611,10 +605,11 @@ SetShieldThrobEffect (FRAME ShieldFrame,
 	Color *pix;
 	int level;
 
+	width = GetFrameWidth (ShieldFrame);
+	height = GetFrameHeight (ShieldFrame);	
+
 	level = shield_level (offset);
 
-	width = GetFrameWidth (ShieldFrame);
-	height = GetFrameHeight (ShieldFrame);
 	ReadFramePixelColors (ShieldFrame, Orbit->ScratchArray, width, height);
 	
 	for (i = 0, pix = Orbit->ScratchArray; i < width * height; ++i, ++pix)
@@ -685,24 +680,25 @@ calc_map_light (UBYTE val, DWORD dif, in
 }
 
 static inline Color
-get_map_pixel (Color *pixels, int x, int y)
+get_map_pixel (Color *pixels, int x, int y, COUNT width, COUNT spherespanx)
 {
-	return pixels[y * (MAP_WIDTH + SPHERE_SPAN_X) + x];
+	/*if (y * (width + spherespanx) + x > 463000)
+		log_add(log_Warning,"x:%u, y:%u, width:%u, spherespanx:%u, slot:%u. Max:%u", x, y, width, spherespanx, y * (width + spherespanx) + x, (MAP_HEIGHT+1) * (MAP_WIDTH + spherespanx));*/
+	return pixels[y * (width + spherespanx) + x];
 }
 
 static inline int
-get_map_elev (SBYTE *elevs, int x, int y, int offset)
+get_map_elev (SBYTE *elevs, int x, int y, int offset, COUNT width)
 {
-	return elevs[y * MAP_WIDTH + (offset + x) % MAP_WIDTH];
+	return elevs[y * width + (offset + x) % width];
 }
 
 // RenderPlanetSphere builds a frame for the rotating planet view
 // offset is effectively the angle of rotation around the planet's axis
 // We use the SDL routines to directly write to the SDL_Surface to improve performance
 void
-RenderPlanetSphere (FRAME MaskFrame, int offset, BOOLEAN doThrob)
+RenderPlanetSphere (PLANET_ORBIT *Orbit, FRAME MaskFrame, int offset, BOOLEAN shielded, BOOLEAN doThrob, COUNT width, COUNT height, COUNT radius)
 {
-	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 	POINT pt;
 	Color *pix;
 	Color clear;
@@ -710,7 +706,10 @@ RenderPlanetSphere (FRAME MaskFrame, int
 	Color *pixels;
 	SBYTE *elevs;
 	int shLevel;
-
+	COUNT spherespanx = height;
+	COUNT tworadius = radius << 1;
+	COUNT diameter = tworadius + 1;
+	
 #if PROFILE_ROTATION
 	static clock_t t = 0;
 	static int frames_done = 1;
@@ -726,14 +725,14 @@ RenderPlanetSphere (FRAME MaskFrame, int
 	pixels = Orbit->TopoColors + offset;
 	elevs = Orbit->lpTopoData;
 	
-	for (pt.y = 0, y = -RADIUS; pt.y <= TWORADIUS; ++pt.y, ++y)
+	for (pt.y = 0, y = -radius; pt.y <= tworadius; ++pt.y, ++y)
 	{
-		for (pt.x = 0, x = -RADIUS; pt.x <= TWORADIUS; ++pt.x, ++x, ++pix)
+		for (pt.x = 0, x = -radius; pt.x <= tworadius; ++pt.x, ++x, ++pix)
 		{
 			Color c;
-			DWORD diffus = light_diff[pt.y][pt.x];
+			DWORD diffus = Orbit->light_diff[pt.y][pt.x];
 			int i;
-			MAP3D_POINT *ppt = &map_rotate[pt.y][pt.x];
+			MAP3D_POINT *ppt = &Orbit->map_rotate[pt.y][pt.x];
 			int lvf; // light variance factor
 	
 			if (diffus == 0)
@@ -745,8 +744,8 @@ RenderPlanetSphere (FRAME MaskFrame, int
 			// get pixel from topo map and factor from light variance map
 			if (ppt->m[0] == 0) 
 			{	// exact pixel from the topo map
-				c = get_map_pixel (pixels, ppt->p[0].x, ppt->p[0].y);
-				lvf = get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y, offset);
+				c = get_map_pixel (pixels, ppt->p[0].x, ppt->p[0].y, width, spherespanx);
+				lvf = get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y, offset, width);
 			}
 			else
 			{	// fractional pixel -- blend from 4
@@ -755,7 +754,7 @@ RenderPlanetSphere (FRAME MaskFrame, int
 
 				// compute 'ideal' pixel
 				for (i = 0; i < 4; i++)
-					p[i] = get_map_pixel (pixels, ppt->p[i].x, ppt->p[i].y);
+					p[i] = get_map_pixel (pixels, ppt->p[i].x, ppt->p[i].y, width, spherespanx);
 				
 				c.r = get_avg_channel (p, ppt->m, 0);
 				c.g = get_avg_channel (p, ppt->m, 1);
@@ -764,13 +763,13 @@ RenderPlanetSphere (FRAME MaskFrame, int
 				// compute 'ideal' light variance
 				for (i = 0, lvsum = 0; i < 4; i++)
 					lvsum += get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y,
-							offset) * ppt->m[i];
+							       offset, width) * ppt->m[i];
 				lvf = lvsum >> AA_WEIGHT_BITS;
 			}
 		
 			// Apply the lighting model.  This also bounds the sphere
 			// to make it circular.
-			if (pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED)
+			if (shielded)
 			{
 				int r;
 				
@@ -808,12 +807,12 @@ RenderPlanetSphere (FRAME MaskFrame, int
 		}
 	}
 	
-	WriteFramePixelColors (MaskFrame, Orbit->ScratchArray, DIAMETER, DIAMETER);
-	SetFrameHot (MaskFrame, MAKE_HOT_SPOT (RADIUS + 1, RADIUS + 1));
+	WriteFramePixelColors (MaskFrame, Orbit->ScratchArray, diameter, diameter);
+	SetFrameHot (MaskFrame, MAKE_HOT_SPOT (radius + 1, radius + 1));
 
 #if PROFILE_ROTATION
 	t += clock() - t1;
-	if (frames_done == MAP_WIDTH)
+	if (frames_done == width)
 	{
 		log_add (log_Debug, "Rotation frames/sec: %d/%ld(msec)=%f",
 				frames_done,
@@ -831,18 +830,18 @@ RenderPlanetSphere (FRAME MaskFrame, int
 #define RANGE_SHIFT 6
 
 static void
-DitherMap (SBYTE *DepthArray)
+DitherMap (SBYTE *DepthArray, COUNT width, COUNT height)
 {
 #define DITHER_VARIANCE  (1 << (RANGE_SHIFT - 3))
-	COUNT i;
+	DWORD i;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
 	SBYTE *elev;
 	DWORD rand_val = 0;
 
-	for (i = 0, elev = DepthArray; i < MAP_WIDTH * MAP_HEIGHT; ++i, ++elev)
+	for (i = 0, elev = DepthArray; i < (DWORD)(width * height); ++i, ++elev)
 	{
 		// Use up the random value byte by byte
 		if ((i & 3) == 0)
-			rand_val = RandomContext_Random (SysGenRNG);
+			rand_val = TFB_Random ();
 		else
 			rand_val >>= 8;
 
@@ -853,14 +852,14 @@ DitherMap (SBYTE *DepthArray)
 
 static void
 MakeCrater (RECT *pRect, SBYTE *DepthArray, SIZE rim_delta, SIZE
-		crater_delta, BOOLEAN SetDepth)
+		crater_delta, BOOLEAN SetDepth, COUNT width)
 {
 	COORD x, y, lf_x, rt_x;
 	SIZE A, B;
-	long Asquared, TwoAsquared,
-				Bsquared, TwoBsquared;
-	long d, dx, dy;
+	SDWORD Asquared, TwoAsquared, Bsquared, TwoBsquared;	// JMS_GFX: Was 'long' - type changed to conform to UQM's own types
+	SDWORD d, dx, dy;									// JMS_GFX: Was 'long' - type changed to conform to UQM's own types
 	COUNT TopIndex, BotIndex, rim_pixels;
+ 
 
 	A = pRect->extent.width >> 1;
 	B = pRect->extent.height >> 1;
@@ -879,8 +878,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 
 	A += pRect->corner.x;
 	B += pRect->corner.y;
-	TopIndex = (B - y) * MAP_WIDTH;
-	BotIndex = (B + y) * MAP_WIDTH;
+	TopIndex = (B - y) * width;
+	BotIndex = (B + y) * width;
 	rim_pixels = 1;
 	while (dx < dy)
 	{
@@ -932,8 +931,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 			}
 		
 			--y;
-			TopIndex += MAP_WIDTH;
-			BotIndex -= MAP_WIDTH;
+			TopIndex += width;
+			BotIndex -= width;
 			dy -= TwoAsquared;
 			d -= dy;
 		}
@@ -1001,8 +1000,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 
 		rim_pixels = 1;
 		--y;
-		TopIndex += MAP_WIDTH;
-		BotIndex -= MAP_WIDTH;
+		TopIndex += width;
+		BotIndex -= width;
 		dy -= TwoAsquared;
 		d += Asquared - dy;
 	}
@@ -1044,9 +1043,9 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 #define NUM_BAND_COLORS 4
 
 static void
-MakeStorms (COUNT storm_count, SBYTE *DepthArray)
+MakeStorms (COUNT storm_count, SBYTE *DepthArray, COUNT width)
 {
-#define MAX_STORMS 8
+#define MAX_STORMS 12 // JMS_GFX: was 8
 	COUNT i;
 	RECT storm_r[MAX_STORMS];
 	RECT *pstorm_r;
@@ -1069,25 +1068,18 @@ MakeStorms (COUNT storm_count, SBYTE *De
 			rand_val = RandomContext_Random (SysGenRNG);
 			loword = LOWORD (rand_val);
 			hiword = HIWORD (rand_val);
-			switch (HIBYTE (hiword) & 31)
-			{
+			switch (HIBYTE (hiword) & 31) {
 				case 0:
-					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 2))
-							+ (MAP_HEIGHT >> 2);
+					pstorm_r->extent.height = (LOBYTE (hiword) % (MAP_HEIGHT >> 2)) + (MAP_HEIGHT >> 2);
 					break;
 				case 1:
 				case 2:
 				case 3:
 				case 4:
-					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 3))
-							+ (MAP_HEIGHT >> 3);
+					pstorm_r->extent.height = (LOBYTE (hiword) % (MAP_HEIGHT >> 3)) + (MAP_HEIGHT >> 3);
 					break;
 				default:
-					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 4))
-							+ 4;
+					pstorm_r->extent.height = (LOBYTE (hiword) % (MAP_HEIGHT >> 4)) + 4;
 					break;
 			}
 
@@ -1098,13 +1090,10 @@ MakeStorms (COUNT storm_count, SBYTE *De
 			loword = LOWORD (rand_val);
 			hiword = HIWORD (rand_val);
 
-			pstorm_r->extent.width = pstorm_r->extent.height
-					+ (LOBYTE (loword) % pstorm_r->extent.height);
+			pstorm_r->extent.width = pstorm_r->extent.height + (LOBYTE (loword) % pstorm_r->extent.height);
 
-			pstorm_r->corner.x = HIBYTE (loword)
-					% (MAP_WIDTH - pstorm_r->extent.width);
-			pstorm_r->corner.y = LOBYTE (loword)
-					% (MAP_HEIGHT - pstorm_r->extent.height);
+			pstorm_r->corner.x = HIBYTE (loword) % (MAP_WIDTH - pstorm_r->extent.width);
+			pstorm_r->corner.y = LOBYTE (loword) % (MAP_HEIGHT - pstorm_r->extent.height);
 
 			for (j = i + 1; j < storm_count; ++j)
 			{
@@ -1124,7 +1113,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 
 		} while (intersect);
 
-		MakeCrater (pstorm_r, DepthArray, 6, 6, FALSE);
+		MakeCrater (pstorm_r, DepthArray, 6, 6, FALSE, width);
 		++pstorm_r->corner.x;
 		++pstorm_r->corner.y;
 		pstorm_r->extent.width -= 2;
@@ -1132,8 +1121,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 
 		band_delta = HIBYTE (loword) & ((3 << RANGE_SHIFT) + 20);
 
-		MakeCrater (pstorm_r, DepthArray,
-				band_delta, band_delta, TRUE);
+		MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 		++pstorm_r->corner.x;
 		++pstorm_r->corner.y;
 		pstorm_r->extent.width -= 2;
@@ -1142,8 +1130,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		band_delta += 2;
 		if (pstorm_r->extent.width > 2 && pstorm_r->extent.height > 2)
 		{
-			MakeCrater (pstorm_r, DepthArray,
-					band_delta, band_delta, TRUE);
+			MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 			++pstorm_r->corner.x;
 			++pstorm_r->corner.y;
 			pstorm_r->extent.width -= 2;
@@ -1153,8 +1140,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		band_delta += 2;
 		if (pstorm_r->extent.width > 2 && pstorm_r->extent.height > 2)
 		{
-			MakeCrater (pstorm_r, DepthArray,
-					band_delta, band_delta, TRUE);
+			MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 			++pstorm_r->corner.x;
 			++pstorm_r->corner.y;
 			pstorm_r->extent.width -= 2;
@@ -1162,8 +1148,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		}
 
 		band_delta += 4;
-		MakeCrater (pstorm_r, DepthArray,
-				band_delta, band_delta, TRUE);
+		MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 	}
 }
 
@@ -1178,14 +1163,14 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 	UWORD loword, hiword;
 	DWORD rand_val;
 
-	band_height = pRect->extent.height / num_bands;
-	band_bump = pRect->extent.height % num_bands;
+	// band_height = pRect->extent.height / num_bands;
+	band_height = MAP_HEIGHT / num_bands;
+	// band_bump = pRect->extent.height % num_bands;
+	band_bump = MAP_HEIGHT % num_bands;
 	band_error = num_bands >> 1;
 	lpDst = DepthArray;
 
-	band_delta = ((LOWORD (RandomContext_Random (SysGenRNG))
-			& (NUM_BAND_COLORS - 1)) << RANGE_SHIFT)
-			+ (1 << (RANGE_SHIFT - 1));
+	band_delta = ((LOWORD (RandomContext_Random (SysGenRNG)) & (NUM_BAND_COLORS - 1)) << RANGE_SHIFT) + (1 << (RANGE_SHIFT - 1));
 	last_y = next_y = 0;
 	for (i = num_bands; i > 0; --i)
 	{
@@ -1207,23 +1192,22 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 		{
 			RECT r;
 
-			cur_y = next_y
-					+ ((band_height - 2) >> 1)
-					- ((LOBYTE (hiword) % (band_height - 2)) + 1);
+			cur_y = next_y + ((band_height - 2) >> 1) - ((LOBYTE (hiword) % (band_height - 2)) + 1);
+			cur_y = cur_y * pRect->extent.height / MAP_HEIGHT;
 			r.corner.x = r.corner.y = 0;
 			r.extent.width = pRect->extent.width;
-			r.extent.height = 5;
+			r.extent.height = 5 * pRect->extent.height / MAP_HEIGHT;
 			DeltaTopography (50,
-					&DepthArray[(cur_y - 2) * r.extent.width],
+					&DepthArray[(cur_y - (r.extent.height >>1)) * r.extent.width],
 					&r, depth_delta);
 		}
 
-		for (j = cur_y - last_y; j > 0; --j)
-		{
+		for (j = cur_y - last_y; j > 0; --j) {
 			COUNT k;
 
-			for (k = pRect->extent.width; k > 0; --k)
+			for (k = pRect->extent.width; k > 0; --k){
 				*lpDst++ += band_delta;
+			}
 		}
 
 		last_y = cur_y;
@@ -1232,13 +1216,13 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 				& (((1 << RANGE_SHIFT) * NUM_BAND_COLORS) - 1);
 	}
 
-	MakeStorms (4 + (RandomContext_Random (SysGenRNG) & 3) + 1, DepthArray);
+	MakeStorms (4 + (TFB_Random () & 7) + 1, DepthArray, pRect->extent.width);
 
-	DitherMap (DepthArray);
+	DitherMap (DepthArray, pRect->extent.width, pRect->extent.height);
 }
 
 static void
-ValidateMap (SBYTE *DepthArray)
+ValidateMap (SBYTE *DepthArray, COUNT width, COUNT height)
 {
 	BYTE state;
 	BYTE pixel_count[2], lb[2];
@@ -1246,7 +1230,7 @@ ValidateMap (SBYTE *DepthArray)
 	COUNT i;
 	SBYTE *lpDst;
 
-	i = MAP_WIDTH - 1;
+	i = width - 1;
 	lpDst = DepthArray;
 	last_byte = *lpDst++;
 	state = pixel_count[0] = pixel_count[1] = 0;
@@ -1268,7 +1252,7 @@ ValidateMap (SBYTE *DepthArray)
 		last_byte = *lpDst++;
 	} while (--i);
 
-	i = MAP_WIDTH * MAP_HEIGHT;
+	i = width * height;
 	lpDst = DepthArray;
 	if (pixel_count[0] > pixel_count[1])
 		last_byte = lb[0];
@@ -1291,24 +1275,44 @@ ValidateMap (SBYTE *DepthArray)
 }
 
 static void
-planet_orbit_init (void)
+PlanetOrbitInit (COUNT width, COUNT height, BOOLEAN inOrbit)
 {
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
+	COUNT SphereSpanX = height;
+	COUNT OldShieldRadius, ShieldRadius, ShieldDiam, i;
+	COUNT Diameter = height + 1;
+
+	if (inOrbit){
+		OldShieldRadius = SHIELD_RADIUS;
+	} else {
+		OldShieldRadius = (RADIUS + (SHIELD_HALO << 1));
+	}
+	
+	ShieldRadius = (height >> 1) * OldShieldRadius / RADIUS;
+	ShieldDiam = (ShieldRadius << 1) + 1;
 
-	Orbit->SphereFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP | WANT_ALPHA, DIAMETER, DIAMETER, 2));
-	Orbit->TintFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP, MAP_WIDTH, MAP_HEIGHT, 1));
+
+	Orbit->SphereFrame = CaptureDrawable (CreateDrawable (WANT_PIXMAP | WANT_ALPHA, Diameter, Diameter, 2));
 	Orbit->ObjectFrame = 0;
 	Orbit->WorkFrame = 0;
-	Orbit->lpTopoData = HCalloc (MAP_WIDTH * MAP_HEIGHT);
-	Orbit->TopoZoomFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP, MAP_WIDTH << 2, MAP_HEIGHT << 2, 1));
-	Orbit->TopoColors = HMalloc (sizeof (Orbit->TopoColors[0])
-			* (MAP_HEIGHT * (MAP_WIDTH + SPHERE_SPAN_X)));
+	Orbit->lpTopoData = HCalloc (width * height);
+	Orbit->TopoZoomFrame = CaptureDrawable (CreateDrawable (WANT_PIXMAP, MAP_WIDTH << 2, MAP_HEIGHT << 2, 1));
+	Orbit->TopoColors = HMalloc (sizeof (Orbit->TopoColors[0]) * (height * (width + SphereSpanX)));
 	// always allocate the scratch array to largest needed size
-	Orbit->ScratchArray = HMalloc (sizeof (Orbit->ScratchArray[0])
-			* (SHIELD_DIAM) * (SHIELD_DIAM));
+	Orbit->ScratchArray = HMalloc (sizeof (Orbit->ScratchArray[0]) * (ShieldDiam) * (ShieldDiam));
+	Orbit->light_diff = HMalloc (sizeof (DWORD *) * Diameter);
+	Orbit->map_rotate = HMalloc (sizeof (MAP3D_POINT *) * Diameter);
+	for (i=0 ; i < Diameter ; i++) {
+		Orbit->light_diff[i] = HMalloc (sizeof (DWORD)* Diameter);
+		Orbit->map_rotate[i] = HMalloc (sizeof (MAP3D_POINT) * Diameter);
+	}
+
+	if (inOrbit){
+		Orbit->TintFrame = CaptureDrawable (CreateDrawable (
+				WANT_PIXMAP, width, height, 1));
+		Orbit->TopoZoomFrame = CaptureDrawable (CreateDrawable (
+				WANT_PIXMAP, width << 2, height << 2, 1));
+	}
 }
 
 static unsigned
@@ -1555,7 +1559,7 @@ typedef struct
 } elev_block_t;
 
 static inline void
-get_vblock_avg (elev_block_t *pblk, SBYTE *pTopo, int x, int y)
+get_vblock_avg (elev_block_t *pblk, SBYTE *pTopo, int x, int y, COUNT width, COUNT height)
 {
 	SBYTE *elev = pTopo;
 	int y0, y1, i;
@@ -1563,17 +1567,17 @@ get_vblock_avg (elev_block_t *pblk, SBYT
 	int avg = 0, total_weight = 0;
 
 	// surface wraps around along x
-	x = (x + MAP_WIDTH) % MAP_WIDTH;
+	x = (x + width) % width;
 	
 	y0 = y - LMAP_MAX_DIST;
 	y1 = y + LMAP_MAX_DIST;
 	if (y0 < 0)
 		y0 = 0;
-	if (y1 > MAP_HEIGHT)
-		y1 = MAP_HEIGHT;
+	if (y1 > height)
+		y1 = height;
 
-	elev = pTopo + y0 * MAP_WIDTH + x;
-	for (i = y0; i < y1; ++i, elev += MAP_WIDTH)
+	elev = pTopo + y0 * height + x;
+	for (i = y0; i < y1; ++i, elev += height)
 	{
 		int delta = abs (i - y);
 		int weight = 255; // full weight
@@ -1589,7 +1593,7 @@ get_vblock_avg (elev_block_t *pblk, SBYT
 			max = v;
 		if (v < min)
 			min = v;
-		avg += v * weight;
+		avg += pblk->avg * weight;
 		total_weight += weight;
 	}
 	avg /= total_weight;
@@ -1663,7 +1667,7 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 			// blocks wrap around on both sides
 			pblk = vblocks + ((i + LMAP_BLOCKS) % LMAP_BLOCKS);
 
-			get_vblock_avg (pblk, pTopo, i, y);
+			get_vblock_avg (pblk, pTopo, i, y, w, h);
 		}
 
 		for (x = 0; x < w; ++x, ++elev)
@@ -1675,7 +1679,7 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 
 			// prepare next block as we move along x
 			pblk = vblocks + ((x + LMAP_MAX_DIST) % LMAP_BLOCKS);
-			get_vblock_avg (pblk, pTopo, x + LMAP_MAX_DIST, y);
+			get_vblock_avg (pblk, pTopo, x + LMAP_MAX_DIST, y, w, h);
 
 			// compute the min, max and weighted avg of blocks
 			for (i = x - LMAP_MAX_DIST; i <= x + LMAP_MAX_DIST; ++i)
@@ -1718,25 +1722,27 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 	}
 }
 
-// Sets the SysGenRNG to the required state first.
 void
-GeneratePlanetSurface (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame)
-{
+GeneratePlanetSurface (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame, COUNT Width, COUNT Height, BOOLEAN inOrbit) {
 	RECT r;
 	const PlanetFrame *PlanDataPtr;
 	PLANET_INFO *PlanetInfo = &pSolarSysState->SysInfo.PlanetInfo;
-	COUNT i, y;
+	COUNT i, y; 
 	POINT loc;
 	CONTEXT OldContext;
 	CONTEXT TopoContext;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-	BOOLEAN shielded = (pPlanetDesc->data_index & PLANET_SHIELDED) != 0;
+	BOOLEAN SurfDef = FALSE;
+	BOOLEAN shielded = (pPlanetDesc->data_index & PLANET_SHIELDED) != 0;	
+	
+	COUNT SphereSpanX = Height;
+	COUNT Radius = Height >> 1;
 
 	RandomContext_SeedRandom (SysGenRNG, pPlanetDesc->rand_seed);
 
 	TopoContext = CreateContext ("Plangen.TopoContext");
 	OldContext = SetContext (TopoContext);
-	planet_orbit_init ();
+	PlanetOrbitInit (Width, Height, inOrbit);
 
 	PlanDataPtr = &PlanData[pPlanetDesc->data_index & ~PLANET_SHIELDED];
 
@@ -1744,15 +1750,17 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	{	// This is a defined planet; pixmap for the topography and
 		// elevation data is supplied in Surface Definition frame
 		BOOLEAN DeleteDef = FALSE;
+		BOOLEAN DeleteElev = FALSE;
 		FRAME ElevFrame;
 
 		// surface pixmap
+		SurfDef = TRUE;
 		SurfDefFrame = SetAbsFrameIndex (SurfDefFrame, 0);
-		if (GetFrameWidth (SurfDefFrame) != MAP_WIDTH
-				|| GetFrameHeight (SurfDefFrame) != MAP_HEIGHT)
+		if (GetFrameWidth (SurfDefFrame) != Width
+				|| GetFrameHeight (SurfDefFrame) != Height)
 		{
 			pSolarSysState->TopoFrame = CaptureDrawable (RescaleFrame (
-					SurfDefFrame, MAP_WIDTH, MAP_HEIGHT));
+					SurfDefFrame, Width, Height, FALSE));
 			// will not need the passed FRAME anymore
 			DeleteDef = TRUE;
 		}
@@ -1765,40 +1773,66 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 			SBYTE* elev;
 
 			ElevFrame = SetAbsFrameIndex (SurfDefFrame, 1);
-			if (GetFrameWidth (ElevFrame) != MAP_WIDTH
-					|| GetFrameHeight (ElevFrame) != MAP_HEIGHT)
+			if (GetFrameWidth (ElevFrame) != Width
+					|| GetFrameHeight (ElevFrame) != Height)
 			{
 				ElevFrame = CaptureDrawable (RescaleFrame (ElevFrame,
-						MAP_WIDTH, MAP_HEIGHT));
+						Width, Height, TRUE));
+				DeleteElev = TRUE;
 			}
 
 			// grab the elevation data in 1 byte per pixel format
 			ReadFramePixelIndexes (ElevFrame, (BYTE *)Orbit->lpTopoData,
-					MAP_WIDTH, MAP_HEIGHT);
+					Width, Height, inOrbit);
 			// the supplied data is in unsigned format, must convert
-			for (i = 0, elev = Orbit->lpTopoData;
-					i < MAP_WIDTH * MAP_HEIGHT;
-					++i, ++elev)
-			{
+			for (i = 0, elev = Orbit->lpTopoData; i < Width * Height; ++i, ++elev) {
 				*elev = *(BYTE *)elev - 128;
 			}
 		}
 		else
 		{	// no elevation data -- planet flat as a pancake
-			memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
+			memset (Orbit->lpTopoData, 0, Width * Height);
+		}
+
+		// JMS: Planets with special colormaps
+		if (pPlanetDesc->alternate_colormap) {
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (pPlanetDesc->alternate_colormap));
+			pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (SPECIAL_CMAP_XLAT_TAB));
+		} else { // JMS: Normal planets
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (PlanDataPtr->CMapInstance));
+			pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (PlanDataPtr->XlatTabInstance));
+		}
+
+		if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD) {
+			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+					pSolarSysState->OrbitalCMap, 2);
+			pSolarSysState->XlatRef = SetAbsStringTableIndex (
+					pSolarSysState->XlatRef, 2);
+		} else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD) {
+			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+					pSolarSysState->OrbitalCMap, 1);
+			pSolarSysState->XlatRef = SetAbsStringTableIndex (
+					pSolarSysState->XlatRef, 1);
 		}
+		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
 
 		if (DeleteDef)
 			DestroyDrawable (ReleaseDrawable (SurfDefFrame));
+		if (DeleteElev)
+			DestroyDrawable (ReleaseDrawable (ElevFrame));
 	}
 	else
 	{	// Generate planet surface elevation data and look
 
 		r.corner.x = r.corner.y = 0;
-		r.extent.width = MAP_WIDTH;
-		r.extent.height = MAP_HEIGHT;
+		r.extent.width = Width;
+		r.extent.height = Height;
 		{
-			memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
+			memset (Orbit->lpTopoData, 0, Width * Height);
 			switch (PLANALGO (PlanDataPtr->Type))
 			{
 				case GAS_GIANT_ALGO:
@@ -1822,81 +1856,106 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 						{
 							case 0:
 								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 2))
-										+ (MAP_HEIGHT >> 2);
+										(LOBYTE (loword) % (Height >> 2))
+										+ (Height >> 2);
 								break;
 							case 1:
 							case 2:
 							case 3:
 							case 4:
 								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 3))
-										+ (MAP_HEIGHT >> 3);
+										(LOBYTE (loword) % (Height >> 3))
+										+ (Height >> 3);
 								break;
 							default:
 								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 4))
+										(LOBYTE (loword) % (Height >> 4))
 										+ 4;
 								break;
 						}
-					
+
 						loword = LOWORD (RandomContext_Random (SysGenRNG));
+
 						crater_r.extent.height = crater_r.extent.width;
 						crater_r.corner.x = HIBYTE (loword)
-								% (MAP_WIDTH - crater_r.extent.width);
+								% (Width - crater_r.extent.width);
 						crater_r.corner.y = LOBYTE (loword)
-								% (MAP_HEIGHT - crater_r.extent.height);
+								% (Height - crater_r.extent.height);
+
 						MakeCrater (&crater_r, Orbit->lpTopoData,
 								PlanDataPtr->fault_depth << 2,
 								-(PlanDataPtr->fault_depth << 2),
-								FALSE);
+								FALSE, Width);
 					}
 
 					if (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO)
-						DitherMap (Orbit->lpTopoData);
-					ValidateMap (Orbit->lpTopoData);
+						DitherMap (Orbit->lpTopoData, Width, Height);
+					ValidateMap (Orbit->lpTopoData, Width, Height);
 					break;
 			}
 		}
 		pSolarSysState->TopoFrame = CaptureDrawable (
-				CreateDrawable (WANT_PIXMAP, (SIZE)MAP_WIDTH,
-				(SIZE)MAP_HEIGHT, 1));
-		pSolarSysState->OrbitalCMap = CaptureColorMap (
+				CreateDrawable (WANT_PIXMAP, (SIZE)Width,
+				(SIZE)Height, 1));
+		if (inOrbit){
+			// JMS: Planets with special colormaps
+			if (pPlanetDesc->alternate_colormap) {
+				pSolarSysState->OrbitalCMap = CaptureColorMap (
+					LoadColorMap (pPlanetDesc->alternate_colormap));
+				pSolarSysState->XlatRef = CaptureStringTable (
+					LoadStringTable (SPECIAL_CMAP_XLAT_TAB));
+			} else { // JMS: Normal planets
+				pSolarSysState->OrbitalCMap = CaptureColorMap (
+					LoadColorMap (PlanDataPtr->CMapInstance));
+				pSolarSysState->XlatRef = CaptureStringTable (
+					LoadStringTable (PlanDataPtr->XlatTabInstance));
+			}
+			if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD) {
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 2);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 2);
+			} else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD) {
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 1);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 1);
+			}
+		} else {
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
 				LoadColorMap (PlanDataPtr->CMapInstance));
-		pSolarSysState->XlatRef = CaptureStringTable (
+			pSolarSysState->XlatRef = CaptureStringTable (
 				LoadStringTable (PlanDataPtr->XlatTabInstance));
-
-		if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
-		{
-			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
-					pSolarSysState->OrbitalCMap, 2);
-			pSolarSysState->XlatRef = SetAbsStringTableIndex (
-					pSolarSysState->XlatRef, 2);
-		}
-		else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
-		{
-			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
-					pSolarSysState->OrbitalCMap, 1);
-			pSolarSysState->XlatRef = SetAbsStringTableIndex (
-					pSolarSysState->XlatRef, 1);
+			if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
+			{
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 2);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 2);
+			}
+			else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
+			{
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 1);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 1);
+			}
 		}
 		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
-		RenderTopography (pSolarSysState->TopoFrame,
-				Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
-
+		RenderTopography (pSolarSysState->TopoFrame, Orbit->lpTopoData, Width, Height, FALSE);
 	}
 
-	if (!shielded && PlanetInfo->AtmoDensity != GAS_GIANT_ATMOSPHERE)
+	if (!shielded && PlanetInfo->AtmoDensity != GAS_GIANT_ATMOSPHERE && inOrbit)
 	{	// produce 4x scaled topo image for Planetside
 		// for the planets that we can land on
-		SBYTE *pScaledTopo = HMalloc (MAP_WIDTH * 4 * MAP_HEIGHT * 4);
+		SBYTE *pScaledTopo = HMalloc (Width * 4 * Height * 4);
 		if (pScaledTopo)
 		{
 			TopoScale4x (pScaledTopo, Orbit->lpTopoData,
 					PlanDataPtr->num_faults, PlanDataPtr->fault_depth
 					* (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO ? 2 : 1  ));
 			RenderTopography (Orbit->TopoZoomFrame, pScaledTopo,
-					MAP_WIDTH * 4, MAP_HEIGHT * 4);
+					Width * 4, Height * 4, SurfDef);
 
 			HFree (pScaledTopo);
 		}
@@ -1908,21 +1967,21 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	// It may be more efficient to build it from lpTopoData instead of the
 	// FRAMPTR though.
 	ReadFramePixelColors (pSolarSysState->TopoFrame, Orbit->TopoColors,
-			MAP_WIDTH + SPHERE_SPAN_X, MAP_HEIGHT);
-	// Extend the width from MAP_WIDTH to MAP_WIDTH+SPHERE_SPAN_X
-	for (y = 0; y < MAP_HEIGHT * (MAP_WIDTH + SPHERE_SPAN_X);
-			y += MAP_WIDTH + SPHERE_SPAN_X)
-		memcpy (Orbit->TopoColors + y + MAP_WIDTH, Orbit->TopoColors + y,
-				SPHERE_SPAN_X * sizeof (Orbit->TopoColors[0]));
+			Width + SphereSpanX, Height);
+	// Extend the Width from MAP_WIDTH to MAP_WIDTH+SPHERE_SPAN_X
+	for (y = 0; y < (DWORD)(Height * (Width + SphereSpanX));
+			y += Width + SphereSpanX)
+		memcpy (Orbit->TopoColors + y + Width, Orbit->TopoColors + y,
+				SphereSpanX * sizeof (Orbit->TopoColors[0]));
 
 	if (PLANALGO (PlanDataPtr->Type) != GAS_GIANT_ALGO)
 	{	// convert topo data to a light map, based on relative
 		// map point elevations
-		GenerateLightMap (Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
+		GenerateLightMap (Orbit->lpTopoData, Width, Height);
 	}
 	else
 	{	// gas giants are pretty much flat
-		memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
+		memset (Orbit->lpTopoData, 0, Width * Height);
 	}
 			
 	if (pSolarSysState->pOrbitalDesc->pPrevDesc ==
@@ -1936,14 +1995,22 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	}
 	
 	// Rotating planet sphere initialization
-	GenerateSphereMask (loc);
-	CreateSphereTiltMap (PlanetInfo->AxialTilt);
+	GenerateSphereMask (loc, Radius);
+	CreateSphereTiltMap (PlanetInfo->AxialTilt, Height, Radius);
 	if (shielded)
-		Orbit->ObjectFrame = CreateShieldMask ();
-	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded);
+		Orbit->ObjectFrame = CreateShieldMask (Radius, inOrbit);
+	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded, Width, Height);
 
-	if (shielded)
-	{	// This overwrites pSolarSysState->TopoFrame, so everything that
+	if (!inOrbit){
+		pPlanetDesc->rotDirection = 1 - 2 * (PlanetInfo->AxialTilt & 1);
+		pPlanetDesc->rotwidth = Width;
+		pPlanetDesc->rotheight = Height;
+		pPlanetDesc->rotFrameIndex = 0;
+		pPlanetDesc->rotPointIndex = 0; 
+		pPlanetDesc->rot_speed = ((double)(pPlanetDesc->rotwidth * pPlanetDesc->rotDirection * 240)) / PlanetInfo->RotationPeriod;
+	}
+
+	if (shielded) {	// This overwrites pSolarSysState->TopoFrame, so everything that
 		// needs it has to come before
 		ApplyShieldTint ();
 	}
@@ -1952,3 +2019,5 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	DestroyContext (TopoContext);
 }
 
+void
+	newFunct (void) {}
\ No newline at end of file
diff -ruNp src.orig/uqm/planets/pstarmap.c src/uqm/planets/pstarmap.c
--- src.orig/uqm/planets/pstarmap.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/pstarmap.c	2017-11-22 08:52:12 -0600
@@ -41,14 +41,24 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
 #include "libs/memlib.h"
-
+#include "../util.h"
+		// For get_fuel_to_sol()
 #include <stdlib.h>
 
+typedef enum {
+	NORMAL_STARMAP		  = 0,
+	PREWAR_STARMAP		  = 1,
+	CONSTELLATION_STARMAP = 2,
+	NUM_STARMAPS
+} CURRENT_STARMAP_SHOWN;
+
 
 static POINT cursorLoc;
 static POINT mapOrigin;
 static int zoomLevel;
 static FRAME StarMapFrame;
+static BOOLEAN show_prewar_situation; // JMS
+static CURRENT_STARMAP_SHOWN which_starmap; // JMS
 
 
 static inline long
@@ -276,13 +286,179 @@ GetSphereRect (FLEET_INFO *FleetPtr, REC
 	}
 }
 
+
+// JMS: For showing the SC1-era situation in starmap
+static void
+GetPrewarSphereRect (COUNT index, FLEET_INFO *FleetPtr, RECT *pRect, RECT *pRepairRect)
+{
+	long diameter;
+	
+	static const COUNT prewar_strengths[] =
+	{
+		RACE_PREWAR_STRENGTHS
+	};
+	static const POINT prewar_locations[] =
+	{
+		RACE_PREWAR_LOCATIONS
+	};
+	static const BOOLEAN prewar_name_unknown[] =
+	{
+		RACE_PREWAR_NAME_UNKNOWN
+	};
+
+	diameter = (long)(prewar_strengths[index] * 2);
+	pRect->extent.width = UNIVERSE_TO_DISPX (diameter) - UNIVERSE_TO_DISPX (0);
+	if (pRect->extent.width < 0)
+		pRect->extent.width = -pRect->extent.width;
+	else if (pRect->extent.width == 0)
+		pRect->extent.width = 1;
+	pRect->extent.height = UNIVERSE_TO_DISPY (diameter)
+			- UNIVERSE_TO_DISPY (0);
+	if (pRect->extent.height < 0)
+		pRect->extent.height = -pRect->extent.height;
+	else if (pRect->extent.height == 0)
+		pRect->extent.height = 1;
+
+	pRect->corner.x = UNIVERSE_TO_DISPX (prewar_locations[index].x);
+	pRect->corner.y = UNIVERSE_TO_DISPY (prewar_locations[index].y);
+	pRect->corner.x -= pRect->extent.width >> 1;
+	pRect->corner.y -= pRect->extent.height >> 1;
+
+	{
+		TEXT t;
+		STRING locString;
+
+		SetContextFont (TinyFont);
+
+		t.baseline.x = pRect->corner.x + (pRect->extent.width >> 1);
+		t.baseline.y = pRect->corner.y + (pRect->extent.height >> 1) - 1;
+		t.align = ALIGN_CENTER;
+		
+		if (prewar_name_unknown[index])
+		{
+			t.CharCount = 7;
+			t.pStr = GAME_STRING (STAR_STRING_BASE + 132);
+		}
+		else
+		{
+			locString = SetAbsStringTableIndex (FleetPtr->race_strings, 1);
+			t.CharCount = GetStringLength (locString);
+			t.pStr = (UNICODE *)GetStringAddress (locString);
+		}
+		
+		if (prewar_strengths[index])
+			TextRect (&t, pRepairRect, NULL);
+		
+		if (pRepairRect->corner.x <= 0)
+			pRepairRect->corner.x = 1;
+		else if (pRepairRect->corner.x + pRepairRect->extent.width >=
+				SIS_SCREEN_WIDTH)
+			pRepairRect->corner.x =
+					SIS_SCREEN_WIDTH - pRepairRect->extent.width - 1;
+		if (pRepairRect->corner.y <= 0)
+			pRepairRect->corner.y = 1;
+		else if (pRepairRect->corner.y + pRepairRect->extent.height >=
+				SIS_SCREEN_HEIGHT)
+			pRepairRect->corner.y =
+					SIS_SCREEN_HEIGHT - pRepairRect->extent.height - 1;
+
+		BoxUnion (pRepairRect, pRect, pRepairRect);
+		pRepairRect->extent.width++;
+		pRepairRect->extent.height++;
+	}
+}
+
+static void
+DrawFuelCircles ()
+{
+	RECT r;
+	long diameter;
+	long diameter_no_return;
+	POINT corner;
+	Color OldColor;
+	DWORD OnBoardFuel = !optInfiniteFuel ? GLOBAL_SIS (FuelOnBoard) : 0;
+
+	diameter = OnBoardFuel << 1;
+
+	/* Terribly ugly hack to keep this from being assigned
+	 * a negative value, and also to make sure the inner circle
+	 * is not drawn if we don't have enough fuel to get to Sol at
+	 * all.
+	 */
+	if (((OnBoardFuel) - (long)get_fuel_to_sol() < 0) ||
+		(get_fuel_to_sol () > OnBoardFuel))
+	{
+		diameter_no_return = 0;
+	} else
+	{
+		diameter_no_return = OnBoardFuel - get_fuel_to_sol();
+	}
+
+	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+		corner = CurStarDescPtr->star_pt;
+	else
+	{
+		corner.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+		corner.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+	}
+
+	/* Draw outer circle*/
+	r.extent.width = UNIVERSE_TO_DISPX (diameter)
+	                 - UNIVERSE_TO_DISPX (0);
+
+	if (r.extent.width < 0)
+		r.extent.width = -r.extent.width;
+
+	r.extent.height = UNIVERSE_TO_DISPY (diameter)
+	                  - UNIVERSE_TO_DISPY (0);
+
+	if (r.extent.height < 0)
+		r.extent.height = -r.extent.height;
+
+	r.corner.x = UNIVERSE_TO_DISPX (corner.x)
+	             - (r.extent.width >> 1);
+	r.corner.y = UNIVERSE_TO_DISPY (corner.y)
+	             - (r.extent.height >> 1);
+
+	OldColor = SetContextForeGroundColor (
+	                   BUILD_COLOR (MAKE_RGB15 (0x03, 0x03, 0x03), 0x22));
+	DrawFilledOval (&r);
+	SetContextForeGroundColor (OldColor);
+
+	/* Draw a second fuel circle showing the 'point of no return', past which there will
+	 * not be enough fuel to return to Sol.
+	 */
+
+	r.extent.width = UNIVERSE_TO_DISPX (diameter_no_return)
+	                 - UNIVERSE_TO_DISPX (0);
+
+	if (r.extent.width < 0)
+		r.extent.width = -r.extent.width;
+
+	r.extent.height = UNIVERSE_TO_DISPY (diameter_no_return)
+	                  - UNIVERSE_TO_DISPY (0);
+
+	if (r.extent.height < 0)
+		r.extent.height = -r.extent.height;
+
+	r.corner.x = UNIVERSE_TO_DISPX (corner.x)
+	             - (r.extent.width >> 1);
+	r.corner.y = UNIVERSE_TO_DISPY (corner.y)
+	             - (r.extent.height >> 1);
+
+	OldColor = SetContextForeGroundColor (
+	                   BUILD_COLOR (MAKE_RGB15 (0x04, 0x04, 0x05), 0x22));
+	DrawFilledOval (&r);
+	SetContextForeGroundColor (OldColor);
+}
+
 static void
 DrawStarMap (COUNT race_update, RECT *pClipRect)
 {
 #define GRID_DELTA 500
 	SIZE i;
 	COUNT which_space;
-	long diameter;
+	// long diameter;
 	RECT r, old_r;
 	POINT oldOrigin = {0, 0};
 	STAMP s;
@@ -340,42 +516,8 @@ DrawStarMap (COUNT race_update, RECT *pC
 	ClearDrawable ();
 
 	// Draw the fuel range circle
-	if (race_update == 0
-			&& which_space < 2
-			&& (diameter = (long)GLOBAL_SIS (FuelOnBoard) << 1))
-	{
-		Color OldColor;
-
-		if (!inHQSpace ())
-			r.corner = CurStarDescPtr->star_pt;
-		else
-		{
-			r.corner.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
-			r.corner.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
-		}
-
-		// Cap the diameter to a sane range
-		if (diameter > MAX_X_UNIVERSE * 4)
-			diameter = MAX_X_UNIVERSE * 4;
-
-		r.extent.width = UNIVERSE_TO_DISPX (diameter)
-				- UNIVERSE_TO_DISPX (0);
-		if (r.extent.width < 0)
-			r.extent.width = -r.extent.width;
-		r.extent.height = UNIVERSE_TO_DISPY (diameter)
-				- UNIVERSE_TO_DISPY (0);
-		if (r.extent.height < 0)
-			r.extent.height = -r.extent.height;
-
-		r.corner.x = UNIVERSE_TO_DISPX (r.corner.x)
-				- (r.extent.width >> 1);
-		r.corner.y = UNIVERSE_TO_DISPY (r.corner.y)
-				- (r.extent.height >> 1);
-
-		OldColor = SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x03, 0x03, 0x03), 0x22));
-		DrawFilledOval (&r);
-		SetContextForeGroundColor (OldColor);
+	if (race_update == 0 && which_space < 2) {
+		DrawFuelCircles ();
 	}
 
 	for (i = MAX_Y_UNIVERSE + 1; i >= 0; i -= GRID_DELTA)
@@ -399,7 +541,7 @@ DrawStarMap (COUNT race_update, RECT *pC
 	}
 
 	star_frame = SetRelFrameIndex (StarMapFrame, 2);
-	if (which_space <= 1)
+	if (which_space <= 1 && which_starmap != CONSTELLATION_STARMAP)
 	{
 		COUNT index;
 		HFLEETINFO hStarShip, hNextShip;
@@ -408,6 +550,19 @@ DrawStarMap (COUNT race_update, RECT *pC
 			RACE_COLORS
 		};
 
+		// JMS: For drawing SC1-era starmap.
+		static const BOOLEAN prewar_name_unknown[] =
+		{
+			RACE_PREWAR_NAME_UNKNOWN
+		};
+		static const COUNT prewar_strengths[] =
+		{
+			RACE_PREWAR_STRENGTHS
+		};
+		const char name_androsynth[] = "Androsynth";
+		const char name_chenjesu[] = "Chenjesu";
+		const char name_mmrnmhrm[] = "Mmrnmhrm";
+
 		for (index = 0,
 				hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
 				hStarShip != 0; ++index, hStarShip = hNextShip)
@@ -417,11 +572,16 @@ DrawStarMap (COUNT race_update, RECT *pC
 			FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 			hNextShip = _GetSuccLink (FleetPtr);
 
-			if (FleetPtr->known_strength)
+			if (FleetPtr->known_strength || 
+				(show_prewar_situation && prewar_strengths[index]))
 			{
 				RECT repair_r;
 
-				GetSphereRect (FleetPtr, &r, &repair_r);
+				if (show_prewar_situation)
+					GetPrewarSphereRect (index, FleetPtr, &r, &repair_r);
+				else
+					GetSphereRect (FleetPtr, &r, &repair_r);
+
 				if (r.corner.x < SIS_SCREEN_WIDTH
 						&& r.corner.y < SIS_SCREEN_HEIGHT
 						&& r.corner.x + r.extent.width > 0
@@ -448,11 +608,39 @@ DrawStarMap (COUNT race_update, RECT *pC
 					t.baseline.x = r.corner.x + (r.extent.width >> 1);
 					t.baseline.y = r.corner.y + (r.extent.height >> 1) - 1;
 					t.align = ALIGN_CENTER;
-					locString = SetAbsStringTableIndex (
-							FleetPtr->race_strings, 1);
-					t.CharCount = GetStringLength (locString);
-					t.pStr = (UNICODE *)GetStringAddress (locString);
-					TextRect (&t, &r, NULL);
+					// JMS: For drawing SC1-era starmap.
+					if (show_prewar_situation && prewar_name_unknown[index])
+					{
+						t.CharCount = 7;
+						t.pStr = GAME_STRING (STAR_STRING_BASE + 132);
+					}
+					// JMS: A kludgy way to fix Mrns, Chenjesus and Andros' names.
+					else if (show_prewar_situation && 
+						(index == 1 || index == 16 || index == 20))
+					{
+						if (index == 1)
+						{
+							t.CharCount = 8;
+							t.pStr = (UNICODE *)name_mmrnmhrm;
+						}
+						else if (index == 16)
+						{
+							t.CharCount = 8;
+							t.pStr = (UNICODE *)name_chenjesu;
+						}
+						else if (index == 20)
+						{
+							t.CharCount = 10;
+							t.pStr = (UNICODE *)name_androsynth;
+						}
+					}
+					else
+					{
+						locString = SetAbsStringTableIndex (
+								FleetPtr->race_strings, 1);
+						t.CharCount = GetStringLength (locString);
+						t.pStr = (UNICODE *)GetStringAddress (locString);
+					}
 
 					if (r.corner.x <= 0)
 						t.baseline.x -= r.corner.x - 1;
@@ -475,7 +663,9 @@ DrawStarMap (COUNT race_update, RECT *pC
 							0xff : c.b + CC5TO8 (0x03);
 
 					SetContextForeGroundColor (c);
-					font_DrawText (&t);
+					if ((!show_prewar_situation) ||
+						(show_prewar_situation && prewar_strengths[index]))
+						font_DrawText (&t);
 				}
 			}
 
@@ -509,6 +699,20 @@ DrawStarMap (COUNT race_update, RECT *pC
 	} while (SDPtr->star_pt.x <= MAX_X_UNIVERSE
 			&& SDPtr->star_pt.y <= MAX_Y_UNIVERSE);
 
+	// JMS: This draws the constellation lines on the constellation starmap.
+	if (which_space <= 1 && which_starmap == CONSTELLATION_STARMAP)
+	{
+		s.frame = SetAbsFrameIndex (ConstellationsFrame, 0);
+		DrawStamp (&s);
+		
+		// JMS: If we have a separate frame containing the constellation names, display it.
+		if (GetFrameCount(ConstellationsFrame) > 1)
+		{
+			s.frame = IncFrameIndex (s.frame);
+			DrawStamp (&s);
+		}
+	}
+
 	if (GET_GAME_STATE (ARILOU_SPACE))
 	{
 		if (which_space <= 1)
@@ -671,6 +875,10 @@ UpdateCursorLocation (int sx, int sy, co
 			cursorLoc.y = MAX_Y_UNIVERSE;
 
 		s.origin.y = UNIVERSE_TO_DISPY (cursorLoc.y);
+		if (s.origin.y < 0) {
+			s.origin.y = 0;
+			cursorLoc.y = DISP_TO_UNIVERSEY (0);
+		}
 	}
 
 	if (s.origin.x < 0 || s.origin.y < 0
@@ -701,6 +909,23 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	STAR_DESC *SDPtr;
 	STAR_DESC *BestSDPtr;
 
+	// JMS: Display star map title.
+	if (which_starmap == CONSTELLATION_STARMAP)
+	{	
+		// "- Known constellations -"
+		utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 4));
+	}
+	else if (which_starmap == PREWAR_STARMAP)
+	{	
+		// "- Old map from 2135 -"
+		utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 3));
+	}
+	else
+	{	
+		// "(Star search:F6 Toggle maps:F7)"
+		utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 2));
+	}
+
 	pt.x = UNIVERSE_TO_DISPX (cursorLoc.x);
 	pt.y = UNIVERSE_TO_DISPY (cursorLoc.y);
 
@@ -765,10 +990,8 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	}
 }
 
-static void
-UpdateFuelRequirement (void)
-{
-	UNICODE buf[80];
+static int
+FuelRequired (void){
 	COUNT fuel_required;
 	DWORD f;
 	POINT pt;
@@ -789,6 +1012,15 @@ UpdateFuelRequirement (void)
 	else
 		fuel_required = square_root (f) + (FUEL_TANK_SCALE / 20);
 
+	return fuel_required;
+}
+
+static void
+UpdateFuelRequirement (void)
+{
+	UNICODE buf[80];
+	COUNT fuel_required = FuelRequired();
+
 	sprintf (buf, "%s %u.%u",
 			GAME_STRING (NAVIGATION_STRING_BASE + 4),
 			fuel_required / FUEL_TANK_SCALE,
@@ -1215,6 +1447,8 @@ DoMoveCursor (MENU_STATE *pMS)
 #define STEP_ACCEL_DELAY (ONE_SECOND / 120)
 	static UNICODE last_buf[CURSOR_INFO_BUFSIZE];
 	DWORD TimeIn = GetTimeCounter ();
+	static COUNT moveRepeats;
+	BOOLEAN isMove = FALSE;
 
 	if (!pMS->Initialized)
 	{
@@ -1244,30 +1478,32 @@ DoMoveCursor (MENU_STATE *pMS)
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SELECT])
 	{
-		GLOBAL (autopilot) = cursorLoc;
-#ifdef DEBUG
-		if (instantMove)
-		{
-			PlayMenuSound (MENU_SOUND_INVOKED);
+		// printf("Fuel Available: %d | Fuel Requirement: %d\n", GLOBAL_SIS (FuelOnBoard), FuelRequired());
 
-			if (inHQSpace ())
-			{
-				// Move to the new location immediately.
-				doInstantMove ();
-			}
-			else if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
-			{
-				// We're in a solar system; exit it.
-				GLOBAL (CurrentActivity) |= END_INTERPLANETARY;
-			
-				// Set a hook to move to the new location:
-				debugHook = doInstantMove;
+		if (optBubbleWarp) {
+			if (GLOBAL_SIS (FuelOnBoard) >= FuelRequired() || optInfiniteFuel){
+				GLOBAL (autopilot) = cursorLoc;
+				PlayMenuSound (MENU_SOUND_BUBBLEWARP);
+				if (inHQSpace ()) {
+					// Move to the new location immediately.
+					doInstantMove ();
+				} else if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY) {
+					// We're in a solar system; exit it.
+					GLOBAL (CurrentActivity) |= END_INTERPLANETARY;			
+					// Set a hook to move to the new location:
+					debugHook = doInstantMove;
+				}
+				if(!optInfiniteFuel)
+					DeltaSISGauges (0, -FuelRequired(), 0);
+				
+				return FALSE;
+			} else { 
+				PlayMenuSound (MENU_SOUND_FAILURE);
 			}
-
-			return FALSE;
+		} else {
+			GLOBAL (autopilot) = cursorLoc;
+			DrawStarMap (0, NULL);
 		}
-#endif
-		DrawStarMap (0, NULL);
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SEARCH])
 	{
@@ -1293,6 +1529,22 @@ DoMoveCursor (MENU_STATE *pMS)
 			PlayMenuSound (MENU_SOUND_FAILURE);
 		}
 	}
+	else if (PulsedInputState.menu[KEY_MENU_TOGGLEMAP] 
+		&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+	{
+		++which_starmap;
+		which_starmap %= NUM_STARMAPS;
+		
+		if (which_starmap == PREWAR_STARMAP) 
+			show_prewar_situation = TRUE;
+		else
+			show_prewar_situation = FALSE;
+	
+		DrawStarMap (0, NULL);
+		last_buf[0] = '\0';
+		UpdateCursorInfo (last_buf);
+		SleepThread (ONE_SECOND / 8);
+	}
 	else
 	{
 		SBYTE sx, sy;
@@ -1317,11 +1569,17 @@ DoMoveCursor (MENU_STATE *pMS)
 			UpdateCursorLocation (sx, sy, NULL);
 			UpdateCursorInfo (last_buf);
 			UpdateFuelRequirement ();
+			isMove = TRUE;
 		}
 
 		SleepThreadUntil (TimeIn + MIN_ACCEL_DELAY);
 	}
 
+	if (isMove)
+		++moveRepeats;
+	else
+		moveRepeats = 0;
+
 	flashCurrentLocation (NULL);
 
 	return !(GLOBAL (CurrentActivity) & CHECK_ABORT);
@@ -1574,6 +1832,10 @@ StarMap (void)
 
 	memset (&MenuState, 0, sizeof (MenuState));
 
+	// JMS: For showing SC1-era starmap / starmap with constellations.
+	show_prewar_situation = FALSE; 
+	which_starmap = NORMAL_STARMAP;
+
 	zoomLevel = 0;
 	mapOrigin.x = MAX_X_UNIVERSE >> 1;
 	mapOrigin.y = MAX_Y_UNIVERSE >> 1;
@@ -1597,6 +1859,9 @@ StarMap (void)
 	transition_pending = TRUE;
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 		UpdateMap ();
+	
+	if(optSubmenu)
+		DrawSubmenu (2);
 
 	DrawStarMap (0, (RECT*)-1);
 	transition_pending = FALSE;
@@ -1621,6 +1886,9 @@ StarMap (void)
 	DrawSISMessage (NULL);
 	DrawStatusMessage (NULL);
 
+	if (optSubmenu)
+		DrawSubmenu (0);
+
 	if (GLOBAL (autopilot.x) == universe.x
 			&& GLOBAL (autopilot.y) == universe.y)
 		GLOBAL (autopilot.x) = GLOBAL (autopilot.y) = ~0;
diff -ruNp src.orig/uqm/planets/report.c src/uqm/planets/report.c
--- src.orig/uqm/planets/report.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/report.c	2017-11-22 08:52:12 -0600
@@ -167,12 +167,20 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 						PlaySound (ReadOutSounds, NotPositional (), NULL,
 								GAME_SOUND_PRIORITY);
 
-						if (c == ',')
-							TimeOut += ONE_SECOND / 4;
-						if (c == '.' || c == '!' || c == '?')
-							TimeOut += ONE_SECOND / 2;
+						if (last_c && last_c != ' ' && last_c != ',' &&
+								last_c != '.' && last_c != '!' && last_c != '?')
+						{
+							if (c == ',')
+								TimeOut += ONE_SECOND / 4;
+							if (c == '.' || c == '!' || c == '?')
+								TimeOut += ONE_SECOND / 2;
+							else
+								TimeOut += ONE_SECOND / 20;
+						}
 						else
 							TimeOut += ONE_SECOND / 20;
+						last_c = c;
+
 						if (word_chars == 0)
 							TimeOut += ONE_SECOND / 20;
 
diff -ruNp src.orig/uqm/planets/roster.c src/uqm/planets/roster.c
--- src.orig/uqm/planets/roster.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/roster.c	2017-11-22 08:52:12 -0600
@@ -235,7 +235,7 @@ static BOOLEAN
 DoModifyRoster (MENU_STATE *pMS)
 {
 	ROSTER_STATE *rosterState = pMS->privData;
-	BOOLEAN select, cancel, up, down, horiz;
+	BOOLEAN select, cancel, up, down, pgup, pgdn, horiz;
 
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 		return FALSE;
@@ -247,6 +247,8 @@ DoModifyRoster (MENU_STATE *pMS)
 	// Left or right produces the same effect because there are 2 columns
 	horiz = PulsedInputState.menu[KEY_MENU_LEFT] ||
 			PulsedInputState.menu[KEY_MENU_RIGHT];
+	pgup = PulsedInputState.menu[KEY_MENU_PAGE_UP];
+	pgdn = PulsedInputState.menu[KEY_MENU_PAGE_DOWN];
 
 	if (cancel && !rosterState->modifyingCrew)
 	{
@@ -258,14 +260,15 @@ DoModifyRoster (MENU_STATE *pMS)
 		if (!rosterState->modifyingCrew)
 		{
 			SetFlashRect (NULL);
-			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+			SetMenuSounds (MENU_SOUND_ARROWS | MENU_SOUND_PAGEUP |
+				MENU_SOUND_PAGEDOWN, MENU_SOUND_SELECT);
 		}
 		else
 		{
 			drawModifiedSupportShip (rosterState);
 			flashSupportShipCrew ();
-			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-					MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
+			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN | MENU_SOUND_PAGEUP |
+				MENU_SOUND_PAGEDOWN, MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
 		}
 	}
 	else if (rosterState->modifyingCrew)
@@ -273,17 +276,17 @@ DoModifyRoster (MENU_STATE *pMS)
 		SIZE delta = 0;
 		BOOLEAN failed = FALSE;
 
-		if (up)
+		if (up || pgup)
 		{
 			if (GLOBAL_SIS (CrewEnlisted))
-				delta = 1;
+				delta = pgup ? 10 : 1;
 			else
 				failed = TRUE;
 		}
-		else if (down)
+		else if (down || pgdn)
 		{
 			if (GLOBAL_SIS (CrewEnlisted) < GetCrewPodCapacity ())
-				delta = -1;
+				delta = pgdn ? -10 : -1;
 			else
 				failed = TRUE;
 		}
diff -ruNp src.orig/uqm/planets/scan.c src/uqm/planets/scan.c
--- src.orig/uqm/planets/scan.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/scan.c	2017-11-22 08:52:12 -0600
@@ -30,7 +30,7 @@
 #include "../nameref.h"
 #include "../resinst.h"
 #include "../settings.h"
-#include "../util.h"
+#include "../util.h" // for get_fuel_to_sol()
 #include "../process.h"
 #include "../setup.h"
 #include "../sounds.h"
@@ -619,7 +619,9 @@ DispatchLander (void)
 	// Deactivate planet rotation callback
 	oldCallback = SetInputCallback (NULL);
 
-	DeltaSISGauges (0, -landingFuel, 0);
+	if (!optInfiniteFuel)
+		DeltaSISGauges (0, -landingFuel, 0);
+
 	SetContext (ScanContext);
 	drawPlanetCursor (FALSE);
 
@@ -736,12 +738,26 @@ DoPickPlanetSide (MENU_STATE *pMS)
 static void
 drawLandingFuelUsage (COUNT fuel)
 {
+	/* We need this so we can save the StatusMessageMode
+	 * and fix it when we're done.
+	 */
+	StatMsgMode old_status_message_mode;
 	UNICODE buf[100];
 
+	if (((SDWORD) (GLOBAL_SIS (FuelOnBoard)) - fuel) <= (SDWORD)(get_fuel_to_sol ()))
+	{ /* We will not have enough fuel to get to Sol if we dispatch the lander */
+		old_status_message_mode = SetStatusMessageMode (SMM_ALERT);
+	} else if (((SDWORD) (GLOBAL_SIS (FuelOnBoard)) - fuel) <= (SDWORD)(get_fuel_to_sol () + (5 * FUEL_TANK_SCALE)))
+	{ /* We will have enough fuel to get to Sol if we dispatch the lander, but will have less than 5 to spare */
+		old_status_message_mode = SetStatusMessageMode (SMM_WARNING);
+	}
+
 	sprintf (buf, "%s%1.1f",
 			GAME_STRING (NAVIGATION_STRING_BASE + 5),
 			(float) fuel / FUEL_TANK_SCALE);
 	DrawStatusMessage (buf);
+
+	SetStatusMessageMode (old_status_message_mode);
 }
 
 static void
@@ -1307,7 +1323,11 @@ GeneratePlanetSide (void)
 			if (scan == MINERAL_SCAN)
 			{
 				NodeElementPtr->turn_wait = info.type;
-				NodeElementPtr->mass_points = HIBYTE (info.density);
+
+				// JMS: Partially scavenged energy blips won't return anymore to original size after leaving planet.
+				NodeElementPtr->mass_points = HIBYTE (info.density)
+				- pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[scan][num_nodes];
+
 				NodeElementPtr->current.image.frame = SetAbsFrameIndex (
 						MiscDataFrame, (NUM_SCANDOT_TRANSITIONS * 2)
 						+ ElementCategory (info.type) * 5);
diff -ruNp src.orig/uqm/planets/solarsys.c src/uqm/planets/solarsys.c
--- src.orig/uqm/planets/solarsys.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/solarsys.c	2017-11-22 08:52:12 -0600
@@ -47,18 +47,28 @@
 #include "libs/mathlib.h"
 #include "libs/log.h"
 #include "libs/misc.h"
+#include "scan.h"
 
+#include <math.h>
+#include <time.h>
 
 //#define DEBUG_SOLARSYS
 //#define SMOOTH_SYSTEM_ZOOM  1
 
 #define IP_FRAME_RATE  (ONE_SECOND / 30)
 
+#define GENERATE_PLANET_DIAMETER (29 << 2)
+#define GENERATE_MOON_DIAMETER (7 << 2)
+#define GENERATE_PLANET_PERIMETER (GENERATE_PLANET_DIAMETER * MAP_WIDTH / MAP_HEIGHT)
+#define GENERATE_MOON_PERIMETER (GENERATE_MOON_DIAMETER * MAP_WIDTH / MAP_HEIGHT)
+
 static BOOLEAN DoIpFlight (SOLARSYS_STATE *pSS);
 static void DrawSystem (SIZE radius, BOOLEAN IsInnerSystem);
 static FRAME CreateStarBackGround (void);
 static void DrawInnerSystem (void);
 static void DrawOuterSystem (void);
+static void SetPlanetColorMap (PLANET_DESC *planet); // JMS, BW
+static void ValidateInnerOrbits (void);
 static void ValidateOrbits (void);
 
 // SolarSysMenu() items
@@ -222,11 +232,11 @@ GenerateMoons (SOLARSYS_STATE *system, P
 
 	RandomContext_SeedRandom (SysGenRNG, planet->rand_seed);
 
-	(*system->genFuncs->generateName) (system, planet);
+	/*(*system->genFuncs->generateName) (system, planet);
 	(*system->genFuncs->generateMoons) (system, planet);
 
 	facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-			ARCTAN (planet->location.x, planet->location.y)));
+			ARCTAN (planet->location.x, planet->location.y)));*/
 	for (i = 0, pMoonDesc = &system->MoonDesc[0];
 			i < MAX_MOONS; ++i, ++pMoonDesc)
 	{
@@ -236,6 +246,117 @@ GenerateMoons (SOLARSYS_STATE *system, P
 		
 		pMoonDesc->temp_color = planet->temp_color;
 	}
+
+	(*system->genFuncs->generateName) (system, planet);
+	(*system->genFuncs->generateMoons) (system, planet);
+
+	facing = NORMALIZE_FACING (ANGLE_TO_FACING (
+			ARCTAN (planet->location.x, planet->location.y)));
+}
+
+static void
+GenerateTexturedMoons (SOLARSYS_STATE *system, PLANET_DESC *planet)
+{
+	COUNT i;
+	FRAME SurfFrame;
+	PLANET_DESC *pMoonDesc;
+
+	// RandomContext_SeedRandom (SysGenRNG, planet->rand_seed);
+
+	PLANET_DESC *previousOrbitalDesc;
+	previousOrbitalDesc = pSolarSysState->pOrbitalDesc;
+
+	for (i = 0, pMoonDesc = &system->MoonDesc[0];
+			i < planet->NumPlanets; ++i, ++pMoonDesc)
+	{
+		SurfFrame = NULL;
+	
+		// BW : precompute the generated texture to display it in IP
+		if (!(pMoonDesc->data_index & WORLD_TYPE_SPECIAL))
+		{
+			DoPlanetaryAnalysis (&pSolarSysState->SysInfo, pMoonDesc);
+			
+			if (CurStarDescPtr->Index == SOL_DEFINED)
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 0;
+
+			pSolarSysState->pOrbitalDesc = pMoonDesc;
+
+			if (CurStarDescPtr->Index == SOL_DEFINED)
+			{	// png defined moons in Sol
+			
+				COUNT curr_planet_index = planetIndex (pSolarSysState, planet);
+		
+				if (curr_planet_index == 2) {
+					// EARTH
+					switch (i) {
+						case 1: /* LUNA */
+							SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_LUNA_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 0;
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 240 * 29;
+							break;
+					}
+				} else if (curr_planet_index == 4) {
+					// JUPITER
+					switch (i) {
+						case 0: /* IO */
+							SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_IO_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 390;
+							break;
+						case 1: /* EUROPA */
+							SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_EUROPA_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 840;
+							break;
+						case 2: /* GANYMEDE */
+							SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_GANYMEDE_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 1728;
+							break;
+						case 3: /* CALLISTO */
+							SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_CALLISTO_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 4008;
+							break;
+					}
+				} else if (curr_planet_index == 5) {
+					// SATURN
+					switch (i) {
+						case 0: /* TITAN */
+							SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_TITAN_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 3816;
+							break;
+					}
+				} else if (curr_planet_index == 7) {
+					// NEPTUNE
+					switch (i) {
+						case 0: /* TRITON */
+							SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_TRITON_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 4300;
+							break;
+					}
+				}
+			}
+
+			GeneratePlanetSurface (pMoonDesc, SurfFrame, GENERATE_MOON_PERIMETER, GENERATE_MOON_DIAMETER, FALSE);
+			pMoonDesc->orbit = pSolarSysState->Orbit;
+			PrepareNextRotationFrame (pMoonDesc, 0, FALSE);
+
+			// Clean up some parasitic use of pSolarSysState
+			//LockMutex (GraphicsLock);
+			// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
+			// pSolarSysState->Orbit.TintFrame = 0;
+			// pSolarSysState->Orbit.TintColor = BLACK_COLOR;
+		
+			// DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
+			// pSolarSysState->Orbit.TopoZoomFrame = 0;
+			DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+			pSolarSysState->XlatRef = 0;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+			pSolarSysState->TopoFrame = 0;
+			DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+			pSolarSysState->OrbitalCMap = 0;
+			//UnlockMutex (GraphicsLock);
+			// End clean up
+		}
+	}
+	pSolarSysState->pOrbitalDesc = previousOrbitalDesc;
 }
 
 void
@@ -263,17 +384,15 @@ FreeIPData (void)
 void
 LoadIPData (void)
 {
+	SunFrame = CaptureDrawable (LoadGraphic (SUN_MASK_PMAP_ANIM));
 	if (SpaceJunkFrame == 0)
 	{
-		SpaceJunkFrame = CaptureDrawable (
-				LoadGraphic (IPBKGND_MASK_PMAP_ANIM));
+		SpaceJunkFrame = CaptureDrawable (LoadGraphic (IPBKGND_MASK_PMAP_ANIM));
 		SISIPFrame = CaptureDrawable (LoadGraphic (SISIP_MASK_PMAP_ANIM));
 
 		OrbitalCMap = CaptureColorMap (LoadColorMap (ORBPLAN_COLOR_MAP));
-		OrbitalFrame = CaptureDrawable (
-				LoadGraphic (ORBPLAN_MASK_PMAP_ANIM));
+		OrbitalFrame = CaptureDrawable (LoadGraphic (ORBPLAN_MASK_PMAP_ANIM));
 		SunCMap = CaptureColorMap (LoadColorMap (IPSUN_COLOR_MAP));
-		SunFrame = CaptureDrawable (LoadGraphic (SUN_MASK_PMAP_ANIM));
 
 		SpaceMusic = LoadMusic (IP_MUSIC);
 	}
@@ -363,6 +482,89 @@ GetRandomSeedForStar (const STAR_DESC *s
 	return MAKE_DWORD (star->star_pt.x, star->star_pt.y);
 }
 
+void GenerateTexturedPlanets (void)
+{
+	COUNT i;
+	FRAME SurfFrame;
+	PLANET_DESC *pCurDesc;
+	PLANET_DESC *previousOrbitalDesc;
+	previousOrbitalDesc = pSolarSysState->pOrbitalDesc;
+	
+	for (i = 0, pCurDesc = pSolarSysState->PlanetDesc;
+			i < pSolarSysState->SunDesc[0].NumPlanets; ++i, ++pCurDesc)
+	{
+		SurfFrame = NULL;
+
+		DoPlanetaryAnalysis (&pSolarSysState->SysInfo, pCurDesc);
+		
+		// BW : precompute the generated texture to display it in IP
+		pSolarSysState->pOrbitalDesc = pCurDesc;
+		if (CurStarDescPtr->Index == SOL_DEFINED){
+			switch (i) {
+				case 0: /* MERCURY */
+					SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_MERCURY_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 59 * 240;
+					break;
+				case 1: /* VENUS */
+					SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_VENUS_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 177;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 243 * 240;
+					break;
+				case 2: // EARTH
+					SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? EARTH_MASK_ANIM : IP_EARTH_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 23;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 240;
+					break;
+				case 3: // MARS
+					SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_MARS_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 24;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 246;
+					break;
+				case 4: /* JUPITER */
+					SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_JUPITER_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 98;
+					break;
+				case 5: /* SATURN */
+					SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_SATURN_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 27;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 102;
+					break;
+				case 6: /* URANUS */
+					SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_URANUS_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 98;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 172;
+					break;
+				case 7: /* NEPTUNE */
+					SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_NEPTUNE_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 30;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 182;
+					break;
+				case 8: /* PLUTO */
+					SurfFrame = CaptureDrawable (LoadGraphic (!solTexturesPresent ? NULL : IP_PLUTO_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 119;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 1533;
+					break;
+			}
+		}
+		
+		GeneratePlanetSurface (pCurDesc, SurfFrame, GENERATE_PLANET_PERIMETER, GENERATE_PLANET_DIAMETER, FALSE);
+		pCurDesc->orbit = pSolarSysState->Orbit;
+		PrepareNextRotationFrame (pCurDesc, 0, FALSE);
+		
+		// Clean up some parasitic use of pSolarSysState
+		DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+		pSolarSysState->XlatRef = 0;
+		DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+		pSolarSysState->TopoFrame = 0;
+		DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+		pSolarSysState->OrbitalCMap = 0;
+		// End clean up
+	}
+	pSolarSysState->pOrbitalDesc = previousOrbitalDesc;
+}
+
 // Returns an orbital PLANET_DESC when player is in orbit
 static PLANET_DESC *
 LoadSolarSys (void)
@@ -373,7 +575,12 @@ LoadSolarSys (void)
 #define NUM_TEMP_RANGES 5
 	static const Color temp_color_array[NUM_TEMP_RANGES] =
 	{
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x0E), 0x54),
+		// BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x0E), 0x54),
+		// BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),
+		// BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0B, 0x00), 0x6D),
+		// BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),
+		// BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x08, 0x00), 0x75),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x12), 0x54),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0B, 0x00), 0x6D),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),
@@ -497,16 +704,117 @@ saveNonOrbitalLocation (void)
 static void
 FreeSolarSys (void)
 {
-	if (pSolarSysState->InIpFlight)
-	{
+	COUNT i, j;
+	PLANET_DESC *pCurDesc;
+
+	if (pSolarSysState->InIpFlight) {
 		pSolarSysState->InIpFlight = FALSE;
-		
+			
 		if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 			saveNonOrbitalLocation ();
 	}
-
+	
 	DestroyDrawable (ReleaseDrawable (SolarSysFrame));
 	SolarSysFrame = NULL;
+	
+	if (TEXTURED_PLANETS)
+	{
+		// BW: clean up data generated for textured IP planets
+		for (i = 0, pCurDesc = pSolarSysState->PlanetDesc;
+			 i < pSolarSysState->SunDesc[0].NumPlanets; ++i, ++pCurDesc)
+		{
+			PLANET_ORBIT *Orbit = &pCurDesc->orbit;
+			HFree (Orbit->lpTopoData);
+			Orbit->lpTopoData = 0;
+			DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+			Orbit->SphereFrame = NULL;
+		
+			DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+			Orbit->ObjectFrame = 0;
+			DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+			Orbit->WorkFrame = 0;
+		
+			// JMS: Not sure if these do any good...
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
+			pSolarSysState->Orbit.TintFrame = 0;
+			pSolarSysState->Orbit.TintColor = BLACK_COLOR;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
+			pSolarSysState->Orbit.TopoZoomFrame = 0;
+			DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+			pSolarSysState->XlatRef = 0;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+			pSolarSysState->TopoFrame = 0;
+			DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+			pSolarSysState->OrbitalCMap = 0;
+			// JMS ends.
+		
+			HFree (Orbit->TopoColors);
+			Orbit->TopoColors = NULL;
+			HFree (Orbit->ScratchArray);
+			Orbit->ScratchArray = NULL;
+			if (Orbit->map_rotate && Orbit->light_diff)
+			{
+				for (j=0 ; j < GENERATE_PLANET_DIAMETER+1 ; j++)
+				{
+					HFree (Orbit->map_rotate[j]);
+					HFree (Orbit->light_diff[j]);
+				}
+			}
+ 
+			HFree (Orbit->map_rotate);
+			Orbit->map_rotate = NULL;
+			HFree (Orbit->light_diff);
+			Orbit->light_diff = NULL;
+		}	
+
+		// BW: if we were in Inner System, clean up data for textured IP moons
+		if (playerInInnerSystem())
+		{
+			COUNT numMoons;
+			if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
+				numMoons = pSolarSysState->pOrbitalDesc->pPrevDesc->NumPlanets;
+			else
+				numMoons = pSolarSysState->pOrbitalDesc->NumPlanets;
+		
+			for (i = 0, pCurDesc = pSolarSysState->MoonDesc;
+				 i < numMoons; ++i, ++pCurDesc)
+			{
+				if (!(pCurDesc->data_index & WORLD_TYPE_SPECIAL))
+				{
+					PLANET_ORBIT *Orbit = &pCurDesc->orbit;
+			
+					HFree (Orbit->lpTopoData);
+					Orbit->lpTopoData = 0;
+					DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+					Orbit->SphereFrame = NULL;
+			
+					DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+					Orbit->ObjectFrame = 0;
+					DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+					Orbit->WorkFrame = 0;
+			
+					HFree (Orbit->TopoColors);
+					Orbit->TopoColors = NULL;
+					HFree (Orbit->ScratchArray);
+					Orbit->ScratchArray = NULL;
+					if (Orbit->map_rotate && Orbit->light_diff)
+					{
+						for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++)
+						{
+							HFree (Orbit->map_rotate[j]);
+							HFree (Orbit->light_diff[j]);
+						}
+					}
+				
+					HFree (Orbit->map_rotate);
+					Orbit->map_rotate = NULL;
+					HFree (Orbit->light_diff);
+					Orbit->light_diff = NULL;
+				}
+			}
+		}
+	// End clean up
+	}
 
 	StopMusic ();
 
@@ -669,6 +977,18 @@ ValidateOrbit (PLANET_DESC *planet, int
 {
 	COUNT index;
 
+	if (ORBITING_PLANETS) {
+		// BW: recompute planet position to account for orbiting
+		// COUNT newAngle;
+		// newAngle = NORMALIZE_ANGLE(planet->angle + (COUNT)(daysElapsed() * planet->orb_speed));
+		// planet->location.x = COSINE (newAngle, planet->radius);
+		// planet->location.y = SINE (newAngle, planet->radius);
+		double newAngle;
+		newAngle = (planet->angle + daysElapsed() * planet->orb_speed) * M_PI / 32 - M_PI/2 ;
+		planet->location.x = (COORD)(cos(newAngle) * planet->radius);
+		planet->location.y = (COORD)(sin(newAngle) * planet->radius);
+	}
+
 	if (sizeNumer <= DISPLAY_FACTOR)
 	{	// All planets in outer view, and moons in inner
 		RECT r;
@@ -702,7 +1022,9 @@ ValidateOrbit (PLANET_DESC *planet, int
 		}
 		else if (worldIsMoon (pSolarSysState, planet))
 		{
-			Size += 2;
+			Size = 2; // += 2;
+			// BW:	Force moons to size 2 to avoid issues with
+			//		Triton (the one and only large rocky moon)
 		}
 		else if (denom <= (MAX_ZOOM_RADIUS >> 2))
 		{
@@ -720,6 +1042,23 @@ ValidateOrbit (PLANET_DESC *planet, int
 			angle = ARCTAN (planet->pPrevDesc->location.x,
 					planet->pPrevDesc->location.y);
 		}
+		if (TEXTURED_PLANETS) {
+			// Those match the sizes of the png planets
+			switch (Size) {
+			case 0: planet->size = 3;
+				break;
+			case 1: planet->size = 4;
+				break;
+			case 2: planet->size = 7;
+				break;
+			case 3: planet->size = 11;
+				break;
+			case 4: planet->size = 15;
+				break;
+			case 5: planet->size = 29;
+				break;
+			}
+		}
 		planet->image.frame =	SetAbsFrameIndex (OrbitalFrame,
 				(Size << FACING_SHIFT) + NORMALIZE_FACING (
 				ANGLE_TO_FACING (angle)));
@@ -915,6 +1254,8 @@ enterInnerSystem (PLANET_DESC *planet)
 	ZeroVelocityComponents (&GLOBAL (velocity));
 
 	GenerateMoons (pSolarSysState, planet);
+	if (TEXTURED_PLANETS)
+		GenerateTexturedMoons (pSolarSysState, planet);
 	pSolarSysState->pBaseDesc = pSolarSysState->MoonDesc;
 	pSolarSysState->pOrbitalDesc = planet;
 }
@@ -923,17 +1264,62 @@ static void
 leaveInnerSystem (PLANET_DESC *planet)
 {
 	COUNT outerPlanetWait;
+	COUNT i, j;
+	PLANET_DESC *pMoonDesc;
 
 	pSolarSysState->pBaseDesc = pSolarSysState->PlanetDesc;
 	pSolarSysState->pOrbitalDesc = NULL;
 
 	outerPlanetWait = MAKE_WORD (planet - pSolarSysState->PlanetDesc + 1, 0);
+	// BW: planet may have moved while we were into Inner System
+	ValidateOrbit (planet, DISPLAY_FACTOR, DISPLAY_FACTOR / 4,
+		       pSolarSysState->SunDesc[0].radius);
+	pSolarSysState->SunDesc[0].location =
+			planetOuterLocation (planetIndex (pSolarSysState, planet));
 	GLOBAL (ip_location) = pSolarSysState->SunDesc[0].location;
 	XFormIPLoc (&GLOBAL (ip_location), &GLOBAL (ShipStamp.origin), TRUE);
 	ZeroVelocityComponents (&GLOBAL (velocity));
 
 	// Now the ship is in outer system (as per game logic)
 
+	if (TEXTURED_PLANETS) {
+		// BW: clean up data generated for textured IP moons
+		for (i = 0, pMoonDesc = pSolarSysState->MoonDesc;
+			 i < planet->NumPlanets; ++i, ++pMoonDesc)
+		{
+			if (!(pMoonDesc->data_index & WORLD_TYPE_SPECIAL)) {
+				PLANET_ORBIT *Orbit = &pMoonDesc->orbit;
+
+				HFree (Orbit->lpTopoData);
+				Orbit->lpTopoData = 0;
+				DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+				Orbit->SphereFrame = NULL;
+		
+				DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+				Orbit->ObjectFrame = 0;
+				DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+				Orbit->WorkFrame = 0;
+
+				HFree (Orbit->TopoColors);
+				Orbit->TopoColors = NULL;
+				HFree (Orbit->ScratchArray);
+				Orbit->ScratchArray = NULL;
+				if (Orbit->map_rotate && Orbit->light_diff) {
+					for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++) {
+						HFree (Orbit->map_rotate[j]);
+						HFree (Orbit->light_diff[j]);
+					}
+				}
+
+				HFree (Orbit->map_rotate);
+				Orbit->map_rotate = NULL;
+				HFree (Orbit->light_diff);
+				Orbit->light_diff = NULL;
+			}
+		}
+		// End clean up
+	}
+
 	pSolarSysState->WaitIntersect = outerPlanetWait;
 	// See if we also intersect with another planet, and if we do,
 	// disable collisions comletely until we stop intersecting
@@ -955,6 +1341,7 @@ static BOOLEAN
 CheckShipLocation (SIZE *newRadius)
 {
 	SIZE radius;
+	BYTE ec = GET_GAME_STATE (ESCAPE_COUNTER); // JMS_GFX
 
 	radius = pSolarSysState->SunDesc[0].radius;
 	*newRadius = pSolarSysState->SunDesc[0].radius;
@@ -992,7 +1379,7 @@ CheckShipLocation (SIZE *newRadius)
 		return TRUE;
 	}
 
-	if (GLOBAL (autopilot.x) == ~0 && GLOBAL (autopilot.y) == ~0)
+	if (GLOBAL (autopilot.x) == ~0 && GLOBAL (autopilot.y) == ~0 && (ec < 60))
 	{	// Not on autopilot -- may collide with a planet
 		PLANET_DESC *planet = CheckIntersect ();
 		if (planet)
@@ -1037,7 +1424,7 @@ TransitionSystemIn (void)
 static void
 ScaleSystem (SIZE new_radius)
 {
-#ifdef SMOOTH_SYSTEM_ZOOM
+#ifdef SMOOTH_SYSTEM_ZOOM // Enabled this for shits 'n gigs.
 	// XXX: This appears to have been an attempt to zoom the system view
 	//   in a different way. This code zooms gradually instead of
 	//   doing a crossfade from one zoom level to the other.
@@ -1046,7 +1433,7 @@ ScaleSystem (SIZE new_radius)
 	//   controls are not handled in the loop, and the flagship
 	//   can collide with a group while zooming, and that is not handled
 	//   100% correctly.
-#define NUM_STEPS 10
+#define NUM_STEPS 1
 	COUNT i;
 	SIZE old_radius;
 	SIZE d, step;
@@ -1108,38 +1495,237 @@ RestoreSystemView (void)
 	DrawStamp (&s);
 }
 
+static void
+CalcSunSize (PLANET_DESC *pSunDesc, SIZE radius)
+{
+	SIZE index = 0;
+
+	if (radius <= (MAX_ZOOM_RADIUS >> 1))
+	{
+		++index;
+		if (radius <= (MAX_ZOOM_RADIUS >> 2))
+			++index;
+	}
+
+	pSunDesc->image.origin.x = SIS_SCREEN_WIDTH >> 1;
+	pSunDesc->image.origin.y = SIS_SCREEN_HEIGHT >> 1;
+	pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index);
+}
+
+static void
+SetPlanetColorMap (PLANET_DESC *planet)
+{
+	COUNT index = planet->data_index & ~WORLD_TYPE_SPECIAL;
+	assert (index < NUMBER_OF_PLANET_TYPES);
+	SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (OrbitalCMap,
+			PLANCOLOR (PlanData[index].Type))));
+}
+
+static void
+DrawTexturedBody (PLANET_DESC* planet, STAMP s)
+{
+	int oldScale;
+	int oldMode;
+	
+	BatchGraphics ();
+	oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
+	if (worldIsMoon(pSolarSysState, planet))
+		oldScale = SetGraphicScale (GSCALE_IDENTITY * planet->size / GENERATE_MOON_DIAMETER);
+	else
+		oldScale = SetGraphicScale (GSCALE_IDENTITY * planet->size / GENERATE_PLANET_DIAMETER);
+	s.frame = planet->orbit.SphereFrame;
+	DrawStamp (&s);
+	if (planet->orbit.ObjectFrame)
+	{
+		s.frame = planet->orbit.ObjectFrame;
+		DrawStamp (&s);
+	}
+	SetGraphicScale (oldScale);
+	SetGraphicScaleMode (oldMode);
+	
+	UnbatchGraphics ();
+}
+
+static void
+DrawInnerPlanets (PLANET_DESC *planet)
+{
+	STAMP s;
+	COUNT i;
+	PLANET_DESC *moon;
+
+	s.origin.x = SIS_SCREEN_WIDTH >> 1;
+	s.origin.y = SIS_SCREEN_HEIGHT >> 1;
+
+	if (TEXTURED_PLANETS) {
+		// Draw the planet image
+		DrawTexturedBody (planet, s);
+		
+		// Draw the moon images
+		for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
+		     i; --i, ++moon)
+		{
+			if (moon->data_index & WORLD_TYPE_SPECIAL)
+				DrawStamp (&moon->image);
+			else
+				DrawTexturedBody(moon, moon->image);
+		}
+	} else {
+		// Draw the planet image
+		SetPlanetColorMap (planet);
+		s.frame = planet->image.frame;
+
+		i = planet->data_index & ~WORLD_TYPE_SPECIAL;
+		if (i < NUMBER_OF_PLANET_TYPES
+			&& (planet->data_index & PLANET_SHIELDED))
+		{	// Shielded world looks "shielded" in inner view
+			s.frame = SetAbsFrameIndex (SpaceJunkFrame, 17);
+		}
+		DrawStamp (&s);
+
+		// Draw the moon images
+		for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
+			i; --i, ++moon)
+		{
+			if (!(moon->data_index & WORLD_TYPE_SPECIAL))
+				SetPlanetColorMap (moon);
+			DrawStamp (&moon->image);
+		}
+	}
+}
+
+static void
+DrawOuterPlanets (SIZE radius)
+{
+	SIZE index;
+	PLANET_DESC *pCurDesc;
+	
+	CalcSunSize (&pSolarSysState->SunDesc[0], radius);
+	
+	index = pSolarSysState->FirstPlanetIndex;
+	for (;;)
+	{
+		pCurDesc = &pSolarSysState->PlanetDesc[index];
+		if (TEXTURED_PLANETS)
+		{
+			if (pCurDesc == &pSolarSysState->SunDesc[0])
+			{	// It's a sun
+				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
+					SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
+				DrawStamp (&pCurDesc->image);
+			}
+			else
+			{	// It's a planet
+				DrawTexturedBody(pCurDesc, pCurDesc->image);
+			}
+		}
+		else
+		{
+			if (pCurDesc == &pSolarSysState->SunDesc[0])
+			{	// It's a sun
+				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
+					SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
+			}
+			else
+			{	// It's a planet
+				SetPlanetColorMap (pCurDesc);
+			}
+			DrawStamp (&pCurDesc->image);
+		}
+		
+		if (index == pSolarSysState->LastPlanetIndex)
+			break;
+		index = pCurDesc->NextIndex;
+	}
+}
+
+void RotatePlanets (BOOLEAN IsInnerSystem, SIZE frameCounter)
+{
+	PLANET_DESC *planet;
+	PLANET_DESC *moon;
+	COUNT i;
+
+	// Do not try to rotate planets that haven't been generated yet.
+	if (!pSolarSysState->PlanetDesc->orbit.lpTopoData)
+		return;
+	
+	if (IsInnerSystem) {
+		planet = pSolarSysState->pOrbitalDesc;
+		PrepareNextRotationFrame (planet, frameCounter, FALSE);
+		for (i = 0; i < planet->NumPlanets; ++i) {
+			moon = &pSolarSysState->MoonDesc[i];
+			if (!(moon->data_index & WORLD_TYPE_SPECIAL))
+				PrepareNextRotationFrame (moon, frameCounter, FALSE);
+		}
+	} else {
+		for (i = pSolarSysState->SunDesc[0].NumPlanets,
+			     planet = &pSolarSysState->PlanetDesc[0]; i; --i, ++planet)
+			PrepareNextRotationFrame (planet, frameCounter, FALSE);
+	}
+}
+
 // Normally called by DoIpFlight() to process a frame
 static void
 IP_frame (void)
 {
 	BOOLEAN locChange;
 	SIZE newRadius;
+	static SIZE frameCounter;
 
 	SetContext (SpaceContext);
 
 	GameClockTick ();
+	++frameCounter;
+	//frameCounter = frameCounter % 5; // (ONE_SECOND/IP_FRAME_RATE); // % 30
 	ProcessShipControls ();
 	
 	locChange = CheckShipLocation (&newRadius);
-	if (locChange)
-	{
-		if (playerInInnerSystem ())
-		{	// Entering inner system
+	if (locChange) {
+		if (playerInInnerSystem ()) {	// Entering inner system
 			DrawSystemTransition (TRUE);
-		}
-		else if (pSolarSysState->SunDesc[0].radius == newRadius)
-		{	// Leaving inner system to outer
+		} else if (pSolarSysState->SunDesc[0].radius == newRadius) {	
+			// Leaving inner system to outer
 			DrawSystemTransition (FALSE);
-		}
-		else
-		{	// Zooming outer system
+		} else {	// Zooming outer system
 			ScaleSystem (newRadius);
 		}
-	}
-	else
-	{	// Just flying around, minding own business..
+	} else if (!pSolarSysState->InOrbit) {
+		// Just flying around, minding own business..
 		BatchGraphics ();
 		RestoreSystemView ();
+
+		if (ORBITING_PLANETS) {
+			// BW: recompute planet position to account for orbiting
+			if (playerInInnerSystem ()) {
+				// Draw the inner system view
+				ValidateInnerOrbits ();
+			} else {
+				// Draw the outer system view
+				ValidateOrbits ();
+			}
+		}
+		
+		if (ROTATING_PLANETS) {
+		// BW: rotate planets
+		// every frame in Inner (not much CPU required)
+		// depending on planet size and speed in Outer
+			if (playerInInnerSystem ()) {
+				RotatePlanets (TRUE, frameCounter);
+			} else {
+				RotatePlanets (FALSE, frameCounter);
+			}
+		}
+
+		if (ORBITING_PLANETS || ROTATING_PLANETS) { 
+			// Planets have probably moved or changed
+			if (playerInInnerSystem ()) {	
+				// Draw the inner system view
+				DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
+			} else {
+				// Draw the outer system view
+				DrawOuterPlanets (pSolarSysState->SunDesc[0].radius);
+			}
+		}
+
 		RedrawQueue (FALSE);
 		DrawAutoPilotMessage (FALSE);
 		UnbatchGraphics ();
@@ -1207,7 +1793,10 @@ DrawInnerSystem (void)
 {
 	ValidateInnerOrbits ();
 	DrawSystem (pSolarSysState->pOrbitalDesc->radius, TRUE);
+	if (ORBITING_PLANETS || ROTATING_PLANETS)
+		DrawInnerPlanets(pSolarSysState->pOrbitalDesc);
 	DrawSISTitle (GLOBAL_SIS (PlanetName));
+	IP_frame(); // MB: To fix planet texture and sun corona 'pop-in'
 }
 
 static void
@@ -1215,7 +1804,10 @@ DrawOuterSystem (void)
 {
 	ValidateOrbits ();
 	DrawSystem (pSolarSysState->SunDesc[0].radius, FALSE);
-	DrawHyperCoords (CurStarDescPtr->star_pt);
+	if (ORBITING_PLANETS || ROTATING_PLANETS)
+		DrawOuterPlanets(pSolarSysState->SunDesc[0].radius);
+ 	DrawHyperCoords (CurStarDescPtr->star_pt);
+	IP_frame(); // MB: To fix planet texture and sun corona 'pop-in'
 }
 
 static void
@@ -1255,24 +1847,26 @@ ResetSolarSys (void)
 static void
 EnterPlanetOrbit (void)
 {
-	if (pSolarSysState->InIpFlight)
-	{	// This means we hit a planet in IP flight; not a Load into orbit
+	//	if (pSolarSysState->InIpFlight)
+	//	{	// This means we hit a planet in IP flight; not a Load into orbit
+	// BW: It seems that even a Load generates a solar system...
 		FreeSolarSys ();
 
 		if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
-		{	// Moon -- use its origin
+		{	
+			// int moon;
+			// Moon -- use its origin
 			// XXX: The conversion functions do not error-correct, so the
 			//   point we set here will change once flag_ship_preprocess()
 			//   in ipdisp.c starts over again.
-			GLOBAL (ShipStamp.origin) =
-					pSolarSysState->pOrbitalDesc->image.origin;
+			GLOBAL (ShipStamp.origin) = pSolarSysState->pOrbitalDesc->image.origin;
 		}
 		else
 		{	// Planet -- its origin is for the outer view, so use mid-screen
 			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
 			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
 		}
-	}
+	// }
 
 	GetPlanetInfo ();
 	(*pSolarSysState->genFuncs->generateOrbital) (pSolarSysState,
@@ -1281,7 +1875,9 @@ EnterPlanetOrbit (void)
 	if ((GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD |
 			START_ENCOUNTER)) || GLOBAL_SIS (CrewEnlisted) == (COUNT)~0
 			|| GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
-		return;
+		{
+			return;
+		}
 
 	// Implement a to-do in generate.h for a better test
 	if (pSolarSysState->TopoFrame)
@@ -1306,6 +1902,13 @@ EnterPlanetOrbit (void)
 		ValidateOrbits ();
 		ValidateInnerOrbits ();
 		ResetSolarSys ();
+		if (TEXTURED_PLANETS) {
+			if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc)) {
+				GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc->pPrevDesc);
+			} else {
+				GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc);
+			}
+		}
 
 		RepairSISBorder ();
 		TransitionSystemIn ();
@@ -1380,6 +1983,10 @@ InitSolarSys (void)
 
 		ResetSolarSys ();
 
+		// JMS: This is to prevent flashing the 3do "navigate"
+		// unnecessarily whilst starting a new game.
+		SetFlashRect (NULL);
+
 		if (LastActivity == (CHECK_LOAD | CHECK_RESTART))
 		{	// Starting a new game, NOT from load!
 			// We have to fade the screen in from intro or menu
@@ -1397,8 +2004,12 @@ InitSolarSys (void)
 		}
 		else
 		{	// Entered a new system, or loaded into inner or outer
-			if (InnerSystem)
-				DrawInnerSystem ();
+			if (InnerSystem) {
+				if (TEXTURED_PLANETS) {
+					GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc);
+				}
+ 				DrawInnerSystem ();
+			}
 			else
 				DrawOuterSystem ();
 			RedrawQueue (FALSE);
@@ -1407,6 +2018,7 @@ InitSolarSys (void)
 
 			LastActivity &= ~CHECK_LOAD;
 		}
+		IP_frame(); // MB: To fix planet texture and sun corona 'pop-in'
 	}
 }
 
@@ -1461,8 +2073,8 @@ UninitSolarSys (void)
 {
 	FreeSolarSys ();
 
-//FreeLanderData ();
-//FreeIPData ();
+	// FreeLanderData (); // JMS: This is not needed since the landerframes won't reload if they're already loaded once.
+	FreeIPData (); // JMS This IS necessary.
 
 	DestroyDrawable (ReleaseDrawable (StarsFrame));
 	StarsFrame = NULL;
@@ -1490,63 +2102,6 @@ UninitSolarSys (void)
 }
 
 static void
-CalcSunSize (PLANET_DESC *pSunDesc, SIZE radius)
-{
-	SIZE index = 0;
-
-	if (radius <= (MAX_ZOOM_RADIUS >> 1))
-	{
-		++index;
-		if (radius <= (MAX_ZOOM_RADIUS >> 2))
-			++index;
-	}
-
-	pSunDesc->image.origin.x = SIS_SCREEN_WIDTH >> 1;
-	pSunDesc->image.origin.y = SIS_SCREEN_HEIGHT >> 1;
-	pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index);
-}
-
-static void
-SetPlanetColorMap (PLANET_DESC *planet)
-{
-	COUNT index = planet->data_index & ~WORLD_TYPE_SPECIAL;
-	assert (index < NUMBER_OF_PLANET_TYPES);
-	SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (OrbitalCMap,
-			PLANCOLOR (PlanData[index].Type))));
-}
-
-static void
-DrawInnerPlanets (PLANET_DESC *planet)
-{
-	STAMP s;
-	COUNT i;
-	PLANET_DESC *moon;
-
-	// Draw the planet image
-	SetPlanetColorMap (planet);
-	s.origin.x = SIS_SCREEN_WIDTH >> 1;
-	s.origin.y = SIS_SCREEN_HEIGHT >> 1;
-	s.frame = planet->image.frame;
-
-	i = planet->data_index & ~WORLD_TYPE_SPECIAL;
-	if (i < NUMBER_OF_PLANET_TYPES
-			&& (planet->data_index & PLANET_SHIELDED))
-	{	// Shielded world looks "shielded" in inner view
-		s.frame = SetAbsFrameIndex (SpaceJunkFrame, 17);
-	}
-	DrawStamp (&s);
-
-	// Draw the moon images
-	for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
-			i; --i, ++moon)
-	{
-		if (!(moon->data_index & WORLD_TYPE_SPECIAL))
-			SetPlanetColorMap (moon);
-		DrawStamp (&moon->image);
-	}
-}
-
-static void
 DrawSystem (SIZE radius, BOOLEAN IsInnerSystem)
 {
 	BYTE i;
@@ -1555,6 +2110,12 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 	CONTEXT oldContext;
 	STAMP s;
 
+	if (TEXTURED_PLANETS) {
+		// BW: This to test if we have already rendered 
+		if (!pSolarSysState->PlanetDesc->orbit.lpTopoData)
+			GenerateTexturedPlanets();
+	}
+
 	if (!SolarSysFrame)
 	{	// Create the saved view graphic
 		RECT clipRect;
@@ -1588,34 +2149,13 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 					radius);
 	}
 
-	if (IsInnerSystem)
-	{	// Draw the inner system view
-		DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
-	}
-	else
-	{	// Draw the outer system view
-		SIZE index;
-
-		CalcSunSize (&pSolarSysState->SunDesc[0], radius);
-
-		index = pSolarSysState->FirstPlanetIndex;
-		for (;;)
-		{
-			pCurDesc = &pSolarSysState->PlanetDesc[index];
-			if (pCurDesc == &pSolarSysState->SunDesc[0])
-			{	// It's a sun
-				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
-						SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
-			}
-			else
-			{	// It's a planet
-				SetPlanetColorMap (pCurDesc);
-			}
-			DrawStamp (&pCurDesc->image);
-
-			if (index == pSolarSysState->LastPlanetIndex)
-				break;
-			index = pCurDesc->NextIndex;
+	if (!ORBITING_PLANETS && !ROTATING_PLANETS) {
+		if (IsInnerSystem) {	
+			// Draw the inner system view
+			DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
+		} else {	
+			// Draw the outer system view
+			DrawOuterPlanets (radius);
 		}
 	}
 
@@ -1626,6 +2166,7 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 	s.origin.y = 0;
 	s.frame = SolarSysFrame;
 	DrawStamp (&s);
+	IP_frame();  // MB: To fix planet texture and sun corona 'pop-in'
 }
 
 void
@@ -1644,10 +2185,12 @@ CreateStarBackGround (void)
 {
 	COUNT i, j;
 	DWORD rand_val;
-	STAMP s;
+	STAMP s, nebula; // JMS (added that nebula there)
 	CONTEXT oldContext;
 	RECT clipRect;
 	FRAME frame;
+	BYTE numNebulae = 44;
+	COUNT NebulaePercent = CurStarDescPtr->star_pt.x % numNebulae;
 
 	// Use SpaceContext to find out the dimensions of the background
 	oldContext = SetContext (SpaceContext);
@@ -1694,6 +2237,16 @@ CreateStarBackGround (void)
 		}
 		s.frame = IncFrameIndex (s.frame);
 	}
+	
+	if (optNebulae && seroNebulaePresent && (CurStarDescPtr->star_pt.y % (numNebulae + 6)) < numNebulae){ // MB: Make some solar systems not have nebulae
+		nebula.origin.x = nebula.origin.y = 0;
+		nebula.frame = SetAbsFrameIndex (NebulaeFrame, NebulaePercent);
+		DrawStamp(&nebula);
+#ifdef DEBUG
+		// Prints out the frame number of the current system's nebula
+		printf("Nebula Frame: %d\n", NebulaePercent);
+#endif	
+	}
 
 	SetContext (oldContext);
 
@@ -1825,8 +2378,10 @@ void
 GetPlanetOrMoonName (UNICODE *buf, COUNT bufsize)
 {
 	UNICODE *named;
-	int moon;
-	int i;
+	UNICODE *tempbuf;
+	int		moon;
+	int		i;
+	BOOLEAN name_has_suffix = FALSE;
 
 	named = GetNamedPlanetaryBody ();
 	if (named)
@@ -1846,11 +2401,20 @@ GetPlanetOrMoonName (UNICODE *buf, COUNT
 
 	// Orbiting an unnamed moon
 	i = strlen (buf);
+	tempbuf = buf;
 	buf += i;
 	bufsize -= i;
 	moon = moonIndex (pSolarSysState, pSolarSysState->pOrbitalDesc);
-	if (bufsize >= 3)
-	{
+	
+	log_add (log_Debug,"last %02d, i %d", tempbuf[i-1], i);	
+	// JMS: Prevent printing something like 'planet II-A-A' in summary screen.
+	if (i > 0) {
+		if(tempbuf[i-1] == 'A' || tempbuf[i-1] == 'B' 
+			|| tempbuf[i-1] == 'C' || tempbuf[i-1] == 'D')
+			name_has_suffix = TRUE;
+	}
+	
+	if (bufsize >= 3 && !name_has_suffix) {
 		snprintf (buf, bufsize, "-%c", 'A' + moon);
 		buf[bufsize - 1] = '\0';
 	}
diff -ruNp src.orig/uqm/planets/solarsys.h src/uqm/planets/solarsys.h
--- src.orig/uqm/planets/solarsys.h	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/solarsys.h	2017-11-22 08:52:12 -0600
@@ -23,6 +23,8 @@
 extern "C" {
 #endif
 
+#define SMOOTH_SYSTEM_ZOOM
+
 extern void LoadIPData (void);
 extern void FreeIPData (void);
 
diff -ruNp src.orig/uqm/planets/surface.c src/uqm/planets/surface.c
--- src.orig/uqm/planets/surface.c	2017-11-21 16:07:12 -0600
+++ src/uqm/planets/surface.c	2017-11-22 08:52:12 -0600
@@ -47,18 +47,36 @@ CalcMineralDeposits (const SYSTEM_INFO *
 		while (num_possible--)
 		{
 #define MEDIUM_DEPOSIT_THRESHOLD 150
-#define LARGE_DEPOSIT_THRESHOLD 225
+#define LARGE_DEPOSIT_THRESHOLD 220
 			COUNT deposit_quality_fine;
 			COUNT deposit_quality_gross;
 
+			// JMS: For making the mineral blip smaller in case it is partially scavenged.
+			SDWORD temp_deposit_quality;
+
 			deposit_quality_fine = (LOWORD (RandomContext_Random (SysGenRNG)) % 100)
 					+ (
 					DEPOSIT_QUALITY (eptr->Density)
 					+ SysInfoPtr->StarSize
 					) * 50;
-			if (deposit_quality_fine < MEDIUM_DEPOSIT_THRESHOLD)
+
+			// JMS: This makes the mineral blip smaller in case it is partially scavenged.
+			if (which_deposit < 32)
+				temp_deposit_quality = deposit_quality_fine - ((SysInfoPtr->PlanetInfo.PartiallyScavengedList[MINERAL_SCAN][which_deposit]) * 10);
+			// JMS: In case which_deposit >= 32 (most likely 65535), it means that this
+			// function is being called only to count the number of deposit nodes on the
+			// surface. In that case we don't need to use the PartiallyScavengedList
+			// since the amount of minerals in that node is not stored yet.
+			// (AND we cannot use the list since accessing element 65535 would crash the game ;)
+			else
+				temp_deposit_quality = deposit_quality_fine;
+			
+			if (temp_deposit_quality < 0)
+				temp_deposit_quality = 0;
+			
+			if (temp_deposit_quality < MEDIUM_DEPOSIT_THRESHOLD)
 				deposit_quality_gross = 0;
-			else if (deposit_quality_fine < LARGE_DEPOSIT_THRESHOLD)
+			else if (temp_deposit_quality < LARGE_DEPOSIT_THRESHOLD)
 				deposit_quality_gross = 1;
 			else
 				deposit_quality_gross = 2;
diff -ruNp src.orig/uqm/races.h src/uqm/races.h
--- src.orig/uqm/races.h	2017-11-21 16:07:12 -0600
+++ src/uqm/races.h	2017-11-22 08:52:12 -0600
@@ -56,6 +56,8 @@ extern "C" {
 #define DONT_CHASE        (1 << 12)
 #define PLAYER_CAPTAIN    (1 << 13)
 		/* The protagonist himself is on board. He gets a different color. */
+#define LIGHT_POINT_DEFENSE (1 << 14)
+#define HEAVY_POINT_DEFENSE (1 << 15)
 
 typedef UWORD STATUS_FLAGS;
 
@@ -389,6 +391,7 @@ enum
 	DEAD_GUY = 0,  // Race is extinct
 	GOOD_GUY,      // Race is allied with the player
 	BAD_GUY,       // Race is not allied with the player
+	CAN_BUILD,	   // Ships can be built regardless
 };
 
 static inline FLEET_INFO *
@@ -593,7 +596,7 @@ typedef enum
 		 0,  /* URQUAN_DRONE_SHIP */
 
 #define RACE_INTERPLANETARY_PERCENT \
-		 0,  /* ARILOU_SHIP */ \
+		 5,  /* ARILOU_SHIP */ \
 		 0,  /* CHMMR_SHIP */ \
 		 0,  /* HUMAN_SHIP */ \
 		20,  /* ORZ_SHIP */ \
@@ -647,30 +650,108 @@ typedef enum
 		MAKE_BYTE (1, 5),  /* YEHAT_REBEL_SHIP */
 
 #define RACE_COLORS \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x10), 0x53),  /* ARILOU_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* CHMMR_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x12), 0x53),  /* ARILOU_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0D, 0x0D, 0x0D), 0x00),  /* CHMMR_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x01, 0x1f), 0x4D),  /* HUMAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x00, 0x0E), 0x36),  /* ORZ_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* PKUNK_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* SHOFIXTI_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0C, 0x05, 0x00), 0x76),  /* SPATHI_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0C, 0x05, 0x00), 0x76),  /* SUPOX_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* THRADDASH_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* UTWIG_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x10), 0x53),  /* VUX_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x00, 0x11), 0x3D),  /* YEHAT_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x09, 0x11), 0x62),  /* PKUNK_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x06, 0x00), 0x77),  /* SHOFIXTI_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x07, 0x00), 0x76),  /* SPATHI_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x07, 0x00), 0x76),  /* SUPOX_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x09, 0x11), 0x62),  /* THRADDASH_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x09, 0x11), 0x62),  /* UTWIG_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x12), 0x53),  /* VUX_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0B, 0x00, 0x12), 0x3D),  /* YEHAT_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* MELNORME_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),  /* DRUUGE_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x00, 0x0E), 0x36),  /* ILWRATH_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x00, 0x0E), 0x36),  /* MYCON_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0C, 0x05, 0x00), 0x76),  /* SLYLANDRO_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x08, 0x08, 0x0D), 0x76),  /* SLYLANDRO_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x00, 0x11), 0x3D),  /* UMGAH_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x08, 0x00), 0x6E),  /* URQUAN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x10, 0x00), 0x6E),  /* URQUAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),  /* ZOQFOTPIK_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* SYREEN_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x06, 0x06, 0x06), 0x20),  /* BLACK_URQUAN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0B, 0x00), 0x00),  /* SYREEN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x08, 0x08, 0x08), 0x20),  /* BLACK_URQUAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x14, 0x07, 0x1F), 0x39),  /* YEHAT_REBEL_SHIP */
 
+// JMS: For showing the SC1-era situation in starmap
+#define RACE_PREWAR_STRENGTHS \
+		0,    /* ARILOU_SHIP */ \
+		500,  /* CHMMR_SHIP masquerading as Mmrnmhrm */ \
+		400,  /* HUMAN_SHIP */ \
+		0,    /* ORZ_SHIP */ \
+		642,  /* PKUNK_SHIP, should be marked 'Unknown' */ \
+		400,  /* SHOFIXTI_SHIP */ \
+		1003, /* SPATHI_SHIP */ \
+		0,	  /* SUPOX_SHIP */ \
+		835,  /* THRADDASH_SHIP, should be marked 'Unknown' */ \
+		0,    /* UTWIG_SHIP masquerading as Chenjesu */ \
+		700,  /* VUX_SHIP */ \
+		1100, /* YEHAT_SHIP */ \
+		0,	  /* MELNORME_SHIP */ \
+		800,  /* DRUUGE_SHIP, should be marked 'Unknown' */ \
+		500,  /* ILWRATH_SHIP */ \
+		650,  /* MYCON_SHIP */ \
+		750,  /* SLYLANDRO_SHIP masquerading as Chenjesu */ \
+		633,  /* UMGAH_SHIP */ \
+		0,    /* URQUAN_SHIP */ \
+		0,	  /* ZOQFOTPIK_SHIP */ \
+		450,  /* SYREEN_SHIP masquareding as Androsynth */ \
+		0,	  /* BLACK_URQUAN_SHIP */ \
+		0,	  /* YEHAT_REBEL_SHIP */
+		
+// JMS: For showing the SC1-era situation in starmap
+#define RACE_PREWAR_LOCATIONS \
+		{0,0},		 /* ARILOU_SHIP */ \
+		{742,2968},	 /* CHMMR_SHIP masquerading as Mmrnmhrm */ \
+		{1752,1450}, /* HUMAN_SHIP */ \
+		{0,0 },		 /* ORZ_SHIP */ \
+		{502,401},   /* PKUNK_SHIP, should be marked 'Unknown' */ \
+		{2908,269},	 /* SHOFIXTI_SHIP */ \
+		{2549,3600}, /* SPATHI_SHIP */ \
+		{0,0},		 /* SUPOX_SHIP */ \
+		{2535,8358}, /* THRADDASH_SHIP, should be marked 'Unknown' */ \
+		{0,0},		 /* UTWIG_SHIP masquerading as Chenjesu */ \
+		{4333,1687}, /* VUX_SHIP */ \
+		{4923,294},  /* YEHAT_SHIP */ \
+		{0,0},		 /* MELNORME_SHIP */ \
+		{9469,2806}, /* DRUUGE_SHIP, should be marked 'Unknown' */ \
+		{229,3666},  /* ILWRATH_SHIP */ \
+		{6392,2200}, /* MYCON_SHIP */ \
+		{0742,2268}, /* SLYLANDRO_SHIP masquerading as Chenjesu */ \
+		{1978,5968}, /* UMGAH_SHIP */ \
+		{0,0},		 /* URQUAN_SHIP */ \
+		{0,0},		 /* ZOQFOTPIK_SHIP */ \
+		{3587,2566}, /* SYREEN_SHIP masquerading as Androsynth */ \
+		{0,0},		 /* BLACK_URQUAN_SHIP */ \
+		{0,0},		 /* YEHAT_REBEL_SHIP */
+		
+// JMS: For showing the SC1-era situation in starmap
+#define RACE_PREWAR_NAME_UNKNOWN \
+		FALSE,  /* ARILOU_SHIP */ \
+		FALSE,  /* CHMMR_SHIP masquerading as Mmrnmhrm */ \
+		FALSE,  /* HUMAN_SHIP */ \
+		FALSE,  /* ORZ_SHIP */ \
+		TRUE,   /* PKUNK_SHIP, should be marked 'Unknown' */ \
+		FALSE,  /* SHOFIXTI_SHIP */ \
+		FALSE,  /* SPATHI_SHIP */ \
+		FALSE,	/* SUPOX_SHIP */ \
+		TRUE,   /* THRADDASH_SHIP, should be marked 'Unknown' */ \
+		FALSE,  /* UTWIG_SHIP */ \
+		FALSE,  /* VUX_SHIP */ \
+		FALSE,  /* YEHAT_SHIP */ \
+		FALSE,	/* MELNORME_SHIP */ \
+		TRUE,   /* DRUUGE_SHIP, should be marked 'Unknown' */ \
+		FALSE,  /* ILWRATH_SHIP */ \
+		FALSE,  /* MYCON_SHIP */ \
+		FALSE,	/* SLYLANDRO_SHIP masquerading as Chenjesu */ \
+		FALSE,  /* UMGAH_SHIP */ \
+		FALSE,  /* URQUAN_SHIP */ \
+		FALSE,	/* ZOQFOTPIK_SHIP */ \
+		FALSE,  /* SYREEN_SHIP masquareding as Androsynth */ \
+		FALSE,	/* BLACK_URQUAN_SHIP */ \
+		FALSE,	/* YEHAT_REBEL_SHIP */
+
 #if defined(__cplusplus)
 }
 #endif
diff -ruNp src.orig/uqm/restart.c src/uqm/restart.c
--- src.orig/uqm/restart.c	2017-11-21 16:07:12 -0600
+++ src/uqm/restart.c	2017-11-22 08:52:12 -0600
@@ -40,7 +40,8 @@
 #include "uqmversion.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
-
+#include "libs/graphics/sdl/pure.h"
+#include "options.h"
 
 enum
 {
@@ -59,6 +60,7 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	STAMP s;
 	TEXT t;
 	UNICODE buf[64];
+	COUNT svn_revision = 0; // JMS
 
 	s.frame = pMS->CurFrame;
 	GetFrameRect (s.frame, &r);
@@ -74,14 +76,20 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	// Put the version number in the bottom right corner.
 	SetContextFont (TinyFont);
 	t.pStr = buf;
-	t.baseline.x = SCREEN_WIDTH - 3;
+	t.baseline.x = SCREEN_WIDTH - 2;
 	t.baseline.y = SCREEN_HEIGHT - 2;
 	t.align = ALIGN_RIGHT;
 	t.CharCount = (COUNT)~0;
-	sprintf (buf, "v%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
-			UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
+	sprintf (buf, "v%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION, UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
 	SetContextForeGroundColor (WHITE_COLOR);
 	font_DrawText (&t);
+	// Put the main menu music credit in the bottom left corner.
+	memset(&buf[0], 0, sizeof(buf));
+	t.baseline.x = 2;
+	t.baseline.y = SCREEN_HEIGHT - 2;
+	t.align = ALIGN_LEFT;
+	sprintf (buf, "Main Menu Music by Saibuster");
+	font_DrawText (&t);
 
 	UnbatchGraphics ();
 }
@@ -118,22 +126,26 @@ DoRestart (MENU_STATE *pMS)
 			pMS->hMusic = 0;
 		}
 		pMS->hMusic = LoadMusic (MAINMENU_MUSIC);
-		InactTimeOut = (pMS->hMusic ? 120 : 20) * ONE_SECOND;
+		InactTimeOut = (pMS->hMusic && optMainMenuMusic ? 86 : 20) * ONE_SECOND;
 		pMS->flashContext = Flash_createOverlay (ScreenContext,
 				NULL, NULL);
 		Flash_setMergeFactors (pMS->flashContext, -3, 3, 16);
-		Flash_setSpeed (pMS->flashContext, (6 * ONE_SECOND) / 16, 0,
-				(6 * ONE_SECOND) / 16, 0);
+		Flash_setSpeed (pMS->flashContext, (6 * ONE_SECOND) / 14, 0,
+				(6 * ONE_SECOND) / 14, 0);
 		Flash_setFrameTime (pMS->flashContext, ONE_SECOND / 16);
 		Flash_setState(pMS->flashContext, FlashState_fadeIn,
 				(3 * ONE_SECOND) / 16);
 		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
 		Flash_start (pMS->flashContext);
-		PlayMusic (pMS->hMusic, TRUE, 1);
 		LastInputTime = GetTimeCounter ();
 		pMS->Initialized = TRUE;
 
 		SleepThreadUntil (FadeScreen (FadeAllToColor, ONE_SECOND / 2));
+		FadeMusic(0,0);
+		PlayMusic (pMS->hMusic, TRUE, 1);
+		
+		if (optMainMenuMusic)
+			FadeMusic (NORMAL_VOLUME+70, ONE_SECOND * 3);
 	}
 	else if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 	{
@@ -161,6 +173,7 @@ DoRestart (MENU_STATE *pMS)
 				SetupMenu ();
 				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
 						MENU_SOUND_SELECT);
+				InactTimeOut = (pMS->hMusic && optMainMenuMusic ? 86 : 20) * ONE_SECOND;
 				LastInputTime = GetTimeCounter ();
 				SetTransitionSource (NULL);
 				BatchGraphics ();
@@ -308,11 +321,17 @@ RestartMenu (MENU_STATE *pMS)
 	SetDefaultMenuRepeatDelay ();
 	DoInput (pMS, TRUE);
 	
+	if (optMainMenuMusic)
+		SleepThreadUntil (FadeMusic (0, ONE_SECOND));
+
 	StopMusic ();
 	if (pMS->hMusic)
 	{
 		DestroyMusic (pMS->hMusic);
 		pMS->hMusic = 0;
+
+		if (optMainMenuMusic)
+			FadeMusic (NORMAL_VOLUME, 0);
 	}
 
 	Flash_terminate (pMS->flashContext);
@@ -381,6 +400,9 @@ StartGame (void)
 			{	// timed out
 				GLOBAL (CurrentActivity) = 0;
 				SplashScreen (0);
+				if(optWhichIntro == OPT_3DO && optFMV){
+					Drumall ();
+				}
 				Credits (FALSE);
 			}
 
@@ -390,7 +412,10 @@ StartGame (void)
 
 		if (LastActivity & CHECK_RESTART)
 		{	// starting a new game
-			Introduction ();
+			FadeMusic (NORMAL_VOLUME, 0);
+			if(!optSkipIntro){
+				Introduction ();
+			}
 		}
 	
 	} while (GLOBAL (CurrentActivity) & CHECK_ABORT);
diff -ruNp src.orig/uqm/setup.c src/uqm/setup.c
--- src.orig/uqm/setup.c	2017-11-21 16:07:12 -0600
+++ src/uqm/setup.c	2017-11-22 09:28:15 -0600
@@ -62,11 +62,17 @@ FONT TinyFont;
 QUEUE race_q[NUM_PLAYERS];
 FRAME ActivityFrame;
 FRAME StatusFrame;
+FRAME SubmenuFrame;
+FRAME ConstellationsFrame; // JMS
+FRAME NebulaeFrame; // JMS
 FRAME FlagStatFrame;
 FRAME MiscDataFrame;
 FRAME FontGradFrame;
 STRING GameStrings;
 QUEUE disp_q;
+// Serosis
+BOOLEAN solTexturesPresent;
+BOOLEAN seroNebulaePresent;
 
 uio_Repository *repository;
 uio_DirHandle *rootDir;
@@ -115,15 +121,39 @@ LoadKernel (int argc, char *argv[])
 		return FALSE; // Must have at least one index in content dir
 
 	/* Load addons demanded by the current configuration. */
+	if(loadAddon("sero-setup-080")){
+		printf("Loading Sero-Setup \n");
+		log_add (log_Debug, "loading sero-setup-080\n");
+	} else {
+		log_add (log_Fatal, "\nPANIC: Sero Setup not found in addons directory!\n");
+		exit (EXIT_FAILURE);
+ 	}
+	if(loadAddon("sero-nebulae-1x")){
+		seroNebulaePresent = TRUE;
+		printf("Loading Sero-Nebulae \n");
+		log_add (log_Debug, "loading sero-nebulae-1x");
+	}
+	if(loadAddon("sol-textures-1x")){
+		solTexturesPresent = TRUE;
+		printf("Loading Sol Textures \n");
+		log_add (log_Debug, "loading sol-textures-1x");
+	}
+
 	if (opt3doMusic)
 	{
 		loadAddon ("3domusic");
 	}
 
 	usingSpeech = optSpeech;
-	if (optSpeech && !loadAddon ("3dovoice"))
-	{
+	if (optSpeech && !loadAddon ("3dovoice")) {
 		usingSpeech = FALSE;
+	} else {
+		loadAddon("rmx-subtitle");
+		loadAddon("rmx-shofixti");
+		loadAddon("rmx-utwig");
+		// Autoload support for Soul Reaver's dialog fixes
+		loadAddon("MelnormeVoicePack");
+		loadAddon("MyconVoiceFix");
 	}
 
 	if (optRemixMusic)
@@ -210,6 +240,22 @@ InitKernel (void)
 	if (StatusFrame == NULL)
 		return FALSE;
 
+	if (optNebulae && seroNebulaePresent) {
+		NebulaeFrame = CaptureDrawable (LoadGraphic (NEBULAE_PMAP_ANIM));
+		if (NebulaeFrame == NULL)
+			return FALSE;
+	}
+		
+	// JMS: Constellation lines for the constellation starmap.
+	ConstellationsFrame = CaptureDrawable (LoadGraphic (CONSTELLATIONS_MASK_PMAP_ANIM));
+	if (ConstellationsFrame == NULL)
+		return FALSE;
+		
+	// JMS: This is a table of mineral values that will be shown on the status bar.
+	SubmenuFrame = CaptureDrawable (LoadGraphic (SUBMENU_MASK_PMAP_ANIM));
+	if (SubmenuFrame == NULL)
+		return FALSE;
+
 	GameStrings = CaptureStringTable (LoadStringTable (STARCON_GAME_STRINGS));
 	if (GameStrings == 0)
 		return FALSE;
diff -ruNp src.orig/uqm/setup.h src/uqm/setup.h
--- src.orig/uqm/setup.h	2017-11-21 16:07:12 -0600
+++ src/uqm/setup.h	2017-11-22 09:27:46 -0600
@@ -33,6 +33,9 @@ extern RESOURCE_INDEX hResIndex;
 extern FRAME Screen;
 extern FRAME ActivityFrame;
 extern FRAME StatusFrame;
+extern FRAME SubmenuFrame; // JMS
+extern FRAME ConstellationsFrame; // JMS
+extern FRAME NebulaeFrame;	// JMS
 extern FRAME FlagStatFrame;
 extern FRAME MiscDataFrame;
 extern FRAME FontGradFrame;
@@ -57,6 +60,10 @@ extern QUEUE race_q[];
 		/* Array of lists of ships involved in a battle, one queue per side;
 		 * queue element is STARSHIP */
 
+// Serosis
+extern BOOLEAN solTexturesPresent;
+extern BOOLEAN seroNebulaePresent;
+
 extern ACTIVITY LastActivity;
 
 extern BYTE PlayerControl[];
diff -ruNp src.orig/uqm/setupmenu.c src/uqm/setupmenu.c
--- src.orig/uqm/setupmenu.c	2017-11-21 16:07:12 -0600
+++ src/uqm/setupmenu.c	2017-11-22 08:52:12 -0600
@@ -59,7 +59,7 @@ static int quit_sub_menu (WIDGET *self,
 static int do_graphics (WIDGET *self, int event);
 static int do_audio (WIDGET *self, int event);
 static int do_engine (WIDGET *self, int event);
-static int do_resources (WIDGET *self, int event);
+static int do_cheats (WIDGET *self, int event);
 static int do_keyconfig (WIDGET *self, int event);
 static int do_advanced (WIDGET *self, int event);
 static int do_editkeys (WIDGET *self, int event);
@@ -75,7 +75,7 @@ static void clear_control (WIDGET_CONTRO
 #endif
 
 #define MENU_COUNT          8
-#define CHOICE_COUNT       24
+#define CHOICE_COUNT       43
 #define SLIDER_COUNT        4
 #define BUTTON_COUNT       10
 #define LABEL_COUNT         4
@@ -96,75 +96,101 @@ static WIDGET_CONTROLENTRY controlentrie
 typedef int (*HANDLER)(WIDGET *, int);
 
 static int choice_widths[CHOICE_COUNT] = {
-	3, 2, 3, 3, 2, 2, 2, 2, 2, 2, 
+	3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 
 	2, 2, 3, 2, 2, 3, 3, 2,	3, 3, 
-	3, 2, 2, 2 };
+	3, 2, 2, 2, 
+	2, 2, 3, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 3, 2, 2, 2, 2 };
 
 static HANDLER button_handlers[BUTTON_COUNT] = {
 	quit_main_menu, quit_sub_menu, do_graphics, do_engine,
-	do_audio, do_resources, do_keyconfig, do_advanced, do_editkeys, 
+	do_audio, do_cheats, do_keyconfig, do_advanced, do_editkeys, 
 	do_keyconfig };
 
 /* These refer to uninitialized widgets, but that's OK; we'll fill
  * them in before we touch them */
 static WIDGET *main_widgets[] = {
-	(WIDGET *)(&buttons[2]),
-	(WIDGET *)(&buttons[3]),
-	(WIDGET *)(&buttons[4]),
-	(WIDGET *)(&buttons[5]),
-	(WIDGET *)(&buttons[6]),
-	(WIDGET *)(&buttons[7]),
-	(WIDGET *)(&buttons[0]),
+	(WIDGET *)(&buttons[2]),	// Graphics
+	(WIDGET *)(&buttons[4]),	// Sound
+	(WIDGET *)(&buttons[3]),	// PC/3DO Compat Options
+	(WIDGET *)(&buttons[5]),	// Cheats
+	(WIDGET *)(&buttons[6]),	// Controls
+	(WIDGET *)(&buttons[7]),	// Advanced
+	(WIDGET *)(&buttons[0]),	// Quit Setup Menu
 	NULL };
 
 static WIDGET *graphics_widgets[] = {
-	(WIDGET *)(&choices[0]),
-	(WIDGET *)(&choices[23]),
-	(WIDGET *)(&choices[10]),
-	(WIDGET *)(&sliders[3]),
-	(WIDGET *)(&choices[2]),
-	(WIDGET *)(&choices[3]),
+	(WIDGET *)(&choices[0]),	// Resolution
+#ifdef HAVE_OPENGL
+	(WIDGET *)(&choices[1]),	// Use Framebuffer
+#endif
+	(WIDGET *)(&choices[23]),	// Aspect Ratio
+	(WIDGET *)(&choices[10]),	// Display
+	(WIDGET *)(&sliders[3]),	// Gamma Correction
+	(WIDGET *)(&choices[2]),	// Scaler
+	(WIDGET *)(&choices[3]),	// Scanlines
 	(WIDGET *)(&buttons[1]),
 	NULL };
 
-static WIDGET *audio_widgets[] = {
-	(WIDGET *)(&sliders[0]),
-	(WIDGET *)(&sliders[1]),
-	(WIDGET *)(&sliders[2]),
-	(WIDGET *)(&choices[14]),
-	(WIDGET *)(&choices[9]),
-	(WIDGET *)(&choices[21]),
-	(WIDGET *)(&choices[22]),
+static WIDGET *engine_widgets[] = {
+	(WIDGET *)(&choices[4]),	// Menu Style
+	(WIDGET *)(&choices[5]),	// Font Style
+	(WIDGET *)(&choices[6]),	// Scan Style
+	(WIDGET *)(&choices[7]),	// Scroll Style
+	(WIDGET *)(&choices[8]),	// Subtitles
+	(WIDGET *)(&choices[13]),	// Melee Zoom
+	(WIDGET *)(&choices[11]),	// Cutscenes
+	(WIDGET *)(&choices[33]),	// Extra Cutscenes
+	(WIDGET *)(&choices[17]),	// Slave Shields
+	(WIDGET *)(&choices[32]),	// Skip Intro
 	(WIDGET *)(&buttons[1]),
 	NULL };
 
-static WIDGET *engine_widgets[] = {
-	(WIDGET *)(&choices[4]),
-	(WIDGET *)(&choices[5]),
-	(WIDGET *)(&choices[6]),
-	(WIDGET *)(&choices[7]),
-	(WIDGET *)(&choices[8]),
-	(WIDGET *)(&choices[13]),
-	(WIDGET *)(&choices[11]),
-	(WIDGET *)(&choices[17]),
+static WIDGET *audio_widgets[] = {
+	(WIDGET *)(&sliders[0]),	// Music Volume
+	(WIDGET *)(&sliders[1]),	// SFX Volume
+	(WIDGET *)(&sliders[2]),	// Speech Volume
+	(WIDGET *)(&choices[14]),	// Positional Audio
+	(WIDGET *)(&choices[9]),	// 3DO Remixes
+	(WIDGET *)(&choices[21]),	// Precursor's Remixes
+	(WIDGET *)(&choices[22]),	// Speech
+	(WIDGET *)(&choices[34]),	// JMS: Main Menu Music
 	(WIDGET *)(&buttons[1]),
 	NULL };
 
-static WIDGET *advanced_widgets[] = {
-#ifdef HAVE_OPENGL
-	(WIDGET *)(&choices[1]),
-#endif
-	(WIDGET *)(&choices[12]),
-	(WIDGET *)(&choices[15]),
-	(WIDGET *)(&choices[16]),
-	(WIDGET *)(&buttons[1]),
+static WIDGET *cheat_widgets[] = {
+	(WIDGET *)(&choices[24]), // JMS: cheatMode on/off
+	// Serosis
+	(WIDGET *)(&choices[25]),	// God Mode
+	(WIDGET *)(&choices[26]),	// Time Dilation
+	(WIDGET *)(&choices[27]),	// Bubble Warp
+	(WIDGET *)(&choices[28]),	// Unlock Ships
+	(WIDGET *)(&choices[29]),	// Head Start
+	(WIDGET *)(&choices[30]),	// Unlock Upgrades
+	(WIDGET *)(&choices[31]),	// Infinite RU
+	(WIDGET *)(&choices[39]),	// Infinite Fuel
+	(WIDGET *)(&buttons[1]),	// Exit to Menu
 	NULL };
 	
 static WIDGET *keyconfig_widgets[] = {
-	(WIDGET *)(&choices[18]),
-	(WIDGET *)(&choices[19]),
+	(WIDGET *)(&choices[18]),	// Bottom Player
+	(WIDGET *)(&choices[19]),	// Top Player
 	(WIDGET *)(&labels[1]),
-	(WIDGET *)(&buttons[8]),
+	(WIDGET *)(&buttons[8]),	// Edit Controls
+	(WIDGET *)(&buttons[1]),
+	NULL };
+
+static WIDGET *advanced_widgets[] = {
+	(WIDGET *)(&choices[12]),	// Show FPS
+	(WIDGET *)(&choices[15]),	// Sound Driver
+	(WIDGET *)(&choices[16]),	// Sound Quality
+	(WIDGET *)(&choices[35]),	// JMS: IP nebulae on/off
+	(WIDGET *)(&choices[36]),	// JMS: orbitingPlanets on/off
+	(WIDGET *)(&choices[37]),	// JMS: texturedPlanets on/off
+	(WIDGET *)(&choices[38]),	// Nic: Switch date formats
+	(WIDGET *)(&choices[40]),	// Serosis: Thraddash Story switch
+	(WIDGET *)(&choices[41]),	// Serosis: Partial Pickup switch
+	(WIDGET *)(&choices[42]),	// Serosis: Submenu switch
 	(WIDGET *)(&buttons[1]),
 	NULL };
 
@@ -182,11 +208,6 @@ static WIDGET *editkeys_widgets[] = {
 	(WIDGET *)(&buttons[9]),
 	NULL };
 
-static WIDGET *incomplete_widgets[] = {
-	(WIDGET *)(&labels[0]),
-	(WIDGET *)(&buttons[1]),
-	NULL };
-
 static const struct
 {
 	WIDGET **widgets;
@@ -196,12 +217,12 @@ menu_defs[] =
 {
 	{main_widgets, 0},
 	{graphics_widgets, 1},
-	{audio_widgets, 1},
-	{engine_widgets, 2},
-	{incomplete_widgets, 3},
-	{keyconfig_widgets, 1},
-	{advanced_widgets, 2},
-	{editkeys_widgets, 1},
+	{audio_widgets, 2},
+	{engine_widgets, 3},
+	{cheat_widgets, 4},
+	{keyconfig_widgets, 5},
+	{advanced_widgets, 6},
+	{editkeys_widgets, 7},
 	{NULL, 0}
 };
 
@@ -282,7 +303,7 @@ do_engine (WIDGET *self, int event)
 }
 
 static int
-do_resources (WIDGET *self, int event)
+do_cheats (WIDGET *self, int event)
 {
 	if (event == WIDGET_EVENT_SELECT)
 	{
@@ -384,7 +405,7 @@ SetDefaults (void)
 	GLOBALOPTS opts;
 	
 	GetGlobalOptions (&opts);
-	if (opts.res == OPTVAL_CUSTOM)
+	if (opts.screenResolution == OPTVAL_CUSTOM)
 	{
 		choices[0].numopts = RES_OPTS + 1;
 	}
@@ -392,7 +413,7 @@ SetDefaults (void)
 	{
 		choices[0].numopts = RES_OPTS;
 	}
-	choices[0].selected = opts.res;
+	choices[0].selected = opts.screenResolution;
 	choices[1].selected = opts.driver;
 	choices[2].selected = opts.scaler;
 	choices[3].selected = opts.scanlines;
@@ -417,6 +438,30 @@ SetDefaults (void)
 	choices[22].selected = opts.speech;
 	choices[23].selected = opts.keepaspect;
 
+ 	choices[24].selected = opts.cheatMode; // JMS	
+	// Serosis
+	choices[25].selected = opts.godMode;
+	choices[26].selected = opts.tdType;
+	choices[27].selected = opts.bubbleWarp;
+	choices[28].selected = opts.unlockShips;
+	choices[29].selected = opts.headStart;
+	choices[30].selected = opts.unlockUpgrades;
+	choices[31].selected = opts.infiniteRU;
+	choices[32].selected = opts.skipIntro;
+	choices[33].selected = opts.FMV;
+	// JMS
+	choices[34].selected = opts.mainMenuMusic;
+	choices[35].selected = opts.nebulae;
+	choices[36].selected = opts.orbitingPlanets;
+	choices[37].selected = opts.texturedPlanets;
+	// Nic
+	choices[38].selected = opts.dateType;
+	 // Serosis
+	choices[39].selected = opts.infiniteFuel;
+	choices[40].selected = opts.thraddStory;
+	choices[41].selected = opts.partialPickup;
+	choices[42].selected = opts.submenu;
+
 	sliders[0].value = opts.musicvol;
 	sliders[1].value = opts.sfxvol;
 	sliders[2].value = opts.speechvol;
@@ -427,7 +472,7 @@ static void
 PropagateResults (void)
 {
 	GLOBALOPTS opts;
-	opts.res = choices[0].selected;
+	opts.screenResolution = choices[0].selected;
 	opts.driver = choices[1].selected;
 	opts.scaler = choices[2].selected;
 	opts.scanlines = choices[3].selected;
@@ -451,6 +496,30 @@ PropagateResults (void)
 	opts.speech = choices[22].selected;
 	opts.keepaspect = choices[23].selected;
 
+ 	opts.cheatMode = choices[24].selected; // JMS
+	// Serosis
+	opts.godMode = choices[25].selected;
+	opts.tdType = choices[26].selected;
+	opts.bubbleWarp = choices[27].selected;
+	opts.unlockShips = choices[28].selected;
+	opts.headStart = choices[29].selected;
+	opts.unlockUpgrades = choices[30].selected;
+	opts.infiniteRU = choices[31].selected;
+	opts.skipIntro = choices[32].selected;
+	opts.FMV = choices[33].selected;
+	 // JMS
+	opts.mainMenuMusic = choices[34].selected;
+	opts.nebulae = choices[35].selected;
+	opts.orbitingPlanets = choices[36].selected;
+	opts.texturedPlanets = choices[37].selected;
+	// Nic
+	opts.dateType = choices[38].selected;
+	// Serosis
+	opts.infiniteFuel = choices[39].selected;
+	opts.thraddStory = choices[40].selected;
+	opts.partialPickup = choices[41].selected;
+	opts.submenu = choices[42].selected;
+
 	opts.musicvol = sliders[0].value;
 	opts.sfxvol = sliders[1].value;
 	opts.speechvol = sliders[2].value;
@@ -469,7 +538,7 @@ DoSetupMenu (SETUP_MENU_STATE *pInputSta
 		SetDefaultMenuRepeatDelay ();
 		pInputState->NextTime = GetTimeCounter ();
 		SetDefaults ();
-		Widget_SetFont (StarConFont);
+		Widget_SetFont (LoadFont (PLAYER_FONT)); // Was StarconFont: Switched for better readability
 		Widget_SetWindowColors (SHADOWBOX_BACKGROUND_COLOR,
 				SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
 
@@ -837,7 +906,7 @@ init_widgets (void)
 	/* Options */
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 2)), '\n', 100, buffer, bank) != CHOICE_COUNT)
 	{
-		log_add (log_Fatal, "PANIC: Incorrect number of Choice Options");
+		log_add (log_Fatal, "PANIC: Incorrect number of Choice Options: %d. Should be %d", CHOICE_COUNT, SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 2)), '\n', 100, buffer, bank));
 		exit (EXIT_FAILURE);
 	}
 
@@ -1309,17 +1378,17 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	case 320:
 		if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
 		{
-			opts->res = OPTVAL_320_240;
+			opts->screenResolution = OPTVAL_320_240;
 		}
 		else
 		{
 			if (ScreenHeightActual != 240)
 			{
-				opts->res = OPTVAL_CUSTOM;
+				opts->screenResolution = OPTVAL_CUSTOM;
 			}
 			else
 			{
-				opts->res = OPTVAL_320_240;
+				opts->screenResolution = OPTVAL_320_240;
 				opts->driver = OPTVAL_ALWAYS_GL;
 			}
 		}
@@ -1327,43 +1396,43 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	case 640:
 		if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
 		{
-			opts->res = OPTVAL_640_480;
+			opts->screenResolution = OPTVAL_640_480;
 		}
 		else
 		{
 			if (ScreenHeightActual != 480)
 			{
-				opts->res = OPTVAL_CUSTOM;
+				opts->screenResolution = OPTVAL_CUSTOM;
 			}
 			else
 			{
-				opts->res = OPTVAL_640_480;
+				opts->screenResolution = OPTVAL_640_480;
 				opts->driver = OPTVAL_ALWAYS_GL;
 			}
 		}
 		break;
-	case 800:
-		if (ScreenHeightActual != 600)
+	case 960:
+		if (ScreenHeightActual != 720)
 		{
-			opts->res = OPTVAL_CUSTOM;
+			opts->screenResolution = OPTVAL_CUSTOM;
 		}
 		else
 		{
-			opts->res = OPTVAL_800_600;
+			opts->screenResolution = OPTVAL_960_720;
 		}
 		break;
-	case 1024:
-		if (ScreenHeightActual != 768)
+	case 1280:
+		if (ScreenHeightActual != 960)
 		{
-			opts->res = OPTVAL_CUSTOM;
+			opts->screenResolution = OPTVAL_CUSTOM;
 		}
 		else
 		{
-			opts->res = OPTVAL_1024_768;
+			opts->screenResolution = OPTVAL_1280_960;
 		}		
 		break;
 	default:
-		opts->res = OPTVAL_CUSTOM;
+		opts->screenResolution = OPTVAL_CUSTOM;
 		break;
 	}
 
@@ -1395,6 +1464,30 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	opts->musicvol = (((int)(musicVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->sfxvol = (((int)(sfxVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->speechvol = (((int)(speechVolumeScale * 100.0f) + 2) / 5) * 5;
+
+ 	opts->cheatMode = optCheatMode ? OPTVAL_ENABLED : OPTVAL_DISABLED; // JMS
+	// Serosis
+	opts->godMode = optGodMode ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->tdType = res_GetInteger ("config.timeDilation");
+	opts->bubbleWarp = optBubbleWarp ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->unlockShips = optUnlockShips ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->headStart = optHeadStart ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->unlockUpgrades = optUnlockUpgrades ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->infiniteRU = optInfiniteRU ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->skipIntro = optSkipIntro ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->FMV = optFMV ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	// JMS
+	opts->mainMenuMusic = optMainMenuMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->nebulae = optNebulae ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->orbitingPlanets = optOrbitingPlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->texturedPlanets = optTexturedPlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	// Nic
+	opts->dateType = res_GetInteger ("config.dateFormat");
+	// Serosis
+	opts->infiniteFuel = optInfiniteFuel ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->thraddStory = optThraddStory ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->partialPickup = optPartialPickup ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->submenu = optSubmenu ? OPTVAL_ENABLED : OPTVAL_DISABLED;
 }
 
 void
@@ -1407,7 +1500,7 @@ SetGlobalOptions (GLOBALOPTS *opts)
 
 	NewGfxFlags &= ~TFB_GFXFLAGS_SCALE_ANY;
 
-	switch (opts->res) {
+	switch (opts->screenResolution) {
 	case OPTVAL_320_240:
 		NewWidth = 320;
 		NewHeight = 240;
@@ -1426,14 +1519,14 @@ SetGlobalOptions (GLOBALOPTS *opts)
 		NewDriver = TFB_GFXDRIVER_SDL_PURE;
 #endif
 		break;
-	case OPTVAL_800_600:
-		NewWidth = 800;
-		NewHeight = 600;
+	case OPTVAL_960_720:
+		NewWidth = 960;
+		NewHeight = 720;
 		NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
 		break;
-	case OPTVAL_1024_768:
-		NewWidth = 1024;
-		NewHeight = 768;
+	case OPTVAL_1280_960:
+		NewWidth = 1280;
+		NewHeight = 960;
 		NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
 		break;
 	default:
@@ -1444,7 +1537,112 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	res_PutInteger ("config.reswidth", NewWidth);
 	res_PutInteger ("config.resheight", NewHeight);
 	res_PutBoolean ("config.alwaysgl", opts->driver == OPTVAL_ALWAYS_GL);
-	res_PutBoolean ("config.usegl", NewDriver == TFB_GFXDRIVER_SDL_OPENGL);
+	res_PutBoolean ("config.usegl", NewDriver == TFB_GFXDRIVER_SDL_OPENGL);	
+
+	// JMS: Cheat Mode: Kohr-Ah move at zero speed when trying to cleanse the galaxy
+	res_PutBoolean ("config.kohrStahp", opts->cheatMode == OPTVAL_ENABLED);
+	optCheatMode = opts->cheatMode == OPTVAL_ENABLED;
+
+	// Serosis: God Mode: Health and Energy does not deplete in battle.
+	res_PutBoolean ("config.godMode", opts->godMode == OPTVAL_ENABLED);
+	optGodMode = opts->godMode == OPTVAL_ENABLED;
+
+	// Serosis: Time Dilation: Increases and divides time in IP and HS by a factor of 12
+	switch (opts->tdType){
+		case OPTVAL_SLOW:
+			timeDilationScale=1;
+		break;
+		case OPTVAL_FAST:
+			timeDilationScale=2;
+		break;
+		case OPTVAL_NORMAL:
+		default:
+			timeDilationScale=0;
+		break;
+	}
+	res_PutInteger ("config.timeDilation", opts->tdType);
+
+	// Serosis: Bubble Warp: Warp instantly to your destination
+	res_PutBoolean ("config.bubbleWarp", opts->bubbleWarp == OPTVAL_ENABLED);
+	optBubbleWarp = opts->bubbleWarp == OPTVAL_ENABLED;
+
+	// Serosis: Unlocks ships that you can not unlock under normal conditions
+	res_PutBoolean ("config.unlockShips", opts->unlockShips == OPTVAL_ENABLED);
+	optUnlockShips = opts->unlockShips == OPTVAL_ENABLED;
+
+	// Serosis: Gives you 1000 Radioactives and a better outfitted ship on a a new game
+	res_PutBoolean ("config.headStart", opts->headStart == OPTVAL_ENABLED);
+	optHeadStart = opts->headStart == OPTVAL_ENABLED;
+
+	// Serosis: Unlocks all upgrades
+	res_PutBoolean ("config.unlockUpgrades", opts->unlockUpgrades == OPTVAL_ENABLED);
+	optUnlockUpgrades = opts->unlockUpgrades == OPTVAL_ENABLED;
+
+	// Serosis: Virtually Infinite RU
+	res_PutBoolean ("config.infiniteRU", opts->infiniteRU == OPTVAL_ENABLED);
+	optInfiniteRU = opts->infiniteRU == OPTVAL_ENABLED;
+
+	// Serosis: Skip the intro
+	res_PutBoolean ("config.skipIntro", opts->skipIntro == OPTVAL_ENABLED);
+	optSkipIntro = opts->skipIntro == OPTVAL_ENABLED;
+
+	// Serosis: Adds the Crystal Dynamics Logo and Commercial to the loaded 3DO videos
+	res_PutBoolean ("config.FMV", opts->FMV == OPTVAL_ENABLED);
+	optFMV = opts->FMV == OPTVAL_ENABLED;
+	
+	// JMS: Main menu music
+	res_PutBoolean ("config.mainMenuMusic", opts->mainMenuMusic == OPTVAL_ENABLED);
+	optMainMenuMusic = opts->mainMenuMusic == OPTVAL_ENABLED;
+	if(!optMainMenuMusic)
+		FadeMusic (0,ONE_SECOND);
+	else
+		FadeMusic (NORMAL_VOLUME+70, ONE_SECOND);
+	
+	// JMS: Is a beautiful nebula background shown as the background of solarsystems.
+	res_PutBoolean ("config.nebulae", opts->nebulae == OPTVAL_ENABLED);
+	optNebulae = opts->nebulae == OPTVAL_ENABLED;
+	
+	// JMS: Rotating planets in IP.
+	res_PutBoolean ("config.orbitingPlanets", opts->orbitingPlanets == OPTVAL_ENABLED);
+	optOrbitingPlanets = opts->orbitingPlanets == OPTVAL_ENABLED;
+	
+	// JMS: Textured or plain(==vanilla UQM style) planets in IP.
+	res_PutBoolean ("config.texturedPlanets", opts->texturedPlanets == OPTVAL_ENABLED);
+	optTexturedPlanets = opts->texturedPlanets == OPTVAL_ENABLED;	
+
+	// Nic: Date Format: Switch the displayed date format
+	switch (opts->dateType){
+		case OPTVAL_MMDDYYYY:
+			optDateFormat=1;
+		break;
+		case OPTVAL_DDMMMYYYY:
+			optDateFormat=2;
+		break;
+		case OPTVAL_DDMMYYYY:
+			optDateFormat=3;
+		break;
+		case OPTVAL_MMMDDYYYY:
+		default:
+			optDateFormat=0;
+		break;
+	}
+	res_PutInteger ("config.dateFormat", opts->dateType);	
+	
+	// Serosis: Infinite Fuel
+	res_PutBoolean ("config.infiniteFuel", opts->infiniteFuel == OPTVAL_ENABLED);
+	optInfiniteFuel = opts->infiniteFuel == OPTVAL_ENABLED;
+	
+	// Serosis: Optionalized the alt Thraddash story
+	res_PutBoolean ("config.thraddStory", opts->thraddStory == OPTVAL_ENABLED);
+	optThraddStory = opts->thraddStory == OPTVAL_ENABLED;
+	
+	// Serosis: Partial mineral pickup when enabled.
+	res_PutBoolean ("config.partialPickup", opts->partialPickup == OPTVAL_ENABLED);
+	optPartialPickup = opts->partialPickup == OPTVAL_ENABLED;
+	
+	// Serosis: Show submenu
+	res_PutBoolean ("config.submenu", opts->submenu == OPTVAL_ENABLED);
+	optSubmenu = opts->submenu == OPTVAL_ENABLED;
 
 	switch (opts->scaler) {
 	case OPTVAL_BILINEAR_SCALE:
diff -ruNp src.orig/uqm/setupmenu.h src/uqm/setupmenu.h
--- src.orig/uqm/setupmenu.h	2017-11-21 16:07:12 -0600
+++ src/uqm/setupmenu.h	2017-11-22 08:52:12 -0600
@@ -47,8 +47,8 @@ typedef enum {
 typedef enum {
 	OPTVAL_320_240,
 	OPTVAL_640_480,
-	OPTVAL_800_600,
-	OPTVAL_1024_768,
+	OPTVAL_960_720,
+	OPTVAL_1280_960,
 	OPTVAL_CUSTOM
 } OPT_RESTYPE;
 
@@ -68,19 +68,35 @@ typedef enum {
 	OPTVAL_MEDIUM,
 	OPTVAL_HIGH
 } OPT_AQUALITYTYPE;
+ 
+typedef enum {
+	OPTVAL_NORMAL,
+	OPTVAL_SLOW,
+	OPTVAL_FAST
+} OPT_TDTYPE;
+ 
+typedef enum {
+	OPTVAL_MMMDDYYYY,
+	OPTVAL_MMDDYYYY,
+	OPTVAL_DDMMMYYYY,
+	OPTVAL_DDMMYYYY
+} OPT_DATETYPE;
 
 /* At the moment, CONTROL_TEMPLATE is directly in this structure.  If
  * CONTROL_TEMPLATE and the options available diverge, this will need
  * to change */
 typedef struct globalopts_struct {
 	OPT_SCALETYPE scaler;
-	OPT_RESTYPE res;
+	OPT_RESTYPE screenResolution;
 	OPT_DRIVERTYPE driver;
 	OPT_ADRIVERTYPE adriver;
 	OPT_AQUALITYTYPE aquality;
-	OPT_ENABLABLE fullscreen, subtitles, scanlines, fps, stereo;
-	OPT_ENABLABLE music3do, musicremix, speech;
-	OPT_ENABLABLE keepaspect;
+	OPT_TDTYPE tdType; // Serosis
+	OPT_DATETYPE dateType; //
+	OPT_ENABLABLE fullscreen, subtitles, scanlines, fps, stereo, music3do, musicremix, speech, keepaspect,
+		cheatMode, godMode, bubbleWarp, unlockShips, headStart, unlockUpgrades, infiniteRU, skipIntro, FMV, // Serosis: except for cheatMode = JMS
+		mainMenuMusic, nebulae, orbitingPlanets, texturedPlanets, // JMS
+		infiniteFuel, thraddStory, partialPickup, submenu; // Serosis
 	OPT_CONSOLETYPE menu, text, cscan, scroll, intro, meleezoom, shield;
 	CONTROL_TEMPLATE player1, player2;
 	int speechvol, musicvol, sfxvol;
diff -ruNp src.orig/uqm/ships/arilou/arilou.c src/uqm/ships/arilou/arilou.c
--- src.orig/uqm/ships/arilou/arilou.c	2017-11-21 16:07:12 -0600
+++ src/uqm/ships/arilou/arilou.c	2017-11-22 08:52:12 -0600
@@ -19,8 +19,10 @@
 #include "../ship.h"
 #include "arilou.h"
 #include "resinst.h"
-
+#include "libs/log.h"
 #include "libs/mathlib.h"
+#include "uqm/globdata.h"
+#include <math.h>
 
 // Core characteristics
 #define MAX_CREW 6
@@ -274,13 +276,24 @@ arilou_preprocess (ELEMENT *ElementPtr)
 				else
 					ElementPtr->next.image.frame =
 							IncFrameIndex (ElementPtr->next.image.frame);
-			}
-			else
-			{
-				ElementPtr->next.location.x =
-						WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
-				ElementPtr->next.location.y =
-						WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
+			} else { // JMS: Reduce the odds of teleporting into Sa-Matra.
+				if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE) {
+					SDWORD dist = 0;
+					SDWORD dx, dy;
+                    do {
+                        ElementPtr->next.location.x = WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
+                        ElementPtr->next.location.y = WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
+                        
+                        dx = ((SDWORD)ElementPtr->next.location.x - (LOG_SPACE_WIDTH >> 1));
+                        dy = ((SDWORD)ElementPtr->next.location.y - (LOG_SPACE_HEIGHT >> 1));
+                        
+                        dist = sqrt(dx*dx + dy*dy);                        
+                    } 
+					while (dist < (2800));
+                } else {
+                    ElementPtr->next.location.x = WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
+					ElementPtr->next.location.y = WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
+				}
 			}
 		}
 
diff -ruNp src.orig/uqm/ships/chmmr/chmmr.c src/uqm/ships/chmmr/chmmr.c
--- src.orig/uqm/ships/chmmr/chmmr.c	2017-11-21 16:07:12 -0600
+++ src/uqm/ships/chmmr/chmmr.c	2017-11-22 08:52:12 -0600
@@ -19,7 +19,7 @@
 #include "../ship.h"
 #include "chmmr.h"
 #include "resinst.h"
-
+#include "../../setup.h"
 #include "uqm/colors.h"
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
@@ -289,7 +289,6 @@ static void
 chmmr_postprocess (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
-
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 
 	if (StarShipPtr->cur_status_flags & WEAPON)
@@ -683,12 +682,20 @@ spawn_satellites (ELEMENT *ElementPtr)
 {
 	COUNT i;
 	STARSHIP *StarShipPtr;
+	BYTE NumSatellites = NUM_SATELLITES;
+
+	if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+		(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
+		((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
+	{
+		NumSatellites = NUM_SATELLITES + 2;
+	}
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->hShip)
 	{
 		LockElement (StarShipPtr->hShip, &ElementPtr);
-		for (i = 0; i < NUM_SATELLITES; ++i)
+		for (i = 0; i < NumSatellites; ++i)
 		{
 			HELEMENT hSatellite;
 
@@ -706,8 +713,8 @@ spawn_satellites (ELEMENT *ElementPtr)
 				SattPtr->hit_points = SATELLITE_HITPOINTS;
 				SattPtr->mass_points = SATELLITE_MASS;
 
-				angle = (i * FULL_CIRCLE + (NUM_SATELLITES >> 1))
-						/ NUM_SATELLITES;
+				angle = (i * FULL_CIRCLE + (NumSatellites >> 1))
+						/ NumSatellites;
 				SattPtr->turn_wait = (BYTE)angle;
 				SattPtr->current.location.x = ElementPtr->next.location.x
 						+ COSINE (angle, SATELLITE_OFFSET);
diff -ruNp src.orig/uqm/ships/melnorme/melnorme.c src/uqm/ships/melnorme/melnorme.c
--- src.orig/uqm/ships/melnorme/melnorme.c	2017-11-21 16:07:13 -0600
+++ src/uqm/ships/melnorme/melnorme.c	2017-11-22 08:52:12 -0600
@@ -19,7 +19,7 @@
 #include "../ship.h"
 #include "melnorme.h"
 #include "resinst.h"
-
+#include "../../setup.h"
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
@@ -463,7 +463,14 @@ confusion_collision (ELEMENT *ElementPtr
 				ConfusionPtr->hTarget = StarShipPtr->hShip;
 			}
 
-			ConfusionPtr->life_span = 400;
+			if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+				(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr0->playerNr == 0) || 
+				((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr0->playerNr == 1))))
+			{
+				ConfusionPtr->life_span = 0;
+			} else {
+				ConfusionPtr->life_span = 400;
+			}
 			ConfusionPtr->turn_wait =
 					(BYTE)(1 << ((BYTE)TFB_Random () & 1)); /* LEFT or RIGHT */
 
diff -ruNp src.orig/uqm/ships/orz/orz.c src/uqm/ships/orz/orz.c
--- src.orig/uqm/ships/orz/orz.c	2017-11-21 16:07:13 -0600
+++ src/uqm/ships/orz/orz.c	2017-11-22 08:52:13 -0600
@@ -19,7 +19,7 @@
 #include "../ship.h"
 #include "orz.h"
 #include "resinst.h"
-
+#include "../../setup.h"
 #include "uqm/colors.h"
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
@@ -433,8 +433,15 @@ LeftShip:
 				}
 				else if (randval < (0x0100 / 2 + 0x0100 / 16))
 				{
-					if (!DeltaCrew (ShipPtr, -1))
-						ShipPtr->life_span = 0;
+					if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+						(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0) || 
+						((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1))))
+					{
+						// Marines do no damage to player while boarded
+					} else {
+						if (!DeltaCrew (ShipPtr, -1))
+							ShipPtr->life_span = 0;
+					}
 
 					++ElementPtr->thrust_wait;
 					s.origin.x = 16 + (ElementPtr->turn_wait & 3) * 9;
@@ -733,84 +740,69 @@ marine_preprocess (ELEMENT *ElementPtr)
 }
 
 void
-marine_collision (ELEMENT *ElementPtr0, POINT *pPt0,
-		ELEMENT *ElementPtr1, POINT *pPt1)
-{
-	if (ElementPtr0->life_span
-			&& !(ElementPtr0->state_flags & (NONSOLID | COLLISION))
-			&& !(ElementPtr1->state_flags & FINITE_LIFE))
-	{
-		if (!elementsOfSamePlayer (ElementPtr0, ElementPtr1))
-		{
-			ElementPtr0->turn_wait =
-					MAKE_BYTE (5, HINIBBLE (ElementPtr0->turn_wait));
-			ElementPtr0->thrust_wait &=
-					~((SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED) >> 6);
+marine_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1) {	
+	STAMP s;
+	STARSHIP *StarShipPtr;
+	GetElementStarShip (ElementPtr0, &StarShipPtr);
+	if (ElementPtr0->life_span && !(ElementPtr0->state_flags & (NONSOLID | COLLISION)) && !(ElementPtr1->state_flags & FINITE_LIFE)) {
+		if (!elementsOfSamePlayer (ElementPtr0, ElementPtr1)) {
+			ElementPtr0->turn_wait = MAKE_BYTE (5, HINIBBLE (ElementPtr0->turn_wait));
+			ElementPtr0->thrust_wait &= ~((SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED) >> 6);
 			ElementPtr0->state_flags |= COLLISION;
 		}
-
-		if (GRAVITY_MASS (ElementPtr1->mass_points))
-		{
+		if (GRAVITY_MASS (ElementPtr1->mass_points)) {
 			ElementPtr0->state_flags |= NONSOLID | FINITE_LIFE;
 			ElementPtr0->hit_points = 0;
 			ElementPtr0->life_span = 0;
-		}
-		else if ((ElementPtr1->state_flags & PLAYER_SHIP)
-				&& ((ElementPtr1->state_flags & FINITE_LIFE)
-				|| ElementPtr1->life_span == NORMAL_LIFE))
-		{
+		} else if ((ElementPtr1->state_flags & PLAYER_SHIP) && ((ElementPtr1->state_flags & FINITE_LIFE) || ElementPtr1->life_span == NORMAL_LIFE)) {
 			ElementPtr1->state_flags &= ~COLLISION;
-
-			if (!(ElementPtr0->state_flags & COLLISION))
-			{
+			if (!(ElementPtr0->state_flags & COLLISION)) {
 				DeltaCrew (ElementPtr1, 1);
-
-				ElementPtr0->state_flags |=
-						DISAPPEARING | NONSOLID | FINITE_LIFE;
+				ElementPtr0->state_flags |= DISAPPEARING | NONSOLID | FINITE_LIFE;
 				ElementPtr0->hit_points = 0;
 				ElementPtr0->life_span = 0;
-			}
-			else if ((ElementPtr0->state_flags & IGNORE_SIMILAR)
-					&& ElementPtr1->crew_level
-#ifdef NEVER
-					&& (BYTE)TFB_Random () <= (0x0100 / 3)
-#endif /* NEVER */
-					)
-			{
-				STAMP s;
-				STARSHIP *StarShipPtr;
-
-				GetElementStarShip (ElementPtr0, &StarShipPtr);
-				if (!DeltaCrew (ElementPtr1, -1))
-					ElementPtr1->life_span = 0;
-				else
+			} else if ((ElementPtr0->state_flags & IGNORE_SIMILAR) && ElementPtr1->crew_level) {
+				if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+				(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 1) || 
+				((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 0))))
 				{
-					ElementPtr0->turn_wait = count_marines (StarShipPtr, TRUE);
-					ElementPtr0->thrust_wait = MARINE_WAIT;
-					ElementPtr0->next.image.frame = SetAbsFrameIndex (
-							ElementPtr0->next.image.farray[0],
-							22 + ElementPtr0->turn_wait
-							);
-					ElementPtr0->state_flags |= NONSOLID;
-					ElementPtr0->state_flags &= ~CREW_OBJECT;
-					SetPrimType (&(GLOBAL (DisplayArray))[
-							ElementPtr0->PrimIndex
-							], NO_PRIM);
-					ElementPtr0->preprocess_func = intruder_preprocess;
-
-					s.origin.x = 16 + (ElementPtr0->turn_wait & 3) * 9;
-					s.origin.y = 14 + (ElementPtr0->turn_wait >> 2) * 11;
-					s.frame = ElementPtr0->next.image.frame;
-					ModifySilhouette (ElementPtr1, &s, 0);
+					if (!DeltaCrew (ElementPtr1, 0)){ // Marines won't damage player while boarding
+						ElementPtr1->life_span = 0;
+					} else {
+						ElementPtr0->turn_wait = count_marines (StarShipPtr, TRUE);
+						ElementPtr0->thrust_wait = MARINE_WAIT;
+						ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
+						ElementPtr0->state_flags |= NONSOLID;
+						ElementPtr0->state_flags &= ~CREW_OBJECT;
+						SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr0->PrimIndex], NO_PRIM);
+						ElementPtr0->preprocess_func = intruder_preprocess;
+						s.origin.x = 16 + (ElementPtr0->turn_wait & 3) * 9;
+						s.origin.y = 14 + (ElementPtr0->turn_wait >> 2) * 11;
+						s.frame = ElementPtr0->next.image.frame;
+						ModifySilhouette (ElementPtr1, &s, 0);
+					}
+					ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1);
+				} else {
+					if (!DeltaCrew (ElementPtr1, -1)){
+						ElementPtr1->life_span = 0;
+					} else {
+						ElementPtr0->turn_wait = count_marines (StarShipPtr, TRUE);
+						ElementPtr0->thrust_wait = MARINE_WAIT;
+						ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
+						ElementPtr0->state_flags |= NONSOLID;
+						ElementPtr0->state_flags &= ~CREW_OBJECT;
+						SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr0->PrimIndex], NO_PRIM);
+						ElementPtr0->preprocess_func = intruder_preprocess;
+						s.origin.x = 16 + (ElementPtr0->turn_wait & 3) * 9;
+						s.origin.y = 14 + (ElementPtr0->turn_wait >> 2) * 11;
+						s.frame = ElementPtr0->next.image.frame;
+						ModifySilhouette (ElementPtr1, &s, 0);
+					}
+					ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1);
 				}
-
-				ProcessSound (SetAbsSoundIndex (
-						StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2),
-						ElementPtr1);
 			}
-
 			ElementPtr0->state_flags &= ~COLLISION;
-		}
+		}			
 	}
 	(void) pPt0;  /* Satisfying compiler (unused parameter) */
 	(void) pPt1;  /* Satisfying compiler (unused parameter) */
@@ -1002,7 +994,14 @@ turret_postprocess (ELEMENT *ElementPtr)
 				UnlockElement (hSpaceMarine);
 				PutElement (hSpaceMarine);
 
-				DeltaCrew (ShipPtr, -1);
+				if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+					(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
+					((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
+				{
+					// Marines launched does not count towards crew
+				} else {
+					DeltaCrew (ShipPtr, -1);
+				}
 				ProcessSound (SetAbsSoundIndex (
 						StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1),
 						SpaceMarinePtr);
diff -ruNp src.orig/uqm/ships/pkunk/pkunk.c src/uqm/ships/pkunk/pkunk.c
--- src.orig/uqm/ships/pkunk/pkunk.c	2017-11-21 16:07:13 -0600
+++ src/uqm/ships/pkunk/pkunk.c	2017-11-22 08:52:13 -0600
@@ -450,19 +450,16 @@ phoenix_transition (ELEMENT *ElementPtr)
 		}
 		else
 		{
+			SDWORD temp_x, temp_y;
 			angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 
-			ShipImagePtr->current.location.x -=
-					COSINE (angle, TRANSITION_SPEED)
-					* (ElementPtr->life_span - 1);
-			ShipImagePtr->current.location.y -=
-					SINE (angle, TRANSITION_SPEED)
-					* (ElementPtr->life_span - 1);
-
-			ShipImagePtr->current.location.x =
-					WRAP_X (ShipImagePtr->current.location.x);
-			ShipImagePtr->current.location.y =
-					WRAP_Y (ShipImagePtr->current.location.y);
+            // JMS_GFX: Circumventing overflows by using temp variables instead of
+            // subtracting straight from the POINT sized ShipImagePtr->current.location.
+            temp_x = (SDWORD)ShipImagePtr->current.location.x - COSINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+            temp_y = (SDWORD)ShipImagePtr->current.location.y - SINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+            
+            ShipImagePtr->current.location.x = WRAP_X (temp_x);
+            ShipImagePtr->current.location.y = WRAP_Y (temp_y);
 		}
 
 		ShipImagePtr->mass_points = (BYTE)angle;
diff -ruNp src.orig/uqm/ships/sis_ship/sis_ship.c src/uqm/ships/sis_ship/sis_ship.c
--- src.orig/uqm/ships/sis_ship/sis_ship.c	2017-11-21 16:07:14 -0600
+++ src/uqm/ships/sis_ship/sis_ship.c	2017-11-22 08:52:13 -0600
@@ -221,11 +221,12 @@ SetCustomShipData (RACE_DESC *pRaceDesc,
 static void
 sis_hyper_preprocess (ELEMENT *ElementPtr)
 {
-	SIZE udx = 0, udy = 0;
 	SIZE dx = 0, dy = 0;
 	SIZE AccelerateDirection;
 	STARSHIP *StarShipPtr;
 
+	SDWORD udx = 0, udy = 0, dtempx, dtempy;
+
 	if (ElementPtr->state_flags & APPEARING)
 		ElementPtr->velocity = GLOBAL (velocity);
 
@@ -234,21 +235,33 @@ sis_hyper_preprocess (ELEMENT *ElementPt
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	++StarShipPtr->weapon_counter; /* no shooting in hyperspace! */
 	if ((GLOBAL (autopilot)).x == ~0
-			|| (GLOBAL (autopilot)).y == ~0
-			|| (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST)))
+		|| (GLOBAL (autopilot)).y == ~0
+		|| (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST))
+		|| !(GET_GAME_STATE(AUTOPILOT_OK))) // JMS: This check makes autopilot engage only after coming to full stop
 	{
-LeaveAutoPilot:
-		(GLOBAL (autopilot)).x =
-				(GLOBAL (autopilot)).y = ~0;
+	LeaveAutoPilot:
+		
+		// JMS: This re-check is now needed because of the added autopilot_ok variable to previous check
+		if ((GLOBAL (autopilot)).x == ~0 || (GLOBAL (autopilot)).y == ~0 || (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST)))
+			(GLOBAL (autopilot)).x = (GLOBAL (autopilot)).y = ~0;
 		if (!(StarShipPtr->cur_status_flags & THRUST)
 				|| (GLOBAL_SIS (FuelOnBoard) == 0
 				&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
 		{
 			AccelerateDirection = -1;
-			GetCurrentVelocityComponents (&ElementPtr->velocity,
-					&dx, &dy);
-			udx = dx << 4;
-			udy = dy << 4;
+			GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+			
+			// JMS: Engage autopilot only after coming to full stop
+			if (dx==0 && dy==0)
+				SET_GAME_STATE (AUTOPILOT_OK, 1);
+			else
+				SET_GAME_STATE (AUTOPILOT_OK, 0);
+			
+			dtempx = (SDWORD)dx;
+			dtempy = (SDWORD)dy;
+			
+			udx = dtempx;
+			udy = dtempy;
 
 			StarShipPtr->cur_status_flags &= ~THRUST;
 		}
@@ -316,8 +329,8 @@ LeaveAutoPilot:
 		else
 		{
 			AccelerateDirection = -1;
-			udx = dx << 4;
-			udy = dy << 4;
+			udx = dx;// << 4;
+			udy = dy;// << 4;
 		}
 	}
 
@@ -363,12 +376,11 @@ LeaveAutoPilot:
 			}
 		}
 
-		dx = (SIZE)((long)udx * speed / (long)dist);
-		dy = (SIZE)((long)udy * speed / (long)dist);
-		SetVelocityComponents (&ElementPtr->velocity, dx, dy);
-
-		ElementPtr->thrust_wait =
-				StarShipPtr->RaceDescPtr->characteristics.thrust_wait;
+		dtempx = (SDWORD)((long)udx * speed / (long)dist);
+		dtempy = (SDWORD)((long)udy * speed / (long)dist);
+		
+		SetVelocityComponents (&ElementPtr->velocity, dtempx, dtempy);
+		ElementPtr->thrust_wait =StarShipPtr->RaceDescPtr->characteristics.thrust_wait;
 	}
 }
 
diff -ruNp src.orig/uqm/ships/slylandr/slylandr.c src/uqm/ships/slylandr/slylandr.c
--- src.orig/uqm/ships/slylandr/slylandr.c	2017-11-21 16:07:14 -0600
+++ src/uqm/ships/slylandr/slylandr.c	2017-11-22 08:52:13 -0600
@@ -267,8 +267,11 @@ slylandro_intelligence (ELEMENT *ShipPtr
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER)
-			/* no dodging in role playing game */
+	// no dodging in role playing game, unless you haven't
+	// visited the starbase yet
+	if ((LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER) &&
+			GET_GAME_STATE (STARBASE_AVAILABLE))
+
 		ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr = 0;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
diff -ruNp src.orig/uqm/ships/syreen/syreen.c src/uqm/ships/syreen/syreen.c
--- src.orig/uqm/ships/syreen/syreen.c	2017-11-21 16:07:14 -0600
+++ src/uqm/ships/syreen/syreen.c	2017-11-22 08:52:13 -0600
@@ -19,7 +19,7 @@
 #include "../ship.h"
 #include "syreen.h"
 #include "resinst.h"
-
+#include "../../setup.h"
 #include "libs/mathlib.h"
 
 // Core characteristics
@@ -207,9 +207,14 @@ spawn_crew (ELEMENT *ElementPtr)
 				{
 					COUNT crew_loss;
 
-					crew_loss = ((MAX_ABANDONERS
-							* (ABANDONER_RANGE - square_root (d_squared)))
-							/ ABANDONER_RANGE) + 1;
+					if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+						(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0) || 
+						((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1))))
+					{
+						crew_loss = 0;
+					} else {
+						crew_loss = ((MAX_ABANDONERS * (ABANDONER_RANGE - square_root (d_squared))) / ABANDONER_RANGE) + 1;
+					}
 					if (crew_loss >= ObjPtr->crew_level)
 						crew_loss = ObjPtr->crew_level - 1;
 
diff -ruNp src.orig/uqm/ships/urquan/urquan.c src/uqm/ships/urquan/urquan.c
--- src.orig/uqm/ships/urquan/urquan.c	2017-11-21 16:07:14 -0600
+++ src/uqm/ships/urquan/urquan.c	2017-11-22 08:52:13 -0600
@@ -19,9 +19,9 @@
 #include "../ship.h"
 #include "urquan.h"
 #include "resinst.h"
-
+#include "../../intel.h"
 #include "uqm/globdata.h"
-
+#include "../../setup.h"
 #include <stdlib.h>
 
 // Core characteristics
@@ -414,7 +414,14 @@ spawn_fighters (ELEMENT *ElementPtr)
 		COUNT fighter_facing;
 		ELEMENT *FighterElementPtr;
 
-		DeltaCrew (ElementPtr, -1);
+		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+			(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
+			((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
+		{
+			//DeltaCrew (ElementPtr, -1);
+		} else {
+			DeltaCrew (ElementPtr, -1);
+		}
 
 		PutElement (hFighterElement);
 		LockElement (hFighterElement, &FighterElementPtr);
diff -ruNp src.orig/uqm/ships/vux/vux.c src/uqm/ships/vux/vux.c
--- src.orig/uqm/ships/vux/vux.c	2017-11-21 16:07:14 -0600
+++ src/uqm/ships/vux/vux.c	2017-11-22 08:52:13 -0600
@@ -19,7 +19,7 @@
 #include "../ship.h"
 #include "vux.h"
 #include "resinst.h"
-
+#include "../../setup.h"
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
@@ -155,47 +155,41 @@ limpet_preprocess (ELEMENT *ElementPtr)
 }
 
 static void
-limpet_collision (ELEMENT *ElementPtr0, POINT *pPt0,
-		ELEMENT *ElementPtr1, POINT *pPt1)
-{
-	if (ElementPtr1->state_flags & PLAYER_SHIP)
-	{
-		STAMP s;
-		STARSHIP *StarShipPtr;
-		RACE_DESC *RDPtr;
-
+limpet_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1) {
+	STAMP s;
+	STARSHIP *StarShipPtr;
+	RACE_DESC *RDPtr;
+	if (ElementPtr1->state_flags & PLAYER_SHIP) {
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
 		RDPtr = StarShipPtr->RaceDescPtr;
-
-		if (++RDPtr->characteristics.turn_wait == 0)
-			--RDPtr->characteristics.turn_wait;
-		if (++RDPtr->characteristics.thrust_wait == 0)
-			--RDPtr->characteristics.thrust_wait;
-		if (RDPtr->characteristics.thrust_increment <= MIN_THRUST_INCREMENT)
+		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+			(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 1) || 
+			((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 0))))
 		{
-			RDPtr->characteristics.max_thrust =
-					RDPtr->characteristics.thrust_increment << 1;
+			RDPtr->cyborg_control.ManeuverabilityIndex = 0;
+			GetElementStarShip (ElementPtr0, &StarShipPtr);
+			ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1); // LIMPET_AFFIXES
+			s.frame = SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.weapon[0], (COUNT)TFB_Random ());
+			ModifySilhouette (ElementPtr1, &s, MODIFY_IMAGE);
+		} else {
+			if (++RDPtr->characteristics.turn_wait == 0)
+				--RDPtr->characteristics.turn_wait;
+			if (++RDPtr->characteristics.thrust_wait == 0)
+				--RDPtr->characteristics.thrust_wait;
+			if (RDPtr->characteristics.thrust_increment <= MIN_THRUST_INCREMENT) {
+				RDPtr->characteristics.max_thrust = RDPtr->characteristics.thrust_increment << 1;
+			} else {
+				COUNT num_thrusts;
+				num_thrusts = RDPtr->characteristics.max_thrust / RDPtr->characteristics.thrust_increment;
+				--RDPtr->characteristics.thrust_increment;
+				RDPtr->characteristics.max_thrust = RDPtr->characteristics.thrust_increment * num_thrusts;
+			}
+			RDPtr->cyborg_control.ManeuverabilityIndex = 0;
+			GetElementStarShip (ElementPtr0, &StarShipPtr);
+			ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1); // LIMPET_AFFIXES
+			s.frame = SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.weapon[0], (COUNT)TFB_Random ());
+			ModifySilhouette (ElementPtr1, &s, MODIFY_IMAGE);
 		}
-		else
-		{
-			COUNT num_thrusts;
-
-			num_thrusts = RDPtr->characteristics.max_thrust /
-					RDPtr->characteristics.thrust_increment;
-			--RDPtr->characteristics.thrust_increment;
-			RDPtr->characteristics.max_thrust =
-					RDPtr->characteristics.thrust_increment * num_thrusts;
-		}
-		RDPtr->cyborg_control.ManeuverabilityIndex = 0;
-
-		GetElementStarShip (ElementPtr0, &StarShipPtr);
-		ProcessSound (SetAbsSoundIndex (
-						/* LIMPET_AFFIXES */
-				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1);
-		s.frame = SetAbsFrameIndex (
-				StarShipPtr->RaceDescPtr->ship_data.weapon[0], (COUNT)TFB_Random ()
-				);
-		ModifySilhouette (ElementPtr1, &s, MODIFY_IMAGE);
 	}
 
 	ElementPtr0->hit_points = 0;
@@ -334,36 +328,37 @@ vux_preprocess (ELEMENT *ElementPtr)
 				&& TrackShip (ElementPtr, &facing) >= 0)
 		{
 			ELEMENT *OtherShipPtr;
-
+			SDWORD SA_MATRA_EXTRA_DIST = 0;
 			LockElement (ElementPtr->hTarget, &OtherShipPtr);
 
-			do
-			{
-				SIZE dx, dy;
+			// JMS: Not REALLY necessary as VUX can ordinarily never be played against Sa-Matra. 
+            // But handy in debugging as a single VUX limpet incapacitates Sa-Matra completely.
+            if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE) {
+				SA_MATRA_EXTRA_DIST += 1000;
+			}
+			do {
+                // JMS_GFX: Circumventing overflows by using temp variables instead of
+                // subtracting straight from the POINT sized ShipImagePtr->current.location.
+				SDWORD dx, dy;
 
-				ElementPtr->current.location.x =
-						(OtherShipPtr->current.location.x -
+				SDWORD temp_x =
+						((SDWORD)OtherShipPtr->current.location.x -
 						(MAXX_ENTRY_DIST >> 1)) +
 						((COUNT)TFB_Random () % MAXX_ENTRY_DIST);
-				ElementPtr->current.location.y =
-						(OtherShipPtr->current.location.y -
+				SDWORD temp_y =
+						((SDWORD)OtherShipPtr->current.location.y -
 						(MAXY_ENTRY_DIST >> 1)) +
 						((COUNT)TFB_Random () % MAXY_ENTRY_DIST);
-				dx = OtherShipPtr->current.location.x -
-						ElementPtr->current.location.x;
-				dy = OtherShipPtr->current.location.y -
-						ElementPtr->current.location.y;
-				facing = NORMALIZE_FACING (
-						ANGLE_TO_FACING (ARCTAN (dx, dy))
-						);
-				ElementPtr->current.image.frame =
-						SetAbsFrameIndex (ElementPtr->current.image.frame,
-						facing);
-
-				ElementPtr->current.location.x =
-						WRAP_X (DISPLAY_ALIGN (ElementPtr->current.location.x));
-				ElementPtr->current.location.y =
-						WRAP_Y (DISPLAY_ALIGN (ElementPtr->current.location.y));
+				temp_x += temp_x > 0 ? SA_MATRA_EXTRA_DIST : -SA_MATRA_EXTRA_DIST;
+				temp_y += temp_y > 0 ? SA_MATRA_EXTRA_DIST : -SA_MATRA_EXTRA_DIST;
+                
+				dx = OtherShipPtr->current.location.x - temp_x;
+				dy = OtherShipPtr->current.location.y - temp_y;
+				facing = NORMALIZE_FACING ( ANGLE_TO_FACING (ARCTAN (dx, dy)) );
+				ElementPtr->current.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, facing);
+
+				ElementPtr->current.location.x = WRAP_X (DISPLAY_ALIGN (temp_x));
+				ElementPtr->current.location.y = WRAP_Y (DISPLAY_ALIGN (temp_y));
 			} while (CalculateGravity (ElementPtr)
 					|| TimeSpaceMatterConflict (ElementPtr));
 
diff -ruNp src.orig/uqm/shipyard.c src/uqm/shipyard.c
--- src.orig/uqm/shipyard.c	2017-11-21 16:07:15 -0600
+++ src/uqm/shipyard.c	2017-11-22 09:24:08 -0600
@@ -37,7 +37,7 @@
 #include "sounds.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
-
+#include "uqmdebug.h"
 
 #ifdef USE_3DO_HANGAR
 // 3DO 4x3 hangar layout
@@ -99,7 +99,7 @@ animatePowerLines (MENU_STATE *pMS)
 	{	// Init animation
 		s.origin.x = 0;
 		s.origin.y = 0;
-		s.frame = SetAbsFrameIndex (pMS->ModuleFrame, 24);
+		s.frame = SetAbsFrameIndex (pMS->ModuleFrame, 25);
 		ColorMap = SetAbsColorMapIndex (pMS->CurString, 0);
 	}
 
@@ -124,7 +124,6 @@ on_input_frame (void)
 	SetContext (oldContext);
 }
 
-#ifdef WANT_SHIP_SPINS
 static void
 SpinStarShip (MENU_STATE *pMS, HFLEETINFO hStarShip)
 {
@@ -140,7 +139,6 @@ SpinStarShip (MENU_STATE *pMS, HFLEETINF
 		DoShipSpin (Index, pMS->hMusic);
 	}
 }
-#endif
 
 // Count the ships which can be built by the player.
 static COUNT
@@ -156,7 +154,7 @@ GetAvailableRaceCount (void)
 		FLEET_INFO *FleetPtr;
 
 		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
-		if (FleetPtr->allied_state == GOOD_GUY)
+		if (FleetPtr->allied_state == GOOD_GUY || FleetPtr->allied_state == CAN_BUILD)
 			++Index;
 
 		hNextShip = _GetSuccLink (FleetPtr);
@@ -177,7 +175,7 @@ GetAvailableRaceFromIndex (BYTE Index)
 		FLEET_INFO *FleetPtr;
 
 		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
-		if (FleetPtr->allied_state == GOOD_GUY && Index-- == 0)
+		if (FleetPtr->allied_state == GOOD_GUY && Index-- == 0 || FleetPtr->allied_state == CAN_BUILD && Index-- == 0)
 		{
 			UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 			return hStarShip;
@@ -247,8 +245,12 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 		t.pStr = buf;
 		sprintf (buf, "%u", ShipCost[NewRaceItem]);
 		SetContextFont (TinyFont);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
+		if ((ShipCost[NewRaceItem]) <= (GLOBAL_SIS (ResUnits))) {
+			SetContextForeGroundColor (BRIGHT_GREEN_COLOR);
+		} else if ((ShipCost[NewRaceItem]) > (GLOBAL_SIS (ResUnits)))
+		{ /* We don't have enough to purchase this ship. */
+			SetContextForeGroundColor (BRIGHT_RED_COLOR);
+		}
 		font_DrawText (&t);
 	}
 	UnbatchGraphics ();
@@ -635,7 +637,7 @@ DMS_SetMode (MENU_STATE *pMS, DMS_Mode m
 			SetFlashRect (SFR_MENU_ANY);
 			break;
 		case DMS_Mode_editCrew:
-			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
+			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN | MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN,
 					MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
 			if (HINIBBLE (pMS->CurState))
 			{
@@ -656,7 +658,6 @@ DMS_SetMode (MENU_STATE *pMS, DMS_Mode m
 }
 
 #define MODIFY_CREW_FLAG (1 << 8)
-#ifdef WANT_SHIP_SPINS
 // Helper function for DoModifyShips(), called when the player presses the
 // special button.
 // It works both when the cursor is over an escort ship, while not editing
@@ -707,7 +708,6 @@ DMS_SpinShip (MENU_STATE *pMS, HSHIPFRAG
 
 	return TRUE;
 }
-#endif  /* WANT_SHIP_SPINS */
 
 // Helper function for DoModifyShips(), called when the player presses the
 // up button when modifying the crew of the flagship.
@@ -888,62 +888,57 @@ DMS_DismissEscortShipCrew (SHIP_FRAGMENT
 // 'dy' is -1 if the 'up' button was pressed, or '1' if the down button was
 // pressed.
 static void
-DMS_ModifyCrew (MENU_STATE *pMS, HSHIPFRAG hStarShip, SBYTE dy)
+DMS_ModifyCrew (MENU_STATE *pMS, HSHIPFRAG hStarShip, SBYTE dy, SBYTE dx, SBYTE DoLoop)
 {
 	SIZE crew_delta = 0;
+	int loop;
 	SHIP_FRAGMENT *StarShipPtr = NULL;
 
 	if (hStarShip)
 		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 
-	if (hStarShip == 0)
-	{
-		// Add/Dismiss crew for the flagship.
-		if (dy < 0)
-		{
-			// Add crew for the flagship.
-			crew_delta = DMS_HireFlagShipCrew ();
-		}
-		else
+	for (loop = 0; loop < (DoLoop ? 10 : 1); loop++) {
+		if (hStarShip == 0)
 		{
-			// Dismiss crew from the flagship.
-			crew_delta = DMS_DismissFlagShipCrew ();
-		}
+			// Add/Dismiss crew for the flagship.
+			if (dy < 0 || dx > 0) {
+				// Add crew for the flagship.
+				crew_delta += DMS_HireFlagShipCrew ();
+			} else {
+				// Dismiss crew from the flagship.
+				crew_delta -= DMS_DismissFlagShipCrew ();
+			}
 
-		if (crew_delta != 0)
-			DMS_FlashFlagShipCrewCount ();
-	}
-	else
-	{
-		// Add/Dismiss crew for an escort ship.
-		if (dy < 0)
-		{
-			// Add crew for an escort ship.
-			crew_delta = DMS_HireEscortShipCrew (StarShipPtr);
-		}
-		else
-		{
-			// Dismiss crew from an escort ship.
-			crew_delta = DMS_DismissEscortShipCrew (StarShipPtr);
-		}
+			if (crew_delta != 0)
+				DMS_FlashFlagShipCrewCount ();
+		} else {
+			// Add/Dismiss crew for an escort ship.
+			if (dy < 0 || dx > 0) {
+				// Add crew for an escort ship.
+				crew_delta = DMS_HireEscortShipCrew (StarShipPtr);
+			} else {
+				// Dismiss crew from an escort ship.
+				crew_delta = DMS_DismissEscortShipCrew (StarShipPtr);
+			}
 		
-		if (crew_delta != 0)
-			DMS_FlashEscortShipCrewCount (StarShipPtr->index);
-	}
+			if (crew_delta != 0)
+				DMS_FlashEscortShipCrewCount (StarShipPtr->index);
+		}
 
-	if (crew_delta == 0)
-		PlayMenuSound (MENU_SOUND_FAILURE);
+		if (crew_delta == 0)
+			PlayMenuSound (MENU_SOUND_FAILURE);
 
-	if (hStarShip)
-	{
-		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		if (hStarShip)
+		{
+			UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 		
-		// Clear out the bought ship index so that flash rects work
-		// correctly.
-		pMS->delta_item &= MODIFY_CREW_FLAG;
-	}
+			// Clear out the bought ship index so that flash rects work
+			// correctly.
+			pMS->delta_item &= MODIFY_CREW_FLAG;
+		}
 
-	CrewTransaction (crew_delta);
+		CrewTransaction (crew_delta);
+	}
 }
 
 // Helper function for DoModifyShips(), called when the player presses the
@@ -985,7 +980,6 @@ DMS_AddEscortShip (MENU_STATE *pMS, BOOL
 {
 	assert (pMS->delta_item & MODIFY_CREW_FLAG);
 
-#ifdef WANT_SHIP_SPINS
 	if (special)
 	{
 		HSHIPFRAG hStarShip = GetEscortByStarShipIndex (pMS->delta_item);
@@ -993,9 +987,6 @@ DMS_AddEscortShip (MENU_STATE *pMS, BOOL
 			DMS_SetMode (pMS, DMS_Mode_addEscort);
 		return;
 	}
-#else
-	(void) special;  // Satisfying compiler.
-#endif  /* WANT_SHIP_SPINS */
 
 	if (cancel)
 	{
@@ -1107,7 +1098,7 @@ DMS_MoveCursor (BYTE curState, SBYTE dx,
 // called when we are in crew editing mode.
 static void
 DMS_EditCrewMode (MENU_STATE *pMS, HSHIPFRAG hStarShip,
-		BOOLEAN select, BOOLEAN cancel, SBYTE dy)
+		BOOLEAN select, BOOLEAN cancel, SBYTE dy, SBYTE dx, SBYTE DoLoop)
 {
 	if (select || cancel)
 	{
@@ -1131,11 +1122,11 @@ DMS_EditCrewMode (MENU_STATE *pMS, HSHIP
 		pMS->delta_item &= ~MODIFY_CREW_FLAG;
 		DMS_SetMode (pMS, DMS_Mode_navigate);
 	}
-	else if (dy)
+	else if (dy || DoLoop)
 	{
 		// Hire or dismiss crew for the flagship or an escort
 		// ship.
-		DMS_ModifyCrew (pMS, hStarShip, dy);
+		DMS_ModifyCrew (pMS, hStarShip, dy, dx, DoLoop);
 	}
 }
 
@@ -1158,17 +1149,12 @@ DMS_NavigateShipSlots (MENU_STATE *pMS,
 		}
 	}
 
-#ifndef WANT_SHIP_SPINS
-	(void) special;  // Satisfying compiler.
-#else
 	if (special)
 	{
 		if (DMS_SpinShip (pMS, hStarShip))
 			DMS_SetMode (pMS, DMS_Mode_navigate);
 	}
-	else
-#endif  /* WANT_SHIP_SPINS */
-	if (select)
+	else if (select)
 	{
 		if (hStarShip == 0 && HINIBBLE (pMS->CurState) == 0)
 		{
@@ -1186,8 +1172,7 @@ DMS_NavigateShipSlots (MENU_STATE *pMS,
 			DMS_SetMode (pMS, DMS_Mode_editCrew);
 		}
 	}
-	else if (cancel)
-	{
+	else if (cancel) {
 		// Leave escort ship editor.
 		pMS->InputFunc = DoShipyard;
 		pMS->CurState = SHIPYARD_CREW;
@@ -1229,6 +1214,7 @@ DoModifyShips (MENU_STATE *pMS)
 		BOOLEAN cancel = (PulsedInputState.menu[KEY_MENU_CANCEL] != 0);
 		SBYTE dx = 0;
 		SBYTE dy = 0;
+		SBYTE DoLoop = 0;
 
 		if (PulsedInputState.menu[KEY_MENU_RIGHT])
 			dx = 1;
@@ -1238,6 +1224,10 @@ DoModifyShips (MENU_STATE *pMS)
 			dy = -1;
 		if (PulsedInputState.menu[KEY_MENU_DOWN])
 			dy = 1;
+		if (PulsedInputState.menu[KEY_MENU_PAGE_UP]) 
+			DoLoop = dx = 1;
+		if (PulsedInputState.menu[KEY_MENU_PAGE_DOWN]) 
+			DoLoop = dx = -1;
 
 
 		if (!(pMS->delta_item & MODIFY_CREW_FLAG))
@@ -1259,7 +1249,7 @@ DoModifyShips (MENU_STATE *pMS)
 			else
 			{
 				// Crew editing mode.
-				DMS_EditCrewMode (pMS, hStarShip, select, cancel, dy);
+				DMS_EditCrewMode (pMS, hStarShip, select, cancel, dy, dx, DoLoop);
 			}
 		}
 
@@ -1365,7 +1355,44 @@ DrawBluePrint (MENU_STATE *pMS)
 		{
 			COUNT m;
 
+			// JMS_GFX
+			COUNT slotNr = 0;
+			DWORD compartmentNr = 0;
+			BYTE moduleType;
+			DWORD fuelAmount;
+			DWORD volume;
+			
+			// JMS_GFX
+			fuelAmount = GLOBAL_SIS (FuelOnBoard);
+			if (fuelAmount >= FUEL_RESERVE)
+			{
+				COUNT slotI;
+				DWORD capacity = FUEL_RESERVE;
+				
+				slotI = NUM_MODULE_SLOTS;
+				while (slotI--)
+				{
+					BYTE moduleType = GLOBAL_SIS (ModuleSlots[slotI]);
+					
+					capacity += GetModuleFuelCapacity (moduleType);
+					
+					//log_add (log_Debug, "fuelAmount %d, capacity %d, moduletype %d, slotI %d", fuelAmount, capacity, moduleType, slotI);
+					
+					if (fuelAmount < capacity)
+					{
+						slotNr = slotI;
+						compartmentNr = capacity - fuelAmount;
+						break;
+					}
+				}
+				
+				moduleType = GLOBAL_SIS (ModuleSlots[slotNr]);
+				volume = GetModuleFuelCapacity (moduleType);
+			}
+
 			GetFTankCapacity (&r.corner);
+			r.corner.y -= volume == HEFUEL_TANK_CAPACITY ? 0 : 0; // JMS_GFX
+			r.corner.x += volume == HEFUEL_TANK_CAPACITY ? 0 : 0; // JMS_GFX
 			DrawPoint (&r.corner);
 			r.corner.x += r.extent.width + 1;
 			DrawPoint (&r.corner);
diff -ruNp src.orig/uqm/sis.c src/uqm/sis.c
--- src.orig/uqm/sis.c	2017-11-21 16:07:15 -0600
+++ src/uqm/sis.c	2017-11-22 08:52:13 -0600
@@ -347,9 +347,27 @@ void
 DateToString (char *buf, size_t bufLen,
 		BYTE month_index, BYTE day_index, COUNT year_index)
 {
-	snprintf (buf, bufLen, "%s %02d" STR_MIDDLE_DOT "%04d",
-			GAME_STRING (MONTHS_STRING_BASE + month_index - 1),
-			day_index, year_index);
+	switch (optDateFormat) {
+		case 1: /* MM.DD.YYYY */
+			snprintf (buf, bufLen, "%02d%s%02d%s%04d", month_index,
+					STR_MIDDLE_DOT, day_index, STR_MIDDLE_DOT, year_index);
+			break;
+		case 2: /* DD MMM YYYY */
+			snprintf (buf, bufLen, "%02d %s%s%04d", day_index,
+					GAME_STRING (MONTHS_STRING_BASE + month_index - 1),
+					STR_MIDDLE_DOT, year_index);
+			break;
+		case 3: /* DD.MM.YYYY */
+			snprintf (buf, bufLen, "%02d%s%02d%s%04d", day_index,
+					STR_MIDDLE_DOT, month_index, STR_MIDDLE_DOT, year_index);
+			break;
+		case 0:
+		default: /* MMM DD.YYYY */
+			snprintf (buf, bufLen, "%s %02d%s%04d",
+					GAME_STRING (MONTHS_STRING_BASE + month_index - 1),
+					day_index, STR_MIDDLE_DOT, year_index);
+			break;
+	}
 }
 
 void
@@ -396,18 +414,15 @@ DrawStatusMessage (const UNICODE *pStr)
 		}
 		else if (curMsgMode == SMM_RES_UNITS)
 		{
-			if (GET_GAME_STATE (CHMMR_BOMB_STATE) < 2)
-			{
-				snprintf (buf, sizeof buf, "%u %s", GLOBAL_SIS (ResUnits),
-						GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
-			}
-			else
-			{
+			if (GET_GAME_STATE (CHMMR_BOMB_STATE) > 2 || GLOBAL_SIS (ResUnits) > 2000000L) {
 				snprintf (buf, sizeof buf, "%s %s",
 						(optWhichMenu == OPT_PC) ?
 							GAME_STRING (STATUS_STRING_BASE + 2)
 							: STR_INFINITY_SIGN, // "UNLIMITED"
 						GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
+			} else {
+				snprintf (buf, sizeof buf, "%u %s", GLOBAL_SIS (ResUnits),
+						GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
 			}
 		}
 		else
@@ -426,6 +441,14 @@ DrawStatusMessage (const UNICODE *pStr)
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 
+	if (curMsgMode == SMM_WARNING) {
+		SetContextForeGroundColor (STATUS_MESSAGE_WARNING_TEXT_COLOR);
+	} else if (curMsgMode == SMM_ALERT) {
+		SetContextForeGroundColor (STATUS_MESSAGE_ALERT_TEXT_COLOR);
+	} else {
+		SetContextForeGroundColor (STATUS_MESSAGE_TEXT_COLOR);
+	}
+
 	SetContextFont (TinyFont);
 	SetContextForeGroundColor (STATUS_MESSAGE_TEXT_COLOR);
 	font_DrawText (&t);
@@ -1058,10 +1081,16 @@ DeltaSISGauges_fuelDelta (SIZE fuel_delt
 	if (new_coarse_fuel != old_coarse_fuel)
 	{
 		TEXT t;
-		UNICODE buf[60];
+		// buf from [60] to [4]: The max fuel anyone can ever get is 1610
+		// I.E. only 4 characters, we don't need that much extra padding.
+		UNICODE buf[4];
 		RECT r;
 
-		snprintf (buf, sizeof buf, "%u", new_coarse_fuel);
+		if(!optInfiniteFuel)
+			snprintf (buf, sizeof buf, "%u", new_coarse_fuel);
+		else
+			snprintf (buf, sizeof buf, "%s", STR_INFINITY_SIGN);
+
 
 		GetGaugeRect (&r, FALSE);
 		
@@ -1115,6 +1144,8 @@ void
 DeltaSISGauges (SIZE crew_delta, SIZE fuel_delta, int resunit_delta)
 {
 	CONTEXT OldContext;
+	Color OldColor;
+	RECT r;
 
 	if (crew_delta == 0 && fuel_delta == 0 && resunit_delta == 0)
 		return;
@@ -1127,6 +1158,15 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 		STAMP s;
 		s.origin.x = 0;
 		s.origin.y = 0;
+
+		// JMS: These lines prevent the flagship status box from turning grey.
+		OldColor = SetContextForeGroundColor (BLACK_COLOR);
+		r.corner.y = 23;
+		r.corner.x = 2;
+		r.extent.width = STATUS_WIDTH - 4;
+		r.extent.height = 105;
+		DrawFilledRectangle (&r);
+
 		s.frame = FlagStatFrame;
 		DrawStamp (&s);
 
@@ -1138,6 +1178,8 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 		DrawModules ();
 
 		DrawSupportShips ();
+		// JMS: In conjunction with the JMS lines above.
+		SetContextForeGroundColor (OldColor);
 	}
 
 	SetContextFont (TinyFont);
diff -ruNp src.orig/uqm/sis.h src/uqm/sis.h
--- src.orig/uqm/sis.h	2017-11-21 16:07:15 -0600
+++ src/uqm/sis.h	2017-11-22 08:52:13 -0600
@@ -199,6 +199,8 @@ typedef enum
 	SMM_DATE,
 	SMM_RES_UNITS,
 	SMM_CREDITS,
+	SMM_WARNING,
+	SMM_ALERT,
 
 	SMM_DEFAULT = SMM_DATE,
 } StatMsgMode;
diff -ruNp src.orig/uqm/sounds.h src/uqm/sounds.h
--- src.orig/uqm/sounds.h	2017-11-21 16:07:15 -0600
+++ src/uqm/sounds.h	2017-11-22 08:52:13 -0600
@@ -43,6 +43,7 @@ typedef enum
 	MENU_SOUND_SUCCESS,
 	MENU_SOUND_FAILURE,
 	MENU_SOUND_INVOKED,
+	MENU_SOUND_BUBBLEWARP,
 } MENU_SOUND_EFFECT;
 
 extern SOUND MenuSounds;
diff -ruNp src.orig/uqm/starbase.c src/uqm/starbase.c
--- src.orig/uqm/starbase.c	2017-11-21 16:07:15 -0600
+++ src/uqm/starbase.c	2017-11-22 08:52:13 -0600
@@ -32,6 +32,13 @@
 #include "sounds.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/tasklib.h"
+#include "libs/log.h"
+
+#include "planets/planets.h"
+// JMS: For MIN_MOON_RADIUS
+
+#include <math.h>
+// JMS: For sin and cos
 
 
 static void CleanupAfterStarBase (void);
@@ -425,6 +432,41 @@ DoTimePassage (void)
 #define LOST_DAYS 14
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND * 2));
 	MoveGameClockDays (LOST_DAYS);
+
+	// JMS: Calculate flagship location in IP.
+	{
+		double newAngle;
+		POINT starbase_coords;
+		RECT r;
+		COORD dx, dy;
+		
+		// Starbase's radius from earth is MIN_MOON_RADIUS.
+		dx = MIN_MOON_RADIUS;
+		dy = MIN_MOON_RADIUS;
+		
+		// Calculate the starbase position on a circle with the help of sin and cos.
+		newAngle = ((double)(10) + daysElapsed() * (FULL_CIRCLE / 11.46)) * M_PI / 32 - M_PI/2 ; // JMS: Starbase orbit values copied from gensol.c
+		starbase_coords.x = (COORD)(cos(newAngle) * MIN_MOON_RADIUS);
+		starbase_coords.y = (COORD)(sin(newAngle) * MIN_MOON_RADIUS);
+		
+		//log_add (log_Debug, "startangle:%d angle:%f, radius:%d, speed:%f, days:%f X:%d, y:%d", 10, newAngle, MIN_MOON_RADIUS, FULL_CIRCLE / 11.46, daysElapsed(), starbase_coords.x, starbase_coords.y);
+		
+		// Translate the coordinates on a circle to an ellipse.
+		r.corner.x = (SIS_SCREEN_WIDTH >> 1) + (long)-dx;
+		r.corner.y = (SIS_SCREEN_HEIGHT >> 1) + (long)-dy / 2;
+		r.extent.width = (long)MIN_MOON_RADIUS * (2 << 1) / 2;
+		r.extent.height = r.extent.width >> 1;
+		r.corner.x += r.extent.width >> 1;
+		r.corner.y += r.extent.height >> 1;
+		r.corner.x += (long)starbase_coords.x;
+		r.corner.y += (long)starbase_coords.y / 2;
+		
+		//log_add (log_Debug, "X:%d, y:%d", r.corner.x, r.corner.y);
+		
+		// Update the ship's graphics' coordinates on the screen.
+		GLOBAL (ShipStamp.origin.x) = r.corner.x;
+		GLOBAL (ShipStamp.origin.y) = r.corner.y;
+	}
 }
 
 void
diff -ruNp src.orig/uqm/starcon.c src/uqm/starcon.c
--- src.orig/uqm/starcon.c	2017-11-21 16:07:15 -0600
+++ src/uqm/starcon.c	2017-11-22 08:52:13 -0600
@@ -47,9 +47,13 @@
 #include "libs/graphics/tfb_draw.h"
 #include "libs/misc.h"
 #include "libs/scriptlib.h"
-
+#include "build.h"
 #include "uqmversion.h"
 #include "options.h"
+#include "setupmenu.h"
+#include "build.h"
+#include "gameopt.h" // JMS: For naming captain and ship at game start.
+
 
 volatile int MainExited = FALSE;
 #ifdef DEBUG_SLEEP
@@ -206,7 +210,10 @@ while (--ac > 0)
 
 	GLOBAL (CurrentActivity) = 0;
 	luaUqm_initState ();
-	// show splash and init the kernel in the meantime
+	// show logo then splash and init the kernel in the meantime
+	if(optWhichIntro == OPT_3DO && optFMV && !optSkipIntro){
+		Logo ();
+	}
 	SplashScreen (BackgroundInitKernel);
 
 //	OpenJournal ();
@@ -224,9 +231,13 @@ while (--ac > 0)
 		initEventSystem ();
 		AddInitialGameEvents();
 
+		// JMS: Name Captain & Ship at start (not at loading old game).
+		if (LastActivity == (CHECK_LOAD | CHECK_RESTART))
+			AskNameForCaptainAndShip();
+
 		do
 		{
-#ifdef DEBUG
+//#ifdef DEBUG
 			if (debugHook != NULL)
 			{
 				void (*saveDebugHook) (void);
@@ -237,7 +248,7 @@ while (--ac > 0)
 				(*saveDebugHook) ();
 				continue;
 			}
-#endif
+//#endif
 			SetStatusMessageMode (SMM_DEFAULT);
 
 			if (!((GLOBAL (CurrentActivity) | NextActivity) & CHECK_LOAD))
@@ -307,6 +318,9 @@ while (--ac > 0)
 					GLOBAL (CurrentActivity) &= ~CHECK_RESTART;
 				break;
 			}
+			if (optInfiniteRU){
+				GLOBAL_SIS (ResUnits) = 4000000000L;
+			}
 		} while (!(GLOBAL (CurrentActivity) & CHECK_ABORT));
 
 		StopSound ();
diff -ruNp src.orig/uqm/state.c src/uqm/state.c
--- src.orig/uqm/state.c	2017-11-21 16:07:15 -0600
+++ src/uqm/state.c	2017-11-22 08:52:14 -0600
@@ -236,17 +236,25 @@ UninitPlanetInfo (void)
 }
 
 #define OFFSET_SIZE       (sizeof (DWORD))
-#define SCAN_RECORD_SIZE  (sizeof (DWORD) * NUM_SCAN_TYPES)
+//#define SCAN_RECORD_SIZE  (sizeof (DWORD) * NUM_SCAN_TYPES)
+// JMS: Increased the size of scan record to house partially scavenged minerals.
+#define SCAN_RECORD_SIZE  ((sizeof (DWORD) * NUM_SCAN_TYPES) + (sizeof(BYTE) * NUM_SCAN_TYPES * 32))
 
 void
 GetPlanetInfo (void)
 {
 	GAME_STATE_FILE *fp;
+	COUNT k,l;
 
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] = 0;
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[MINERAL_SCAN] = 0;
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN] = 0;
 
+	// JMS: Init also the partially scavenged mineral deposit values.
+	for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+		for (k = 0; k < 32; k++)
+			pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[l][k] = 0;
+
 	fp = OpenStateFile (STARINFO_FILE, "rb");
 	if (fp)
 	{
@@ -280,6 +288,15 @@ GetPlanetInfo (void)
 			SeekStateFile (fp, offset, SEEK_SET);
 			sread_a32 (fp, pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask,
 					NUM_SCAN_TYPES);
+
+			{
+				BYTE *ar = &(pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[0][0]); // JMS
+				
+				// JMS: Read which mineral deposits are partially retrieved (and how much).
+				for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+					for (k = 0; k < 32; k++, ar++)
+						sread_8 (fp, ar);
+			}
 		}
 
 		CloseStateFile (fp);
@@ -294,7 +311,7 @@ PutPlanetInfo (void)
 	fp = OpenStateFile (STARINFO_FILE, "r+b");
 	if (fp)
 	{
-		COUNT i;
+		COUNT i, k, l;
 		COUNT star_index, planet_index, moon_index;
 		DWORD offset;
 
@@ -317,6 +334,12 @@ PutPlanetInfo (void)
 				0, 0, 0,
 			};
 
+			// JMS: Init also the partially scavenged mineral deposit values.
+			BYTE PartiallyScavengedList[NUM_SCAN_TYPES][32];
+			for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+				for (k = 0; k < 32; k++)
+					PartiallyScavengedList[l][k] = 0;
+
 			offset = LengthStateFile (fp);
 
 			// Write the record offset
@@ -328,11 +351,26 @@ PutPlanetInfo (void)
 			for (i = 0; i < pSolarSysState->SunDesc[0].NumPlanets; ++i)
 			{
 				COUNT j;
+				BYTE *ar = &(PartiallyScavengedList[0][0]); // JMS
 
 				swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
+
+				// JMS: Also init with zeroes the list of partially scavenged mineral amounts.
+				for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+					for (k = 0; k < 32; k++, ar++)
+						swrite_8 (fp, *ar);
+
 				// init moons
-				for (j = 0; j < pSolarSysState->PlanetDesc[i].NumPlanets; ++j)
-					swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
+				for (j = 0; j < pSolarSysState->PlanetDesc[i].NumPlanets; ++j) {
+					BYTE *ar = &(PartiallyScavengedList[0][0]); // JMS
+					
+ 					swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
+					
+					// JMS: Ditto for the moons.
+					for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+						for (k = 0; k < 32; k++, ar++)
+							swrite_8 (fp, *ar);
+				}
 			}
 		}
 
@@ -345,9 +383,20 @@ PutPlanetInfo (void)
 		offset += moon_index * SCAN_RECORD_SIZE;
 
 		SeekStateFile (fp, offset, SEEK_SET);
+
+		// Store which mineral deposits we have already retrieved.
 		swrite_a32 (fp, pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask,
 				NUM_SCAN_TYPES);
 
+		{
+			BYTE *ar = &(pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[0][0]); // JMS
+			
+			// JMS: Store which mineral deposits are partially retrieved (and how much).
+			for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+				for (k = 0; k < 32; k++, ar++)
+					swrite_8 (fp, *ar);
+		}
+
 		CloseStateFile (fp);
 	}
 }
diff -ruNp src.orig/uqm/tactrans.c src/uqm/tactrans.c
--- src.orig/uqm/tactrans.c	2017-11-21 16:07:16 -0600
+++ src/uqm/tactrans.c	2017-11-22 08:52:14 -0600
@@ -937,17 +937,15 @@ ship_transition (ELEMENT *ElementPtr)
 			}
 			else if (ElementPtr->crew_level)
 			{
-				ShipImagePtr->current.location.x -=
-						COSINE (angle, TRANSITION_SPEED)
-						* (ElementPtr->life_span - 1);
-				ShipImagePtr->current.location.y -=
-						SINE (angle, TRANSITION_SPEED)
-						* (ElementPtr->life_span - 1);
-
-				ShipImagePtr->current.location.x =
-						WRAP_X (ShipImagePtr->current.location.x);
-				ShipImagePtr->current.location.y =
-						WRAP_Y (ShipImagePtr->current.location.y);
+				// JMS_GFX: Circumventing overflows by using temp variables instead of 
+				// subtracting straight from the POINT sized ShipImagePtr->current.location.
+				SDWORD temp_x = (SDWORD)ShipImagePtr->current.location.x -
+					COSINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+				SDWORD temp_y = (SDWORD)ShipImagePtr->current.location.y -
+					SINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+                
+				ShipImagePtr->current.location.x = WRAP_X (temp_x);
+				ShipImagePtr->current.location.y = WRAP_Y (temp_y);
 			}
 			ShipImagePtr->preprocess_func = ship_transition;
 			ShipImagePtr->death_func = cycle_ion_trail;
diff -ruNp src.orig/uqm/trans.c src/uqm/trans.c
--- src.orig/uqm/trans.c	2017-11-21 16:07:16 -0600
+++ src/uqm/trans.c	2017-11-22 08:52:14 -0600
@@ -20,7 +20,7 @@
 #include "libs/compiler.h"
 
 
-SIZE sinetab[] =
+SDWORD sinetab[] =
 {
 	-FLT_ADJUST (1.000000),
 	-FLT_ADJUST (0.995185),
diff -ruNp src.orig/uqm/units.h src/uqm/units.h
--- src.orig/uqm/units.h	2017-11-21 16:07:16 -0600
+++ src/uqm/units.h	2017-11-22 08:52:14 -0600
@@ -81,9 +81,10 @@ extern int ScreenHeight;
 #define SCALED_ONE (1 << ONE_SHIFT)
 #define DISPLAY_TO_WORLD(x) ((x)<<ONE_SHIFT)
 #define WORLD_TO_DISPLAY(x) ((x)>>ONE_SHIFT)
-#define DISPLAY_ALIGN(x) ((COORD)(x)&~(SCALED_ONE-1))
-#define DISPLAY_ALIGN_X(x) ((COORD)((COUNT)(x)%LOG_SPACE_WIDTH)&~(SCALED_ONE-1))
-#define DISPLAY_ALIGN_Y(y) ((COORD)((COUNT)(y)%LOG_SPACE_HEIGHT)&~(SCALED_ONE-1))
+// JMS_GFX: Changed from COORD to SDWORD and from COUNT to DWORD
+#define DISPLAY_ALIGN(x) ((SDWORD)(x)&~(SCALED_ONE-1))
+#define DISPLAY_ALIGN_X(x) ((SDWORD)((DWORD)(x)%LOG_SPACE_WIDTH)&~(SCALED_ONE-1))
+#define DISPLAY_ALIGN_Y(y) ((SDWORD)((DWORD)(y)%LOG_SPACE_HEIGHT)&~(SCALED_ONE-1))
 
 #define LOG_SPACE_WIDTH \
 		(DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_REDUCTION)
@@ -190,8 +191,8 @@ universeToLogy (COORD uy)
 										>>(CIRCLE_SHIFT-FACING_SHIFT))
 #define FACING_TO_ANGLE(f) ((f)<<(CIRCLE_SHIFT-FACING_SHIFT))
 
-#define NORMALIZE_ANGLE(a) ((COUNT)((a)&(FULL_CIRCLE-1)))
-#define NORMALIZE_FACING(f) ((COUNT)((f)&((1 << FACING_SHIFT)-1)))
+#define NORMALIZE_ANGLE(a) ((DWORD)((a)&(FULL_CIRCLE-1)))
+#define NORMALIZE_FACING(f) ((DWORD)((f)&((1 << FACING_SHIFT)-1)))
 
 #define DEGREES_TO_ANGLE(d) NORMALIZE_ANGLE((((d) % 360) * FULL_CIRCLE \
 				+ HALF_CIRCLE) / 360)
@@ -204,7 +205,7 @@ universeToLogy (COORD uy)
 #define UNADJUST(x) (SIZE)((x)>>SIN_SHIFT)
 #define ROUND(x,y) ((x)+((x)>=0?((y)>>1):-((y)>>1)))
 
-extern SIZE sinetab[];
+extern SDWORD sinetab[];
 #define SINVAL(a) sinetab[NORMALIZE_ANGLE(a)]
 #define COSVAL(a) SINVAL((a)+QUADRANT)
 #define SINE(a,m) ((SIZE)((((long)SINVAL(a))*(long)(m))>>SIN_SHIFT))
diff -ruNp src.orig/uqm/uqmdebug.c src/uqm/uqmdebug.c
--- src.orig/uqm/uqmdebug.c	2017-11-21 16:07:16 -0600
+++ src/uqm/uqmdebug.c	2017-11-22 08:52:14 -0600
@@ -14,7 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#if defined(DEBUG) || defined(USE_DEBUG_KEY)
 
 #include "uqmdebug.h"
 
@@ -23,7 +22,7 @@
 #include "controls.h"
 #include "clock.h"
 #include "starmap.h"
-#include "element.h"
+#include "intel.h"
 #include "sis.h"
 #include "status.h"
 #include "gamestr.h"
@@ -41,6 +40,114 @@
 #include <stdio.h>
 #include <errno.h>
 
+void (* volatile debugHook) (void) = NULL;
+
+// Move the Flagship to the destination of the autopilot.
+// Should only be called from HyperSpace/QuasiSpace.
+// It can be called from debugHook directly after entering HS/QS though.
+void
+doInstantMove (void)
+{
+	// Move to the new location:
+	if ((GLOBAL (autopilot)).x == ~0 || (GLOBAL (autopilot)).y == ~0)
+	{
+		// If no destination has been selected, use the current location
+		// as the destination.
+		(GLOBAL (autopilot)).x = LOGX_TO_UNIVERSE(GLOBAL_SIS (log_x));
+		(GLOBAL (autopilot)).y = LOGY_TO_UNIVERSE(GLOBAL_SIS (log_y));
+	}
+	else
+	{
+		// A new destination has been selected.
+		GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX((GLOBAL (autopilot)).x);
+		GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY((GLOBAL (autopilot)).y);
+	}
+
+	// Check for a solar systems at the destination.
+	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+	{
+		// If there's a solar system at the destination, enter it.
+		CurStarDescPtr = FindStar (0, &(GLOBAL (autopilot)), 0, 0);
+		if (CurStarDescPtr)
+		{
+			// Leave HyperSpace/QuasiSpace if we're there:
+			SET_GAME_STATE (USED_BROADCASTER, 0);
+			GLOBAL (CurrentActivity) &= ~IN_BATTLE;
+
+			// Enter IP:
+			GLOBAL (ShipFacing) = 0;
+			GLOBAL (ip_planet) = 0;
+			GLOBAL (in_orbit) = 0;
+					// This causes the ship position in IP to be reset.
+			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
+		}
+	}
+
+	// Turn off the autopilot:
+	(GLOBAL (autopilot)).x = ~0;
+	(GLOBAL (autopilot)).y = ~0;
+}
+
+// playerNr should be 0 or 1
+STARSHIP*
+findPlayerShip (SIZE playerNr)
+{
+	HELEMENT hElement, hNextElement;
+
+	for (hElement = GetHeadElement (); hElement; hElement = hNextElement)
+	{
+		ELEMENT *ElementPtr;
+
+		LockElement (hElement, &ElementPtr);
+		hNextElement = GetSuccElement (ElementPtr);
+					
+		if ((ElementPtr->state_flags & PLAYER_SHIP)	&&
+				ElementPtr->playerNr == playerNr)
+		{
+			STARSHIP *StarShipPtr;
+			GetElementStarShip (ElementPtr, &StarShipPtr);
+			UnlockElement (hElement);
+			return StarShipPtr;
+		}
+		
+		UnlockElement (hElement);
+	}
+	return NULL;
+}
+
+////////////////////////////////////////////////////////////////////////////
+
+void
+resetEnergyBattle (void)
+{
+	STARSHIP *StarShipPtr;
+	COUNT delta;
+	CONTEXT OldContext;
+	
+	if (!(GLOBAL (CurrentActivity) & IN_BATTLE) ||
+			(LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE))
+		return;	
+
+	if (PlayerControl[1] & HUMAN_CONTROL){
+		StarShipPtr = findPlayerShip (NPC_PLAYER_NUM);
+	} else if (PlayerControl[0] & HUMAN_CONTROL) {
+		StarShipPtr = findPlayerShip (RPG_PLAYER_NUM);
+	} else {
+		StarShipPtr = NULL;
+	}
+
+	if (StarShipPtr == NULL || StarShipPtr->RaceDescPtr == NULL)
+		return;
+
+	delta = StarShipPtr->RaceDescPtr->ship_info.max_energy -
+			StarShipPtr->RaceDescPtr->ship_info.energy_level;
+
+	OldContext = SetContext (StatusContext);
+	DeltaEnergy (StarShipPtr->hShip, delta);
+	SetContext (OldContext);
+}
+
+#if defined(DEBUG) || defined(USE_DEBUG_KEY)
 
 static void dumpEventCallback (const EVENT *eventPtr, void *arg);
 
@@ -72,7 +179,6 @@ static void dumpPlanetTypeCallback (int
 
 BOOLEAN instantMove = FALSE;
 BOOLEAN disableInteractivity = FALSE;
-void (* volatile debugHook) (void) = NULL;
 
 
 // Must be called on the Starcon2Main thread.
@@ -465,52 +571,6 @@ findFlagshipElement (void)
 }
 #endif
 
-// Move the Flagship to the destination of the autopilot.
-// Should only be called from HyperSpace/QuasiSpace.
-// It can be called from debugHook directly after entering HS/QS though.
-void
-doInstantMove (void)
-{
-	// Move to the new location:
-	if ((GLOBAL (autopilot)).x == ~0 || (GLOBAL (autopilot)).y == ~0)
-	{
-		// If no destination has been selected, use the current location
-		// as the destination.
-		(GLOBAL (autopilot)).x = LOGX_TO_UNIVERSE(GLOBAL_SIS (log_x));
-		(GLOBAL (autopilot)).y = LOGY_TO_UNIVERSE(GLOBAL_SIS (log_y));
-	}
-	else
-	{
-		// A new destination has been selected.
-		GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX((GLOBAL (autopilot)).x);
-		GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY((GLOBAL (autopilot)).y);
-	}
-
-	// Check for a solar systems at the destination.
-	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
-	{
-		// If there's a solar system at the destination, enter it.
-		CurStarDescPtr = FindStar (0, &(GLOBAL (autopilot)), 0, 0);
-		if (CurStarDescPtr)
-		{
-			// Leave HyperSpace/QuasiSpace if we're there:
-			SET_GAME_STATE (USED_BROADCASTER, 0);
-			GLOBAL (CurrentActivity) &= ~IN_BATTLE;
-
-			// Enter IP:
-			GLOBAL (ShipFacing) = 0;
-			GLOBAL (ip_planet) = 0;
-			GLOBAL (in_orbit) = 0;
-					// This causes the ship position in IP to be reset.
-			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
-		}
-	}
-
-	// Turn off the autopilot:
-	(GLOBAL (autopilot)).x = ~0;
-	(GLOBAL (autopilot)).y = ~0;
-}
-
 ////////////////////////////////////////////////////////////////////////////
 
 void
@@ -1473,35 +1533,6 @@ depositQualityString (BYTE quality)
 
 ////////////////////////////////////////////////////////////////////////////
 
-// playerNr should be 0 or 1
-STARSHIP*
-findPlayerShip (SIZE playerNr)
-{
-	HELEMENT hElement, hNextElement;
-
-	for (hElement = GetHeadElement (); hElement; hElement = hNextElement)
-	{
-		ELEMENT *ElementPtr;
-
-		LockElement (hElement, &ElementPtr);
-		hNextElement = GetSuccElement (ElementPtr);
-					
-		if ((ElementPtr->state_flags & PLAYER_SHIP)	&&
-				ElementPtr->playerNr == playerNr)
-		{
-			STARSHIP *StarShipPtr;
-			GetElementStarShip (ElementPtr, &StarShipPtr);
-			UnlockElement (hElement);
-			return StarShipPtr;
-		}
-		
-		UnlockElement (hElement);
-	}
-	return NULL;
-}
-
-////////////////////////////////////////////////////////////////////////////
-
 void
 resetCrewBattle (void)
 {
@@ -1525,29 +1556,6 @@ resetCrewBattle (void)
 	SetContext (OldContext);
 }
 
-void
-resetEnergyBattle (void)
-{
-	STARSHIP *StarShipPtr;
-	COUNT delta;
-	CONTEXT OldContext;
-	
-	if (!(GLOBAL (CurrentActivity) & IN_BATTLE) ||
-			(inHQSpace ()))
-		return;
-	
-	StarShipPtr = findPlayerShip (RPG_PLAYER_NUM);
-	if (StarShipPtr == NULL || StarShipPtr->RaceDescPtr == NULL)
-		return;
-
-	delta = StarShipPtr->RaceDescPtr->ship_info.max_energy -
-			StarShipPtr->RaceDescPtr->ship_info.energy_level;
-
-	OldContext = SetContext (StatusContext);
-	DeltaEnergy (StarShipPtr->hShip, delta);
-	SetContext (OldContext);
-}
-
 ////////////////////////////////////////////////////////////////////////////
 
 // This function should help in making sure that gamestr.h matches
diff -ruNp src.orig/uqm/uqmdebug.h src/uqm/uqmdebug.h
--- src.orig/uqm/uqmdebug.h	2017-11-21 16:07:16 -0600
+++ src/uqm/uqmdebug.h	2017-11-22 08:52:14 -0600
@@ -14,25 +14,36 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#if !defined(_DEBUG_H) && (defined(DEBUG) || defined(USE_DEBUG_KEY))
-#define _DEBUG_H
-
 #include "clock.h"
 #include "planets/planets.h"
 #include "races.h"
 #include "libs/compiler.h"
 
 #include <stdio.h>
+ 
+// If a function is assigned to this, it will be called from the
+// Starcon2Main thread, in the main game loop.
+extern void (* volatile debugHook) (void);
+
+// Move the Flagship to the destination of the autopilot.
+// Should only be called from HS/QS.
+// It can be called from debugHook directly after entering HS/QS though.
+void doInstantMove (void);
+
+// Find a player ship. Setting playerNr to non-0 is only meaningful in battle.
+STARSHIP* findPlayerShip (SIZE playerNr);
+
+// Resets the energy of the first player (the bottom one) to its maximum.
+void resetEnergyBattle(void);
+
+#if !defined(_DEBUG_H) && (defined(DEBUG) || defined(USE_DEBUG_KEY))
+#define _DEBUG_H
 
 
 // If set to true, interactive routines that are called (indirectly) in debug
 // functions are a no-op.
 extern BOOLEAN disableInteractivity;
 
-// If a function is assigned to this, it will be called from the
-// Starcon2Main thread, in the main game loop.
-extern void (* volatile debugHook) (void);
-
 // Called on the main() thread when the debug key (symbol 'Debug' in the
 // keys.cfg) is pressed
 void debugKeyPressed (void);
@@ -66,12 +77,6 @@ void showSpheres (void);
 // Make the ships of all races available for building at the shipyard.
 void activateAllShips (void);
 
-// Move the Flagship to the destination of the autopilot.
-// Should only be called from HS/QS.
-// It can be called from debugHook directly after entering HS/QS though.
-void doInstantMove (void);
-
-
 // Call a function for all stars.
 void forAllStars (void (*callback) (STAR_DESC *, void *), void *arg);
 // Call a function for all planets in a star system.
@@ -169,17 +174,9 @@ const char *densityString (BYTE density)
 // Get a string describing the quality of a deposit.
 const char *depositQualityString (BYTE quality);
 
-
-// Find a player ship. Setting playerNr to non-0 is only meaningful in battle.
-STARSHIP* findPlayerShip (SIZE playerNr);
-
 // Resets the crew of the first player (the bottom one) to its maximum.
 void resetCrewBattle(void);
 
-// Resets the energy of the first player (the bottom one) to its maximum.
-void resetEnergyBattle(void);
-
-
 // Move instantly across hyperspace/quasispace.
 extern BOOLEAN instantMove;
 
diff -ruNp src.orig/uqm/util.c src/uqm/util.c
--- src.orig/uqm/util.c	2017-11-21 16:07:16 -0600
+++ src/uqm/util.c	2017-11-22 08:52:14 -0600
@@ -25,7 +25,7 @@
 #include "libs/sound/trackplayer.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
-
+#include "hyper.h"
 
 void
 DrawStarConBox (RECT *pRect, SIZE BorderWidth, Color TopLeftColor,
@@ -310,3 +310,24 @@ SleepGame (void)
 
 	TaskSwitch ();
 }
+
+/* Returns the fuel requirement to get to Sol (in fuel units * 100)
+ */
+DWORD
+get_fuel_to_sol (void)
+{
+	POINT pt;
+	DWORD f;
+
+	pt.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+	pt.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+	
+	pt.x -= SOL_X;
+	pt.y -= SOL_Y;
+
+	f = (DWORD)((long)pt.x * pt.x + (long)pt.y * pt.y);
+	if (f == 0 || GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1)
+		return 0;
+	else
+		return (square_root (f) + (FUEL_TANK_SCALE / 20));
+}
\ No newline at end of file
diff -ruNp src.orig/uqm/util.h src/uqm/util.h
--- src.orig/uqm/util.h	2017-11-21 16:07:16 -0600
+++ src/uqm/util.h	2017-11-22 08:52:14 -0600
@@ -32,6 +32,8 @@ extern DWORD SeedRandomNumbers (void);
 // saveRect can be NULL to save the entire context frame
 extern STAMP SaveContextFrame (const RECT *saveRect);
 
+extern DWORD get_fuel_to_sol (void);
+
 #if defined(__cplusplus)
 }
 #endif
diff -ruNp src.orig/uqm.c src/uqm.c
--- src.orig/uqm.c	2017-11-21 16:07:16 -0600
+++ src/uqm.c	2017-11-22 08:52:14 -0600
@@ -130,6 +130,29 @@ struct options_struct
 	DECL_CONFIG_OPTION(float, sfxVolumeScale);
 	DECL_CONFIG_OPTION(float, speechVolumeScale);
 	DECL_CONFIG_OPTION(bool, safeMode);
+ 	DECL_CONFIG_OPTION(bool, cheatMode); // JMS
+	// Serosis
+	DECL_CONFIG_OPTION(bool, godMode);
+	DECL_CONFIG_OPTION(int, timeDilationScale);
+	DECL_CONFIG_OPTION(bool, bubbleWarp);
+	DECL_CONFIG_OPTION(bool, unlockShips);
+	DECL_CONFIG_OPTION(bool, headStart);
+	DECL_CONFIG_OPTION(bool, unlockUpgrades);
+	DECL_CONFIG_OPTION(bool, infiniteRU);
+	DECL_CONFIG_OPTION(bool, skipIntro);
+	DECL_CONFIG_OPTION(bool, FMV);
+	// JMS
+	DECL_CONFIG_OPTION(bool, mainMenuMusic);
+	DECL_CONFIG_OPTION(bool, nebulae);
+	DECL_CONFIG_OPTION(bool, orbitingPlanets);
+	DECL_CONFIG_OPTION(bool, texturedPlanets);
+	// Nic
+	DECL_CONFIG_OPTION(int, optDateFormat);
+	// Serosis
+	DECL_CONFIG_OPTION(bool, infiniteFuel);
+	DECL_CONFIG_OPTION(bool, thraddStory);
+	DECL_CONFIG_OPTION(bool, partialPickup);
+	DECL_CONFIG_OPTION(bool, submenu);
 
 #define INIT_CONFIG_OPTION(name, val) \
 	{ val, false }
@@ -238,10 +261,10 @@ main (int argc, char *argv[])
 		/* .addons = */             NULL,
 		/* .numAddons = */          0,
 
-		INIT_CONFIG_OPTION(  opengl,            false ),
+		INIT_CONFIG_OPTION(  opengl,            true ),
 		INIT_CONFIG_OPTION2( resolution,        640, 480 ),
 		INIT_CONFIG_OPTION(  fullscreen,        false ),
-		INIT_CONFIG_OPTION(  scanlines,         false ),
+		INIT_CONFIG_OPTION(  scanlines,         true ),
 		INIT_CONFIG_OPTION(  scaler,            0 ),
 		INIT_CONFIG_OPTION(  showFps,           false ),
 		INIT_CONFIG_OPTION(  keepAspectRatio,   false ),
@@ -252,18 +275,40 @@ main (int argc, char *argv[])
 		INIT_CONFIG_OPTION(  useRemixMusic,     false ),
 		INIT_CONFIG_OPTION(  useSpeech,         true ),
 		INIT_CONFIG_OPTION(  whichCoarseScan,   OPT_PC ),
-		INIT_CONFIG_OPTION(  whichMenu,         OPT_PC ),
+		INIT_CONFIG_OPTION(  whichMenu,         OPT_3DO ),
 		INIT_CONFIG_OPTION(  whichFonts,        OPT_PC ),
-		INIT_CONFIG_OPTION(  whichIntro,        OPT_PC ),
-		INIT_CONFIG_OPTION(  whichShield,       OPT_PC ),
+		INIT_CONFIG_OPTION(  whichIntro,        OPT_3DO ),
+		INIT_CONFIG_OPTION(  whichShield,       OPT_3DO ),
 		INIT_CONFIG_OPTION(  smoothScroll,      OPT_PC ),
 		INIT_CONFIG_OPTION(  meleeScale,        TFB_SCALE_TRILINEAR ),
 		INIT_CONFIG_OPTION(  subtitles,         true ),
 		INIT_CONFIG_OPTION(  stereoSFX,         false ),
 		INIT_CONFIG_OPTION(  musicVolumeScale,  1.0f ),
 		INIT_CONFIG_OPTION(  sfxVolumeScale,    1.0f ),
-		INIT_CONFIG_OPTION(  speechVolumeScale, 1.0f ),
+		INIT_CONFIG_OPTION(  speechVolumeScale, 0.8f ),
 		INIT_CONFIG_OPTION(  safeMode,          false ),
+		INIT_CONFIG_OPTION(  cheatMode,			false ), // JMS
+		//Serosis
+		INIT_CONFIG_OPTION(  godMode,			false ), 
+		INIT_CONFIG_OPTION(  timeDilationScale,	0 ),
+		INIT_CONFIG_OPTION(  bubbleWarp,		false ),
+		INIT_CONFIG_OPTION(  unlockShips,		false ),
+		INIT_CONFIG_OPTION(  headStart,			false ),
+		INIT_CONFIG_OPTION(  unlockUpgrades,	false ),
+		INIT_CONFIG_OPTION(  infiniteRU,		false ),
+		INIT_CONFIG_OPTION(  skipIntro,			false ),
+		INIT_CONFIG_OPTION(  FMV,				false ),
+		// JMS
+		INIT_CONFIG_OPTION(  mainMenuMusic,     true ),
+		INIT_CONFIG_OPTION(  nebulae,			true ),
+		INIT_CONFIG_OPTION(  orbitingPlanets,	false),
+		INIT_CONFIG_OPTION(  texturedPlanets,	false),
+		// Nic
+		INIT_CONFIG_OPTION(  optDateFormat,		0),
+		INIT_CONFIG_OPTION(  infiniteFuel,		false),
+		INIT_CONFIG_OPTION(  thraddStory,		false),
+		INIT_CONFIG_OPTION(  partialPickup,		false),
+		INIT_CONFIG_OPTION(  submenu,			true),
 	};
 	struct options_struct defaults = options;
 	int optionsResult;
@@ -391,6 +436,30 @@ main (int argc, char *argv[])
 	sfxVolumeScale = options.sfxVolumeScale.value;
 	speechVolumeScale = options.speechVolumeScale.value;
 	optAddons = options.addons;
+	
+	optGodMode = options.godMode.value; // JMS
+	// Serosis
+	timeDilationScale = options.timeDilationScale.value;
+	optBubbleWarp = options.bubbleWarp.value;
+	optUnlockShips = options.unlockShips.value;
+	optHeadStart = options.headStart.value;
+	optUnlockUpgrades = options.unlockUpgrades.value;
+	optInfiniteRU = options.infiniteRU.value;
+	optSkipIntro = options.skipIntro.value;
+	optFMV = options.FMV.value;
+	// JMS
+	optMainMenuMusic = options.mainMenuMusic.value;
+	optNebulae = options.nebulae.value;
+	optOrbitingPlanets = options.orbitingPlanets.value;
+	optTexturedPlanets = options.texturedPlanets.value;
+ 	optCheatMode = options.cheatMode.value;
+	// Nic
+	optDateFormat = options.optDateFormat.value;
+	// Serosis	
+	optInfiniteFuel = options.infiniteFuel.value;
+	optThraddStory = options.thraddStory.value;
+	optPartialPickup = options.partialPickup.value;
+	optSubmenu = options.submenu.value;
 
 	prepareContentDir (options.contentDir, options.addonDir, argv[0]);
 	prepareMeleeDir ();
@@ -675,6 +744,34 @@ getUserConfigOptions (struct options_str
 	getVolumeConfigValue (&options->musicVolumeScale, "config.musicvol");
 	getVolumeConfigValue (&options->sfxVolumeScale, "config.sfxvol");
 	getVolumeConfigValue (&options->speechVolumeScale, "config.speechvol");
+
+	getBoolConfigValue (&options->cheatMode, "config.kohrStahp"); // JMS
+	// Serosis
+	getBoolConfigValue (&options->godMode, "config.godMode");
+	if (res_IsInteger ("config.timeDilation") && !options->timeDilationScale.set) {
+		options->timeDilationScale.value = res_GetInteger ("config.timeDilation");
+	}
+	getBoolConfigValue (&options->bubbleWarp, "config.bubbleWarp");
+	getBoolConfigValue (&options->unlockShips, "config.unlockShips");
+	getBoolConfigValue (&options->headStart, "config.headStart");
+	getBoolConfigValue (&options->unlockUpgrades, "config.unlockUpgrades");
+	getBoolConfigValue (&options->infiniteRU, "config.infiniteRU");
+	getBoolConfigValue (&options->skipIntro, "config.skipIntro");
+	getBoolConfigValue (&options->FMV, "config.FMV");
+	// JMS
+	getBoolConfigValue (&options->mainMenuMusic, "config.mainMenuMusic");
+	getBoolConfigValue (&options->nebulae, "config.nebulae");
+	getBoolConfigValue (&options->orbitingPlanets, "config.orbitingPlanets");
+	getBoolConfigValue (&options->texturedPlanets, "config.texturedPlanets");
+	// Nic	
+	if (res_IsInteger ("config.dateFormat") && !options->optDateFormat.set) {
+		options->optDateFormat.value = res_GetInteger ("config.dateFormat");
+	}
+	// Serosis	
+	getBoolConfigValue (&options->infiniteFuel, "config.infiniteFuel");
+	getBoolConfigValue (&options->thraddStory, "config.thraddStory");
+	getBoolConfigValue (&options->partialPickup, "config.partialPickup");
+	getBoolConfigValue (&options->submenu, "config.submenu");
 	
 	if (res_IsInteger ("config.player1control"))
 	{
@@ -714,6 +811,25 @@ enum
 	ADDONDIR_OPT,
 	ACCEL_OPT,
 	SAFEMODE_OPT,
+	CHEATMODE_OPT, //Serosis
+	GODMODE_OPT,
+	TDM_OPT,
+	BWARP_OPT,
+	UNLOCKSHIPS_OPT,
+	HEADSTART_OPT,
+	UPGRADES_OPT,
+	INFINITERU_OPT,
+	SKIPINTRO_OPT,
+	FMV_OPT,
+	MENUMUS_OPT,
+	NEBU_OPT,
+	ORBITS_OPT,
+	TEXTPLAN_OPT,
+	DATE_OPT,
+	INFFUEL_OPT,
+	THRADD_OPT,
+	PICKUP_OPT,
+	SUBMENU_OPT,
 #ifdef NETPLAY
 	NETHOST1_OPT,
 	NETPORT1_OPT,
@@ -761,6 +877,25 @@ static struct option longOptions[] =
 	{"addondir", 1, NULL, ADDONDIR_OPT},
 	{"accel", 1, NULL, ACCEL_OPT},
 	{"safe", 0, NULL, SAFEMODE_OPT},
+	{"kohrstahp", 0, NULL, CHEATMODE_OPT}, //Serosis
+	{"godmode", 0, NULL, GODMODE_OPT},
+	{"timedilation", 1, NULL, TDM_OPT},
+	{"bubblewarp", 0, NULL, BWARP_OPT},
+	{"unlockships", 0, NULL, UNLOCKSHIPS_OPT},
+	{"headstart", 0, NULL, HEADSTART_OPT},
+	{"unlockupgrades", 0, NULL, UPGRADES_OPT},
+	{"infiniteru", 0, NULL, INFINITERU_OPT},
+	{"skipintro", 0, NULL, SKIPINTRO_OPT},
+	{"fmv", 0, NULL, FMV_OPT},
+	{"mainmenumusic", 0, NULL, MENUMUS_OPT},
+	{"nebulae", 0, NULL, NEBU_OPT},
+	{"orbitingplanets", 0, NULL, ORBITS_OPT},
+	{"texturedplanets", 0, NULL, TEXTPLAN_OPT},
+	{"dateformat", 0, NULL, DATE_OPT},
+	{"infinitefuel", 0, NULL, INFFUEL_OPT},
+	{"thraddstory", 0, NULL, THRADD_OPT},
+	{"partialpickup", 0, NULL, PICKUP_OPT},
+	{"submenu", 0, NULL, SUBMENU_OPT},
 #ifdef NETPLAY
 	{"nethost1", 1, NULL, NETHOST1_OPT},
 	{"netport1", 1, NULL, NETPORT1_OPT},
@@ -1017,6 +1152,85 @@ parseOptions (int argc, char *argv[], st
 			case STEREOSFX_OPT:
 				setBoolOption (&options->stereoSFX, true);
 				break;
+			case CHEATMODE_OPT:
+				setBoolOption (&options->cheatMode, true); //Serosis
+				break;
+			case GODMODE_OPT:
+				setBoolOption (&options->godMode, true);
+				break;
+			case TDM_OPT:{
+				int temp;
+				if (parseIntOption (optarg, &temp, "Time Dilation scale") == -1) {
+					badArg = true;
+					break;
+				} else if (temp < 0 || temp > 2) {					
+					saveError ("\nTime Dilation scale has to be 0, 1, or 2.\n");
+					badArg = true;
+				} else {
+					options->timeDilationScale.value = temp;
+					options->timeDilationScale.set = true;
+				}
+				break;
+			}
+			case BWARP_OPT:
+				setBoolOption (&options->bubbleWarp, true);
+				break;
+			case UNLOCKSHIPS_OPT:
+				setBoolOption (&options->unlockShips, true);
+				break;
+			case HEADSTART_OPT:
+				setBoolOption (&options->headStart, true);
+				break;
+			case UPGRADES_OPT:
+				setBoolOption (&options->unlockUpgrades, true);
+				break;
+			case INFINITERU_OPT:
+				setBoolOption (&options->infiniteRU, true);
+				break;
+			case SKIPINTRO_OPT:
+				setBoolOption (&options->skipIntro, true);
+				break;
+			case FMV_OPT:
+				setBoolOption (&options->FMV, true);
+				break;
+			case MENUMUS_OPT:
+				setBoolOption (&options->mainMenuMusic, true);
+				break;
+			case NEBU_OPT:
+				setBoolOption (&options->nebulae, true);
+				break;
+			case ORBITS_OPT:
+				setBoolOption (&options->orbitingPlanets, true);
+				break;
+			case TEXTPLAN_OPT:
+				setBoolOption (&options->texturedPlanets, true);
+				break;
+			case DATE_OPT:{
+				int temp;
+				if (parseIntOption (optarg, &temp, "Date Format") == -1) {
+					badArg = true;
+					break;
+				} else if (temp < 0 || temp > 3) {					
+					saveError ("\nDate Format has to be 0, 1, 2, or 3.\n");
+					badArg = true;
+				} else {
+					options->optDateFormat.value = temp;
+					options->optDateFormat.set = true;
+				}
+				break;
+			}
+			case INFFUEL_OPT:
+				setBoolOption (&options->infiniteFuel, true);
+				break;
+			case THRADD_OPT:
+				setBoolOption (&options->thraddStory, true);
+				break;
+			case PICKUP_OPT:
+				setBoolOption (&options->partialPickup, true);
+				break;
+			case SUBMENU_OPT:
+				setBoolOption (&options->submenu, true);
+				break;
 			case ADDON_OPT:
 				options->numAddons++;
 				options->addons = HRealloc ((void *) options->addons,
@@ -1232,6 +1446,52 @@ usage (FILE *out, const struct options_s
 	log_add (log_User, "  --scroll    : ff/frev during comm.  pc=per-page, "
 			"3do=smooth (default %s)",
 			choiceOptString (&defaults->smoothScroll));
+	log_add (log_User, "The following options are for the Mega Mod"); // Serosis
+	log_add (log_User, "  --kohrstahp : Stops Kohr-Ah advancing.    (default %s)",
+			boolOptString (&defaults->cheatMode));
+	log_add (log_User, "  --godmode : Player ships and lander invulnerable. "
+			"Also refills energy every shot during melee.    (default %s)",
+			boolOptString (&defaults->godMode));
+	log_add (log_User, "  --timedilation : =1 Time is slowed down times 6. "
+			"=2 Time is sped up times 5    (default 0)");
+	log_add (log_User, "  --bubblewarp : Instantaneous travel to any point on "
+			"the Starmap.    (default %s)",
+			boolOptString (&defaults->bubbleWarp));
+	log_add (log_User, "  --unlockships : Allows you to purchase ships that you can't "
+			"normally acquire in the main game.    (default %s)",
+			boolOptString (&defaults->unlockShips));
+	log_add (log_User, "  --headstart : Equips your ship with full thrusters and jets, "
+			"two ion bolt guns, two cargo bays, two crew pods, four dynamos, two full fuel tanks, "
+			"max landers, 1000 radioactives, and 1000 bio-units.    (default %s)",
+			boolOptString (&defaults->headStart));
+	log_add (log_User, "  --unlockupgrades : Unlocks every upgrade for your flagship "
+			"and landers.    (default %s)",
+			boolOptString (&defaults->unlockUpgrades));
+	log_add (log_User, "  --infiniteru : Gives you infinite R.U. as long as the cheat is on "
+			" (default %s)",
+			boolOptString (&defaults->infiniteRU));
+	log_add (log_User, "  --skipintro : Skips the intro    (default %s)",
+			boolOptString (&defaults->skipIntro));
+	log_add (log_User, "  --fmv : Adds Logo and Commercial 3DO videos    (default %s)",
+			boolOptString (&defaults->FMV));
+	log_add (log_User, "  --mainmenumusic : Switches the main menu music on/off    (default %s)",
+			boolOptString (&defaults->mainMenuMusic));
+	log_add (log_User, "  --nebulae : Enables/Disables nebulae in star systems    (default %s)",
+			boolOptString (&defaults->nebulae));
+	log_add (log_User, "  --orbitingplanets : Enables/Disables orbiting planets in star systems    (default %s)",
+			boolOptString (&defaults->orbitingPlanets));
+	log_add (log_User, "  --texturedplanets : Enables/Disables textured planets in star systems    (default %s)",
+			boolOptString (&defaults->texturedPlanets));
+	log_add (log_User, "  --infinitefuel : Infinite fuel in the main game    (default %s)",
+			boolOptString (&defaults->infiniteFuel));
+	log_add (log_User, "  --thraddstory : Enables/Disables the Alt Thraddash Storyline    (default %s)",
+			boolOptString (&defaults->thraddStory));
+	log_add (log_User, "  --partialpickup : Enables/Disables partial mineral pickup    (default %s)",
+			boolOptString (&defaults->partialPickup));
+	log_add (log_User, "  --submenu : Enables/Disables mineral and star map keys submenu    (default %s)",
+			boolOptString (&defaults->submenu));
+	log_add (log_User, "  --dateformat : 0: MMM DD.YYYY | 1: MM.DD.YYYY"
+			"2: DD MMM.YYYY | 3: DD.MM.YYYY   (default 0)");
 	log_setOutput (old);
 }
 
diff -ruNp src.orig/uqmversion.h src/uqmversion.h
--- src.orig/uqmversion.h	2017-11-21 16:07:16 -0600
+++ src/uqmversion.h	2017-11-22 08:52:14 -0600
@@ -19,11 +19,11 @@
 
 #define UQM_MAJOR_VERSION     0
 #define UQM_MAJOR_VERSION_S  "0"
-#define UQM_MINOR_VERSION     7
-#define UQM_MINOR_VERSION_S  "7"
+#define UQM_MINOR_VERSION     8
+#define UQM_MINOR_VERSION_S  "8"
 #define UQM_PATCH_VERSION     0
 #define UQM_PATCH_VERSION_S  "0"
-#define UQM_EXTRA_VERSION    ""
+#define UQM_EXTRA_VERSION    " MegaMod Beta"
 /* The final version is interpreted as:
  * printf ("%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
  * 		UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
