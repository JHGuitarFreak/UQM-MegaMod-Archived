diff -ruNp src.orig/config_vc6.h src/config_vc6.h
--- src.orig/config_vc6.h	2017-12-30 00:14:37 -0800
+++ src/config_vc6.h	2017-12-30 00:14:49 -0800
@@ -15,7 +15,7 @@
 
 /* Directory where game data will be stored */
 //#define USERDIR "../userdata/"
-#define USERDIR "%APPDATA%/uqm/"
+#define USERDIR "%APPDATA%/uqm-080-hd/"
 
 /* Directory where config files will be stored */
 #define CONFIGDIR USERDIR
diff -ruNp src.orig/darwin/SDLMain.h src/darwin/SDLMain.h
--- src.orig/darwin/SDLMain.h	2017-12-30 00:14:37 -0800
+++ src/darwin/SDLMain.h	2017-12-30 00:14:49 -0800
@@ -13,4 +13,11 @@
 @interface SDLMain : NSObject
 @end
 
+/* For some reaon, Apple removed setAppleMenu from the headers in 10.4,
+ but the method still is there and works. To avoid warnings, we declare
+ it ourselves here. */
+@interface NSApplication(SDL_Missing_Methods)
+- (void)setAppleMenu:(NSMenu *)menu;
+@end
+
 #endif /* _SDLMain_h_ */
diff -ruNp src.orig/libs/gfxlib.h src/libs/gfxlib.h
--- src.orig/libs/gfxlib.h	2017-12-30 00:14:37 -0800
+++ src/libs/gfxlib.h	2017-12-30 00:14:49 -0800
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// JMS 2011: Added DPOINT type - a coordinate point with larger values to avoid overflows in hires modes.
+
 #ifndef _GFXLIB_H
 #define _GFXLIB_H
 
@@ -153,11 +155,23 @@ typedef struct extent
 	COORD width, height;
 } EXTENT;
 
+// JMS: Extent with larger values to avoid overflows in hires modes.
+typedef struct dextent
+{
+	SDWORD width, height;
+} DEXTENT;
+
 typedef struct point
 {
 	COORD x, y;
 } POINT;
 
+// JMS: coordinate point with larger values to avoid overflows in hires modes.
+typedef struct dpoint
+{
+	SDWORD x, y;
+} DPOINT;
+
 typedef struct stamp
 {
 	POINT origin;
@@ -423,7 +437,7 @@ extern FRAME DecFrameIndex (FRAME Frame)
 extern DRAWABLE CopyFrameRect (FRAME Frame, const RECT *area);
 extern DRAWABLE CloneFrame (FRAME Frame);
 extern DRAWABLE RotateFrame (FRAME Frame, int angle_deg);
-extern DRAWABLE RescaleFrame (FRAME, int width, int height);
+extern DRAWABLE RescaleFrame (FRAME, int width, int height, BOOLEAN eight_to_32);
 // This pair works for both paletted and trucolor frames
 extern BOOLEAN ReadFramePixelColors (FRAME frame, Color *pixels,
 		int width, int height);
@@ -431,7 +445,7 @@ extern BOOLEAN WriteFramePixelColors (FR
 		int width, int height);
 // This pair only works for paletted frames
 extern BOOLEAN ReadFramePixelIndexes (FRAME frame, BYTE *pixels,
-		int width, int height);
+		int width, int height, BOOLEAN paletted);
 extern BOOLEAN WriteFramePixelIndexes (FRAME frame, const BYTE *pixels,
 		int width, int height);
 extern void SetFrameTransparentColor (FRAME, Color);
diff -ruNp src.orig/libs/graphics/dcqueue.c src/libs/graphics/dcqueue.c
--- src.orig/libs/graphics/dcqueue.c	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/dcqueue.c	2017-12-30 00:14:49 -0800
@@ -26,7 +26,7 @@
 #include "libs/log.h"
 #include "libs/misc.h"
 		// for TFB_DEBUG_HALT
-
+#include "options.h"
 
 static RecursiveMutex DCQ_Mutex;
 
@@ -589,13 +589,13 @@ TFB_FlushGraphics (void)
 				int oldWidth = ScreenWidthActual;
 				int oldHeight = ScreenHeightActual;
 				if (TFB_ReInitGraphics (cmd->driver, cmd->flags,
-						cmd->width, cmd->height))
+						cmd->width, cmd->height, &resolutionFactor))
 				{
 					log_add (log_Error, "Could not provide requested mode: "
 							"reverting to last known driver.");
 					// We don't know what exactly failed, so roll it all back
 					if (TFB_ReInitGraphics (oldDriver, oldFlags,
-							oldWidth, oldHeight))
+							oldWidth, oldHeight, &resolutionFactor))
 					{
 						log_add (log_Fatal,
 								"Couldn't reinit at that point either. "
diff -ruNp src.orig/libs/graphics/drawable.c src/libs/graphics/drawable.c
--- src.orig/libs/graphics/drawable.c	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/drawable.c	2017-12-30 00:14:49 -0800
@@ -16,6 +16,9 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+
+#include "libs/graphics/sdl/sdl_common.h"
+#include "libs/graphics/gfx_common.h"
 #include "libs/gfxlib.h"
 #include "libs/graphics/context.h"
 #include "libs/graphics/drawable.h"
@@ -23,6 +26,7 @@
 #include "libs/memlib.h"
 #include "tfb_draw.h"
 #include <math.h>
+#include "libs/log.h"
 
 #ifndef M_PI
 #	define M_PI 3.14159265358979323846
@@ -402,7 +406,7 @@ CloneFrame (FRAME frame)
 // Creates a new DRAWABLE of specified size and scales the passed
 // frame onto it. The aspect ratio is not preserved.
 DRAWABLE
-RescaleFrame (FRAME frame, int width, int height)
+RescaleFrame (FRAME frame, int width, int height, BOOLEAN eight_to_32)
 {
 	FRAME newFrame;
 	TFB_Image *img;
@@ -426,7 +430,21 @@ RescaleFrame (FRAME frame, int width, in
 	// NOTE: We do not lock the target image because nothing has a
 	//   reference to it yet!
 	src = img->NormalImg;
-	dst = newFrame->image->NormalImg;
+	dst = newFrame->image->NormalImg;	
+	
+	// JMS_GFX
+	if (eight_to_32)
+	{
+		SDL_Surface *src_sdl = src;
+		SDL_Surface *dst_sdl = dst;
+		
+		if (src_sdl->format->BytesPerPixel == 1)
+		{
+			dst_sdl->format->BytesPerPixel = src_sdl->format->BytesPerPixel;
+			dst_sdl->format->BitsPerPixel = 8 * (src_sdl->format->BytesPerPixel);
+		}
+	}
+
 	TFB_DrawCanvas_Rescale_Nearest (src, dst, -1, NULL, NULL, NULL);
 	
 	UnlockMutex (img->mutex);
@@ -468,7 +486,7 @@ WriteFramePixelColors (FRAME frame, cons
 }
 
 BOOLEAN
-ReadFramePixelIndexes (FRAME frame, BYTE *pixels, int width, int height)
+ReadFramePixelIndexes (FRAME frame, BYTE *pixels, int width, int height, BOOLEAN paletted)
 {
 	TFB_Image *img;
 
@@ -479,8 +497,13 @@ ReadFramePixelIndexes (FRAME frame, BYTE
 
 	// TODO: Do we need to lock the img->mutex here?
 	img = frame->image;
-	return TFB_DrawCanvas_GetPixelIndexes (img->NormalImg, pixels,
+	
+	// JMS_GFX: Don't try to read pixel indexes for non-indexed images.
+	if (paletted)
+		return TFB_DrawCanvas_GetPixelIndexes (img->NormalImg, pixels,
 			width, height);
+	else
+		return FALSE;
 }
 
 // Warning: this functions bypasses DCQ, which is why it is not a DrawXXX
diff -ruNp src.orig/libs/graphics/gfx_common.c src/libs/graphics/gfx_common.c
--- src.orig/libs/graphics/gfx_common.c	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/gfx_common.c	2017-12-30 00:14:49 -0800
@@ -23,6 +23,10 @@
 #include "libs/misc.h"
 		// for TFB_DEBUG_HALT
 
+// JMS_GFX
+int fs_height = 0; 
+int fs_width  = 0;
+// End JMS_GFX
 
 int ScreenWidth;
 int ScreenHeight;
@@ -44,12 +48,26 @@ DrawFromExtraScreen (RECT *r)
 	TFB_DrawScreen_Copy(r, TFB_SCREEN_EXTRA, TFB_SCREEN_MAIN);
 }
 
+// JMS_GFX
+void
+DrawFromExtraScreen_Fs (RECT *r)
+{
+	TFB_DrawScreen_Copy_Fs(r, TFB_SCREEN_EXTRA, TFB_SCREEN_MAIN);
+}
+
 void
 LoadIntoExtraScreen (RECT *r)
 {
 	TFB_DrawScreen_Copy(r, TFB_SCREEN_MAIN, TFB_SCREEN_EXTRA);
 }
 
+// JMS_GFX
+void
+LoadIntoExtraScreen_Fs (RECT *r)
+{
+	TFB_DrawScreen_Copy_Fs(r, TFB_SCREEN_MAIN, TFB_SCREEN_EXTRA);
+}
+
 int
 SetGraphicScale (int scale)
 {
diff -ruNp src.orig/libs/graphics/gfx_common.h src/libs/graphics/gfx_common.h
--- src.orig/libs/graphics/gfx_common.h	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/gfx_common.h	2017-12-30 00:14:49 -0800
@@ -63,8 +63,8 @@ extern int GfxFlags;
 
 // The following functions are driver-defined
 void TFB_PreInit (void);
-int TFB_InitGraphics (int driver, int flags, int width, int height);
-int TFB_ReInitGraphics (int driver, int flags, int width, int height);
+int TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int *resFactor);
+int TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int *resFactor);
 void TFB_UninitGraphics (void);
 void TFB_ProcessEvents (void);
 bool TFB_SetGamma (float gamma);
@@ -82,7 +82,9 @@ typedef enum {
 } SCALE;
 
 void LoadIntoExtraScreen (RECT *r);
+void LoadIntoExtraScreen_Fs (RECT *r); // JMS_GFX
 void DrawFromExtraScreen (RECT *r);
+void DrawFromExtraScreen_Fs (RECT *r); // JMS_GFX
 int SetGraphicScale (int scale);
 int GetGraphicScale (void);
 int SetGraphicScaleMode (int mode /* enum SCALE */);
@@ -100,6 +102,11 @@ extern int FrameRateTickBase;
 void TFB_FlushGraphics (void); // Only call from main thread!!
 void TFB_PurgeDanglingGraphics (void); // Only call from main thread as part of shutdown.
 
+// JMS_GFX
+extern int fs_height; 
+extern int fs_width;
+// END JMS_GFX
+
 extern int ScreenWidth;
 extern int ScreenHeight;
 extern int ScreenWidthActual;
diff -ruNp src.orig/libs/graphics/intersec.c src/libs/graphics/intersec.c
--- src.orig/libs/graphics/intersec.c	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/intersec.c	2017-12-30 00:14:49 -0800
@@ -35,11 +35,11 @@ frame_intersect (INTERSECT_CONTROL *pCon
 		INTERSECT_CONTROL *pControl1, RECT *pr1, TIME_VALUE t0,
 		TIME_VALUE t1)
 {
-	SIZE time_error0, time_error1;
-	SIZE cycle0, cycle1;
-	SIZE dx_0, dy_0, dx_1, dy_1;
-	SIZE xincr0, yincr0, xincr1, yincr1;
-	SIZE xerror0, xerror1, yerror0, yerror1;
+	SDWORD time_error0, time_error1;
+	SDWORD cycle0, cycle1;
+	SDWORD dx_0, dy_0, dx_1, dy_1;
+	SDWORD xincr0, yincr0, xincr1, yincr1;
+	SDWORD xerror0, xerror1, yerror0, yerror1;
 	RECT r_intersect;
 	IMAGE_BOX IB0, IB1;
 	BOOLEAN check0, check1;
@@ -109,56 +109,56 @@ frame_intersect (INTERSECT_CONTROL *pCon
 	}
 	else
 	{
-		SIZE delta;
-		COUNT start;
+		SDWORD delta;
+		DWORD start;
 		long error;
 
-		start = (COUNT)cycle0 * (COUNT)(t0 - 1);
+		start = (DWORD)cycle0 * (DWORD)(t0 - 1);
 		time_error0 = start & ((1 << TIME_SHIFT) - 1);
-		if ((start >>= (COUNT)TIME_SHIFT) > 0)
+		if ((start >>= (DWORD)TIME_SHIFT) > 0)
 		{
 			if ((error = (long)xerror0
 					- (long)dx_0 * (long)start) > 0)
-				xerror0 = (SIZE)error;
+				xerror0 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle0) + 1;
+				delta = -(SDWORD)(error / (long)cycle0) + 1;
 				IB0.Box.corner.x += xincr0 * delta;
-				xerror0 = (SIZE)(error + (long)cycle0 * (long)delta);
+				xerror0 = (SDWORD)(error + (long)cycle0 * (long)delta);
 			}
 			if ((error = (long)yerror0
 					- (long)dy_0 * (long)start) > 0)
-				yerror0 = (SIZE)error;
+				yerror0 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle0) + 1;
+				delta = -(SDWORD)(error / (long)cycle0) + 1;
 				IB0.Box.corner.y += yincr0 * delta;
-				yerror0 = (SIZE)(error + (long)cycle0 * (long)delta);
+				yerror0 = (SDWORD)(error + (long)cycle0 * (long)delta);
 			}
 			pr0->corner = IB0.Box.corner;
 		}
 	
-		start = (COUNT)cycle1 * (COUNT)(t0 - 1);
+		start = (DWORD)cycle1 * (DWORD)(t0 - 1);
 		time_error1 = start & ((1 << TIME_SHIFT) - 1);
-		if ((start >>= (COUNT)TIME_SHIFT) > 0)
+		if ((start >>= (DWORD)TIME_SHIFT) > 0)
 		{
 			if ((error = (long)xerror1
 					- (long)dx_1 * (long)start) > 0)
-				xerror1 = (SIZE)error;
+				xerror1 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle1) + 1;
+				delta = -(SDWORD)(error / (long)cycle1) + 1;
 				IB1.Box.corner.x += xincr1 * delta;
-				xerror1 = (SIZE)(error + (long)cycle1 * (long)delta);
+				xerror1 = (SDWORD)(error + (long)cycle1 * (long)delta);
 			}
 			if ((error = (long)yerror1
 					- (long)dy_1 * (long)start) > 0)
-				yerror1 = (SIZE)error;
+				yerror1 = (SDWORD)error;
 			else
 			{
-				delta = -(SIZE)(error / (long)cycle1) + 1;
+				delta = -(SDWORD)(error / (long)cycle1) + 1;
 				IB1.Box.corner.y += yincr1 * delta;
-				yerror1 = (SIZE)(error + (long)cycle1 * (long)delta);
+				yerror1 = (SDWORD)(error + (long)cycle1 * (long)delta);
 			}
 			pr1->corner = IB1.Box.corner;
 		}
@@ -237,8 +237,8 @@ TIME_VALUE
 DrawablesIntersect (INTERSECT_CONTROL *pControl0,
 		INTERSECT_CONTROL *pControl1, TIME_VALUE max_time_val)
 {
-	SIZE dy;
-	SIZE time_y_0, time_y_1;
+	SDWORD dy;
+	SDWORD time_y_0, time_y_1;
 	RECT r0, r1;
 	FRAME FramePtr0, FramePtr1;
 
@@ -278,8 +278,8 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 			|| (time_y_0 > 0 && dy >= time_y_0)
 			|| (time_y_1 < 0 && dy <= time_y_1))
 	{
-		SIZE dx;
-		SIZE time_x_0, time_x_1;
+		SDWORD dx;
+		SDWORD time_x_0, time_x_1;
 
 		dx = r1.corner.x - r0.corner.x;
 		time_x_0 = dx - GetFrameWidth (FramePtr0) + 1;
@@ -296,7 +296,7 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 				time_y_0 = time_y_1 = 0;
 			else
 			{
-				SIZE t;
+				SDWORD t;
 				long time_beg, time_end, fract;
 
 				if (time_y_1 < 0)
@@ -379,14 +379,14 @@ DrawablesIntersect (INTERSECT_CONTROL *p
 				if ((time_beg <<= TIME_SHIFT) < fract)
 					time_y_0 = 0;
 				else
-					time_y_0 = (SIZE)(time_beg / fract);
+					time_y_0 = (SDWORD)(time_beg / fract);
 
 				if (time_end >= fract /* just in case of overflow */
 						|| (time_end <<= TIME_SHIFT) >=
 						fract * (long)max_time_val)
 					time_y_1 = max_time_val - 1;
 				else
-					time_y_1 = (SIZE)((time_end + fract - 1) / fract) - 1;
+					time_y_1 = (SDWORD)((time_end + fract - 1) / fract) - 1;
 			}
 
 #ifdef DEBUG_INTERSEC
diff -ruNp src.orig/libs/graphics/sdl/canvas.c src/libs/graphics/sdl/canvas.c
--- src.orig/libs/graphics/sdl/canvas.c	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/sdl/canvas.c	2017-12-30 00:14:50 -0800
@@ -2119,7 +2119,7 @@ TFB_DrawCanvas_TransferIndexes (TFB_Canv
 	if (!TFB_DrawCanvas_IsPaletted (canvas) || fmt->BitsPerPixel != 8)
 	{
 		log_add (log_Warning, "ERROR: TFB_DrawCanvas_TransferIndexes "
-				"unimplemeted function: not an 8bpp indexed canvas");
+				"unimplemeted function: not an 8bpp indexed canvas", fmt->BitsPerPixel);
 		return FALSE;
 	}
 
diff -ruNp src.orig/libs/graphics/sdl/opengl.c src/libs/graphics/sdl/opengl.c
--- src.orig/libs/graphics/sdl/opengl.c	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/sdl/opengl.c	2017-12-30 00:14:50 -0800
@@ -24,6 +24,7 @@
 #include "options.h"
 #include "libs/log.h"
 
+
 typedef struct _gl_screeninfo {
 	SDL_Surface *scaled;
 	GLuint texture;
@@ -54,6 +55,8 @@ static void TFB_GL_Preprocess (int force
 static void TFB_GL_Postprocess (void);
 static void TFB_GL_Scaled_ScreenLayer (SCREEN screen, Uint8 a, SDL_Rect *rect);
 static void TFB_GL_Unscaled_ScreenLayer (SCREEN screen, Uint8 a, SDL_Rect *rect);
+static void TFB_GL_Unscaled_ScreenLayer_2x (SCREEN screen, Uint8 a, SDL_Rect *rect);
+static void TFB_GL_Unscaled_ScreenLayer_4x (SCREEN screen, Uint8 a, SDL_Rect *rect);
 static void TFB_GL_ColorLayer (Uint8 r, Uint8 g, Uint8 b, Uint8 a, SDL_Rect *rect);
 
 static TFB_GRAPHICS_BACKEND opengl_scaled_backend = {
@@ -68,9 +71,21 @@ static TFB_GRAPHICS_BACKEND opengl_unsca
 	TFB_GL_Unscaled_ScreenLayer,
 	TFB_GL_ColorLayer };
 
+static TFB_GRAPHICS_BACKEND opengl_unscaled_backend_2x = {
+	TFB_GL_Preprocess,
+	TFB_GL_Postprocess,
+	TFB_GL_Unscaled_ScreenLayer_2x,
+	TFB_GL_ColorLayer };
+
+static TFB_GRAPHICS_BACKEND opengl_unscaled_backend_4x = {
+	TFB_GL_Preprocess,
+	TFB_GL_Postprocess,
+	TFB_GL_Unscaled_ScreenLayer_4x,
+	TFB_GL_ColorLayer };
+
 
 static int
-AttemptColorDepth (int flags, int width, int height, int bpp)
+AttemptColorDepth (int flags, int width, int height, int bpp, unsigned int resFactor)
 {
 	int videomode_flags;
 	ScreenColorDepth = bpp;
@@ -113,6 +128,17 @@ AttemptColorDepth (int flags, int width,
 		videomode_flags |= SDL_FULLSCREEN;
 	videomode_flags |= SDL_ANYFORMAT;
 
+	if (resFactor > 0 && flags & TFB_GFXFLAGS_FULLSCREEN)
+	{
+		height = fs_height;
+		width  = fs_width;
+			
+		log_add (log_Debug,"X:%d y:%d", width, height);
+	}
+	
+	ScreenWidthActual = width;
+	ScreenHeightActual = height;
+
 	SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, 
 		bpp, videomode_flags);
 	if (SDL_Video == NULL)
@@ -120,31 +146,47 @@ AttemptColorDepth (int flags, int width,
 		log_add (log_Error, "Couldn't set OpenGL %ix%ix%i video mode: %s",
 				ScreenWidthActual, ScreenHeightActual, bpp,
 				SDL_GetError ());
+
+		if (flags & TFB_GFXFLAGS_FULLSCREEN)
+		{
+			videomode_flags &= ~SDL_FULLSCREEN;
+			log_add (log_Error, "Falling back to windowed mode!!");
+			SDL_Video = SDL_SetVideoMode (ScreenWidthActual, ScreenHeightActual, bpp, videomode_flags);
+			
+			if (SDL_Video != NULL)
+				goto successful_change;
+		}
+
 		return -1;
 	}
 	else
 	{
+		successful_change:
 		log_add (log_Info, "Set the resolution to: %ix%ix%i"
-				" (surface reports %ix%ix%i)",
+				" (surface reports %ix%ix%i) (res_cat %u)",
 				width, height, bpp,			 
 				SDL_GetVideoSurface()->w, SDL_GetVideoSurface()->h,
-				SDL_GetVideoSurface()->format->BitsPerPixel);
+				SDL_GetVideoSurface()->format->BitsPerPixel, resFactor);
 
 		log_add (log_Info, "OpenGL renderer: %s version: %s",
 				glGetString (GL_RENDERER), glGetString (GL_VERSION));
+
+		// JMS: Now, this makes the game center horizontally
+		// between the black bars on the sides.
+		ScreenWidthActual = SDL_GetVideoSurface()->w;
 	}
 	return 0;
 }
 
 int
-TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen)
+TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resFactor)
 {
 	int i, texture_width, texture_height;
 	GraphicsDriver = driver;
 
-	if (AttemptColorDepth (flags, width, height, 32) &&
-			AttemptColorDepth (flags, width, height, 24) &&
-			AttemptColorDepth (flags, width, height, 16))
+	if (AttemptColorDepth (flags, width, height, 32, resFactor) &&
+			AttemptColorDepth (flags, width, height, 24, resFactor) &&
+			AttemptColorDepth (flags, width, height, 16, resFactor))
 	{
 		log_add (log_Error, "Couldn't set any OpenGL %ix%i video mode!",
 			 width, height);
@@ -209,11 +251,26 @@ TFB_GL_ConfigureVideo (int driver, int f
 	}
 	else
 	{
-		texture_width = 512;
-		texture_height = 256;
+		if (resFactor == 0)
+		{
+			texture_width = 512;
+			texture_height = 256;
+			graphics_backend = &opengl_unscaled_backend;
+		}
+		else if (resFactor == 1)
+		{
+			texture_width = 1024;
+			texture_height = 512;
+			graphics_backend = &opengl_unscaled_backend_2x;
+		}
+		else if (resFactor == 2)
+		{
+			texture_width = 2048;
+			texture_height = 1024;
+			graphics_backend = &opengl_unscaled_backend_4x;
+		}
 
 		scaler = NULL;
-		graphics_backend = &opengl_unscaled_backend;
 	}
 
 
@@ -247,7 +304,7 @@ TFB_GL_ConfigureVideo (int driver, int f
 }
 
 int
-TFB_GL_InitGraphics (int driver, int flags, int width, int height)
+TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resFactor)
 {
 	char VideoName[256];
 
@@ -258,10 +315,10 @@ TFB_GL_InitGraphics (int driver, int fla
 	log_add (log_Info, "SDL initialized.");
 	log_add (log_Info, "Initializing Screen.");
 
-	ScreenWidth = 320;
-	ScreenHeight = 240;
+	ScreenWidth = (320 << resFactor); // JMS_GFX
+	ScreenHeight = (240 << resFactor); // JMS_GFX
 
-	if (TFB_GL_ConfigureVideo (driver, flags, width, height, 0))
+	if (TFB_GL_ConfigureVideo (driver, flags, width, height, 0, resFactor))
 	{
 		log_add (log_Fatal, "Could not initialize video: "
 				"no fallback at start of program!");
@@ -300,7 +357,8 @@ TFB_GL_ScanLines (void)
 	glDisable (GL_TEXTURE_2D);
 	glEnable (GL_BLEND);
 	glBlendFunc (GL_DST_COLOR, GL_ZERO);
-	glColor3f (0.85f, 0.85f, 0.85f);
+	// glColor3f (0.85f, 0.85f, 0.85f);
+	glColor3f (0.4f, 0.4f, 0.4f); // Darkened scanlines
 	for (y = 0; y < ScreenHeightActual; y += 2)
 	{
 		glBegin (GL_LINES);
@@ -310,7 +368,7 @@ TFB_GL_ScanLines (void)
 	}
 
 	glBlendFunc (GL_DST_COLOR, GL_ONE);
-	glColor3f (0.2f, 0.2f, 0.2f);
+	glColor3f (0.3f, 0.3f, 0.3f);
 	for (y = 1; y < ScreenHeightActual; y += 2)
 	{
 		glBegin (GL_LINES);
@@ -404,6 +462,172 @@ TFB_GL_DrawQuad (SDL_Rect *r)
 }
 
 static void
+TFB_GL_DrawQuad_2x (SDL_Rect *r)
+{
+	BOOLEAN keep_aspect_ratio = optKeepAspectRatio;
+	int x1 = 0, y1 = 0, x2 = ScreenWidthActual, y2 = ScreenHeightActual;
+	int sx = 0, sy = 0;
+	int sw, sh;
+	float sx_multiplier = 1;
+	float sy_multiplier = 1;
+	
+	if (keep_aspect_ratio)
+	{
+		float threshold = 0.75f;
+		float ratio = ScreenHeightActual / (float)ScreenWidthActual;
+		
+		if (ratio > threshold)
+		{
+			// screen is narrower than 4:3
+			int height = (int)(ScreenWidthActual * threshold);
+			y1 = (ScreenHeightActual - height) / 2;
+			y2 = ScreenHeightActual - y1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+				sy_multiplier = height / (float)ScreenHeight;
+				sx = (int)(r->x * sx_multiplier);
+				sy = (int)(((ScreenHeight - (r->y + r->h)) * sy_multiplier) + y1);
+			}
+		}
+		else if (ratio < threshold)
+		{
+			// screen is wider than 4:3
+			int width = (int)(ScreenHeightActual / threshold);
+			x1 = (ScreenWidthActual - width) / 2;
+			x2 = ScreenWidthActual - x1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = width / (float)ScreenWidth;
+				sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+				sx = (int)((r->x * sx_multiplier) + x1);
+				sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+			}
+		}
+		else
+		{
+			// screen is 4:3
+			keep_aspect_ratio = 0;
+		}
+	}
+	
+	if (r != NULL)
+	{
+		if (!keep_aspect_ratio)
+		{
+			sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+			sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+			sx = (int)(r->x * sx_multiplier);
+			sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+		}
+		sw = (int)(r->w * sx_multiplier);
+		sh = (int)(r->h * sy_multiplier);
+		glScissor (sx, sy, sw, sh);
+		glEnable (GL_SCISSOR_TEST);
+	}
+	
+	glBegin (GL_TRIANGLE_FAN);
+	glTexCoord2f (0, 0);
+	glVertex2i (x1, y1);
+	glTexCoord2f (ScreenWidth / 1024.0f, 0);
+	glVertex2i (x2, y1);	
+	glTexCoord2f (ScreenWidth / 1024.0f, ScreenHeight / 512.0f);
+	glVertex2i (x2, y2);
+	glTexCoord2f (0, ScreenHeight / 512.0f);
+	glVertex2i (x1, y2);
+	glEnd ();
+	if (r != NULL)
+	{
+		glDisable (GL_SCISSOR_TEST);
+	}
+}
+
+static void
+TFB_GL_DrawQuad_4x (SDL_Rect *r)
+{
+	BOOLEAN keep_aspect_ratio = optKeepAspectRatio;
+	int x1 = 0, y1 = 0, x2 = ScreenWidthActual, y2 = ScreenHeightActual;
+	int sx = 0, sy = 0;
+	int sw, sh;
+	float sx_multiplier = 1;
+	float sy_multiplier = 1;
+	
+	if (keep_aspect_ratio)
+	{
+		float threshold = 0.75f;
+		float ratio = ScreenHeightActual / (float)ScreenWidthActual;
+		
+		if (ratio > threshold)
+		{
+			// screen is narrower than 4:3
+			int height = (int)(ScreenWidthActual * threshold);
+			y1 = (ScreenHeightActual - height) / 2;
+			y2 = ScreenHeightActual - y1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+				sy_multiplier = height / (float)ScreenHeight;
+				sx = (int)(r->x * sx_multiplier);
+				sy = (int)(((ScreenHeight - (r->y + r->h)) * sy_multiplier) + y1);
+			}
+		}
+		else if (ratio < threshold)
+		{
+			// screen is wider than 4:3
+			int width = (int)(ScreenHeightActual / threshold);
+			x1 = (ScreenWidthActual - width) / 2;
+			x2 = ScreenWidthActual - x1;
+			
+			if (r != NULL)
+			{
+				sx_multiplier = width / (float)ScreenWidth;
+				sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+				sx = (int)((r->x * sx_multiplier) + x1);
+				sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+			}
+		}
+		else
+		{
+			// screen is 4:3
+			keep_aspect_ratio = 0;
+		}
+	}
+	
+	if (r != NULL)
+	{
+		if (!keep_aspect_ratio)
+		{
+			sx_multiplier = ScreenWidthActual / (float)ScreenWidth;
+			sy_multiplier = ScreenHeightActual / (float)ScreenHeight;
+			sx = (int)(r->x * sx_multiplier);
+			sy = (int)((ScreenHeight - (r->y + r->h)) * sy_multiplier);
+		}
+		sw = (int)(r->w * sx_multiplier);
+		sh = (int)(r->h * sy_multiplier);
+		glScissor (sx, sy, sw, sh);
+		glEnable (GL_SCISSOR_TEST);
+	}
+	
+	glBegin (GL_TRIANGLE_FAN);
+	glTexCoord2f (0, 0);
+	glVertex2i (x1, y1);
+	glTexCoord2f (ScreenWidth / 2048.0f, 0);
+	glVertex2i (x2, y1);	
+	glTexCoord2f (ScreenWidth / 2048.0f, ScreenHeight / 1024.0f);
+	glVertex2i (x2, y2);
+	glTexCoord2f (0, ScreenHeight / 1024.0f);
+	glVertex2i (x1, y2);
+	glEnd ();
+	if (r != NULL)
+	{
+		glDisable (GL_SCISSOR_TEST);
+	}
+}
+
+static void
 TFB_GL_Preprocess (int force_full_redraw, int transition_amount, int fade_amount)
 {
 	glMatrixMode (GL_PROJECTION);
@@ -483,6 +707,100 @@ TFB_GL_Unscaled_ScreenLayer (SCREEN scre
 }
 
 static void
+TFB_GL_Unscaled_ScreenLayer_2x (SCREEN screen, Uint8 a, SDL_Rect *rect)
+{
+	glBindTexture (GL_TEXTURE_2D, GL_Screens[screen].texture);
+	glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+	
+	if (GL_Screens[screen].dirty)
+	{
+		int PitchWords = SDL_Screens[screen]->pitch / 4;
+		glPixelStorei (GL_UNPACK_ROW_LENGTH, PitchWords);
+		/* Matrox OpenGL drivers do not handle GL_UNPACK_SKIP_*
+		 correctly */
+		glPixelStorei (GL_UNPACK_SKIP_ROWS, 0);
+		glPixelStorei (GL_UNPACK_SKIP_PIXELS, 0);
+		SDL_LockSurface (SDL_Screens[screen]);
+		glTexSubImage2D (GL_TEXTURE_2D, 0, GL_Screens[screen].updated.x, 
+						 GL_Screens[screen].updated.y,
+						 GL_Screens[screen].updated.w, 
+						 GL_Screens[screen].updated.h,
+						 GL_RGBA, GL_UNSIGNED_BYTE,
+						 (Uint32 *)SDL_Screens[screen]->pixels +
+						 (GL_Screens[screen].updated.y * PitchWords + 
+						  GL_Screens[screen].updated.x));
+		SDL_UnlockSurface (SDL_Screens[screen]);
+		GL_Screens[screen].dirty = FALSE;
+	}
+	
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, ScreenFilterMode);
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, ScreenFilterMode);
+	glEnable (GL_TEXTURE_2D);
+	
+	if (a == 255)
+	{
+		glDisable (GL_BLEND);
+		glColor4f (1, 1, 1, 1);
+	}
+	else
+	{
+		float a_f = a / 255.0f;
+		glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+		glEnable (GL_BLEND);
+		glColor4f (1, 1, 1, a_f);
+	}
+	
+	TFB_GL_DrawQuad_2x (rect);
+}
+
+static void
+TFB_GL_Unscaled_ScreenLayer_4x (SCREEN screen, Uint8 a, SDL_Rect *rect)
+{
+	glBindTexture (GL_TEXTURE_2D, GL_Screens[screen].texture);
+	glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+	
+	if (GL_Screens[screen].dirty)
+	{
+		int PitchWords = SDL_Screens[screen]->pitch / 4;
+		glPixelStorei (GL_UNPACK_ROW_LENGTH, PitchWords);
+		/* Matrox OpenGL drivers do not handle GL_UNPACK_SKIP_*
+		 correctly */
+		glPixelStorei (GL_UNPACK_SKIP_ROWS, 0);
+		glPixelStorei (GL_UNPACK_SKIP_PIXELS, 0);
+		SDL_LockSurface (SDL_Screens[screen]);
+		glTexSubImage2D (GL_TEXTURE_2D, 0, GL_Screens[screen].updated.x, 
+						 GL_Screens[screen].updated.y,
+						 GL_Screens[screen].updated.w, 
+						 GL_Screens[screen].updated.h,
+						 GL_RGBA, GL_UNSIGNED_BYTE,
+						 (Uint32 *)SDL_Screens[screen]->pixels +
+						 (GL_Screens[screen].updated.y * PitchWords + 
+						  GL_Screens[screen].updated.x));
+		SDL_UnlockSurface (SDL_Screens[screen]);
+		GL_Screens[screen].dirty = FALSE;
+	}
+	
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, ScreenFilterMode);
+	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, ScreenFilterMode);
+	glEnable (GL_TEXTURE_2D);
+	
+	if (a == 255)
+	{
+		glDisable (GL_BLEND);
+		glColor4f (1, 1, 1, 1);
+	}
+	else
+	{
+		float a_f = a / 255.0f;
+		glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+		glEnable (GL_BLEND);
+		glColor4f (1, 1, 1, a_f);
+	}
+	
+	TFB_GL_DrawQuad_4x (rect);
+}
+
+static void
 TFB_GL_Scaled_ScreenLayer (SCREEN screen, Uint8 a, SDL_Rect *rect)
 {
 	glBindTexture (GL_TEXTURE_2D, GL_Screens[screen].texture);
diff -ruNp src.orig/libs/graphics/sdl/opengl.h src/libs/graphics/sdl/opengl.h
--- src.orig/libs/graphics/sdl/opengl.h	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/sdl/opengl.h	2017-12-30 00:14:50 -0800
@@ -21,9 +21,9 @@
 
 #include "libs/graphics/sdl/sdl_common.h"
 
-int TFB_GL_InitGraphics (int driver, int flags, int width, int height);
+int TFB_GL_InitGraphics (int driver, int flags, int width, int height, unsigned int resFactor);
 void TFB_GL_UninitGraphics (void);
-int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
+int TFB_GL_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resFactor);
 void TFB_GL_UploadTransitionScreen (void);
 
 #ifdef HAVE_OPENGL
diff -ruNp src.orig/libs/graphics/sdl/pure.c src/libs/graphics/sdl/pure.c
--- src.orig/libs/graphics/sdl/pure.c	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/sdl/pure.c	2017-12-30 00:14:50 -0800
@@ -100,7 +100,7 @@ CalcAlphaFormat (const SDL_PixelFormat*
 }
 
 int
-TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen)
+TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resFactor)
 {
 	int i, videomode_flags;
 	SDL_PixelFormat conv_fmt;
@@ -119,13 +119,30 @@ TFB_Pure_ConfigureVideo (int driver, int
 	else
 	{
 		videomode_flags = SDL_SWSURFACE;
-		ScreenWidthActual = 640;
-		ScreenHeightActual = 480;
-		graphics_backend = &pure_scaled_backend;
-
-		if (width != 640 || height != 480)
-			log_add (log_Error, "Screen resolution of %dx%d not supported "
-					"under pure SDL, using 640x480", width, height);
+		
+		// JMS_GFX: Resolution is calculated with the help of a Resolution factor.
+		if (resFactor == 0)
+		{
+			// Check the sanity of resolution.
+			if (width != 640 || height != 480)
+			{
+				log_add (log_Error, "Screen resolution of %dx%d not supported "
+						 "under pure SDL, using 640x480", width, height);
+			
+				width = 640;
+				height = 480;
+			}
+			
+			ScreenWidthActual  = width;
+			ScreenHeightActual = height;
+			graphics_backend = &pure_scaled_backend;
+		}
+		else
+		{
+			ScreenWidthActual  = (320 << resFactor);
+			ScreenHeightActual = (240 << resFactor);
+			graphics_backend = &pure_unscaled_backend;
+		}
 	}
 
 	videomode_flags |= SDL_ANYFORMAT;
@@ -231,7 +248,7 @@ TFB_Pure_ConfigureVideo (int driver, int
 }
 
 int
-TFB_Pure_InitGraphics (int driver, int flags, int width, int height)
+TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resFactor)
 {
 	char VideoName[256];
 
@@ -247,10 +264,10 @@ TFB_Pure_InitGraphics (int driver, int f
 	log_add (log_Info, "SDL initialized.");
 	log_add (log_Info, "Initializing Screen.");
 
-	ScreenWidth = 320;
-	ScreenHeight = 240;
+	ScreenWidth = (320 << resFactor); // 320
+	ScreenHeight = (240 << resFactor); // 240
 
-	if (TFB_Pure_ConfigureVideo (driver, flags, width, height, 0))
+	if (TFB_Pure_ConfigureVideo (driver, flags, width, height, 0, resFactor))
 	{
 		log_add (log_Fatal, "Could not initialize video: "
 				"no fallback at start of program!");
diff -ruNp src.orig/libs/graphics/sdl/pure.h src/libs/graphics/sdl/pure.h
--- src.orig/libs/graphics/sdl/pure.h	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/sdl/pure.h	2017-12-30 00:14:50 -0800
@@ -21,9 +21,9 @@
 
 #include "libs/graphics/sdl/sdl_common.h"
 
-int TFB_Pure_InitGraphics (int driver, int flags, int width, int height);
+int TFB_Pure_InitGraphics (int driver, int flags, int width, int height, unsigned int resFactor);
 void TFB_Pure_UninitGraphics (void);
-int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen);
+int TFB_Pure_ConfigureVideo (int driver, int flags, int width, int height, int togglefullscreen, unsigned int resFactor);
 void Scale_PerfTest (void);
 
 #endif
diff -ruNp src.orig/libs/graphics/sdl/sdl_common.c src/libs/graphics/sdl/sdl_common.c
--- src.orig/libs/graphics/sdl/sdl_common.c	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/sdl/sdl_common.c	2017-12-30 00:14:50 -0800
@@ -43,6 +43,8 @@ SDL_Surface *SDL_Screens[TFB_GFX_NUMSCRE
 
 SDL_Surface *format_conv_surf = NULL;
 
+const SDL_VideoInfo *SDL_screen_info; // JMS_GFX
+
 static volatile BOOLEAN abortFlag = FALSE;
 
 int GfxFlags = 0;
@@ -89,7 +91,7 @@ TFB_PreQuit (void)
 }
 
 int
-TFB_ReInitGraphics (int driver, int flags, int width, int height)
+TFB_ReInitGraphics (int driver, int flags, int width, int height, unsigned int *resFactor) // JMS_GFX: Added resFactor
 {
 	int result;
 	int togglefullscreen = 0;
@@ -108,19 +110,19 @@ TFB_ReInitGraphics (int driver, int flag
 	{
 #ifdef HAVE_OPENGL
 		result = TFB_GL_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+				togglefullscreen, *resFactor);
 #else
 		driver = TFB_GFXDRIVER_SDL_PURE;
 		log_add (log_Warning, "OpenGL support not compiled in,"
 				" so using pure SDL driver");
 		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+				togglefullscreen, resFactor);
 #endif
 	}
 	else
 	{
 		result = TFB_Pure_ConfigureVideo (driver, flags, width, height,
-				togglefullscreen);
+				togglefullscreen, *resFactor);
 	}
 
 	sprintf (caption, "The Ur-Quan Masters v%d.%d.%d%s",
@@ -137,27 +139,67 @@ TFB_ReInitGraphics (int driver, int flag
 }
 
 int
-TFB_InitGraphics (int driver, int flags, int width, int height)
+TFB_InitGraphics (int driver, int flags, int width, int height, unsigned int *resFactor)
 {
-	int result;
+	int result, i;
 	char caption[200];
 
+	/* Null out screen pointers the first time */
+	for (i = 0; i < TFB_GFX_NUMSCREENS; i++)
+	{
+		SDL_Screens[i] = NULL;
+	}
+
 	GfxFlags = flags;
+	
+	// JMS_GFX: Let's read the size of the desktop so we can scale the
+	// fullscreen game according to it.
+	SDL_screen_info = SDL_GetVideoInfo ();
+	
+	// JMS_GFX: Upon starting the game, let's find out the resolution
+	// of the desktop.
+	if (fs_height == 0)
+	{
+		int curr_h = SDL_screen_info->current_h;
+		int curr_w = SDL_screen_info->current_w;
+		
+		// JMS_GFX: This makes it sure on certain HD 16:9 monitors
+		// that a bogus stretched 1600x1200 mode isn't used.
+		if ((curr_w == 1920 && curr_h == 1080) || (curr_h == (curr_w / 16) * 10)) { // MB: fix for 16:10 resolutions
+			fs_height = curr_h;
+			fs_width  = curr_w;
+		} else if (curr_h > (curr_w / 4) * 3) { // MB: for monitors using 5:4 modes
+			fs_width = curr_w;
+			fs_height = (curr_w / 4) * 3;
+		} else {
+			fs_height = curr_h;
+			fs_width  = (4 * fs_height) / 3;
+		}
+
+		// MB: Sanitising resolution factor:
+		if (fs_height <= 600 && *resFactor == 2) { // ie. probably netbook or otherwise
+			*resFactor = 1; // drop down to 640x480. netbook won't be able to handle anything higher and quality difference is minimal
+ 		} else if (fs_height <= 300 && resFactor > 0) { // People who like pixels I guess
+			*resFactor = 0; // drop down to 320x240
+		}
+		
+		log_add (log_Debug, "fs_height %u, fs_width %u, current_w %u", fs_height, fs_width, SDL_screen_info->current_w);
+	}
 
 	if (driver == TFB_GFXDRIVER_SDL_OPENGL)
 	{
 #ifdef HAVE_OPENGL
-		result = TFB_GL_InitGraphics (driver, flags, width, height);
+		result = TFB_GL_InitGraphics (driver, flags, width, height, *resFactor);
 #else
 		driver = TFB_GFXDRIVER_SDL_PURE;
 		log_add (log_Warning, "OpenGL support not compiled in,"
 				" so using pure SDL driver");
-		result = TFB_Pure_InitGraphics (driver, flags, width, height);
+		result = TFB_Pure_InitGraphics (driver, flags, width, height, *resFactor);
 #endif
 	}
 	else
 	{
-		result = TFB_Pure_InitGraphics (driver, flags, width, height);
+		result = TFB_Pure_InitGraphics (driver, flags, width, height, *resFactor);
 	}
 
 	sprintf (caption, "The Ur-Quan Masters v%d.%d.%d%s", 
diff -ruNp src.orig/libs/graphics/sdl/sdl_common.h src/libs/graphics/sdl/sdl_common.h
--- src.orig/libs/graphics/sdl/sdl_common.h	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/sdl/sdl_common.h	2017-12-30 00:14:50 -0800
@@ -46,6 +46,8 @@ extern SDL_Surface *SDL_Screens[TFB_GFX_
 
 extern SDL_Surface *format_conv_surf;
 
+extern const SDL_VideoInfo *SDL_screen_info; // JMS_GFX
+
 SDL_Surface* TFB_DisplayFormatAlpha (SDL_Surface *surface);
 
 SDL_Surface* Create_Screen (SDL_Surface *templat, int w, int h);
diff -ruNp src.orig/libs/graphics/tfb_draw.c src/libs/graphics/tfb_draw.c
--- src.orig/libs/graphics/tfb_draw.c	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/tfb_draw.c	2017-12-30 00:14:50 -0800
@@ -154,6 +154,28 @@ TFB_DrawScreen_Copy (const RECT *r, SCRE
 	TFB_EnqueueDrawCommand (&DC);
 }
 
+// JMS_GFX: This ensures the whole screen area is updated in screen transition.
+// Useful at least in hires when landing at planet and transitioning to planetside view.
+// (The planet is cut uglily in about half when using normal TFB_DrawScreen_Copy).
+void
+TFB_DrawScreen_Copy_Fs (RECT *r, SCREEN src, SCREEN dest)
+{
+	RECT locRect;
+	TFB_DrawCommand DC;
+	
+	locRect.corner.x = locRect.corner.y = 0;
+	locRect.extent.width = ScreenWidth;
+	locRect.extent.height = ScreenHeight;
+	r = &locRect;
+	
+	DC.Type = TFB_DRAWCOMMANDTYPE_COPY;
+	DC.data.copy.rect = locRect;
+	DC.data.copy.srcBuffer = src;
+	DC.data.copy.destBuffer = dest;
+	
+	TFB_EnqueueDrawCommand (&DC);
+}
+
 void
 TFB_DrawScreen_SetMipmap (TFB_Image *img, TFB_Image *mmimg, int hotx, int hoty)
 {
diff -ruNp src.orig/libs/graphics/tfb_draw.h src/libs/graphics/tfb_draw.h
--- src.orig/libs/graphics/tfb_draw.h	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/tfb_draw.h	2017-12-30 00:14:50 -0800
@@ -84,6 +84,7 @@ void TFB_DrawScreen_Rect (RECT *rect, Co
 void TFB_DrawScreen_Image (TFB_Image *img, int x, int y, int scale,
 		int scaleMode, TFB_ColorMap *, DrawMode, SCREEN dest);
 void TFB_DrawScreen_Copy (const RECT *r, SCREEN src, SCREEN dest);
+void TFB_DrawScreen_Copy_Fs (RECT *r, SCREEN src, SCREEN dest); // JMS_GFX
 void TFB_DrawScreen_FilledImage (TFB_Image *img, int x, int y, int scale,
 		int scaleMode, Color, DrawMode, SCREEN dest);
 void TFB_DrawScreen_FontChar (TFB_Char *, TFB_Image *backing, int x, int y,
diff -ruNp src.orig/libs/graphics/tfb_prim.c src/libs/graphics/tfb_prim.c
--- src.orig/libs/graphics/tfb_prim.c	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/tfb_prim.c	2017-12-30 00:14:50 -0800
@@ -27,6 +27,8 @@
 #include "tfb_prim.h"
 #include "cmap.h"
 #include "libs/log.h"
+#include "uqm/units.h"
+#include "uqm/planets/planets.h"
 
 void
 TFB_Prim_Point (POINT *p, Color color, DrawMode mode, POINT ctxOrigin)
diff -ruNp src.orig/libs/graphics/widgets.c src/libs/graphics/widgets.c
--- src.orig/libs/graphics/widgets.c	2017-12-30 00:14:37 -0800
+++ src/libs/graphics/widgets.c	2017-12-30 00:14:50 -0800
@@ -17,22 +17,27 @@
 #include "gfx_common.h"
 #include "widgets.h"
 #include "libs/strlib.h"
+#include "uqm/colors.h"
+#include "uqm/units.h"
 
 WIDGET *widget_focus = NULL;
 
 /* Some basic color defines */
 #define WIDGET_ACTIVE_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x00), 0x0E)
+		MENU_HIGHLIGHT_COLOR
 #define WIDGET_INACTIVE_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x18, 0x18, 0x1F), 0x00)
 #define WIDGET_INACTIVE_SELECTED_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), 0x0F)
+		WHITE_COLOR
 #define WIDGET_CURSOR_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00)
+		BLACK_COLOR
 #define WIDGET_DIALOG_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x07)
+		LTGRAY_COLOR
 #define WIDGET_DIALOG_TEXT_COLOR \
-		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x00), 0x00)
+		WIDGET_CURSOR_COLOR
+
+#define WIDGET_ENABLED_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x00, 0xC8, 0x00), 0x00)
 
 static Color win_bg_clr =
 		BUILD_COLOR (MAKE_RGB15_INIT (0x18, 0x18, 0x1F), 0x00);
@@ -98,7 +103,7 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 		oldfont = SetContextFont (cur_font);
 
 	/* Compute the dimensions of the label */
-	win_h = label->height ((WIDGET *)label) + 16;
+	win_h = label->height ((WIDGET *)label) + (16 << RESOLUTION_FACTOR);
 	win_w = 0;
 	for (i = 0; i < label->line_count; i++)
 	{
@@ -108,7 +113,7 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 			win_w = len;
 		}
 	}
-	win_w = (win_w * 6) + 16;
+	win_w = (win_w * (6 << RES_CASE(0,1,1))) + 16; // JMS_GFX
 
 	BatchGraphics ();
 	r.corner.x = (ScreenWidth - win_w) >> 1;
@@ -118,14 +123,14 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 	DrawShadowedBox (&r, win_bg_clr, win_dark_clr, win_medium_clr);
 
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + 16;
+	t.baseline.y = r.corner.y + (16 << RES_CASE(0,0,1)); // JMS_GFX
 	for (i = 0; i < label->line_count; i++)
 	{
 		t.pStr = label->lines[i];
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 8;
+		t.baseline.y += (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 
 	UnbatchGraphics ();
@@ -139,10 +144,10 @@ DrawLabelAsWindow (WIDGET_LABEL *label,
 		// Add the outer border added by DrawShadowedBox.
 		// XXX: It may be nicer to add a border size parameter to
 		// DrawShadowedBox, instead of assuming 2 here.
-		windowRect->corner.x = r.corner.x - 2;
-		windowRect->corner.y = r.corner.y - 2;
-		windowRect->extent.width = r.extent.width + 4;
-		windowRect->extent.height = r.extent.height + 4;
+		windowRect->corner.x = r.corner.x - 2 * (1 + RESOLUTION_FACTOR);
+		windowRect->corner.y = r.corner.y - 2 * (1 + RESOLUTION_FACTOR);
+		windowRect->extent.width = r.extent.width + 4 * (1 + RESOLUTION_FACTOR);
+		windowRect->extent.height = r.extent.height + 4 * (1 + RESOLUTION_FACTOR);
 	}
 }
 
@@ -165,31 +170,33 @@ Widget_SetFont (FONT newFont)
 static void
 Widget_DrawToolTips (int numlines, const char **tips)
 {
+	// This functions draws the text at the bottom of the screen
+	// which explains what the current option does.
 	RECT r;
 	FONT  oldfont = 0;
 	FRAME oldFontEffect = SetContextFontEffect (NULL);
-	Color oldtext = SetContextForeGroundColor (WIDGET_INACTIVE_SELECTED_COLOR);
+	Color oldtext = SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x00, 0x18, 0x00), 0x0E));
 	TEXT t;
 	int i;
 
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 
-	r.corner.x = 2;
-	r.corner.y = 2;
-	r.extent.width = ScreenWidth - 4;
-	r.extent.height = ScreenHeight - 4;
+	r.corner.x = 2 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = 2 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.width = ScreenWidth - (4 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.height = ScreenHeight + (2 << RESOLUTION_FACTOR); // JMS_GFX
 
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + (r.extent.height - 8 - 8 * numlines);
+	t.baseline.y = r.corner.y + (r.extent.height - (8 << RESOLUTION_FACTOR) - (8 << RESOLUTION_FACTOR) * numlines); // JMS_GFX
 
 	for (i = 0; i < numlines; i++)
 	{
 		t.pStr = tips[i];
 		font_DrawText(&t);
-		t.baseline.y += 8;
+		t.baseline.y += (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 
 	SetContextFontEffect (oldFontEffect);
@@ -214,10 +221,10 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 	
-	r.corner.x = 2;
-	r.corner.y = 2;
-	r.extent.width = ScreenWidth - 4;
-	r.extent.height = ScreenHeight - 4;
+	r.corner.x = (2 << RESOLUTION_FACTOR) + 2 * RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = (2 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.width = ScreenWidth - (4 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.height = ScreenHeight - (4 << RESOLUTION_FACTOR); // JMS_GFX
 	
 	title = WIDGET_INACTIVE_SELECTED_COLOR;
 	selected = WIDGET_ACTIVE_COLOR;
@@ -228,12 +235,12 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	
 	oldtext = SetContextForeGroundColor (title);
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + 8;
+	t.baseline.y = r.corner.y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	t.pStr = self->title;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
 	font_DrawText (&t);
-	t.baseline.y += 8;
+	t.baseline.y += 8 << RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = self->subtitle;
 	font_DrawText (&t);
 
@@ -242,17 +249,17 @@ Widget_DrawMenuScreen (WIDGET *_self, in
 	{
 		WIDGET *child = self->child[widget_index];
 		height += (*child->height)(child);
-		height += 8;  /* spacing */
+		height += 8 << RESOLUTION_FACTOR; // JMS_GFX  /* spacing */
 	}
 
-	height -= 8;
+	height -= 8 << RESOLUTION_FACTOR; // JMS_GFX
 
 	widget_y = (ScreenHeight - height) >> 1;
 	for (widget_index = 0; widget_index < self->num_children; widget_index++)
 	{
 		WIDGET *c = self->child[widget_index];
 		(*c->draw)(c, 0, widget_y);
-		widget_y += (*c->height)(c) + 8;
+		widget_y += (*c->height)(c) + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 	
 	SetContextFontEffect (oldFontEffect);
@@ -269,7 +276,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 {
 	WIDGET_CHOICE *self = (WIDGET_CHOICE *)_self;
 	Color oldtext;
-	Color inactive, default_color, selected;
+	Color default_color, selected, enabled, disabled;
 	FONT  oldfont = 0;
 	FRAME oldFontEffect = SetContextFontEffect (NULL);
 	TEXT t;
@@ -279,10 +286,11 @@ Widget_DrawChoice (WIDGET *_self, int x,
 		oldfont = SetContextFont (cur_font);
 	
 	default_color = WIDGET_INACTIVE_SELECTED_COLOR;
+	enabled = WIDGET_ENABLED_COLOR;
+	disabled = DKGRAY_COLOR;
 	selected = WIDGET_ACTIVE_COLOR;
-	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = x + RES_SCALE(16);
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -297,6 +305,8 @@ Widget_DrawChoice (WIDGET *_self, int x,
 	}
 	font_DrawText (&t);
 
+	t.baseline.x -= t.baseline.x;
+
 	home_x = t.baseline.x + 3 * (ScreenWidth / ((self->maxcolumns + 1) * 2));
 	home_y = t.baseline.y;
 	t.align = ALIGN_CENTER;
@@ -304,7 +314,7 @@ Widget_DrawChoice (WIDGET *_self, int x,
 	{
 		t.baseline.x = home_x + ((i % 3) *
 				(ScreenWidth / (self->maxcolumns + 1)));
-		t.baseline.y = home_y + (8 * (i / 3));
+		t.baseline.y = home_y + ((10 * (i / 3)) << RESOLUTION_FACTOR); // JMS_GFX // Was 8*(i/3): Changed for readability
 		t.pStr = self->options[i].optname;
 		if ((widget_focus == _self) &&
 		    (self->highlighted == i))
@@ -314,11 +324,11 @@ Widget_DrawChoice (WIDGET *_self, int x,
 		}
 		else if (i == self->selected)
 		{
-			SetContextForeGroundColor (default_color);
+			SetContextForeGroundColor (enabled);
 		}
 		else
 		{
-			SetContextForeGroundColor (inactive);
+			SetContextForeGroundColor (disabled);
 		}
 		font_DrawText (&t);
 	}
@@ -344,7 +354,7 @@ Widget_DrawButton (WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = 160;
+	t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -379,7 +389,7 @@ Widget_DrawLabel (WIDGET *_self, int x,
 	if (cur_font)
 		oldfont = SetContextFont (cur_font);
 	
-	t.baseline.x = 160;
+	t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -388,7 +398,7 @@ Widget_DrawLabel (WIDGET *_self, int x,
 	{
 		t.pStr = self->lines[i];
 		font_DrawText (&t);
-		t.baseline.y += 8;
+		t.baseline.y += (10 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 	SetContextFontEffect (oldFontEffect);
 	if (oldfont)
@@ -416,7 +426,7 @@ Widget_DrawSlider(WIDGET *_self, int x,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = x + RES_SCALE(16);
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -432,6 +442,8 @@ Widget_DrawSlider(WIDGET *_self, int x,
 	}
 	font_DrawText (&t);
 
+	t.baseline.x -= t.baseline.x;
+
 	r.corner.x = t.baseline.x + 3 * tick;
 	r.corner.y = t.baseline.y - 4;
 	r.extent.height = 2;
@@ -489,7 +501,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 
 	BatchGraphics ();
 
-	t.baseline.x = x;
+	t.baseline.x = x + RES_SCALE(16);
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -504,6 +516,8 @@ Widget_DrawTextEntry (WIDGET *_self, int
 	}
 	font_DrawText (&t);
 
+	t.baseline.x -= t.baseline.x;
+
 	/* Force string termination */
 	self->value[WIDGET_TEXTENTRY_WIDTH-1] = 0;
 
@@ -513,7 +527,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 
 	if (!(self->state & WTE_EDITING))
 	{	// normal or selected state
-		t.baseline.x = 160;
+		t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_CENTER;
 
 		if (widget_focus == _self)
@@ -535,7 +549,7 @@ Widget_DrawTextEntry (WIDGET *_self, int
 		RECT r;
 		SIZE leading;
 
-		t.baseline.x = 90;
+		t.baseline.x = 90 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_LEFT;
 
 		// calc background box dimensions
@@ -625,7 +639,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 	selected = WIDGET_ACTIVE_COLOR;
 	inactive = WIDGET_INACTIVE_COLOR;
 
-	t.baseline.x = x;
+	t.baseline.x = x + RES_SCALE(16);
 	t.baseline.y = y;
 	t.align = ALIGN_LEFT;
 	t.CharCount = ~0;
@@ -640,6 +654,8 @@ Widget_DrawControlEntry (WIDGET *_self,
 	}
 	font_DrawText (&t);
 
+	t.baseline.x -= t.baseline.x;
+
         // 3 * ScreenWidth / ((self->maxcolumns + 1) * 2)) as per CHOICE, but only two options.
 	home_x = t.baseline.x + (ScreenWidth / 2); 
 	home_y = t.baseline.y;
@@ -647,7 +663,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 	for (i = 0; i < 2; i++)
 	{
 		t.baseline.x = home_x + ((i % 3) * (ScreenWidth / 3));  // self->maxcolumns + 1 as per CHOICE.
-		t.baseline.y = home_y + (8 * (i / 3));
+		t.baseline.y = home_y + ((8 * (i / 3)) << RESOLUTION_FACTOR); // JMS_GFX;
 		t.pStr = self->controlname[i];
 		if (!t.pStr[0])
 		{
@@ -673,7 +689,7 @@ Widget_DrawControlEntry (WIDGET *_self,
 int
 Widget_HeightChoice (WIDGET *_self)
 {
-	return ((((WIDGET_CHOICE *)_self)->numopts + 2) / 3) * 8;
+	return ((((WIDGET_CHOICE *)_self)->numopts + 2) / 3) * (8 << RESOLUTION_FACTOR); // JMS_GFX;
 }
 
 int
@@ -687,14 +703,14 @@ int
 Widget_HeightOneLine (WIDGET *_self)
 {
 	(void)_self;
-	return 8;
+	return (8 << RESOLUTION_FACTOR); // JMS_GFX
 }
 
 int
 Widget_HeightLabel (WIDGET *_self)
 {
 	WIDGET_LABEL *self = (WIDGET_LABEL *)_self;
-	return self->line_count * 8;
+	return self->line_count * (8 << RESOLUTION_FACTOR);
 }
 
 int
diff -ruNp src.orig/libs/input/sdl/input.c src/libs/input/sdl/input.c
--- src.orig/libs/input/sdl/input.c	2017-12-30 00:14:37 -0800
+++ src/libs/input/sdl/input.c	2017-12-30 00:14:50 -0800
@@ -75,6 +75,10 @@ static const char *menu_res_names[] = {
 	"editcancel",
 	"search",
 	"next",
+	"togglemap", // JMS: For showing SC1-era starmap.
+	"debug_2", // JMS: Secondary debug key.
+	"debug_3", // JMS: Tertiary debug key.
+	"debug_4", // JMS: Quaternary debug key.
 	NULL
 };
 
@@ -250,11 +254,13 @@ initJoystick (void)
 int 
 TFB_InitInput (int driver, int flags)
 {
+	int signed_num_keys; // JMS: New variable to silence warnings
 	(void)driver;
 	(void)flags;
 
 	SDL_EnableUNICODE(1);
-	(void)SDL_GetKeyState (&num_keys);
+	(void)SDL_GetKeyState (&signed_num_keys);
+	num_keys = (unsigned int) signed_num_keys;
 	kbdstate = (int *)HMalloc (sizeof (int) * (num_keys + 1));
 	
 
diff -ruNp src.orig/libs/input/sdl/vcontrol.c src/libs/input/sdl/vcontrol.c
--- src.orig/libs/input/sdl/vcontrol.c	2017-12-30 00:14:37 -0800
+++ src/libs/input/sdl/vcontrol.c	2017-12-30 00:14:50 -0800
@@ -184,10 +184,12 @@ static void
 key_init (void)
 {
 	unsigned int i;
+	int signed_num_sdl_keys; // JMS: New variable to silence warnings
 	int num_keys; // Temp to match type of param for SDL_GetKeyState().
+
 	pool = allocate_key_chunk ();
-	(void)SDL_GetKeyState (&num_keys);
-	num_sdl_keys = num_keys;
+	(void)SDL_GetKeyState (&signed_num_sdl_keys); // JMS: was num_sdl_keys
+	num_sdl_keys = (unsigned int) signed_num_sdl_keys; // JMS: new line
 	bindings = (keybinding **) HMalloc (sizeof (keybinding *) * num_sdl_keys);
 	for (i = 0; i < num_sdl_keys; i++)
 		bindings[i] = NULL;
diff -ruNp src.orig/libs/network/wspiapiwrap.h src/libs/network/wspiapiwrap.h
--- src.orig/libs/network/wspiapiwrap.h	2017-12-30 00:14:38 -0800
+++ src/libs/network/wspiapiwrap.h	2017-12-30 00:14:51 -0800
@@ -19,7 +19,10 @@
 #ifndef _WSPIAPIWRAP_H
 #define _WSPIAPIWRAP_H
 
-// HACK. See wspiapiwrap.c
+/* ************
+   DC: This whole section commented out due to VSC compiling issues. Found here: http://forum.uqm.stack.nl/index.php?topic=4353.0
+
+   // HACK. See wspiapiwrap.c
 #	define getaddrinfo WspiapiGetAddrInfo
 #	define getnameinfo WspiapiGetNameInfo
 #	define freeaddrinfo WspiapiFreeAddrInfo
@@ -28,6 +31,8 @@ int WINAPI WspiapiGetAddrInfo(const char
 		const struct addrinfo *hints, struct addrinfo **res);
 int WINAPI WspiapiGetNameInfo (const struct sockaddr *sa, socklen_t salen,
 		char *host, size_t hostlen, char *serv, size_t servlen, int flags);
+*/
+#include <wspiapi.h>  //DC: replaced upper section with this part to (hopefully) compile.
 
 #endif  /* _WSPIAPIWRAP_H */
 
diff -ruNp src.orig/libs/uio/uiostream.c src/libs/uio/uiostream.c
--- src.orig/libs/uio/uiostream.c	2017-12-30 00:14:39 -0800
+++ src/libs/uio/uiostream.c	2017-12-30 00:14:51 -0800
@@ -269,6 +269,16 @@ uio_ungetc(int c, uio_Stream *stream) {
 //	return c;
 }
 
+// JMS: The datastream can be stepped back n bytes with this baby.
+int
+uio_backtrack(int rewinded_bytes, uio_Stream *stream) {
+	assert((stream->openFlags & O_ACCMODE) != O_WRONLY);
+
+	stream->operation = uio_StreamOperation_read;
+	stream->dataStart -= rewinded_bytes;
+	return rewinded_bytes;
+}
+
 // NB. POSIX allows errno to be set for vsprintf(), but does not require it:
 // "The value of errno may be set to nonzero by a library function call
 // whether or not there is an error, provided the use of errno is not
diff -ruNp src.orig/libs/uio/uiostream.h src/libs/uio/uiostream.h
--- src.orig/libs/uio/uiostream.h	2017-12-30 00:14:39 -0800
+++ src/libs/uio/uiostream.h	2017-12-30 00:14:51 -0800
@@ -36,6 +36,7 @@ char *uio_fgets(char *buf, int size, uio
 int uio_fgetc(uio_Stream *stream);
 #define uio_getc uio_fgetc
 int uio_ungetc(int c, uio_Stream *stream);
+int uio_backtrack(int rewinded_bytes, uio_Stream *stream); // JMS
 int uio_vfprintf(uio_Stream *stream, const char *format, va_list args);
 int uio_fprintf(uio_Stream *stream, const char *format, ...);
 int uio_fputc(int c, uio_Stream *stream);
diff -ruNp src.orig/libs/video/vidplayer.c src/libs/video/vidplayer.c
--- src.orig/libs/video/vidplayer.c	2017-12-30 00:14:39 -0800
+++ src/libs/video/vidplayer.c	2017-12-30 00:14:51 -0800
@@ -15,7 +15,7 @@
  */
 
 #include "vidplayer.h"
-
+#include "options.h"
 #include "vidintrn.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/graphics/tfb_draw.h"
@@ -232,10 +232,14 @@ TFB_PlayVideo (VIDEO_REF vid, uint32 x,
 		return false; // drawing outside visible
 
 	sr = dr;
-	sr.corner.x = -sr.corner.x;
-	sr.corner.y = -sr.corner.y;
-	if (!BoxIntersect (&clip_r, &sr, &sr))
-		return false; // drawing outside visible
+    // JMS_GFX: Added this if-clause around the following lines to make the
+    // 3DO videos work also in 1280x960. They're still small though.
+    if (resolutionFactor < 2) {
+        sr.corner.x = -sr.corner.x;
+        sr.corner.y = -sr.corner.y;
+        if (!BoxIntersect (&clip_r, &sr, &sr))
+            return false; // drawing outside visible
+    }
 
 	dr.corner.x += scrn_r.corner.x;
 	dr.corner.y += scrn_r.corner.y;
diff -ruNp src.orig/options.c src/options.c
--- src.orig/options.c	2017-12-30 00:14:39 -0800
+++ src/options.c	2017-12-30 00:14:51 -0800
@@ -52,6 +52,40 @@ int optSmoothScroll;
 int optMeleeScale;
 const char **optAddons;
 
+// JMS_GFX
+unsigned int loresBlowupScale;
+unsigned int resolutionFactor;
+BOOLEAN resFactorWasChanged;
+
+BOOLEAN optCheatMode; // JMS
+// Serosis
+BOOLEAN optGodMode;
+int timeDilationScale;
+BOOLEAN optBubbleWarp;
+BOOLEAN optUnlockShips;
+BOOLEAN optHeadStart;
+BOOLEAN optUnlockUpgrades;
+BOOLEAN optInfiniteRU;
+DWORD oldRU;
+BOOLEAN optSkipIntro;
+BOOLEAN optFMV;
+// JMS
+BOOLEAN optMainMenuMusic;
+BOOLEAN optNebulae;
+BOOLEAN optOrbitingPlanets;
+BOOLEAN optTexturedPlanets;
+// Nic
+int optDateFormat;
+// Serosis
+BOOLEAN optInfiniteFuel;
+DWORD loadFuel;
+BOOLEAN optThraddStory;
+BOOLEAN optPartialPickup;
+BOOLEAN optSubmenu;
+BOOLEAN optAddDevices;
+BOOLEAN optScalePlanets;
+BOOLEAN optSuperMelee;
+
 BOOLEAN opt3doMusic;
 BOOLEAN optRemixMusic;
 BOOLEAN optSpeech;
diff -ruNp src.orig/options.h src/options.h
--- src.orig/options.h	2017-12-30 00:14:39 -0800
+++ src/options.h	2017-12-30 00:14:51 -0800
@@ -42,6 +42,41 @@ extern int optWhichShield;
 extern int optSmoothScroll;
 extern int optMeleeScale;
 
+// JMS_GFX
+extern unsigned int loresBlowupScale;
+extern unsigned int resolutionFactor;
+extern BOOLEAN resFactorWasChanged;
+
+extern BOOLEAN optCheatMode; // JMS
+// Serosis
+extern BOOLEAN optGodMode;
+extern int timeDilationScale;
+extern BOOLEAN optBubbleWarp;
+extern BOOLEAN optRoseBud;
+extern BOOLEAN optUnlockShips;
+extern BOOLEAN optHeadStart;
+extern BOOLEAN optUnlockUpgrades;
+extern BOOLEAN optInfiniteRU;
+extern DWORD oldRU;
+extern BOOLEAN optSkipIntro;
+extern BOOLEAN optFMV;
+// JMS
+extern BOOLEAN optMainMenuMusic;
+extern BOOLEAN optNebulae;
+extern BOOLEAN optOrbitingPlanets;
+extern BOOLEAN optTexturedPlanets;
+// Nic
+extern int optDateFormat;
+// Serosis
+extern BOOLEAN optInfiniteFuel;
+extern DWORD loadFuel;
+extern BOOLEAN optThraddStory;
+extern BOOLEAN optPartialPickup;
+extern BOOLEAN optSubmenu;
+extern BOOLEAN optAddDevices;
+extern BOOLEAN optScalePlanets;
+extern BOOLEAN optSuperMelee;
+
 extern BOOLEAN opt3doMusic;
 extern BOOLEAN optRemixMusic;
 extern BOOLEAN optSpeech;
diff -ruNp src.orig/port.h src/port.h
--- src.orig/port.h	2017-12-30 00:14:39 -0800
+++ src/port.h	2017-12-30 00:14:51 -0800
@@ -177,7 +177,7 @@ typedef unsigned short mode_t;
 extern "C" {
 #endif
 int snprintf(char *str, size_t size, const char *format, ...);
-int vsnprintf(char *str, size_t size, const char *format, va_list args);
+// int vsnprintf(char *str, size_t size, const char *format, va_list args);
 #if defined(__cplusplus)
 }
 #endif
diff -ruNp src.orig/regex/regex_internal.h src/regex/regex_internal.h
--- src.orig/regex/regex_internal.h	2017-12-30 00:14:39 -0800
+++ src/regex/regex_internal.h	2017-12-30 00:14:51 -0800
@@ -80,7 +80,11 @@
 # define BE(expr, val) __builtin_expect (expr, val)
 #else
 # define BE(expr, val) (expr)
-# define inline
+#ifdef _MSC_VER
+	#define inline __inline
+#else
+	#define inline
+#endif
 #endif
 
 /* Number of bits in a byte.  */
diff -ruNp src.orig/res/UrQuanMasters.rc src/res/UrQuanMasters.rc
--- src.orig/res/UrQuanMasters.rc	2017-12-30 00:14:39 -0800
+++ src/res/UrQuanMasters.rc	2017-12-30 00:14:52 -0800
@@ -67,10 +67,10 @@ END
 
 // Icon with lowest ID value placed first to ensure application icon
 // remains consistent on all systems.
-SDL_app            ICON    PRELOAD DISCARDABLE "ur-quan-icon-alpha.ico"
+SDL_app            ICON    PRELOAD DISCARDABLE "kohr-ah1.ico"
 102                ICON    DISCARDABLE     "ur-quan-icon-std.ico"
 103                ICON    DISCARDABLE     "ur-quan1.ico"
 104                ICON    DISCARDABLE     "sis1.ico"
 105                ICON    DISCARDABLE     "ur-quan2.ico"
-106                ICON    DISCARDABLE     "kohr-ah1.ico"
+106                ICON    DISCARDABLE     "ur-quan-icon-alpha.ico"
 107                ICON    DISCARDABLE     "starcon2.ico"
diff -ruNp src.orig/res/darwin/Info.plist src/res/darwin/Info.plist
--- src.orig/res/darwin/Info.plist	2017-12-30 00:14:39 -0800
+++ src/res/darwin/Info.plist	2017-12-30 00:14:51 -0800
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 <plist version="1.0">
 <dict>
 	<key>CFBundleDevelopmentRegion</key>
 	<string>English</string>
 	<key>CFBundleExecutable</key>
-	<string>The Ur-Quan Masters</string>
+	<string>The Ur-Quan Masters MegaMod</string>
 	<key>CFBundleIconFile</key>
 	<string>The Ur-Quan Masters.icns</string>
 	<key>CFBundleInfoDictionaryVersion</key>
Files src.orig/res/darwin/The Ur-Quan Masters.icns and src/res/darwin/The Ur-Quan Masters.icns differ
Files src.orig/res/kohr-ah1.ico and src/res/kohr-ah1.ico differ
diff -ruNp src.orig/uqm/border.c src/uqm/border.c
--- src.orig/uqm/border.c	2017-12-30 00:14:39 -0800
+++ src/uqm/border.c	2017-12-30 00:14:52 -0800
@@ -52,29 +52,35 @@ DrawSISFrame (void)
 
 	BatchGraphics ();
 	{
+		// Middle grey rectangles around space window.
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+			//
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.extent.height = SIS_ORG_Y - 1;
 		DrawFilledRectangle (&r);
+			// Inside Left Border
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_ORG_X - 1;
 		r.extent.height = SIS_ORG_Y + SIS_SCREEN_HEIGHT + 1;
 		DrawFilledRectangle (&r);
+			// Bottom left of the border
 		r.corner.x = 0;
 		r.corner.y = r.extent.height;
 		r.extent.width = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.extent.height = SCREEN_HEIGHT - SIS_ORG_Y + SIS_SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
+			// Top right inside border
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH + 1;
 		r.corner.y = 0;
 		r.extent.width = SCREEN_WIDTH - r.corner.x;
 		r.extent.height = SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
-
+		
+		// Light and dark grey edges of the inner space window.
 		r.corner.x = SIS_ORG_X - 1;
 		r.corner.y = SIS_ORG_Y - 1;
 		r.extent.width = SIS_SCREEN_WIDTH + 2;
@@ -84,9 +90,9 @@ DrawSISFrame (void)
 				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
 				TRUE, BLACK_COLOR);
 
+		// The big Blue box in the upper edge of screen containing the star system name.
 		r.corner.y = 0;
 		r.extent.height = SIS_ORG_Y;
-
 		r.corner.x = SIS_ORG_X;
 		r.extent.width = SIS_MESSAGE_BOX_WIDTH;
 		DrawStarConBox (&r, 1,
@@ -94,6 +100,7 @@ DrawSISFrame (void)
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x01, 0x1C), 0x4E),
 				TRUE, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
 
+		// The smaller blue box.
 		r.extent.width = SIS_TITLE_BOX_WIDTH;
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH;
 		DrawStarConBox (&r, 1,
@@ -101,18 +108,23 @@ DrawSISFrame (void)
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x01, 0x1C), 0x4E),
 				TRUE, BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01));
 
+		// Black border between menu area and space window area
 		SetContextForeGroundColor (BLACK_COLOR);
 		r.corner.x = SAFE_X + SPACE_WIDTH - 1;
 		r.corner.y = 0;
 		r.extent.width = 1;
 		r.extent.height = SCREEN_HEIGHT;
 		DrawFilledRectangle (&r);
+		
+		// Bottom corners of the SIS gauges
 		r.corner.x = SAFE_X + SPACE_WIDTH;
-		r.corner.y = SAFE_Y + 139;
+		r.corner.y = SAFE_Y + RES_CASE(139, 282, 434); // JMS_GFX
 		DrawPoint (&r.corner);
-		r.corner.x = SCREEN_WIDTH - 1;
+		
+		r.corner.x = SCREEN_WIDTH - 1; // JMS_GFX
 		DrawPoint (&r.corner);
 
+		// Light grey border on the left side of big blue box.
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 		r.corner.y = 1;
@@ -120,73 +132,98 @@ DrawSISFrame (void)
 		r.extent.height = SAFE_Y + SIS_TITLE_HEIGHT;
 		r.corner.x = SIS_ORG_X - 1;
 		DrawFilledRectangle (&r);
+		
+		// The same for small blue box
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - 1;
 		DrawFilledRectangle (&r);
 
+		// Light grey horizontal line at the bottom of the screen, space window side
 		r.corner.x = 0;
 		r.corner.y = SCREEN_HEIGHT - 1;
 		r.extent.width = SAFE_X + SPACE_WIDTH - 1;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		
+		// Light grey vertical line at the right side of space window
 		r.corner.x = SAFE_X + SPACE_WIDTH - 2;
 		r.corner.y = 0;
 		r.extent.width = 1;
 		r.extent.height = SCREEN_HEIGHT - 1;
 		DrawFilledRectangle (&r);
+		
+		// Vertical line at the right side of the menu window, upper part
 		r.corner.x = SCREEN_WIDTH - 1;
 		r.corner.y = 0;
 		r.extent.width = 1;
-		r.extent.height = SAFE_Y + 139;
+		r.extent.height = SAFE_Y + RES_CASE(139, 282, 434); // JMS_GFX
 		DrawFilledRectangle (&r);
+		
+		// Horizontal line at the bottom of the screen, menu window side
 		r.corner.x = SAFE_X + SPACE_WIDTH;
 		r.corner.y = SCREEN_HEIGHT - 1;
 		r.extent.width = SCREEN_WIDTH - r.corner.x;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		
+		// Vertical line at the right side of the menu window, lower part
 		r.corner.x = SCREEN_WIDTH - 1;
-		r.corner.y = SAFE_Y + 140;
+		r.corner.y = SAFE_Y + RES_CASE(140, 283, 435);
 		r.extent.width = 1;
 		r.extent.height = (SCREEN_HEIGHT - 1) - r.corner.y;
 		DrawFilledRectangle (&r);
 
+		// Dark grey border around blue boxes.
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
-		r.corner.y = 1;
+		// Vertical line on the right side of the big blue box
+		r.corner.y = 1; // There was a reason this was supposed to be "1": Serosis
 		r.extent.width = 1;
 		r.extent.height = SAFE_Y + SIS_MESSAGE_HEIGHT;
 		r.corner.x = SIS_ORG_X + SIS_MESSAGE_BOX_WIDTH;
 		DrawFilledRectangle (&r);
+
+		// Vertical line on the right side of the small blue box
 		r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH;
 		++r.extent.height;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.y = 0;
 		r.extent.width = (SAFE_X + SPACE_WIDTH - 2) - r.corner.x;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		//
 		r.corner.x = 0;
 		r.extent.width = SIS_ORG_X - r.corner.x;
 		DrawFilledRectangle (&r);
+
+		// Horizontal line between boxes
 		r.corner.x = SIS_ORG_X + SIS_MESSAGE_BOX_WIDTH;
 		r.extent.width = SIS_SPACER_BOX_WIDTH;
 		DrawFilledRectangle (&r);
-
+		//
 		r.corner.x = 0;
 		r.corner.y = 1;
 		r.extent.width = 1;
 		r.extent.height = (SCREEN_HEIGHT - 1) - r.corner.y;
 		DrawFilledRectangle (&r);
+
+		// Dark verticle line accent for the top left of the right panel
 		r.corner.x = SAFE_X + SPACE_WIDTH;
 		r.corner.y = 0;
 		r.extent.width = 1;
-		r.extent.height = SAFE_Y + 139;
+		r.extent.height = SAFE_Y + RES_CASE(139, 282, 434); // JMS_GFX 
 		DrawFilledRectangle (&r);
+
+		// Horizontal line of the separator below the SIS gauges 
 		r.corner.x = SAFE_X + SPACE_WIDTH + 1;
-		r.corner.y = SAFE_Y + 139;
+		r.corner.y = SAFE_Y + RES_CASE(139, 282, 434); // JMS_GFX
 		r.extent.width = STATUS_WIDTH - 2;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+
+		// Dark verticle line accent for the bottom left of the right panel
 		r.corner.x = SAFE_X + SPACE_WIDTH;
-		r.corner.y = SAFE_Y + 140;
+		r.corner.y = SAFE_Y + RES_CASE(140, 283, 435); // JMS_GFX
 		r.extent.width = 1;
 		r.extent.height = SCREEN_HEIGHT - r.corner.y;
 		DrawFilledRectangle (&r);
diff -ruNp src.orig/uqm/build.c src/uqm/build.c
--- src.orig/uqm/build.c	2017-12-30 00:14:39 -0800
+++ src/uqm/build.c	2017-12-30 00:14:52 -0800
@@ -17,14 +17,14 @@
  */
 
 #include "build.h"
-
+#include "options.h"
 #include "races.h"
 #include "master.h"
 #include "sis.h"
 #include "setup.h"
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
-
+#include "planets/planets.h"
 #include <stdlib.h>
 
 
@@ -317,6 +317,30 @@ SetRaceAllied (RACE_ID race, BOOLEAN fla
 }
 
 /*
+ * Allows the building of ships regardless of alliance state
+ * flag == TRUE: Allow to build ship
+ * flag == FALSE: Normal, not allowed to build ships if not allied.
+ */
+BOOLEAN
+SetRaceAllowBuild (RACE_ID race) {
+	HFLEETINFO hFleet;
+	FLEET_INFO *FleetPtr;
+
+	hFleet = GetStarShipFromIndex (&GLOBAL (avail_race_q), race);
+	if (!hFleet)
+		return FALSE;
+
+	FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+
+	if (FleetPtr->allied_state != GOOD_GUY) {
+		FleetPtr->allied_state = CAN_BUILD;
+	}
+
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hFleet);
+	return TRUE;
+}
+
+/*
  * 	Make the sphere of influence for the specified race shown on the starmap
  * 	in the future.
  * 	Does nothing for races without a SoI, or for races which have an
@@ -685,3 +709,77 @@ SetEscortCrewComplement (RACE_ID which_s
 	return Index;
 }
 
+void
+loadGameCheats (void){
+	if(optInfiniteRU){
+		oldRU = GlobData.SIS_state.ResUnits;
+	} else {
+		oldRU = 0;
+	}
+	if(optInfiniteFuel){
+		loadFuel = GlobData.SIS_state.FuelOnBoard;
+		GLOBAL_SIS (FuelOnBoard) = GetFuelTankCapacity();
+	} else {
+		loadFuel = 0;
+	}
+	if (optUnlockShips){
+		SetRaceAllowBuild (ARILOU_SHIP);
+		SetRaceAllowBuild (CHMMR_SHIP);
+		SetRaceAllowBuild (ORZ_SHIP);
+		SetRaceAllowBuild (PKUNK_SHIP);
+		SetRaceAllowBuild (SHOFIXTI_SHIP);
+		SetRaceAllowBuild (SPATHI_SHIP);
+		SetRaceAllowBuild (SUPOX_SHIP);
+		SetRaceAllowBuild (THRADDASH_SHIP);
+		SetRaceAllowBuild (UTWIG_SHIP);
+		SetRaceAllowBuild (VUX_SHIP);
+		SetRaceAllowBuild (YEHAT_SHIP);
+		SetRaceAllowBuild (MELNORME_SHIP);
+		SetRaceAllowBuild (DRUUGE_SHIP);
+		SetRaceAllowBuild (ILWRATH_SHIP);
+		SetRaceAllowBuild (MYCON_SHIP);
+		SetRaceAllowBuild (SLYLANDRO_SHIP);
+		SetRaceAllowBuild (UMGAH_SHIP);
+		SetRaceAllowBuild (URQUAN_SHIP);
+		SetRaceAllowBuild (ZOQFOTPIK_SHIP);
+		SetRaceAllowBuild (SYREEN_SHIP);
+		SetRaceAllowBuild (BLACK_URQUAN_SHIP);
+	}
+	if (optUnlockUpgrades){
+		SET_GAME_STATE (IMPROVED_LANDER_SPEED, 1);
+		SET_GAME_STATE (IMPROVED_LANDER_CARGO, 1);
+		SET_GAME_STATE (IMPROVED_LANDER_SHOT, 1);
+		SET_GAME_STATE (LANDER_SHIELDS, (1 << EARTHQUAKE_DISASTER) | (1 << BIOLOGICAL_DISASTER) |
+			(1 << LIGHTNING_DISASTER) | (1 << LAVASPOT_DISASTER));				
+		GLOBAL (ModuleCost[ANTIMISSILE_DEFENSE]) = 4000 / MODULE_COST_SCALE;				
+		GLOBAL (ModuleCost[BLASTER_WEAPON]) = 4000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[HIGHEFF_FUELSYS]) = 1000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[TRACKING_SYSTEM]) = 5000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[CANNON_WEAPON]) = 6000 / MODULE_COST_SCALE;
+		GLOBAL (ModuleCost[SHIVA_FURNACE]) = 4000 / MODULE_COST_SCALE;
+		SET_GAME_STATE (MELNORME_TECH_STACK, 13);
+	}
+	if(optAddDevices){		
+		SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1);
+		SET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP, 1);
+		SET_GAME_STATE (GLOWING_ROD_ON_SHIP, 1);
+		SET_GAME_STATE (SUN_DEVICE_ON_SHIP, 1);
+		SET_GAME_STATE (UTWIG_BOMB_ON_SHIP, 1);
+		SET_GAME_STATE (ULTRON_CONDITION, 1);
+		SET_GAME_STATE (MAIDENS_ON_SHIP, 1);
+		SET_GAME_STATE (TALKING_PET_ON_SHIP, 1);
+		SET_GAME_STATE (AQUA_HELIX_ON_SHIP, 1);
+		SET_GAME_STATE (CLEAR_SPINDLE_ON_SHIP, 1);
+		SET_GAME_STATE (UMGAH_BROADCASTERS_ON_SHIP, 1);
+		SET_GAME_STATE (TAALO_PROTECTOR_ON_SHIP, 1);
+		SET_GAME_STATE (EGG_CASE0_ON_SHIP, 1);
+		SET_GAME_STATE (EGG_CASE1_ON_SHIP, 1);
+		SET_GAME_STATE (EGG_CASE2_ON_SHIP, 1);
+		SET_GAME_STATE (SYREEN_SHUTTLE_ON_SHIP, 1);
+		SET_GAME_STATE (VUX_BEAST_ON_SHIP, 1);
+		SET_GAME_STATE (PORTAL_SPAWNER_ON_SHIP, 1);
+		SET_GAME_STATE (BURV_BROADCASTERS_ON_SHIP, 1);
+		SET_GAME_STATE (DESTRUCT_CODE_ON_SHIP, 1);
+	}
+}
+
diff -ruNp src.orig/uqm/build.h src/uqm/build.h
--- src.orig/uqm/build.h	2017-12-30 00:14:39 -0800
+++ src/uqm/build.h	2017-12-30 00:14:52 -0800
@@ -49,7 +49,7 @@ extern SPECIES_ID ShipIdStrToIndex (cons
 extern RACE_ID RaceIdStrToIndex (const char *raceIdStr);
 extern COUNT AddEscortShips (RACE_ID race, SIZE count);
 extern COUNT CalculateEscortsWorth (void);
-//extern COUNT GetRaceKnownSize (RACE_ID race);
+extern BOOLEAN SetRaceAllowBuild (RACE_ID race);
 extern BOOLEAN SetRaceAllied (RACE_ID race, BOOLEAN flag);
 extern COUNT StartSphereTracking (RACE_ID race);
 extern BOOLEAN CheckSphereTracking (RACE_ID race);
@@ -64,6 +64,7 @@ extern COUNT RemoveEscortShips (RACE_ID
 extern RACE_DESC *load_ship (SPECIES_ID SpeciesID, BOOLEAN LoadBattleData);
 extern void free_ship (RACE_DESC *RaceDescPtr, BOOLEAN FreeIconData,
 		BOOLEAN FreeBattleData);
+extern void loadGameCheats (void);
 
 #if defined(__cplusplus)
 }
diff -ruNp src.orig/uqm/cleanup.c src/uqm/cleanup.c
--- src.orig/uqm/cleanup.c	2017-12-30 00:14:39 -0800
+++ src/uqm/cleanup.c	2017-12-30 00:14:52 -0800
@@ -66,9 +66,14 @@ UninitKernel (void)
 	DestroyFont (MicroFont);
 	DestroyStringTable (ReleaseStringTable (GameStrings));
 	DestroyDrawable (ReleaseDrawable (StatusFrame));
+	DestroyDrawable (ReleaseDrawable (SubmenuFrame)); // JMS
+	DestroyDrawable (ReleaseDrawable (ConstellationsFrame)); // JMS
+	DestroyDrawable (ReleaseDrawable (NebulaeFrame));	// JMS
+	DestroyDrawable (ReleaseDrawable (hyperspacesuns));	// JMS
 	DestroyDrawable (ReleaseDrawable (ActivityFrame));
 	DestroyFont (TinyFont);
 	DestroyFont (StarConFont);
+	DestroyFont (PlyrFont);
 
 	UninitQueue (&race_q[0]);
 	UninitQueue (&race_q[1]);
diff -ruNp src.orig/uqm/clock.c src/uqm/clock.c
--- src.orig/uqm/clock.c	2017-12-30 00:14:39 -0800
+++ src/uqm/clock.c	2017-12-30 00:14:52 -0800
@@ -28,6 +28,7 @@
 #include "libs/threadlib.h"
 #include "libs/log.h"
 #include "libs/misc.h"
+#include "options.h"
 
 // the running of the game-clock is based on game framerates
 // *not* on the system (or translated) timer
@@ -84,6 +85,38 @@ nextClockDay (void)
 	DrawStatusMessage (NULL);
 }
 
+// Computes how many days have passed since the game has begun
+float
+daysElapsed (void)
+{
+	float days = 0;
+	COUNT index;
+	
+	// Years
+	for (index = START_YEAR ; index < GLOBAL (GameClock.year_index) ; index++ ) {
+		days += 365;
+		if(IsLeapYear(index))
+			days++;
+	}
+
+	if (GLOBAL (GameClock.month_index) == 1) {
+		days = days - 31;
+	}
+	
+	// Months
+	for (index = 2 ; index < GLOBAL (GameClock.month_index) ; index++ ) {
+		days += DaysInMonth (index, GLOBAL (GameClock.year_index));
+	}
+	
+	// Days
+	days = days + GLOBAL (GameClock.day_index) - 17;
+
+	// Part of a day
+	days = days + (GLOBAL (GameClock.day_in_ticks) - GLOBAL (GameClock.tick_count)) / (float)GLOBAL (GameClock.day_in_ticks);
+
+	return days;
+}
+
 static void
 processClockDayEvents (void)
 {
@@ -175,6 +208,20 @@ SetGameClockRate (COUNT seconds_per_day)
 	SIZE new_day_in_ticks, new_tick_count;
 
 	new_day_in_ticks = (SIZE)(seconds_per_day * CLOCK_BASE_FRAMERATE);
+	switch (timeDilationScale){
+		case 1:
+			new_day_in_ticks = new_day_in_ticks * 6;
+			//printf("TD Slow\n");
+			break;
+		case 2:
+			new_day_in_ticks = new_day_in_ticks / 5;
+			//printf("TD Fast\n");
+			break;
+		case 0:
+		default:
+			//printf("TD Normal\n");
+			break;
+	}
 	if (GLOBAL (GameClock.day_in_ticks) == 0)
 		new_tick_count = new_day_in_ticks;
 	else if (GLOBAL (GameClock.tick_count) <= 0)
diff -ruNp src.orig/uqm/clock.h src/uqm/clock.h
--- src.orig/uqm/clock.h	2017-12-30 00:14:39 -0800
+++ src/uqm/clock.h	2017-12-30 00:14:52 -0800
@@ -82,6 +82,8 @@ typedef enum
 extern BOOLEAN InitGameClock (void);
 extern BOOLEAN UninitGameClock (void);
 
+extern float daysElapsed (void);
+
 extern void SetGameClockRate (COUNT seconds_per_day);
 extern BOOLEAN ValidateEvent (EVENT_TYPE type, COUNT *pmonth_index,
 		COUNT *pday_index, COUNT *pyear_index);
diff -ruNp src.orig/uqm/cnctdlg.c src/uqm/cnctdlg.c
--- src.orig/uqm/cnctdlg.c	2017-12-30 00:14:39 -0800
+++ src/uqm/cnctdlg.c	2017-12-30 00:14:52 -0800
@@ -29,8 +29,8 @@
 #include "libs/graphics/widgets.h"
 #include "supermelee/netplay/netoptions.h"
 
-#define MCD_WIDTH 260
-#define MCD_HEIGHT 110
+#define MCD_WIDTH (260 << RESOLUTION_FACTOR) // JMS_GFX
+#define MCD_HEIGHT (110 << RESOLUTION_FACTOR) // JMS_GFX
 
 #define MENU_FRAME_RATE (ONE_SECOND / 20)
 
@@ -80,12 +80,12 @@ MCD_DrawMenuScreen (WIDGET *_self, int x
 
 	WIDGET_MENU_SCREEN *self = (WIDGET_MENU_SCREEN *)_self;
 	
-	widget_y = y + 8;
+	widget_y = y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	for (widget_index = 0; widget_index < self->num_children; widget_index++)
 	{
 		WIDGET *c = self->child[widget_index];
 		(*c->draw)(c, x, widget_y);
-		widget_y += (*c->height)(c) + 8;
+		widget_y += (*c->height)(c) + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 }
 
@@ -102,7 +102,7 @@ MCD_DrawButton (WIDGET *_self, int x, in
 	selected = MENU_HIGHLIGHT_COLOR;
 	inactive = MENU_TEXT_COLOR;
 
-	t.baseline.x = 160;
+	t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	t.baseline.y = y;
 	t.align = ALIGN_CENTER;
 	t.CharCount = ~0;
@@ -212,7 +212,7 @@ MCD_DrawTextEntry (WIDGET *_self, int x,
 
 	if (!(self->state & WTE_EDITING))
 	{	// normal or selected state
-		t.baseline.x = 160;
+		t.baseline.x = 160 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_CENTER;
 
 		if (widget_focus == _self)
@@ -234,7 +234,7 @@ MCD_DrawTextEntry (WIDGET *_self, int x,
 		RECT r;
 		SIZE leading;
 
-		t.baseline.x = x + 90;
+		t.baseline.x = x + (90 << RESOLUTION_FACTOR); // JMS_GFX
 		t.align = ALIGN_LEFT;
 
 		// calc background box dimensions
diff -ruNp src.orig/uqm/colors.h src/uqm/colors.h
--- src.orig/uqm/colors.h	2017-12-30 00:14:39 -0800
+++ src/uqm/colors.h	2017-12-30 00:14:52 -0800
@@ -75,6 +75,13 @@
 #define BRIGHT_BLUE_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x1F), 0x01)
 
+/* uqm-hd */
+#define BRIGHT_YELLOW_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x00), 0x01)
+#define DULL_YELLOW_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x0F, 0x0F, 0x00), 0x01)
+/* end uqm-hd */
+
 #define NORMAL_ILLUMINATED_COLOR \
 		WHITE_COLOR
 #define NORMAL_SHADOWED_COLOR \
@@ -235,6 +242,14 @@
 #define STATUS_MESSAGE_TEXT_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x10, 0x00), 0x6B)
 
+// Text color for the status message when it's displaying a warning (yellow).
+#define STATUS_MESSAGE_WARNING_TEXT_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x00), 0x6B)
+
+// Text color for the status message then it's displaying an alert (red).
+#define STATUS_MESSAGE_ALERT_TEXT_COLOR \
+		BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x00), 0x6B)
+
 // Background color of the status message.
 #define STATUS_MESSAGE_BACKGROUND_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x00, 0x08, 0x00), 0x6E)
diff -ruNp src.orig/uqm/comm/arilou/arilouc.c src/uqm/comm/arilou/arilouc.c
--- src.orig/uqm/comm/arilou/arilouc.c	2017-12-30 00:14:39 -0800
+++ src/uqm/comm/arilou/arilouc.c	2017-12-30 00:14:52 -0800
@@ -25,6 +25,7 @@
 
 static LOCDATA arilou_desc =
 {
+	ARILOU_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm/blackur/blackurc.c src/uqm/comm/blackur/blackurc.c
--- src.orig/uqm/comm/blackur/blackurc.c	2017-12-30 00:14:39 -0800
+++ src/uqm/comm/blackur/blackurc.c	2017-12-30 00:14:52 -0800
@@ -22,6 +22,7 @@
 
 static LOCDATA blackurq_desc =
 {
+	BLACKURQ_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm/chmmr/chmmrc.c src/uqm/comm/chmmr/chmmrc.c
--- src.orig/uqm/comm/chmmr/chmmrc.c	2017-12-30 00:14:39 -0800
+++ src/uqm/comm/chmmr/chmmrc.c	2017-12-30 00:14:52 -0800
@@ -24,10 +24,13 @@
 #include "uqm/build.h"
 #include "uqm/hyper.h"
 			// for SOL_X/SOL_Y
+#include "../../nameref.h"
+			// JMS_GFX: For LoadGraphic 
 
 
 static LOCDATA chmmr_desc =
 {
+	CHMMR_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -141,7 +144,7 @@ ExitConversation (RESPONSE_REF R)
 		SET_GAME_STATE (CHMMR_STACK, 0);
 		SET_GAME_STATE (CHMMR_BOMB_STATE, 2);
 		SET_GAME_STATE (UTWIG_BOMB_ON_SHIP, 0);
-		GLOBAL_SIS (ResUnits) = 1000000L;
+		GLOBAL_SIS (ResUnits) = 4000000000L;
 		GLOBAL_SIS (NumLanders) = 0;
 		GLOBAL (ModuleCost[PLANET_LANDER]) = 0;
 
@@ -179,8 +182,8 @@ ExitConversation (RESPONSE_REF R)
 
 			/* XXX : this should be unhardcoded eventually */
 			/* transport to Starbase */
-			GLOBAL (ShipStamp.origin.x) = STARBASE_INNER_X - SAFE_X;
-			GLOBAL (ShipStamp.origin.y) = STARBASE_INNER_Y - SAFE_Y;
+			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
+			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
 		}
 		else
 		{	/* 'Beating Game Differently' mode - never visited Starbase,
@@ -559,6 +562,15 @@ Intro (void)
 			CommData.AlienColorMap = SetAbsColorMapIndex (
 					CommData.AlienColorMap, 1
 					);
+
+			// JMS_GFX: Use separate graphics in hires instead of colormap transform.
+			if (RESOLUTION_FACTOR > 0)
+			{
+				CommData.AlienFrameRes = CHMMR_RED_PMAP_ANIM;
+				CommData.AlienFrame = CaptureDrawable (
+					LoadGraphic (CommData.AlienFrameRes));
+			}
+
 			switch (NumVisits++)
 			{
 				case 0:
@@ -580,6 +592,9 @@ Intro (void)
 		}
 		else
 		{
+			HFLEETINFO hChmmr = GetStarShipFromIndex (&GLOBAL (avail_race_q), CHMMR_SHIP);
+			FLEET_INFO *ChmmrPtr = LockFleetInfo (&GLOBAL (avail_race_q), hChmmr);
+
 			SetCommIntroMode (CIM_FADE_IN_SCREEN, ONE_SECOND * 2);
 			NPCPhrase (WE_ARE_FREE);
 
@@ -598,6 +613,17 @@ Intro (void)
 			}
 
 			SET_GAME_STATE (CHMMR_UNLEASHED, 1);
+
+			// Setup a Chmmr sphere-of-influence, now that they're out
+			// of their shell.  EncounterPercent for the Chmmr is 0,
+			// so this is purely decorative.
+			if (ChmmrPtr) {
+				ChmmrPtr->actual_strength = 1800 / SPHERE_RADIUS_INCREMENT * 2;
+				ChmmrPtr->loc.x = 742;
+				ChmmrPtr->loc.y = 2268;
+				StartSphereTracking (CHMMR_SHIP);
+			}
+			UnlockFleetInfo (&GLOBAL (avail_race_q), hChmmr);
 		}
 		SET_GAME_STATE (CHMMR_HOME_VISITS, NumVisits);
 	}
diff -ruNp src.orig/uqm/comm/chmmr/resinst.h src/uqm/comm/chmmr/resinst.h
--- src.orig/uqm/comm/chmmr/resinst.h	2017-12-30 00:14:39 -0800
+++ src/uqm/comm/chmmr/resinst.h	2017-12-30 00:14:52 -0800
@@ -7,4 +7,5 @@
 #define CHMMR_FONT "comm.chmmr.font"
 #define CHMMR_MUSIC "comm.chmmr.music"
 #define CHMMR_PMAP_ANIM "comm.chmmr.graphics"
+#define CHMMR_RED_PMAP_ANIM "comm.chmmr.red.graphics"
 #define CHMMR_SCRIPT "comm.chmmr.script"
diff -ruNp src.orig/uqm/comm/comandr/comandr.c src/uqm/comm/comandr/comandr.c
--- src.orig/uqm/comm/comandr/comandr.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/comandr/comandr.c	2017-12-30 00:14:52 -0800
@@ -19,15 +19,16 @@
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
-
+#include "uqm/units.h"
 #include "uqm/setup.h"
 #include "uqm/sis.h"
 		// for DeltaSISGauges(), DrawLanders()
 #include "libs/graphics/gfx_common.h"
 #include "uqm/lua/luacomm.h"
 
-static LOCDATA commander_desc =
+static LOCDATA commander_desc_1x =
 {
+	COMMANDER_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -94,6 +95,75 @@ static LOCDATA commander_desc =
 	NULL,
 };
 
+static LOCDATA commander_desc_4x =
+{
+	COMMANDER_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	COMMANDER_PMAP_ANIM, /* AlienFrame */
+	COMMANDER_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	COMMANDER_COLOR_MAP, /* AlienColorMap */
+	COMMANDER_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	COMMANDER_CONVERSATION_PHRASES, /* PlayerPhrases */
+	3, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* Blink */
+			1, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Running light */
+			10, /* StartIndex */
+			27, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			ONE_SECOND * 2, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Staticcy, noisy anim before radioactives arrive */
+			78, /* StartIndex */
+			6, /* NumFrames */
+			RANDOM_ANIM,/* AnimFlags */
+			0, ONE_SECOND / 5, /* FrameRate */
+			0, ONE_SECOND / 4, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		4, /* StartIndex */
+		6, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 ByeBye (RESPONSE_REF R)
 {
@@ -553,7 +623,16 @@ GiveRadios (RESPONSE_REF R)
 		NPCPhrase (FUEL_UP1);		
 		AlienTalkSegue (1);
 
-		CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		// JMS_GFX: Disable noisy static animation in hi-res.
+		if (RESOLUTION_FACTOR > 0) {
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+			CommData.AlienAmbientArray[0].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[1].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		}
+		// End color transform anim in lo-res.
+		else
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
 
 		XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
@@ -642,8 +721,11 @@ post_commander_enc (void)
 LOCDATA*
 init_commander_comm ()
 {
+	static LOCDATA commander_desc;
 	LOCDATA *retval;
 
+	commander_desc = (RESOLUTION_FACTOR == 0 ? commander_desc_1x : commander_desc_4x);
+
 	commander_desc.init_encounter_func = Intro;
 	commander_desc.post_encounter_func = post_commander_enc;
 	commander_desc.uninit_encounter_func = uninit_commander;
@@ -654,24 +736,39 @@ init_commander_comm ()
 
 	if (GET_GAME_STATE (RADIOACTIVES_PROVIDED))
 	{
+		// JMS_GFX: Disable noisy static animation in hi-res.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			commander_desc.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+			commander_desc.AlienAmbientArray[0].AnimFlags &= ~ANIM_DISABLED;
+			commander_desc.AlienAmbientArray[1].AnimFlags &= ~ANIM_DISABLED;
+		}
 		commander_desc.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
 		// regular track -- let's make sure
 		commander_desc.AlienSongFlags &= ~LDASF_USE_ALTERNATE;
 	}
 	else
 	{	
+		// JMS_GFX: Enable noisy static animation in hi-res.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			commander_desc.AlienTalkDesc.AnimFlags |= PAUSE_TALKING;
+			commander_desc.AlienAmbientArray[0].AnimFlags |= ANIM_DISABLED;
+			commander_desc.AlienAmbientArray[1].AnimFlags |= ANIM_DISABLED;
+		}
 		commander_desc.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
 		// use alternate 'low-power' track if available
 		commander_desc.AlienAltSongRes = COMMANDER_LOWPOW_MUSIC;
 		commander_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 	}
 
-	commander_desc.AlienTextWidth = 143;
-	commander_desc.AlienTextBaseline.x = 164;
-	commander_desc.AlienTextBaseline.y = 20;
+	// JMS_GFX
+	commander_desc.AlienTextWidth = RES_SIS_SCALE(143); // JMS_GFX
+	commander_desc.AlienTextBaseline.x = RES_SIS_SCALE(164); // JMS_GFX
+	commander_desc.AlienTextBaseline.y = RES_SIS_SCALE(20); // JMS_GFX
 
 	setSegue (Segue_peace);
 	retval = &commander_desc;
 
 	return (retval);
-}
+}
\ No newline at end of file
diff -ruNp src.orig/uqm/comm/druuge/druugec.c src/uqm/comm/druuge/druugec.c
--- src.orig/uqm/comm/druuge/druugec.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/druuge/druugec.c	2017-12-30 00:14:52 -0800
@@ -26,8 +26,9 @@
 		// for DeltaSISGauges()
 
 
-static LOCDATA druuge_desc =
+static LOCDATA druuge_desc_1x =
 {
+	DRUUGE_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -46,7 +47,8 @@ static LOCDATA druuge_desc =
 	DRUUGE_CONVERSATION_PHRASES, /* PlayerPhrases */
 	11, /* NumAnimations */
 	{ /* AlienAmbientArray (ambient animations) */
-		{
+	
+		{	// Biggest flame
 			5, /* StartIndex */
 			4, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
@@ -54,7 +56,7 @@ static LOCDATA druuge_desc =
 			ONE_SECOND * 3 / 40, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
+		{	// Flame on the right
 			9, /* StartIndex */
 			4, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
@@ -62,7 +64,7 @@ static LOCDATA druuge_desc =
 			ONE_SECOND * 3 / 40, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
-		{
+		{	// Smallest flame (behind the biggest flame)
 			13, /* StartIndex */
 			6, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
@@ -70,7 +72,141 @@ static LOCDATA druuge_desc =
 			ONE_SECOND * 3 / 40, 0, /* RestartRate */
 			0, /* BlockMask */
 		},
+		{	// Flashing eyes
+			19, /* StartIndex */
+			3, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			22, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			25, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			28, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			31, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
 		{
+			33, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND * 7, ONE_SECOND * 3,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			40, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND * 3 / 10, 0, /* FrameRate */
+			ONE_SECOND * 3 / 10, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 5, 0, /* FrameRate */
+			ONE_SECOND / 5, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		4, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND / 12, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
+static LOCDATA druuge_desc_4x =
+{
+	DRUUGE_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	DRUUGE_PMAP_ANIM, /* AlienFrame */
+	DRUUGE_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	DRUUGE_COLOR_MAP, /* AlienColorMap */
+	DRUUGE_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	DRUUGE_CONVERSATION_PHRASES, /* PlayerPhrases */
+	11, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+	
+		{	// Biggest flame
+			5, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND * 3 / 20, 0, /* FrameRate */
+			ONE_SECOND * 3 / 20, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// Flame on the right
+			9, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND * 3 / 24, 0, /* FrameRate */
+			ONE_SECOND * 3 / 24, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// Smallest flame (behind the biggest flame)
+			13, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND * 3 / 30, 0, /* FrameRate */
+			ONE_SECOND * 3 / 30, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{	// Flashing eyes
 			19, /* StartIndex */
 			3, /* NumFrames */
 			CIRCULAR_ANIM, /* AnimFlags */
@@ -227,9 +363,9 @@ Buy (RESPONSE_REF R)
 		NPCPhrase (READY_TO_SELL);
 		if (!GET_GAME_STATE (ROSY_SPHERE))
 			NPCPhrase (HAVE_SPHERE);
-		if (!GET_GAME_STATE (ARTIFACT_2_ON_SHIP))
+		if (!GET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP))
 			NPCPhrase (HAVE_ART_1);
-		if (!GET_GAME_STATE (ARTIFACT_3_ON_SHIP))
+		if (!GET_GAME_STATE (GLOWING_ROD_ON_SHIP))
 			NPCPhrase (HAVE_ART_2);
 		NPCPhrase (SHIPS_AND_FUEL);
 
@@ -274,7 +410,7 @@ Buy (RESPONSE_REF R)
 		{
 			DeltaSISGauges (-ARTIFACT_CREW_COST, 0, 0);
 			SlaveryCount += ARTIFACT_CREW_COST;
-			SET_GAME_STATE (ARTIFACT_2_ON_SHIP, 1);
+			SET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP, 1);
 
 			NPCPhrase (BOUGHT_ART_1);
 		}
@@ -287,7 +423,7 @@ Buy (RESPONSE_REF R)
 		{
 			DeltaSISGauges (-ARTIFACT_CREW_COST, 0, 0);
 			SlaveryCount += ARTIFACT_CREW_COST;
-			SET_GAME_STATE (ARTIFACT_3_ON_SHIP, 1);
+			SET_GAME_STATE (GLOWING_ROD_ON_SHIP, 1);
 
 			NPCPhrase (BOUGHT_ART_2);
 		}
@@ -310,9 +446,9 @@ Buy (RESPONSE_REF R)
 	Response (buy_druuge_ship, Buy);
 	if (!GET_GAME_STATE (ROSY_SPHERE))
 		Response (buy_rosy_sphere, Buy);
-	if (!GET_GAME_STATE (ARTIFACT_2_ON_SHIP))
+	if (!GET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP))
 		Response (buy_art_1, Buy);
-	if (!GET_GAME_STATE (ARTIFACT_3_ON_SHIP))
+	if (!GET_GAME_STATE (GLOWING_ROD_ON_SHIP))
 		Response (buy_art_2, Buy);
 	Response (buy_fuel, Buy);
 	Response (done_buying, TradeWorld);
@@ -897,7 +1033,10 @@ post_druuge_enc (void)
 LOCDATA*
 init_druuge_comm (void)
 {
-	LOCDATA *retval;
+	static LOCDATA druuge_desc;
+ 	LOCDATA *retval;
+
+	druuge_desc = (RESOLUTION_FACTOR == 0 ? druuge_desc_1x : druuge_desc_4x);
 
 	SlaveryCount = 0;
 	AttemptedSalvage = FALSE;
@@ -907,7 +1046,7 @@ init_druuge_comm (void)
 	druuge_desc.uninit_encounter_func = uninit_druuge;
 
 	druuge_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
-	druuge_desc.AlienTextBaseline.y = 70;
+	druuge_desc.AlienTextBaseline.y = RES_SIS_SCALE(70);
 	druuge_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if ((GET_GAME_STATE (DRUUGE_MANNER) == 0
diff -ruNp src.orig/uqm/comm/ilwrath/ilwrathc.c src/uqm/comm/ilwrath/ilwrathc.c
--- src.orig/uqm/comm/ilwrath/ilwrathc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/ilwrath/ilwrathc.c	2017-12-30 00:14:52 -0800
@@ -25,6 +25,7 @@
 
 static LOCDATA ilwrath_desc =
 {
+	ILWRATH_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -629,7 +630,7 @@ init_ilwrath_comm (void)
 	ilwrath_desc.uninit_encounter_func = uninit_ilwrath;
 
 	ilwrath_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
-	ilwrath_desc.AlienTextBaseline.y = 70;
+	ilwrath_desc.AlienTextBaseline.y = RES_SIS_SCALE(70);
 	ilwrath_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if (GET_GAME_STATE (PROBE_ILWRATH_ENCOUNTER)
diff -ruNp src.orig/uqm/comm/melnorm/melnorm.c src/uqm/comm/melnorm/melnorm.c
--- src.orig/uqm/comm/melnorm/melnorm.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/melnorm/melnorm.c	2017-12-30 00:14:52 -0800
@@ -24,7 +24,7 @@
 #include "uqm/shipcont.h"
 #include "libs/inplib.h"
 #include "libs/mathlib.h"
-
+#include "libs/log.h"
 #include "uqm/lua/luacomm.h"
 #include "uqm/hyper.h"
 			// for SOL_X/SOL_Y
@@ -35,8 +35,9 @@
 
 static const NUMBER_SPEECH_DESC melnorme_numbers_english;
 
-static LOCDATA melnorme_desc =
+static LOCDATA melnorme_desc_1x =
 {
+	MELNORME_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -111,6 +112,139 @@ static LOCDATA melnorme_desc =
 	NULL,
 };
 
+static LOCDATA melnorme_desc_4x =
+{
+	MELNORME_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	MELNORME_PMAP_ANIM, /* AlienFrame */
+	MELNORME_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	MELNORME_COLOR_MAP, /* AlienColorMap */
+	MELNORME_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	MELNORME_CONVERSATION_PHRASES, /* PlayerPhrases */
+	11, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{
+			6, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 12, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 4,/* RestartRate */
+			(1 << 1), /* BlockMask */
+		},
+		{
+			11, /* StartIndex */
+			9, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND * 4, ONE_SECOND * 4,/* RestartRate */
+			(1 << 0), /* BlockMask */
+		},
+		{
+			20, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 10), /* BlockMask */
+		},
+		{
+			22, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 10), /* BlockMask */
+		},
+		{
+			24, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 11, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			35, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			37, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			39, /* StartIndex */
+			10, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			49, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			51, /* StartIndex */
+			2, /* NumFrames */
+			YOYO_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			53, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 11, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			(1 << 2) | (1 << 3) /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		5, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	&melnorme_numbers_english, /* AlienNumberSpeech - default */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static COUNT melnorme_digit_names[] =
 {
 	ENUMERATE_ZERO,
@@ -1339,9 +1473,24 @@ NatureOfConversation (RESPONSE_REF R)
 				/* Melnorme reports any news and turns purple */
 			NPCPhrase (BUY_OR_SELL);
 			AlienTalkSegue (1);
-			XFormColorMap (GetColorMapAddress (
+
+			if (RESOLUTION_FACTOR == 0) {
+				XFormColorMap (GetColorMapAddress (
 					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
 					), ONE_SECOND / 2);
+			} else if (RESOLUTION_FACTOR > 0) {
+				CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+				CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
+				CommData.AlienAmbientArray[4].AnimFlags &= ~ANIM_DISABLED;
+				CommData.AlienAmbientArray[5].AnimFlags &= ~ANIM_DISABLED;
+				CommData.AlienAmbientArray[6].AnimFlags &= ~ANIM_DISABLED;
+				CommData.AlienAmbientArray[7].AnimFlags |= ANIM_DISABLED;
+				CommData.AlienAmbientArray[8].AnimFlags |= ANIM_DISABLED;
+				CommData.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
+				
+				CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 33);
+			} 
+
 			AlienTalkSegue ((COUNT)~0);
 		}
 		else if (PLAYER_SAID (R, why_turned_purple))
@@ -1404,12 +1553,27 @@ DoBluster (RESPONSE_REF R)
 {
 	if (PLAYER_SAID (R, trade_is_for_the_weak))
 	{
-		XFormColorMap (GetColorMapAddress (
+		NPCPhrase (WERE_NOT_AFRAID);
+		AlienTalkSegue ((COUNT)~0);
+
+		if (RESOLUTION_FACTOR == 0) {
+			XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
 				), ONE_SECOND / 2);
+		} else if (RESOLUTION_FACTOR > 0) {
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[4].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[5].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[6].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[7].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[8].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
+				
+			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
+		}
 
 		SET_GAME_STATE (MELNORME_YACK_STACK2, 4);
-		NPCPhrase (WERE_NOT_AFRAID);
 	}
 	else if (PLAYER_SAID (R, why_blue_light))
 	{
@@ -1590,20 +1754,59 @@ DoFirstMeeting (RESPONSE_REF R)
 	}
 	else if (PLAYER_SAID (R, yes_really_testing))
 	{
-		XFormColorMap (GetColorMapAddress (
+		NPCPhrase (TEST_RESULTS);
+		AlienTalkSegue ((COUNT)~0);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
 				), ONE_SECOND / 2);
-
-		NPCPhrase (TEST_RESULTS);
+		}
+		else if (RESOLUTION_FACTOR > 0)
+		{
+	
+			CommData.AlienAmbientArray[10].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[3].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[7].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[8].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
+			
+			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 0);
+		}
 	}
 	else if (PLAYER_SAID (R, we_apologize))
 	{
 		SET_GAME_STATE (MELNORME_ANGER, 0);
-		XFormColorMap (GetColorMapAddress (
+		NPCPhrase (APOLOGY_ACCEPTED);
+		AlienTalkSegue ((COUNT)~0);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
 				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
 				), ONE_SECOND / 2);
-
-		NPCPhrase (APOLOGY_ACCEPTED);
+		}
+		else if (RESOLUTION_FACTOR > 0)
+		{
+			
+			CommData.AlienAmbientArray[10].AnimFlags &= ~ANIM_DISABLED;	
+			CommData.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[3].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[7].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[8].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
+			
+			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 0);
+			
+		}
 	}
 
 	temp_func = stack_func[0];
@@ -1638,9 +1841,28 @@ DoMelnormeMiffed (RESPONSE_REF R)
 		}
 		SET_GAME_STATE (MELNORME_MIFFED_COUNT, miffed_count);
 
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
-				), ONE_SECOND / 2);
+		AlienTalkSegue ((COUNT)~0);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
+ 				), ONE_SECOND / 2);
+		}
+		else if (RESOLUTION_FACTOR > 0)
+		{
+			
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[7].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[8].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[9].AnimFlags &= ~ANIM_DISABLED;
+			
+			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
+		}
 	}
 	else if (PLAYER_SAID (R, explore_relationship))
 	{
@@ -1710,9 +1932,28 @@ DoMelnormePissed (RESPONSE_REF R)
 		}
 		SET_GAME_STATE (MELNORME_PISSED_COUNT, pissed_count);
 
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
-				), ONE_SECOND / 2);
+		AlienTalkSegue ((COUNT)~0);
+		
+		if (RESOLUTION_FACTOR == 0)
+		{
+			XFormColorMap (GetColorMapAddress (
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 2)
+ 				), ONE_SECOND / 2);
+		}
+		else if (RESOLUTION_FACTOR > 0)
+		{
+			
+			CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+			CommData.AlienAmbientArray[7].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[8].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienAmbientArray[9].AnimFlags &= ~ANIM_DISABLED;
+			
+			CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
+		} 
 	}
 	else if (PLAYER_SAID (R, beg_forgiveness))
 	{
@@ -1765,9 +2006,28 @@ DoMelnormeHate (RESPONSE_REF R)
 	}
 	SET_GAME_STATE (MELNORME_HATE_COUNT, hate_count);
 
-	XFormColorMap (GetColorMapAddress (
-			SetAbsColorMapIndex (CommData.AlienColorMap, 2)
-			), ONE_SECOND / 2);
+	AlienTalkSegue ((COUNT)~0);
+	
+	if (RESOLUTION_FACTOR == 0)
+	{
+		XFormColorMap (GetColorMapAddress (
+ 			SetAbsColorMapIndex (CommData.AlienColorMap, 2)
+ 			), ONE_SECOND / 2);
+	}
+	else if (RESOLUTION_FACTOR > 0)
+	{
+		
+		CommData.AlienAmbientArray[2].AnimFlags |= ANIM_DISABLED;
+		CommData.AlienAmbientArray[3].AnimFlags |= ANIM_DISABLED;
+		CommData.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+		CommData.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+		CommData.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+		CommData.AlienAmbientArray[7].AnimFlags &= ~ANIM_DISABLED;
+		CommData.AlienAmbientArray[8].AnimFlags &= ~ANIM_DISABLED;
+		CommData.AlienAmbientArray[9].AnimFlags &= ~ANIM_DISABLED;
+
+		CommData.AlienFrame = SetAbsFrameIndex (CommData.AlienFrame, 48);
+	} 
 
 	Response (well_if_thats_the_way_you_feel, ExitConversation);
 	Response (you_hate_us_so_we_go_away, ExitConversation);
@@ -1824,7 +2084,10 @@ post_melnorme_enc (void)
 LOCDATA*
 init_melnorme_comm (void)
 {
-	LOCDATA *retval;
+	static LOCDATA melnorme_desc;
+ 	LOCDATA *retval;
+
+	melnorme_desc = (RESOLUTION_FACTOR == 0 ? melnorme_desc_1x : melnorme_desc_4x);
 
 	melnorme_desc.init_encounter_func = Intro;
 	melnorme_desc.post_encounter_func = post_melnorme_enc;
@@ -1836,7 +2099,20 @@ init_melnorme_comm (void)
 
 	melnorme_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
 	melnorme_desc.AlienTextBaseline.y = 0;
-	melnorme_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
+	melnorme_desc.AlienTextWidth = SIS_TEXT_WIDTH - RES_SCALE(16);
+
+	if (RESOLUTION_FACTOR > 0)
+	{
+		melnorme_desc.AlienAmbientArray[2].AnimFlags &= ~ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[3].AnimFlags &= ~ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[4].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[5].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[6].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[7].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[8].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[9].AnimFlags |= ANIM_DISABLED;
+		melnorme_desc.AlienAmbientArray[10].AnimFlags |= ANIM_DISABLED;
+	}
 
 	local_stack0 = 0;
 	local_stack1 = 0;
diff -ruNp src.orig/uqm/comm/mycon/myconc.c src/uqm/comm/mycon/myconc.c
--- src.orig/uqm/comm/mycon/myconc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/mycon/myconc.c	2017-12-30 00:14:52 -0800
@@ -26,6 +26,7 @@
 
 static LOCDATA mycon_desc =
 {
+	MYCON_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm/orz/orzc.c src/uqm/comm/orz/orzc.c
--- src.orig/uqm/comm/orz/orzc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/orz/orzc.c	2017-12-30 00:14:52 -0800
@@ -22,10 +22,16 @@
 
 #include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
+#include "../../nameref.h"
+		//JMS_GFX: For LoadGraphic 
+
+#include "uqm/setup.h"
+		// for GraphicsLock
 
 
 static LOCDATA orz_desc =
 {
+	ORZ_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -42,7 +48,7 @@ static LOCDATA orz_desc =
 	NULL_RESOURCE, /* AlienAltSong */
 	0, /* AlienSongFlags */
 	ORZ_CONVERSATION_PHRASES, /* PlayerPhrases */
-	12 /* 13 */, /* NumAnimations */
+	14, /* NumAnimations */
 	{ /* AlienAmbientArray (ambient animations) */
 		{
 			4, /* StartIndex */
@@ -148,6 +154,14 @@ static LOCDATA orz_desc =
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
 			(1 << 10), /* BlockMask */
 		},
+		{
+			129, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | WAIT_TALKING | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
 	},
 	{ /* AlienTransitionDesc */
 		0, /* StartIndex */
@@ -163,7 +177,7 @@ static LOCDATA orz_desc =
 		0, /* AnimFlags */
 		ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
 		ONE_SECOND / 12, ONE_SECOND * 3 / 8, /* RestartRate */
-		0, /* BlockMask */
+		(1 << 13), /* BlockMask */
 	},
 	NULL, /* AlienNumberSpeech - none */
 	/* Filler for loaded resources */
@@ -225,11 +239,32 @@ ExitConversation (RESPONSE_REF R)
 	else if (PLAYER_SAID (R, about_andro_3)
 			|| PLAYER_SAID (R, must_know_about_androsyn))
 	{
+		// JMS_GFX: Use separate graphics in hires instead of colormap transform.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			int ii;
+			for (ii = 0; ii < CommData.NumAnimations - 1; ii++)
+				CommData.AlienAmbientArray[ii].AnimFlags |= ANIM_DISABLED;
+			
+			CommData.AlienAmbientArray[13].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienFrameRes = ORZ_ANGRY_PMAP_ANIM;
+			CommData.AlienFrame = CaptureDrawable (LoadGraphic (CommData.AlienFrameRes));
+		}
+
 		if (PLAYER_SAID (R, about_andro_3))
 			NPCPhrase (BLEW_IT);
 		else
 			NPCPhrase (KNOW_TOO_MUCH);
 
+		// JMS_GFX: Use separate graphics in hires instead of colormap transform.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			int ii;
+			AlienTalkSegue (1);
+			for (ii = 0; ii < CommData.NumAnimations - 1; ii++)
+				CommData.AlienAmbientArray[ii].AnimFlags &= ~ANIM_DISABLED;
+		}
+
 		SET_GAME_STATE (ORZ_VISITS, 0);
 		SET_GAME_STATE (ORZ_MANNER, 2);
 		setSegue (Segue_hostile);
@@ -641,6 +676,13 @@ Intro (void)
 		CommData.AlienColorMap =
 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
 
+		// JMS_GFX: Use separate red angry graphics in hires instead of colormap transform.
+		if (RESOLUTION_FACTOR > 0) {
+			CommData.AlienFrameRes = ORZ_ANGRY_PMAP_ANIM;
+			CommData.AlienFrame = CaptureDrawable (
+				LoadGraphic (CommData.AlienFrameRes));
+		}
+
 		NumVisits = GET_GAME_STATE (ORZ_VISITS);
 		switch (NumVisits++)
 		{
diff -ruNp src.orig/uqm/comm/orz/resinst.h src/uqm/comm/orz/resinst.h
--- src.orig/uqm/comm/orz/resinst.h	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/orz/resinst.h	2017-12-30 00:14:52 -0800
@@ -7,4 +7,5 @@
 #define ORZ_FONT "comm.orz.font"
 #define ORZ_MUSIC "comm.orz.music"
 #define ORZ_PMAP_ANIM "comm.orz.graphics"
+#define ORZ_ANGRY_PMAP_ANIM "comm.orz.angry.graphics"
 #define ORZ_SCRIPT "comm.orz.script"
diff -ruNp src.orig/uqm/comm/pkunk/pkunkc.c src/uqm/comm/pkunk/pkunkc.c
--- src.orig/uqm/comm/pkunk/pkunkc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/pkunk/pkunkc.c	2017-12-30 00:14:52 -0800
@@ -27,6 +27,7 @@
 
 static LOCDATA pkunk_desc =
 {
+	PKUNK_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm/rebel/rebel.c src/uqm/comm/rebel/rebel.c
--- src.orig/uqm/comm/rebel/rebel.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/rebel/rebel.c	2017-12-30 00:14:52 -0800
@@ -23,8 +23,9 @@
 #include "uqm/build.h"
 
 
-static LOCDATA yehat_desc =
+static LOCDATA yehat_desc_1x =
 {
+	YEHAT_REBEL_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -47,18 +48,18 @@ static LOCDATA yehat_desc =
 			4, /* StartIndex */
 			3, /* NumFrames */
 			YOYO_ANIM
-					| WAIT_TALKING, /* AnimFlags */
+            | WAIT_TALKING, /* AnimFlags */
 			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
 			(1 << 6) | (1 << 7),
 		},
 		{ /* left hand-wing tapping keyboard; front guy */
 			7, /* StartIndex */
 			3, /* NumFrames */
 			YOYO_ANIM
-					| WAIT_TALKING, /* AnimFlags */
+            | WAIT_TALKING, /* AnimFlags */
 			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
-			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
 			(1 << 6) | (1 << 7),
 		},
 		{
@@ -82,7 +83,7 @@ static LOCDATA yehat_desc =
 			5, /* NumFrames */
 			YOYO_ANIM, /* AnimFlags */
 			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND * 10, ONE_SECOND * 3,/* RestartRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
 			(1 << 2) | (1 << 14),
 		},
 		{
@@ -90,25 +91,23 @@ static LOCDATA yehat_desc =
 			5, /* NumFrames */
 			YOYO_ANIM, /* AnimFlags */
 			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND * 10, ONE_SECOND * 3,/* RestartRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
 			(1 << 3),
 		},
 		{ /* right arm-wing rising; front guy */
 			26, /* StartIndex */
 			2, /* NumFrames */
-			YOYO_ANIM
-					| WAIT_TALKING, /* AnimFlags */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
 			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND * 10, ONE_SECOND * 3,/* RestartRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
 			(1 << 0) | (1 << 1),
 		},
 		{ /* left arm-wing rising; front guy */
 			28, /* StartIndex */
 			2, /* NumFrames */
-			YOYO_ANIM
-					| WAIT_TALKING, /* AnimFlags */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
 			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
-			ONE_SECOND * 10, ONE_SECOND * 3,/* RestartRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
 			(1 << 0) | (1 << 1),
 		},
 		{
@@ -162,8 +161,7 @@ static LOCDATA yehat_desc =
 		{
 			48, /* StartIndex */
 			4, /* NumFrames */
-			YOYO_ANIM
-					| WAIT_TALKING, /* AnimFlags */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
 			ONE_SECOND / 30, 0, /* FrameRate */
 			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
 			(1 << 2) | (1 << 4),
@@ -192,6 +190,309 @@ static LOCDATA yehat_desc =
 	NULL,
 };
 
+
+static LOCDATA yehat_desc_2x =
+{
+	YEHAT_REBEL_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	YEHAT_PMAP_ANIM, /* AlienFrame */
+	YEHAT_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* (SIS_TEXT_WIDTH - 16) * 2 / 3, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	YEHAT_COLOR_MAP, /* AlienColorMap */
+	YEHAT_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	REBEL_CONVERSATION_PHRASES, /* PlayerPhrases */
+	13, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* right hand-wing tapping keyboard; front guy */
+			4, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{ /* left hand-wing tapping keyboard; front guy */
+			7, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{
+			10, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5) | (1 << 12),
+		},
+		{
+			13, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5),
+		},
+		{
+			16, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			0,
+		},
+		{
+			21, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			(1 << 2) | (1 << 3) | (1 << 12),
+		},
+		{
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			29, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			32, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			35, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			38, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 2) | (1 << 5),
+		},
+	},
+	{ /* AlienTransitionDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		3, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
+static LOCDATA yehat_desc_4x =
+{
+	YEHAT_REBEL_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	YEHAT_PMAP_ANIM, /* AlienFrame */
+	YEHAT_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* (SIS_TEXT_WIDTH - 16) * 2 / 3, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	YEHAT_COLOR_MAP, /* AlienColorMap */
+	YEHAT_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	REBEL_CONVERSATION_PHRASES, /* PlayerPhrases */
+	13, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* right hand-wing tapping keyboard; front guy */
+			4, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{ /* left hand-wing tapping keyboard; front guy */
+			7, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{
+			10, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5) | (1 << 12),
+		},
+		{
+			13, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5),
+		},
+		{
+			16, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			0,
+		},
+		{
+			21, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			(1 << 2) | (1 << 3) | (1 << 12),
+		},
+		{
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			29, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			32, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			35, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			38, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 2) | (1 << 5),
+		},
+	},
+	{ /* AlienTransitionDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		3, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 PrepareShip (void)
 {
@@ -428,14 +729,17 @@ post_yehat_enc (void)
 LOCDATA*
 init_rebel_yehat_comm (void)
 {
+	static LOCDATA yehat_desc;
 	LOCDATA *retval;
 
+	yehat_desc = (RESOLUTION_FACTOR == 0 ? yehat_desc_1x : (RESOLUTION_FACTOR == 1 ? yehat_desc_2x : yehat_desc_4x));
+
 	yehat_desc.init_encounter_func = Intro;
 	yehat_desc.post_encounter_func = post_yehat_enc;
 	yehat_desc.uninit_encounter_func = uninit_yehat;
 
 	yehat_desc.AlienTextBaseline.x = SIS_SCREEN_WIDTH * 2 / 3;
-	yehat_desc.AlienTextBaseline.y = 60;
+	yehat_desc.AlienTextBaseline.y = RES_SIS_SCALE(60);
 	yehat_desc.AlienTextWidth = (SIS_TEXT_WIDTH - 16) * 2 / 3;
 
 	// use alternate "Rebels" track if available
diff -ruNp src.orig/uqm/comm/shofixt/shofixt.c src/uqm/comm/shofixt/shofixt.c
--- src.orig/uqm/comm/shofixt/shofixt.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/shofixt/shofixt.c	2017-12-30 00:14:52 -0800
@@ -24,8 +24,9 @@
 #include "uqm/gameev.h"
 
 
-static LOCDATA shofixti_desc =
+static LOCDATA shofixti_desc_1x =
 {
+	SHOFIXTI_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -157,6 +158,125 @@ static LOCDATA shofixti_desc =
 	NULL,
 };
 
+static LOCDATA shofixti_desc_4x =
+{
+	SHOFIXTI_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SHOFIXTI_PMAP_ANIM, /* AlienFrame */
+	SHOFIXTI_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	SHOFIXTI_COLOR_MAP, /* AlienColorMap */
+	SHOFIXTI_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SHOFIXTI_CONVERSATION_PHRASES, /* PlayerPhrases */
+	8, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* 0 bottom left star */
+			1, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 2), /* BlockMask */
+		},
+		{ /* 1 bottom right star */
+			7, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 3), /* BlockMask */
+		},
+		{ /* 2 top left star */
+			13, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 0), /* BlockMask */
+		},
+		{ /* 3 top right star */
+			18, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 1), /* BlockMask */
+		},
+		{ /* 4 eye blink */
+			23, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 5 right hand */
+			26, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			(ONE_SECOND >> 1), (ONE_SECOND >> 1) * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 6 radar */
+			34, /* StartIndex */
+			8, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			ONE_SECOND / 10, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* 7 left hand */
+			42, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, 0, /* FrameRate */
+			(ONE_SECOND >> 1), (ONE_SECOND >> 1) * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+#ifdef WHEN_GRAPHICS_ARE_DONE
+		{ /* 8 upper-middle left star */
+			45, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 20, ONE_SECOND / 30, /* RestartRate */
+			(1 << 10), /* BlockMask */
+		},
+#endif
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		29, /* StartIndex */
+		5, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 20, 0, /* FrameRate */
+		ONE_SECOND / 15, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static RESPONSE_REF shofixti_name;
 
 static void
@@ -621,7 +741,10 @@ post_shofixti_enc (void)
 LOCDATA*
 init_shofixti_comm (void)
 {
-	LOCDATA *retval;
+	static LOCDATA shofixti_desc;
+ 	LOCDATA *retval;
+	
+	shofixti_desc = (RESOLUTION_FACTOR == 0 ? shofixti_desc_1x : shofixti_desc_4x);
 
 	shofixti_desc.init_encounter_func = Intro;
 	shofixti_desc.post_encounter_func = post_shofixti_enc;
diff -ruNp src.orig/uqm/comm/slyhome/slyhome.c src/uqm/comm/slyhome/slyhome.c
--- src.orig/uqm/comm/slyhome/slyhome.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/slyhome/slyhome.c	2017-12-30 00:14:52 -0800
@@ -26,6 +26,7 @@
 
 static LOCDATA slylandro_desc =
 {
+	SLYLANDRO_HOME_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm/slyland/slyland.c src/uqm/comm/slyland/slyland.c
--- src.orig/uqm/comm/slyland/slyland.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/slyland/slyland.c	2017-12-30 00:14:52 -0800
@@ -30,6 +30,7 @@ static const NUMBER_SPEECH_DESC probe_nu
 
 static LOCDATA slylandro_desc =
 {
+	SLYLANDRO_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm/spahome/spahome.c src/uqm/comm/spahome/spahome.c
--- src.orig/uqm/comm/spahome/spahome.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/spahome/spahome.c	2017-12-30 00:14:52 -0800
@@ -25,8 +25,9 @@
 #include "uqm/gameev.h"
 
 
-static LOCDATA spahome_desc =
+static LOCDATA spahome_desc_1x =
 {
+	SPATHI_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -184,6 +185,178 @@ static LOCDATA spahome_desc =
 	NULL,
 };
 
+static LOCDATA spahome_desc_4x =
+{
+	SPATHI_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SPATHI_HOME_PMAP_ANIM, /* AlienFrame */
+	SPATHI_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	SPATHI_HOME_COLOR_MAP, /* AlienColorMap */
+	SPATHI_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SPATHI_HOME_CONVERSATION_PHRASES, /* PlayerPhrases */
+	15, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{
+			1, /* StartIndex */
+			3, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0 | (1 << 14), /* BlockMask */
+		},
+		{
+			4, /* StartIndex */
+			5, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0 | (1 << 14), /* BlockMask */
+		},
+		{
+			9, /* StartIndex */
+			4, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 10) | (1 << 11) | (1 << 14), /* BlockMask */
+		},
+		{
+			13, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND / 20, 0, /* RestartRate */
+			(1 << 4) | (1 << 5) | (1 << 14) /* BlockMask */
+		},
+		{
+			19, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 3) | (1 << 5) | (1 << 14), /* BlockMask */
+		},
+		{
+			22, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* RestartRate */
+			(1 << 3) | (1 << 4)
+			| (1 << 10) | (1 << 14), /* BlockMask */
+		},
+		{
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 10) | (1 << 14), /* BlockMask */
+		},
+		{
+			29, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
+			0 | (1 << 14), /* BlockMask */
+		},
+		{
+			32, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND / 20, 0, /* RestartRate */
+			(1 << 9) | (1 << 10) | (1 << 14), /* BlockMask */
+		},
+		{
+			39, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 8) | (1 << 10) | (1 << 14), /* BlockMask */
+		},
+		{
+			42, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, 0, /* RestartRate */
+			(1 << 8) | (1 << 9)
+			| (1 << 6) | (1 << 2)
+			| (1 << 11) | (1 << 5)
+			 | (1 << 14), /* BlockMask */
+		},
+		{
+			46, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 10, ONE_SECOND / 30, /* RestartRate */
+			(1 << 2) | (1 << 10) | (1 << 14), /* BlockMask */
+		},
+		{
+			50, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND / 20, 0, /* RestartRate */
+			(1 << 13) | (1 << 14), /* BlockMask */
+		},
+		{
+			56, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 12) | (1 << 14), /* BlockMask */
+		},
+		{
+			59, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | WAIT_TALKING | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			0, 0,/* RestartRate */
+			(1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) 
+			| (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7) 
+			| (1 << 8) | (1 << 9) | (1 << 10) | (1 << 11) 
+			| (1 << 12) | (1 << 13) , /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 ExitConversation (RESPONSE_REF R)
 {
@@ -582,9 +755,22 @@ AllianceOffer (RESPONSE_REF R)
 	if (PLAYER_SAID (R, misunderstanding))
 	{
 		NPCPhrase (JUST_MISUNDERSTANDING);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND / 4);
+		if (RESOLUTION_FACTOR == 0){
+			XFormColorMap (GetColorMapAddress (
+					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
+					), ONE_SECOND / 4);
+		} else {
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		}
 
 		SET_GAME_STATE (SPATHI_MANNER, 3);
 		SET_GAME_STATE (SPATHI_VISITS, 0);
@@ -758,9 +944,22 @@ SpathiCouncil (RESPONSE_REF R)
 	else if (PLAYER_SAID (R, good_password))
 	{
 		NPCPhrase (YES_GOOD_PASSWORD);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND / 4);
+		if (RESOLUTION_FACTOR == 0) {
+			XFormColorMap (GetColorMapAddress (
+					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
+					), ONE_SECOND / 4);
+		} else {
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		}
 
 		SET_GAME_STATE (KNOW_SPATHI_PASSWORD, 1);
 		SET_GAME_STATE (SPATHI_HOME_VISITS, 0);
@@ -896,6 +1095,10 @@ Intro (void)
 {
 	BYTE Manner;
 
+	if (RESOLUTION_FACTOR > 0)
+		CommData.AlienFrame = SetAbsFrameIndex 
+			(CommData.AlienFrame, 59);
+
 	Manner = GET_GAME_STATE (SPATHI_MANNER);
 	if (Manner == 2)
 	{
@@ -911,22 +1114,61 @@ Intro (void)
 	}
 	else if (CheckAlliance (SPATHI_SHIP) == GOOD_GUY)
 	{
-		CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		if (RESOLUTION_FACTOR == 0) {
+			CommData.AlienColorMap =
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		} else {
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 1;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+			
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		}
 		SpathiAllies ((RESPONSE_REF)0);
 	}
 	else if (GET_GAME_STATE (SPATHI_PARTY))
 	{
-		CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		if (RESOLUTION_FACTOR == 0){
+			CommData.AlienColorMap =
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		} else {
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 1;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		};
 		SpathiParty ((RESPONSE_REF)0);
 	}
 	else if (GET_GAME_STATE (SPATHI_QUEST))
 	{
 		if (GET_GAME_STATE (LIED_ABOUT_CREATURES) < 2)
 		{
-			CommData.AlienColorMap =
-					SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+			if (RESOLUTION_FACTOR == 0) {
+				CommData.AlienColorMap =
+ 					SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+			} else {
+				COUNT i = 0;
+				COUNT limit = CommData.NumAnimations - 1;
+			
+				for (i = 0; i < limit; i++)
+					CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+				CommData.AlienFrame = SetAbsFrameIndex 
+					(CommData.AlienFrame, 0);
+				
+				CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+			}
 			SpathiQuest ((RESPONSE_REF)0);
 		}
 		else
@@ -939,16 +1181,42 @@ Intro (void)
 	}
 	else if (GET_GAME_STATE (KNOW_SPATHI_QUEST))
 	{
-		CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		if (RESOLUTION_FACTOR == 0) {
+			CommData.AlienColorMap =
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		} else {
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 1;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		}
 		LearnQuest ((RESPONSE_REF)0);
 	}
 	else if (GET_GAME_STATE (KNOW_SPATHI_PASSWORD)
 			&& (GET_GAME_STATE (FOUND_PLUTO_SPATHI)
 			|| GET_GAME_STATE (SPATHI_HOME_VISITS) != 7))
 	{
-		CommData.AlienColorMap =
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		if (RESOLUTION_FACTOR == 0) {
+			CommData.AlienColorMap =
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 1);
+		} else {
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 1;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+				
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+				
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+		}
 		SpathiCouncil ((RESPONSE_REF)0);
 	}
 	else
@@ -984,7 +1252,10 @@ post_spahome_enc (void)
 LOCDATA*
 init_spahome_comm ()
 {
-	LOCDATA *retval;
+	static LOCDATA spahome_desc;
+ 	LOCDATA *retval;
+	
+	spahome_desc = (RESOLUTION_FACTOR == 0 ? spahome_desc_1x : spahome_desc_4x);
 
 	spahome_desc.init_encounter_func = Intro;
 	spahome_desc.post_encounter_func = post_spahome_enc;
@@ -1002,6 +1273,16 @@ init_spahome_comm ()
 	spahome_desc.AlienAltSongRes = SPAHOME_MUSIC;
 	spahome_desc.AlienSongFlags |= LDASF_USE_ALTERNATE;
 
+	if (RESOLUTION_FACTOR > 0) {
+		COUNT i;
+		COUNT limit = spahome_desc.NumAnimations;
+	
+		for (i = 0; i < limit; i++)
+			spahome_desc.AlienAmbientArray[i].AnimFlags |= ANIM_DISABLED;
+			
+		spahome_desc.AlienTalkDesc.AnimFlags |= PAUSE_TALKING;
+	}
+
 	if (GET_GAME_STATE (SPATHI_MANNER) == 3)
 	{
 		setSegue (Segue_peace);
diff -ruNp src.orig/uqm/comm/spathi/spathic.c src/uqm/comm/spathi/spathic.c
--- src.orig/uqm/comm/spathi/spathic.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/spathi/spathic.c	2017-12-30 00:14:52 -0800
@@ -25,6 +25,7 @@
 
 static LOCDATA spathi_desc =
 {
+	SPATHI_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm/starbas/starbas.c src/uqm/comm/starbas/starbas.c
--- src.orig/uqm/comm/starbas/starbas.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/starbas/starbas.c	2017-12-30 00:14:52 -0800
@@ -19,7 +19,7 @@
 #include "../commall.h"
 #include "../comandr/resinst.h"
 #include "strings.h"
-
+#include "../../../options.h"
 #include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/setup.h"
@@ -35,8 +35,9 @@ static void TellMission (RESPONSE_REF R)
 static void SellMinerals (RESPONSE_REF R);
 
 
-static LOCDATA commander_desc =
+static LOCDATA commander_desc_1x =
 {
+	COMMANDER_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -159,6 +160,123 @@ static LOCDATA commander_desc =
 	NULL,
 };
 
+static LOCDATA commander_desc_4x =
+{
+	COMMANDER_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	COMMANDER_PMAP_ANIM, /* AlienFrame */
+	COMMANDER_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	COMMANDER_COLOR_MAP, /* AlienColorMap */
+	COMMANDER_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	STARBASE_CONVERSATION_PHRASES, /* PlayerPhrases */
+	9, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* Blink */
+			1, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Running light */
+			10, /* StartIndex */
+			27, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			ONE_SECOND * 2, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Flagship picture */
+			37, /* StartIndex */
+			1, /* NumFrames */
+			0, /* AnimFlags */
+			0, 0, /* FrameRate */
+			0, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Flagship side lights */
+			38, /* StartIndex */
+			2, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND * 2, 0, /* FrameRate */
+			0, ONE_SECOND * 12, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Arc welder 1 */
+			40, /* StartIndex */
+			8, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Arc welder 2 */
+			48, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Arc welder 3 */
+			54, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Arc welder 4 */
+			60, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{ /* Arc welder 5 */
+			67, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 40, 0, /* FrameRate */
+			0, ONE_SECOND * 8, /* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		4, /* StartIndex */
+		6, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+		ONE_SECOND * 7 / 60, ONE_SECOND / 12, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static DWORD CurBulletinMask;
 
 static void
@@ -1015,7 +1133,7 @@ DiscussDevices (BOOLEAN TalkAbout)
 				}
 				break;
 			case ARTIFACT_2_DEVICE:
-				if (GET_GAME_STATE (ARTIFACT_2_ON_SHIP)
+				if (GET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP)
 						&& !GET_GAME_STATE (DISCUSSED_ARTIFACT_2))
 				{
 					pStr = ABOUT_ARTIFACT_2;
@@ -1023,7 +1141,7 @@ DiscussDevices (BOOLEAN TalkAbout)
 				}
 				break;
 			case ARTIFACT_3_DEVICE:
-				if (GET_GAME_STATE (ARTIFACT_3_ON_SHIP)
+				if (GET_GAME_STATE (GLOWING_ROD_ON_SHIP)
 						&& !GET_GAME_STATE (DISCUSSED_ARTIFACT_3))
 				{
 					pStr = ABOUT_ARTIFACT_3;
@@ -1595,6 +1713,9 @@ NormalStarbase (RESPONSE_REF R)
 		{
 			NPCPhrase (STARBASE_IS_READY);
 			DeltaSISGauges (0, 0, 2500);
+			if(optInfiniteRU){
+				oldRU = 2500;
+			}
 			SET_GAME_STATE (STARBASE_MONTH,
 					GLOBAL (GameClock.month_index));
 			SET_GAME_STATE (STARBASE_DAY,
@@ -1667,7 +1788,7 @@ SellMinerals (RESPONSE_REF R)
 
 		if ((amount = GLOBAL_SIS (ElementAmounts[i])) != 0)
 		{
-			total += amount * GLOBAL (ElementWorth[i]);
+			total = amount * GLOBAL (ElementWorth[i]);
 			do
 			{
 				if (!Sleepy || AnyButtonPress (TRUE) ||
@@ -1676,7 +1797,7 @@ SellMinerals (RESPONSE_REF R)
 					Sleepy = FALSE;
 					GLOBAL_SIS (ElementAmounts[i]) = 0;
 					GLOBAL_SIS (TotalElementMass) -= amount;
-					DeltaSISGauges (0, 0, amount * GLOBAL (ElementWorth[i]));
+					DeltaSISGauges (0, 0, total);
 					break;
 				}
 				
@@ -1790,8 +1911,11 @@ post_starbase_enc (void)
 LOCDATA*
 init_starbase_comm ()
 {
+	static LOCDATA commander_desc;
 	LOCDATA *retval;
 
+	commander_desc = (RESOLUTION_FACTOR == 0 ? commander_desc_1x : commander_desc_4x);
+
 	commander_desc.init_encounter_func = Intro;
 	commander_desc.post_encounter_func = post_starbase_enc;
 	commander_desc.uninit_encounter_func = uninit_starbase;
@@ -1800,9 +1924,9 @@ init_starbase_comm ()
 			// Initialise Lua for string interpolation. This will be
 			// generalised in the future.
 
-	commander_desc.AlienTextWidth = 143;
-	commander_desc.AlienTextBaseline.x = 164;
-	commander_desc.AlienTextBaseline.y = 20;
+	commander_desc.AlienTextWidth = RES_SIS_SCALE(143); // JMS_GFX
+	commander_desc.AlienTextBaseline.x = RES_SIS_SCALE(164); // JMS_GFX
+	commander_desc.AlienTextBaseline.y = RES_SIS_SCALE(20); // JMS_GFX
 
 	// use alternate Starbase track if available
 	commander_desc.AlienAltSongRes = STARBASE_ALT_MUSIC;
diff -ruNp src.orig/uqm/comm/supox/supoxc.c src/uqm/comm/supox/supoxc.c
--- src.orig/uqm/comm/supox/supoxc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/supox/supoxc.c	2017-12-30 00:14:52 -0800
@@ -26,6 +26,7 @@
 
 static LOCDATA supox_desc =
 {
+	SUPOX_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm/syreen/syreenc.c src/uqm/comm/syreen/syreenc.c
--- src.orig/uqm/comm/syreen/syreenc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/syreen/syreenc.c	2017-12-30 00:14:52 -0800
@@ -19,14 +19,15 @@
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
-
+#include "uqm/gameev.h"
 #include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/setup.h"
 
 
-static LOCDATA syreen_desc =
+static LOCDATA syreen_desc_1x =
 {
+	SYREEN_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -191,6 +192,191 @@ static LOCDATA syreen_desc =
 	NULL,
 };
 
+static LOCDATA syreen_desc_4x =
+{
+	SYREEN_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	SYREEN_PMAP_ANIM, /* AlienFrame */
+	SYREEN_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* SIS_TEXT_WIDTH - 16, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	SYREEN_COLOR_MAP, /* AlienColorMap */
+	SYREEN_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	SYREEN_CONVERSATION_PHRASES, /* PlayerPhrases */
+	17, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{
+			5, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			7, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			9, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			11, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			13, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			15, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 12), /* BlockMask */
+		},
+		{
+			17, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			19, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 13),
+		},
+		{
+			21, /* StartIndex */
+			6, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			27, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 14), /* BlockMask */
+		},
+		{
+			31, /* StartIndex */
+			6, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			37, /* StartIndex */
+			4, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5), /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM
+					| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 6, 0, /* FrameRate */
+			ONE_SECOND * 3, ONE_SECOND, /* RestartRate */
+			(1 << 7) | (1 << 14), /* BlockMask */
+		},
+		{
+			48, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+					| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND * 2 / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 10, ONE_SECOND,/* RestartRate */
+			(1 << 9) | (1 << 13), /* BlockMask */
+		},
+		{
+			51, /* StartIndex */
+			13, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM 
+				| WAIT_TALKING | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			0, 0,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			64, /* StartIndex */
+			13, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM 
+				| WAIT_TALKING | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 15, 0, /* FrameRate */
+			0, 0,/* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		4, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 FriendlyExit (RESPONSE_REF R)
 {
@@ -220,10 +406,28 @@ FriendlyExit (RESPONSE_REF R)
 		NPCPhrase (SEX_GOODBYE);
 
 		AlienTalkSegue (2);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
-				), ONE_SECOND / 2);
-		AlienTalkSegue ((COUNT)~0);
+		if (RESOLUTION_FACTOR == 0) {
+			XFormColorMap (GetColorMapAddress (
+ 				SetAbsColorMapIndex (CommData.AlienColorMap, 0)
+ 				), ONE_SECOND / 2);
+			AlienTalkSegue ((COUNT)~0);
+		} else {
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations;
+			
+			CommData.AlienAmbientArray[limit-1].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 0);
+			
+			CommData.AlienTalkDesc.AnimFlags &= ~PAUSE_TALKING;
+			
+			AlienTalkSegue ((COUNT)~0);
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags &= ~ANIM_DISABLED;
+			
+			CommData.AlienAmbientArray[limit-2].AnimFlags |= ANIM_DISABLED;
+		}
 
 		SET_GAME_STATE (PLAYER_HAD_SEX, 1);
 		SET_GAME_STATE (PLAYER_HAVING_SEX, 0);
@@ -285,9 +489,25 @@ Foreplay (RESPONSE_REF R)
 			NPCPhrase (ABOUT_US);
 		NPCPhrase (MORE_COMFORTABLE);
 		AlienTalkSegue (1);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND);
+
+		if (RESOLUTION_FACTOR == 0) {
+			XFormColorMap (GetColorMapAddress (
+					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
+					), ONE_SECOND);
+		} else {
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 2;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags |= ANIM_DISABLED;
+				
+			CommData.AlienAmbientArray[limit].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 63);
+				
+			CommData.AlienTalkDesc.AnimFlags |= PAUSE_TALKING;
+		}
+
 		AlienTalkSegue ((COUNT)~0);
 
 		SET_GAME_STATE (PLAYER_HAVING_SEX, 1);
@@ -686,6 +906,8 @@ InitialSyreen (RESPONSE_REF R)
 static void
 PlanAmbush (RESPONSE_REF R)
 {
+	HFLEETINFO hSyreen = GetStarShipFromIndex (&GLOBAL (avail_race_q), SYREEN_SHIP);
+	FLEET_INFO *SyreenPtr = LockFleetInfo (&GLOBAL (avail_race_q), hSyreen);
 	(void) R;  // ignored
 	NPCPhrase (OK_FOUND_VAULT);
 
@@ -693,6 +915,18 @@ PlanAmbush (RESPONSE_REF R)
 	// This is redundant but left here for clarity
 	SET_GAME_STATE (SYREEN_HOME_VISITS, 0);
 
+	// Send ambush fleet to Organon.  EncounterPercent for the
+	// Syreen is 0, so this is purely decorative.
+
+	if (SyreenPtr) {
+		SyreenPtr->actual_strength = 300 / SPHERE_RADIUS_INCREMENT * 2;
+		SyreenPtr->loc.x = 4125;
+		SyreenPtr->loc.y = 3770;
+		StartSphereTracking (SYREEN_SHIP);
+		SetRaceDest (SYREEN_SHIP, 6858, 577, 15, (BYTE)~0);
+	}
+	UnlockFleetInfo (&GLOBAL (avail_race_q), hSyreen);
+
 	Response (whats_my_reward, Foreplay);
 	Response (bye_after_vault, FriendlyExit);
 }
@@ -849,7 +1083,10 @@ post_syreen_enc (void)
 LOCDATA*
 init_syreen_comm (void)
 {
-	LOCDATA *retval;
+	static LOCDATA syreen_desc;
+ 	LOCDATA *retval;
+	
+	syreen_desc = (RESOLUTION_FACTOR == 0 ? syreen_desc_1x : syreen_desc_4x);
 
 	syreen_desc.init_encounter_func = Intro;
 	syreen_desc.post_encounter_func = post_syreen_enc;
diff -ruNp src.orig/uqm/comm/talkpet/talkpet.c src/uqm/comm/talkpet/talkpet.c
--- src.orig/uqm/comm/talkpet/talkpet.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/talkpet/talkpet.c	2017-12-30 00:14:52 -0800
@@ -29,6 +29,7 @@
 
 static LOCDATA talkpet_desc =
 {
+	TALKING_PET_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm/thradd/thraddc.c src/uqm/comm/thradd/thraddc.c
--- src.orig/uqm/comm/thradd/thraddc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/thradd/thraddc.c	2017-12-30 00:14:52 -0800
@@ -19,7 +19,7 @@
 #include "../commall.h"
 #include "resinst.h"
 #include "strings.h"
-
+#include "../../../options.h"
 #include "uqm/lua/luacomm.h"
 #include "uqm/build.h"
 #include "uqm/gameev.h"
@@ -27,6 +27,7 @@
 
 static LOCDATA thradd_desc =
 {
+	THRADD_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -689,6 +690,8 @@ static void
 Intro (void)
 {
 	BYTE NumVisits;
+	HFLEETINFO hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
+	FLEET_INFO *ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 	{
@@ -698,7 +701,7 @@ Intro (void)
 		return;
 	}
 
-	if (GET_GAME_STATE (AQUA_HELIX))
+	if (GET_GAME_STATE (AQUA_HELIX) && (ThraddPtr->allied_state != GOOD_GUY || !optThraddStory))
 	{
 		NumVisits = GET_GAME_STATE (HELIX_VISITS);
 		switch (NumVisits++)
diff -ruNp src.orig/uqm/comm/umgah/strings.h src/uqm/comm/umgah/strings.h
--- src.orig/uqm/comm/umgah/strings.h	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/umgah/strings.h	2017-12-30 00:14:52 -0800
@@ -107,6 +107,7 @@ enum
 	arilou_told_us,
 	bye_zombie,
 	GOODBYE_ZOMBIE,
+	OUT_TAKES,
 };
 
 #endif /* _STRINGS_H */
diff -ruNp src.orig/uqm/comm/umgah/umgahc.c src/uqm/comm/umgah/umgahc.c
--- src.orig/uqm/comm/umgah/umgahc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/umgah/umgahc.c	2017-12-30 00:14:52 -0800
@@ -26,6 +26,7 @@
 
 static LOCDATA umgah_desc =
 {
+	UMGAH_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -502,8 +503,12 @@ Intro (void)
 {
 	BYTE NumVisits;
 
-	if (GET_GAME_STATE (UMGAH_HOSTILE))
-	{
+
+	if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE) {
+		NPCPhrase (OUT_TAKES);
+		SET_GAME_STATE (BATTLE_SEGUE, 0);
+		return;
+	} else if (GET_GAME_STATE (UMGAH_HOSTILE)) {
 		NumVisits = GET_GAME_STATE (UMGAH_VISITS);
 		switch (NumVisits++)
 		{
diff -ruNp src.orig/uqm/comm/urquan/urquanc.c src/uqm/comm/urquan/urquanc.c
--- src.orig/uqm/comm/urquan/urquanc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/urquan/urquanc.c	2017-12-30 00:14:52 -0800
@@ -22,6 +22,7 @@
 
 static LOCDATA urquan_desc =
 {
+	URQUAN_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm/utwig/utwigc.c src/uqm/comm/utwig/utwigc.c
--- src.orig/uqm/comm/utwig/utwigc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/utwig/utwigc.c	2017-12-30 00:14:52 -0800
@@ -27,6 +27,7 @@
 
 static LOCDATA utwig_desc =
 {
+	UTWIG_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -951,7 +952,7 @@ init_utwig_comm (void)
 			// generalised in the future.
 
 	utwig_desc.AlienTextBaseline.x = TEXT_X_OFFS + (SIS_TEXT_WIDTH >> 1);
-	utwig_desc.AlienTextBaseline.y = 70;
+	utwig_desc.AlienTextBaseline.y = RES_SIS_SCALE(70);
 	utwig_desc.AlienTextWidth = SIS_TEXT_WIDTH - 16;
 
 	if (GET_GAME_STATE (UTWIG_HAVE_ULTRON))
diff -ruNp src.orig/uqm/comm/vux/vuxc.c src/uqm/comm/vux/vuxc.c
--- src.orig/uqm/comm/vux/vuxc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/vux/vuxc.c	2017-12-30 00:14:52 -0800
@@ -20,8 +20,9 @@
 #include "resinst.h"
 #include "strings.h"
 
-static LOCDATA vux_desc =
+static LOCDATA vux_desc_1x =
 {
+	VUX_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -200,6 +201,195 @@ static LOCDATA vux_desc =
 	NULL,
 };
 
+static LOCDATA vux_desc_4x =
+{
+	VUX_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	VUX_PMAP_ANIM, /* AlienFrame */
+	VUX_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* (SIS_TEXT_WIDTH - 16) >> 1, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_TOP, /* AlienTextValign */
+	VUX_COLOR_MAP, /* AlienColorMap */
+	VUX_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	VUX_CONVERSATION_PHRASES, /* PlayerPhrases */
+	18, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{
+			12, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			15, /* StartIndex */
+			5, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			20, /* StartIndex */
+			14, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND / 30, 0, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			34, /* StartIndex */
+			7, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			6, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			47, /* StartIndex */
+			11, /* NumFrames */
+			CIRCULAR_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			58, /* StartIndex */
+			3, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			61, /* StartIndex */
+			4, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			65, /* StartIndex */
+			4, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			69, /* StartIndex */
+			2, /* NumFrames */
+			RANDOM_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			71, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			74, /* StartIndex */
+			6, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			80, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* RestartRate */
+			(1 << 14), /* BlockMask */
+		},
+		{
+			85, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			90, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* RestartRate */
+			(1 << 12), /* BlockMask */
+		},
+		{
+			95, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 5, ONE_SECOND * 5,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			99, /* StartIndex */
+			4, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 5, ONE_SECOND * 5,/* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			103, /* StartIndex */
+			13, /* NumFrames */
+			CIRCULAR_ANIM | ONE_SHOT_ANIM | WAIT_TALKING | ANIM_DISABLED, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			0, 0,/* RestartRate */
+			0, /* BlockMask */
+		},
+	},
+	{ /* AlienTransitionDesc */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		11, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		(1 << 18), /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 CombatIsInevitable (RESPONSE_REF R)
 {
@@ -213,9 +403,25 @@ CombatIsInevitable (RESPONSE_REF R)
 		NPCPhrase (FOOL_AIEE1);
 
 		AlienTalkSegue (1);
-		XFormColorMap (GetColorMapAddress (
-				SetAbsColorMapIndex (CommData.AlienColorMap, 1)
-				), ONE_SECOND / 4);
+
+		if (RESOLUTION_FACTOR == 0) {
+			XFormColorMap (GetColorMapAddress (
+					SetAbsColorMapIndex (CommData.AlienColorMap, 1)
+					), ONE_SECOND / 4);
+		} else {
+			COUNT i = 0;
+			COUNT limit = CommData.NumAnimations - 1;
+			
+			for (i = 0; i < limit; i++)
+				CommData.AlienAmbientArray[i].AnimFlags |= ANIM_DISABLED;
+				
+			CommData.AlienAmbientArray[limit].AnimFlags &= ~ANIM_DISABLED;
+			CommData.AlienFrame = SetAbsFrameIndex 
+				(CommData.AlienFrame, 115);
+				
+			CommData.AlienTalkDesc.AnimFlags |= PAUSE_TALKING;
+		}
+
 		AlienTalkSegue ((COUNT)~0);
 
 		SET_GAME_STATE (VUX_BEAST_ON_SHIP, 0);
@@ -770,7 +976,10 @@ post_vux_enc (void)
 LOCDATA*
 init_vux_comm (void)
 {
-	LOCDATA *retval;
+	static LOCDATA vux_desc;
+ 	LOCDATA *retval;
+	
+	vux_desc = (RESOLUTION_FACTOR == 0 ? vux_desc_1x : vux_desc_4x);
 
 	vux_desc.init_encounter_func = Intro;
 	vux_desc.post_encounter_func = post_vux_enc;
diff -ruNp src.orig/uqm/comm/yehat/yehatc.c src/uqm/comm/yehat/yehatc.c
--- src.orig/uqm/comm/yehat/yehatc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/yehat/yehatc.c	2017-12-30 00:14:52 -0800
@@ -26,8 +26,9 @@
 #include "libs/mathlib.h"
 
 
-static LOCDATA yehat_desc =
+static LOCDATA yehat_desc_1x =
 {
+	YEHAT_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
@@ -192,6 +193,308 @@ static LOCDATA yehat_desc =
 	NULL,
 };
 
+static LOCDATA yehat_desc_2x =
+{
+	YEHAT_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	YEHAT_PMAP_ANIM, /* AlienFrame */
+	YEHAT_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* (SIS_TEXT_WIDTH - 16) * 2 / 3, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	YEHAT_COLOR_MAP, /* AlienColorMap */
+	YEHAT_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	YEHAT_CONVERSATION_PHRASES, /* PlayerPhrases */
+	13, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* right hand-wing tapping keyboard; front guy */
+			4, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{ /* left hand-wing tapping keyboard; front guy */
+			7, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{
+			10, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5) | (1 << 12),
+		},
+		{
+			13, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5),
+		},
+		{
+			16, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			0,
+		},
+		{
+			21, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			(1 << 2) | (1 << 3) | (1 << 12),
+		},
+		{
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			29, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			32, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			35, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			38, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 2) | (1 << 5),
+		},
+	},
+	{ /* AlienTransitionDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		3, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
+static LOCDATA yehat_desc_4x =
+{
+	YEHAT_CONVERSATION, /* AlienConv */
+	NULL, /* init_encounter_func */
+	NULL, /* post_encounter_func */
+	NULL, /* uninit_encounter_func */
+	YEHAT_PMAP_ANIM, /* AlienFrame */
+	YEHAT_FONT, /* AlienFont */
+	WHITE_COLOR_INIT, /* AlienTextFColor */
+	BLACK_COLOR_INIT, /* AlienTextBColor */
+	{0, 0}, /* AlienTextBaseline */
+	0, /* (SIS_TEXT_WIDTH - 16) * 2 / 3, */ /* AlienTextWidth */
+	ALIGN_CENTER, /* AlienTextAlign */
+	VALIGN_MIDDLE, /* AlienTextValign */
+	YEHAT_COLOR_MAP, /* AlienColorMap */
+	YEHAT_MUSIC, /* AlienSong */
+	NULL_RESOURCE, /* AlienAltSong */
+	0, /* AlienSongFlags */
+	YEHAT_CONVERSATION_PHRASES, /* PlayerPhrases */
+	13, /* NumAnimations */
+	{ /* AlienAmbientArray (ambient animations) */
+		{ /* right hand-wing tapping keyboard; front guy */
+			4, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{ /* left hand-wing tapping keyboard; front guy */
+			7, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM
+			| WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 10, ONE_SECOND / 10, /* FrameRate */
+			ONE_SECOND / 4, ONE_SECOND / 2,/* RestartRate */
+			0,
+		},
+		{
+			10, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5) | (1 << 12),
+		},
+		{
+			13, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 20, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 5),
+		},
+		{
+			16, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			0,
+		},
+		{
+			21, /* StartIndex */
+			5, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 15, ONE_SECOND / 15, /* FrameRate */
+			ONE_SECOND * 6, ONE_SECOND * 3,/* RestartRate */
+			(1 << 2) | (1 << 3) | (1 << 12),
+		},
+		{
+			26, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			29, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			32, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			35, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			38, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			41, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM, /* AnimFlags */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* FrameRate */
+			ONE_SECOND / 30, ONE_SECOND / 30, /* RestartRate */
+			0, /* BlockMask */
+		},
+		{
+			44, /* StartIndex */
+			3, /* NumFrames */
+			YOYO_ANIM | WAIT_TALKING, /* AnimFlags */
+			ONE_SECOND / 30, 0, /* FrameRate */
+			ONE_SECOND, ONE_SECOND * 3, /* RestartRate */
+			(1 << 2) | (1 << 5),
+		},
+	},
+	{ /* AlienTransitionDesc - empty */
+		0, /* StartIndex */
+		0, /* NumFrames */
+		0, /* AnimFlags */
+		0, 0, /* FrameRate */
+		0, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	{ /* AlienTalkDesc */
+		1, /* StartIndex */
+		3, /* NumFrames */
+		0, /* AnimFlags */
+		ONE_SECOND / 15, 0, /* FrameRate */
+		ONE_SECOND / 12, 0, /* RestartRate */
+		0, /* BlockMask */
+	},
+	NULL, /* AlienNumberSpeech - none */
+	/* Filler for loaded resources */
+	NULL, NULL, NULL,
+	NULL,
+	NULL,
+};
+
 static void
 ExitConversation (RESPONSE_REF R)
 {
@@ -624,7 +927,10 @@ post_yehat_enc (void)
 LOCDATA*
 init_yehat_comm (void)
 {
-	LOCDATA *retval;
+	static LOCDATA yehat_desc;
+ 	LOCDATA *retval;
+	
+	yehat_desc = (RESOLUTION_FACTOR == 0 ? yehat_desc_1x : yehat_desc_4x);
 
 	yehat_desc.init_encounter_func = Intro;
 	yehat_desc.post_encounter_func = post_yehat_enc;
@@ -635,7 +941,7 @@ init_yehat_comm (void)
 			// generalised in the future.
 
 	yehat_desc.AlienTextBaseline.x = SIS_SCREEN_WIDTH * 2 / 3;
-	yehat_desc.AlienTextBaseline.y = 60;
+	yehat_desc.AlienTextBaseline.y = RES_SIS_SCALE(60);
 	yehat_desc.AlienTextWidth = (SIS_TEXT_WIDTH - 16) * 2 / 3;
 
 	if (LOBYTE (GLOBAL (CurrentActivity)) != WON_LAST_BATTLE)
diff -ruNp src.orig/uqm/comm/zoqfot/zoqfotc.c src/uqm/comm/zoqfot/zoqfotc.c
--- src.orig/uqm/comm/zoqfot/zoqfotc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm/zoqfot/zoqfotc.c	2017-12-30 00:14:52 -0800
@@ -28,7 +28,7 @@
 #define ZOQ_FG_COLOR WHITE_COLOR
 #define ZOQ_BG_COLOR BLACK_COLOR
 #define ZOQ_BASE_X (TEXT_X_OFFS + ((SIS_TEXT_WIDTH >> 1) >> 1))
-#define ZOQ_BASE_Y 24
+#define ZOQ_BASE_Y RES_SIS_SCALE(24)
 #define ZOQ_TALK_INDEX 18
 #define ZOQ_TALK_FRAMES 5
 #define FOT_TO_ZOQ 23
@@ -36,13 +36,14 @@
 #define PIK_FG_COLOR WHITE_COLOR
 #define PIK_BG_COLOR BLACK_COLOR
 #define PIK_BASE_X (SIS_SCREEN_WIDTH - (TEXT_X_OFFS + ((SIS_TEXT_WIDTH >> 1) >> 1)))
-#define PIK_BASE_Y 24
+#define PIK_BASE_Y RES_SIS_SCALE(24)
 #define PIK_TALK_INDEX 29
 #define PIK_TALK_FRAMES 2
 #define FOT_TO_PIK 26
 
 static LOCDATA zoqfot_desc =
 {
+	ZOQFOTPIK_CONVERSATION, /* AlienConv */
 	NULL, /* init_encounter_func */
 	NULL, /* post_encounter_func */
 	NULL, /* uninit_encounter_func */
diff -ruNp src.orig/uqm/comm.c src/uqm/comm.c
--- src.orig/uqm/comm.c	2017-12-30 00:14:40 -0800
+++ src/uqm/comm.c	2017-12-30 00:14:52 -0800
@@ -56,18 +56,24 @@
 // XXX: was 32 picked experimentally?
 #define OSCILLOSCOPE_RATE   (ONE_SECOND / 32)
 
+// JMS_GFX
+#define RESPONSE_EXTRA_Y (RES_CASE(0,12,22))
+
 // Maximum comm animation frame rate (actual execution rate)
 // A gfx frame is not always produced during an execution frame,
 // and several animations are combined into one gfx frame.
 // The rate was originally 120fps which allowed for more animation
 // precision which is ultimately wasted on the human eye anyway.
 // The highest known stable animation rate is 40fps, so that's what we use.
-#define COMM_ANIM_RATE   (ONE_SECOND / 40)
+//
+// JMS: Changed this back to 120 fps since hires4x seems to like it... 
+#define COMM_ANIM_RATE   (ONE_SECOND / 120)
 
 static CONTEXT AnimContext;
 
 LOCDATA CommData;
 UNICODE shared_phrase_buf[2048];
+FONT ComputerFont;
 
 static BOOLEAN TalkingFinished;
 static CommIntroMode curIntroMode = CIM_DEFAULT;
@@ -107,8 +113,8 @@ static FRAME TextCacheFrame;
 
 RECT CommWndRect = {
 	// default values; actually inited by HailAlien()
-	{SIS_ORG_X, SIS_ORG_Y},
-	{0, 0}
+	{0, 0},
+	{0, 0} //was {SIS_ORG_X, SIS_ORG_Y}, // JMS_GFX
 };
 
 static void ClearSubtitles (void);
@@ -159,6 +165,7 @@ add_text (int status, TEXT *pTextIn)
 	static COORD last_baseline;
 	BOOLEAN eol;
 	CONTEXT OldContext = NULL;
+	COUNT computerOn = 0;
 	
 	BatchGraphics ();
 
@@ -194,13 +201,13 @@ add_text (int status, TEXT *pTextIn)
 	}
 	else if (GetContextFontLeading (&leading), status <= -4)
 	{
-		text_width = (SIZE) (SIS_SCREEN_WIDTH - 8 - (TEXT_X_OFFS << 2));
+		text_width = (SIZE) (SIS_SCREEN_WIDTH - (8 << RESOLUTION_FACTOR) - (TEXT_X_OFFS << 2)); // JMS_GFX
 
 		pText = pTextIn;
 	}
 	else
 	{
-		text_width = (SIZE) (SIS_SCREEN_WIDTH - 8 - (TEXT_X_OFFS << 2));
+		text_width = (SIZE) (SIS_SCREEN_WIDTH - (8 << RESOLUTION_FACTOR) - (TEXT_X_OFFS << 2)); // JMS_GFX
 
 		switch (status)
 		{
@@ -221,7 +228,7 @@ add_text (int status, TEXT *pTextIn)
 
 		maxchars = pTextIn->CharCount;
 		locText = *pTextIn;
-		locText.baseline.x -= 8;
+		locText.baseline.x -= (8 << RESOLUTION_FACTOR) - 4 * RESOLUTION_FACTOR; // JMS_GFX
 		locText.CharCount = (COUNT)~0;
 		locText.pStr = STR_BULLET;
 		font_DrawText (&locText);
@@ -275,8 +282,109 @@ add_text (int status, TEXT *pTextIn)
 		else
 		{
 			// Alien speech
-			font_DrawTracedText (pText,
-					CommData.AlienTextFColor, CommData.AlienTextBColor);
+			if (CommData.AlienConv == ORZ_CONVERSATION)
+			{
+				// BW : special case for the Orz conversations
+				// the character $ is recycled as a marker to
+				// switch from and to computer font
+				
+				const char *ptr;
+				RECT rect;
+				COORD baselinex = pText->baseline.x;
+				COORD width = 0;
+				COUNT remChars = pText->CharCount;
+			        // Remaining chars until end of line within width
+				const char *bakptr;
+				COUNT bakChars = remChars;
+				COUNT bakcompOn = computerOn;
+				FONT bakFont = SetContextFont(ComputerFont);
+				
+				SetContextFont(bakFont);
+				ptr = pText->pStr;
+				bakptr = ptr;
+				
+				// We need to manually center the line because
+				// the computer font is larger than the Orzfont
+				
+				// This loop computes the width of the line
+				while (remChars > 0)
+					{
+						while ((*ptr != '$') && remChars > 0)
+							{
+								getCharFromString (&ptr);
+								remChars--;
+							}
+						
+						pText->CharCount -= remChars;
+						TextRect (pText, &rect, NULL);
+						
+						width += rect.extent.width;
+						
+						if (*ptr == '$')
+							{
+								getCharFromString (&ptr);
+								remChars--;
+								computerOn = 1 - computerOn;
+								if (computerOn)
+									SetContextFont (ComputerFont);
+								else
+									SetContextFont (CommData.AlienFont);
+							}
+						pText->CharCount = remChars;
+						pText->pStr = ptr;
+					}
+
+				// This to simulate a centered line
+				pText->baseline.x = baselinex - (width >> 1);
+				pText->align = ALIGN_LEFT;
+				
+				// Put everything back in place for the
+				// actual display 
+				remChars = bakChars;
+				pText->CharCount = bakChars;
+				ptr = bakptr;
+				pText->pStr = bakptr;
+				computerOn = bakcompOn;
+				SetContextFont(bakFont);
+				
+				// This loop is used to look up for $
+				while (remChars > 0)
+					{
+						while ((*ptr != '$') && remChars > 0)
+							{
+								getCharFromString (&ptr);
+								remChars--;
+							}
+						
+						pText->CharCount -= remChars;
+						TextRect (pText, &rect, NULL);
+						
+						font_DrawTracedText (pText,
+								     CommData.AlienTextFColor, CommData.AlienTextBColor);
+						
+						pText->baseline.x += rect.extent.width;
+						
+						if (*ptr == '$')
+							{
+								getCharFromString (&ptr);
+								remChars--;
+								computerOn = 1 - computerOn;
+								if (computerOn)
+									SetContextFont (ComputerFont);
+								else
+									SetContextFont (CommData.AlienFont);
+							}
+						pText->CharCount = remChars;
+						pText->pStr = ptr;
+					}
+				pText->baseline.x = baselinex;
+				pText->align = ALIGN_CENTER;
+			}
+			else
+			{
+				// Normal case : other races than Orz
+				font_DrawTracedText (pText, CommData.AlienTextFColor, CommData.AlienTextBColor);
+			}
 		}
 	} while (!eol && maxchars);
 	pText->pStr = pStr;
@@ -415,21 +523,24 @@ static void
 RefreshResponses (ENCOUNTER_STATE *pES)
 {
 	COORD y;
-	BYTE response;
+	BYTE response, extra_y; // JMS_GFX
 	SIZE leading;
 	STAMP s;
 
+
 	SetContext (SpaceContext);
 	GetContextFontLeading (&leading);
 	BatchGraphics ();
 
 	DrawSISComWindow ();
-	y = SLIDER_Y + SLIDER_HEIGHT + 1;
+	y = SLIDER_Y + SLIDER_HEIGHT + (1 << RESOLUTION_FACTOR); // JMS_GFX
 	for (response = pES->top_response; response < pES->num_responses;
 			++response)
 	{
-		pES->response_list[response].response_text.baseline.x = TEXT_X_OFFS + 8;
-		pES->response_list[response].response_text.baseline.y = y + leading;
+		extra_y = (response == pES->top_response ? 0 : RESPONSE_EXTRA_Y); // JMS_GFX
+		
+		pES->response_list[response].response_text.baseline.x = TEXT_X_OFFS + (8 << RESOLUTION_FACTOR); // JMS_GFX
+		pES->response_list[response].response_text.baseline.y = y + leading + extra_y; // JMS_GFX
 		pES->response_list[response].response_text.align = ALIGN_LEFT;
 		if (response == pES->cur_response)
 			y = add_text (-1, &pES->response_list[response].response_text);
@@ -473,7 +584,7 @@ FeedbackPlayerPhrase (UNICODE *pStr)
 		TEXT ct;
 
 		ct.baseline.x = SIS_SCREEN_WIDTH >> 1;
-		ct.baseline.y = SLIDER_Y + SLIDER_HEIGHT + 13;
+		ct.baseline.y = SLIDER_Y + SLIDER_HEIGHT + (13 << RESOLUTION_FACTOR); // JMS_GFX
 		ct.align = ALIGN_CENTER;
 		ct.CharCount = (COUNT)~0;
 
@@ -482,7 +593,7 @@ FeedbackPlayerPhrase (UNICODE *pStr)
 		SetContextForeGroundColor (COMM_RESPONSE_INTRO_TEXT_COLOR);
 		font_DrawText (&ct);
 
-		ct.baseline.y += 16;
+		ct.baseline.y += (16 << RESOLUTION_FACTOR); // JMS_GFX
 		SetContextForeGroundColor (COMM_FEEDBACK_TEXT_COLOR);
 		ct.pStr = pStr;
 		add_text (-4, &ct);
@@ -796,12 +907,22 @@ typedef struct summary_state
 
 } SUMMARY_STATE;
 
+static void remove_char_from_string(UNICODE* str, const UNICODE c) {
+	// MB: Hack for removing '$' characters from Orz dialogue when viewing summary conversation - Used by DoConvSummary below
+    UNICODE *pr = str, *pw = str;
+    while (*pr) {
+        *pw = *pr++;
+        pw += (*pw != c);
+    }
+    *pw = '\0';
+}
+
 static BOOLEAN
 DoConvSummary (SUMMARY_STATE *pSS)
 {
-#define DELTA_Y_SUMMARY 8
-#define MAX_SUMM_ROWS ((SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT) \
-			/ DELTA_Y_SUMMARY) - 1
+#define DELTA_Y_SUMMARY (8 << RESOLUTION_FACTOR) // JMS_GFX
+	//#define MAX_SUMM_ROWS ((SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT) / DELTA_Y_SUMMARY
+#define MAX_SUMM_ROWS (SLIDER_Y	/ DELTA_Y_SUMMARY) - 1 // JMS_GFX
 
 	if (!pSS->Initialized)
 	{
@@ -838,7 +959,7 @@ DoConvSummary (SUMMARY_STATE *pSS)
 		r.corner.x = 0;
 		r.corner.y = 0;
 		r.extent.width = SIS_SCREEN_WIDTH;
-		r.extent.height = SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2;
+		r.extent.height = SLIDER_Y; //SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + (2 << RESOLUTION_FACTOR) + 16 * RESOLUTION_FACTOR; // JMS_GFX
 
 		SetContext (AnimContext);
 		SetContextForeGroundColor (COMM_HISTORY_BACKGROUND_COLOR);
@@ -847,7 +968,7 @@ DoConvSummary (SUMMARY_STATE *pSS)
 		SetContextForeGroundColor (COMM_HISTORY_TEXT_COLOR);
 
 		r.extent.width -= 2 + 2;
-		t.baseline.x = 2;
+		t.baseline.x = 2 << RESOLUTION_FACTOR; // JMS_GFX
 		t.align = ALIGN_LEFT;
 		t.baseline.y = DELTA_Y_SUMMARY;
 		SetContextFont (TinyFont);
@@ -870,11 +991,16 @@ DoConvSummary (SUMMARY_STATE *pSS)
 			}
 
 			t.CharCount = (COUNT)~0;
-			for ( ; row < MAX_SUMM_ROWS &&
-					!getLineWithinWidth (&t, &next, r.extent.width, (COUNT)~0);
-					++row)
-			{
-				font_DrawText (&t);
+			for ( ; row < MAX_SUMM_ROWS && !getLineWithinWidth (&t, &next, r.extent.width, (COUNT)~0); ++row) {
+				if (CommData.AlienConv == ORZ_CONVERSATION) { // MB: nasty hack: remove '$'s from conversation for Orz
+					UNICODE my_copy[80];
+					strcpy(my_copy, t.pStr);
+					remove_char_from_string(my_copy, '$');
+					t.pStr = my_copy;
+					font_DrawText(&t);
+				} else { // Normal mode
+					font_DrawText(&t);
+				}
 				t.baseline.y += DELTA_Y_SUMMARY;
 				t.pStr = next;
 				t.CharCount = (COUNT)~0;
@@ -888,7 +1014,15 @@ DoConvSummary (SUMMARY_STATE *pSS)
 			}
 		
 			// this subtitle fit completely
-			font_DrawText (&t);
+			if (CommData.AlienConv == ORZ_CONVERSATION) { // MB: nasty hack: remove '$'s from conversation for Orz
+				UNICODE my_copy[80];
+				strcpy(my_copy, t.pStr);
+				remove_char_from_string(my_copy, '$');
+				t.pStr = my_copy;
+				font_DrawText(&t);
+			} else { // Normal mode
+				font_DrawText(&t);
+			}
 			t.baseline.y += DELTA_Y_SUMMARY;
 		}
 
@@ -903,6 +1037,11 @@ DoConvSummary (SUMMARY_STATE *pSS)
 			snprintf (buffer, sizeof (buffer), "%s%s%s", // "MORE"
 					STR_MIDDLE_DOT, GAME_STRING (FEEDBACK_STRING_BASE + 1),
 					STR_MIDDLE_DOT);
+
+			if (CommData.AlienConv == ORZ_CONVERSATION) { // MB: nasty hack: remove '$'s from conversation for Orz
+				remove_char_from_string(buffer, '$');
+			}
+
 			mt.pStr = buffer;
 			SetContextForeGroundColor (COMM_MORE_TEXT_COLOR);
 			font_DrawText (&mt);
@@ -1027,8 +1166,6 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 			COORD y;
 
 			BatchGraphics ();
-			add_text (-2,
-					&pES->response_list[pES->cur_response].response_text);
 
 			pES->cur_response = response;
 
@@ -1037,13 +1174,12 @@ PlayerResponseInput (ENCOUNTER_STATE *pE
 			if (response < pES->top_response)
 			{
 				pES->top_response = 0;
-				RefreshResponses (pES);
 			}
 			else if (y > SIS_SCREEN_HEIGHT)
 			{
 				pES->top_response = response;
-				RefreshResponses (pES);
 			}
+			RefreshResponses (pES);
 			UnbatchGraphics ();
 		}
 
@@ -1199,6 +1335,7 @@ HailAlien (void)
 
 	ES.InputFunc = DoCommunication;
 	PlayerFont = LoadFont (PLAYER_FONT);
+	ComputerFont = LoadFont (COMPUTER_FONT);
 
 	CommData.AlienFrame = CaptureDrawable (
 			LoadGraphic (CommData.AlienFrameRes));
@@ -1222,9 +1359,12 @@ HailAlien (void)
 
 	// init subtitle cache context
 	TextCacheContext = CreateContext ("TextCacheContext");
-	TextCacheFrame = CaptureDrawable (
-			CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
-			SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2, 1));
+	//TextCacheFrame = CaptureDrawable (
+	//		CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH,
+	//		SIS_SCREEN_HEIGHT - SLIDER_Y - SLIDER_HEIGHT + 2, 1));
+	// BW: previous lines were just a complex and wrong way of obtaining 107
+ 	TextCacheFrame = CaptureDrawable (
+ 			CreateDrawable (WANT_PIXMAP, SIS_SCREEN_WIDTH, SLIDER_Y, 1));
 	SetContext (TextCacheContext);
 	SetContextFGFrame (TextCacheFrame);
 	TextBack = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x10), 0x00);
@@ -1246,12 +1386,17 @@ HailAlien (void)
 		SetContextFGFrame (Screen);
 		GetFrameRect (CommData.AlienFrame, &r);
 		r.extent.width = SIS_SCREEN_WIDTH;
+		CommWndRect.corner.x = SIS_ORG_X; // JMS_GFX: Added these lines because of the 
+		CommWndRect.corner.y = SIS_ORG_Y; // changed init of CommWndRect in the beginning of comm.c
 		CommWndRect.extent = r.extent;
 		
 		SetTransitionSource (NULL);
 		BatchGraphics ();
 		if (LOBYTE (GLOBAL (CurrentActivity)) == WON_LAST_BATTLE)
 		{
+			// set the position of outtakes comm
+			CommWndRect.corner.x = ((SCREEN_WIDTH - CommWndRect.extent.width) / 2); // JMS_GFX
+			CommWndRect.corner.y = RES_SCALE(5); // JMS_GFX
 			r.corner = CommWndRect.corner;
 			SetContextClipRect (&r);
 		}
@@ -1305,6 +1450,7 @@ HailAlien (void)
 	DestroyDrawable (ReleaseDrawable (TextCacheFrame));
 
 	DestroyFont (PlayerFont);
+	DestroyFont (ComputerFont);
 
 	// Some support code tests either of these to see if the
 	// game is currently in comm or encounter
diff -ruNp src.orig/uqm/comm.h src/uqm/comm.h
--- src.orig/uqm/comm.h	2017-12-30 00:14:40 -0800
+++ src/uqm/comm.h	2017-12-30 00:14:52 -0800
@@ -26,8 +26,8 @@
 
 #ifdef COMM_INTERNAL
 
-#define SLIDER_Y 107
-#define SLIDER_HEIGHT 15
+#define SLIDER_Y ((107 << RESOLUTION_FACTOR) + RES_CASE(0,6,46)) // JMS_GFX
+#define SLIDER_HEIGHT RES_CASE(15, 15, 30) // JMS_GFX
 
 #include "commanim.h"
 
@@ -105,8 +105,8 @@ signaledStopTalkingAnim (void)
 
 #endif
 
-#define TEXT_X_OFFS 1
-#define TEXT_Y_OFFS 1
+#define TEXT_X_OFFS (1 << RESOLUTION_FACTOR) // JMS_GFX
+#define TEXT_Y_OFFS (1 << RESOLUTION_FACTOR) // JMS_GFX
 #define SIS_TEXT_WIDTH (SIS_SCREEN_WIDTH - (TEXT_X_OFFS << 1))
 
 extern void init_communication (void);
diff -ruNp src.orig/uqm/commanim.c src/uqm/commanim.c
--- src.orig/uqm/commanim.c	2017-12-30 00:14:40 -0800
+++ src/uqm/commanim.c	2017-12-30 00:14:52 -0800
@@ -464,6 +464,36 @@ ProcessCommAnimations (BOOLEAN FullRedra
 				{	// Otherwise, let the animation run until it's safe
 					CanTalk = FALSE;
 				}
+			}			
+			
+			// BW: to be checked. I've tried to remove what's supposed to be removed while keeping the Syreen zoom-in feature.
+			// It may have to be re-programmed in the new commanim style.
+			if (pSeq->AnimType == PICTURE_ANIM
+				&& (ADPtr->AnimFlags & CommData.AlienTalkDesc.AnimFlags & WAIT_TALKING)
+				&& pSeq->Direction != NO_DIR)
+			{
+				// JMS: Cut marked animations short when starting talk.
+				// The animations are marked with FAST_STOP_AT_TALK_START in the races' comm source codes.
+				if (ADPtr->AnimFlags & FAST_STOP_AT_TALK_START)
+				{	CanTalk = TRUE;
+					//pSeq->AnimObj.CurFrame = SetAbsFrameIndex(pSeq->AnimObj.CurFrame, ADPtr->StartIndex);
+					pSeq->Direction = NO_DIR;
+				}
+			}
+			
+			// JMS: This handles ambient animations which should occur only during talk
+			// A lot of conditions are necessary to eliminate unwanted animations
+			// from the duration of talk transition!
+			if (pSeq->AnimType == PICTURE_ANIM
+				&& ADPtr->AnimFlags & WHEN_TALKING 
+				&& (!(CommData.AlienTalkDesc.AnimFlags & WAIT_TALKING) 
+					|| (CommData.AlienTalkDesc.AnimFlags & TALK_INTRO)
+					|| (CommData.AlienTalkDesc.AnimFlags & TALK_DONE))
+				&& !(CommData.AlienTransitionDesc.AnimFlags & PAUSE_TALKING)
+				&& pSeq->Direction != NO_DIR)
+			{
+				// Stop the anim if not talking
+				pSeq->Direction = NO_DIR;
 			}
 		}
 		// All ambient animations have been processed. Advance the mask.
diff -ruNp src.orig/uqm/commanim.h src/uqm/commanim.h
--- src.orig/uqm/commanim.h	2017-12-30 00:14:40 -0800
+++ src/uqm/commanim.h	2017-12-30 00:14:52 -0800
@@ -56,7 +56,11 @@ extern "C" {
 #define TALK_DONE (1 << 6)
 		// In AlienTransitionDesc: indicates a transition to silent state
 		// In AlienTalkDesc: signals the end of talking animation
-#define ANIM_DISABLED (1 << 7)
+#define WHEN_TALKING (1L << 7) // JMS
+#define ANIM_DISABLED (1L << 8) // BW (needed for news anchor and animated background)
+
+#define FAST_STOP_AT_TALK_START (TALK_DONE) // JMS: If there's a very loooong animation, it can be forced to stop when talking with this.
+// (otherwise there'll be nasty, unwanted pauses in the conversation.) 
 
 #define COLORXFORM_ANIM PAUSE_TALKING
 
@@ -72,9 +76,10 @@ typedef struct
 	BYTE NumFrames;
 			// Number of frames in the animation.
 
-	BYTE AnimFlags;
+	COUNT AnimFlags;
 			// One of RANDOM_ANIM, CIRCULAR_ANIM, or YOYO_ANIM
 			// plus flags (WAIT_TALKING, ANIM_DISABLED)
+			// JMS: Changed from BYTE to COUNT to house more possible flags
 
 	COUNT BaseFrameRate;
 			// Minimum interframe delay
@@ -93,7 +98,7 @@ typedef struct
 			// due to the image overlap conflicts.
 } ANIMATION_DESC;
 
-#define MAX_ANIMATIONS 20
+#define MAX_ANIMATIONS 30 // JMS: Was 20
 
 
 #ifdef COMM_INTERNAL
diff -ruNp src.orig/uqm/commglue.h src/uqm/commglue.h
--- src.orig/uqm/commglue.h	2017-12-30 00:14:40 -0800
+++ src/uqm/commglue.h	2017-12-30 00:14:52 -0800
@@ -28,36 +28,6 @@
 extern "C" {
 #endif
 
-typedef enum {
-	ARILOU_CONVERSATION,
-	CHMMR_CONVERSATION,
-	COMMANDER_CONVERSATION,
-	ORZ_CONVERSATION,
-	PKUNK_CONVERSATION,
-	SHOFIXTI_CONVERSATION,
-	SPATHI_CONVERSATION,
-	SUPOX_CONVERSATION,
-	THRADD_CONVERSATION,
-	UTWIG_CONVERSATION,
-	VUX_CONVERSATION,
-	YEHAT_CONVERSATION,
-	MELNORME_CONVERSATION,
-	DRUUGE_CONVERSATION,
-	ILWRATH_CONVERSATION,
-	MYCON_CONVERSATION,
-	SLYLANDRO_CONVERSATION,
-	UMGAH_CONVERSATION,
-	URQUAN_CONVERSATION,
-	ZOQFOTPIK_CONVERSATION,
-	SYREEN_CONVERSATION,
-	BLACKURQ_CONVERSATION,
-	TALKING_PET_CONVERSATION,
-	SLYLANDRO_HOME_CONVERSATION,
-	URQUAN_DRONE_CONVERSATION,
-	YEHAT_REBEL_CONVERSATION,
-	INVALID_CONVERSATION,
-} CONVERSATION;
-
 extern LOCDATA CommData;
 extern UNICODE shared_phrase_buf[2048];
 
diff -ruNp src.orig/uqm/confirm.c src/uqm/confirm.c
--- src.orig/uqm/confirm.c	2017-12-30 00:14:40 -0800
+++ src/uqm/confirm.c	2017-12-30 00:14:52 -0800
@@ -32,8 +32,8 @@
 #include <stdlib.h>
 
 
-#define CONFIRM_WIN_WIDTH 80
-#define CONFIRM_WIN_HEIGHT 22
+#define CONFIRM_WIN_WIDTH (80 << RESOLUTION_FACTOR) // JMS_GFX
+#define CONFIRM_WIN_HEIGHT (22 << RESOLUTION_FACTOR) // JMS_GFX
 
 static void
 DrawConfirmationWindow (BOOLEAN answer)
@@ -53,12 +53,12 @@ DrawConfirmationWindow (BOOLEAN answer)
 			SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
 
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + 8;
+	t.baseline.y = r.corner.y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 	t.pStr = GAME_STRING (QUITMENU_STRING_BASE); // "Really Quit?"
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
-	t.baseline.y += 10;
+	t.baseline.y += (10 << RESOLUTION_FACTOR); // JMS_GFX
 	t.baseline.x = r.corner.x + (r.extent.width >> 2);
 	t.pStr = GAME_STRING (QUITMENU_STRING_BASE + 1); // "Yes"
 	SetContextForeGroundColor (answer ? MENU_HIGHLIGHT_COLOR : MENU_TEXT_COLOR);
diff -ruNp src.orig/uqm/cons_res.c src/uqm/cons_res.c
--- src.orig/uqm/cons_res.c	2017-12-30 00:14:40 -0800
+++ src/uqm/cons_res.c	2017-12-30 00:14:52 -0800
@@ -110,3 +110,11 @@ load_orbit_theme (BYTE selector)
 	buffer[79] = '\0'; /* Shouldn't be necessary, but better safe than sorry */	
 	return LoadMusic (buffer);
 }
+
+MUSIC_REF
+loadMainMenuMusic (BYTE selector)
+{
+	snprintf (buffer, 79, "music.mainmenu%d", selector + 1);
+	buffer[79] = '\0'; /* Shouldn't be necessary, but better safe than sorry */	
+	return LoadMusic (buffer);
+}
diff -ruNp src.orig/uqm/cons_res.h src/uqm/cons_res.h
--- src.orig/uqm/cons_res.h	2017-12-30 00:14:40 -0800
+++ src/uqm/cons_res.h	2017-12-30 00:14:52 -0800
@@ -29,8 +29,13 @@ void free_gravity_well (void);
 
 FRAME load_life_form (BYTE selector);
 
+#define NUM_ORBIT_THEMES 5
+static MUSIC_REF OrbitMusic[NUM_ORBIT_THEMES];
 MUSIC_REF load_orbit_theme (BYTE selector);
 
+#define NUM_MM_THEMES 3
+MUSIC_REF loadMainMenuMusic (BYTE selector);
+
 #if defined(__cplusplus)
 }
 #endif
diff -ruNp src.orig/uqm/controls.h src/uqm/controls.h
--- src.orig/uqm/controls.h	2017-12-30 00:14:40 -0800
+++ src/uqm/controls.h	2017-12-30 00:14:52 -0800
@@ -62,7 +62,11 @@ enum {
 	KEY_MENU_EDIT_CANCEL,
 	KEY_MENU_SEARCH,
 	KEY_MENU_NEXT,
+	KEY_MENU_TOGGLEMAP, // JMS: For showing SC1-era starmap
 	KEY_MENU_ANY, /* abstract char key */
+	KEY_DEBUG_2,  // JMS: Secondary debug key
+	KEY_DEBUG_3,  // JMS: Tertiary debug key
+	KEY_DEBUG_4,  // JMS: Quaternary debug key
 	NUM_MENU_KEYS
 };
 
diff -ruNp src.orig/uqm/credits.c src/uqm/credits.c
--- src.orig/uqm/credits.c	2017-12-30 00:14:40 -0800
+++ src/uqm/credits.c	2017-12-30 00:14:52 -0800
@@ -32,10 +32,10 @@
 #include <math.h>
 
 // Rates in pixel lines per second
-#define CREDITS_BASE_RATE   9
-#define CREDITS_MAX_RATE    130
+#define CREDITS_BASE_RATE   (9 << RESOLUTION_FACTOR) // JMS_GFX - MB: tamed
+#define CREDITS_MAX_RATE    (130 << RESOLUTION_FACTOR) // JMS_GFX - MB: tamed
 // Maximum frame rate
-#define CREDITS_FRAME_RATE  36
+#define CREDITS_FRAME_RATE  (RES_SCALE(36)) // JMS_GFX
 
 #define CREDITS_TIMEOUT   (ONE_SECOND * 5)
 
@@ -267,6 +267,8 @@ Credits_RenderTextFrame (CONTEXT TempCon
 			continue;
 		}
 
+		x <<= RESOLUTION_FACTOR; // JMS_GFX
+
 		switch (c)
 		{
 			case 'L':
@@ -639,7 +641,7 @@ FreeCredits (void)
 static void
 OutTakes (void)
 {
-#define NUM_OUTTAKES 15
+#define NUM_OUTTAKES 16
 	static CONVERSATION outtake_list[NUM_OUTTAKES] =
 	{
 		ZOQFOTPIK_CONVERSATION,
@@ -656,6 +658,7 @@ OutTakes (void)
 		URQUAN_CONVERSATION,
 		VUX_CONVERSATION,
 		BLACKURQ_CONVERSATION,
+		UMGAH_CONVERSATION,
 		ARILOU_CONVERSATION
 	};
 
@@ -791,9 +794,8 @@ Credits (BOOLEAN WithOuttakes)
 	FadeScreen (FadeAllToColor, ONE_SECOND / 2);
 
 	// set the position of outtakes comm
-	CommWndRect.corner.x = (screenRect.extent.width - CommWndRect.extent.width)
-			/ 2;
-	CommWndRect.corner.y = 5;
+	CommWndRect.corner.x = ((screenRect.extent.width - CommWndRect.extent.width) / 2); // JMS_GFX
+	CommWndRect.corner.y = RES_SCALE(5); // JMS_GFX
 	
 	InitCredits ();
 	SetInputCallback (on_input_frame);
diff -ruNp src.orig/uqm/cyborg.c src/uqm/cyborg.c
--- src.orig/uqm/cyborg.c	2017-12-30 00:14:40 -0800
+++ src/uqm/cyborg.c	2017-12-30 00:14:52 -0800
@@ -31,17 +31,19 @@
 
 COUNT
 PlotIntercept (ELEMENT *ElementPtr0, ELEMENT *ElementPtr1,
-		COUNT max_turns, COUNT margin_of_error)
+			   COUNT max_turns, COUNT margin_of_error)
 {
-	SIZE dy;
-	SIZE time_y_0, time_y_1;
-	POINT dst[2];
+	SDWORD dy;
+	SDWORD time_y_0, time_y_1;
+	DPOINT dst[2];
 	RECT r0 = {{0, 0}, {0, 0}};
 	RECT r1 = {{0, 0}, {0, 0}};
-	SIZE dx_0, dy_0, dx_1, dy_1;
-
+	SDWORD dx_0, dy_0, dx_1, dy_1; // JMS:These were SIZE. No overflows now.
+	
 	if ((ElementPtr0->state_flags | ElementPtr1->state_flags) & FINITE_LIFE)
 	{
+		//log_add (log_Debug, "E0:%d, E1:%d, max:%d",ElementPtr0->life_span,ElementPtr1->life_span, max_turns);
+		
 		if (!(ElementPtr0->state_flags & FINITE_LIFE))
 		{
 			if (ElementPtr1->life_span < max_turns)
@@ -60,17 +62,19 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 				max_turns = ElementPtr1->life_span;
 		}
 	}
-
-	dst[0] = ElementPtr0->current.location;
-	GetCurrentVelocityComponents (&ElementPtr0->velocity, &dx_0, &dy_0);
-	dx_0 = (SIZE)VELOCITY_TO_WORLD ((long)dx_0 * (long)max_turns);
-	dy_0 = (SIZE)VELOCITY_TO_WORLD ((long)dy_0 * (long)max_turns);
-
-	dst[1] = ElementPtr1->current.location;
-	GetCurrentVelocityComponents (&ElementPtr1->velocity, &dx_1, &dy_1);
-	dx_1 = (SIZE)VELOCITY_TO_WORLD ((long)dx_1 * (long)max_turns);
-	dy_1 = (SIZE)VELOCITY_TO_WORLD ((long)dy_1 * (long)max_turns);
-
+	
+	dst[0].x = (SDWORD)ElementPtr0->current.location.x;
+	dst[0].y = (SDWORD)ElementPtr0->current.location.y;
+	GetCurrentVelocityComponentsSdword (&ElementPtr0->velocity, &dx_0, &dy_0);
+	dx_0 = (SDWORD)VELOCITY_TO_WORLD ((long)dx_0 * (long)max_turns);
+	dy_0 = (SDWORD)VELOCITY_TO_WORLD ((long)dy_0 * (long)max_turns);
+	
+	dst[1].x = (SDWORD)ElementPtr1->current.location.x;
+	dst[1].y = (SDWORD)ElementPtr1->current.location.y;
+	GetCurrentVelocityComponentsSdword (&ElementPtr1->velocity, &dx_1, &dy_1);
+	dx_1 = (SDWORD)VELOCITY_TO_WORLD ((long)dx_1 * (long)max_turns);
+	dy_1 = (SDWORD)VELOCITY_TO_WORLD ((long)dy_1 * (long)max_turns);
+	
 	if (margin_of_error)
 	{
 		dst[1].y -= margin_of_error;
@@ -81,25 +85,25 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 	{
 		GetFrameRect (ElementPtr0->IntersectControl.IntersectStamp.frame, &r0);
 		GetFrameRect (ElementPtr1->IntersectControl.IntersectStamp.frame, &r1);
-
+		
 		dst[0].y += DISPLAY_TO_WORLD (r0.corner.y);
 		dst[1].y += DISPLAY_TO_WORLD (r1.corner.y);
 		time_y_0 = DISPLAY_TO_WORLD (r0.extent.height);
 		time_y_1 = DISPLAY_TO_WORLD (r1.extent.height);
 	}
-
+	
 	dy = dst[1].y - dst[0].y;
 	time_y_0 = dy - time_y_0 + 1;
 	time_y_1 = dy + time_y_1 - 1;
 	dy = dy_0 - dy_1;
-
+	
 	if ((time_y_0 <= 0 && time_y_1 >= 0)
-			|| (time_y_0 > 0 && dy >= time_y_0)
-			|| (time_y_1 < 0 && dy <= time_y_1))
+		|| (time_y_0 > 0 && dy >= time_y_0)
+		|| (time_y_1 < 0 && dy <= time_y_1))
 	{
-		SIZE dx;
-		SIZE time_x_0, time_x_1;
-
+		SDWORD dx;
+		SDWORD time_x_0, time_x_1;
+		
 		if (margin_of_error)
 		{
 			dst[1].x -= margin_of_error;
@@ -113,23 +117,23 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 			time_x_0 = DISPLAY_TO_WORLD (r0.extent.width);
 			time_x_1 = DISPLAY_TO_WORLD (r1.extent.width);
 		}
-
+		
 		dx = dst[1].x - dst[0].x;
 		time_x_0 = dx - time_x_0 + 1;
 		time_x_1 = dx + time_x_1 - 1;
 		dx = dx_0 - dx_1;
-
+		
 		if ((time_x_0 <= 0 && time_x_1 >= 0)
-				|| (time_x_0 > 0 && dx >= time_x_0)
-				|| (time_x_1 < 0 && dx <= time_x_1))
+			|| (time_x_0 > 0 && dx >= time_x_0)
+			|| (time_x_1 < 0 && dx <= time_x_1))
 		{
 			if (dx == 0 && dy == 0)
 				time_y_0 = time_y_1 = 0;
 			else
 			{
-				SIZE t;
+				SDWORD t;
 				long time_beg, time_end, fract;
-
+				
 				if (time_y_1 < 0)
 				{
 					t = time_y_0;
@@ -146,7 +150,7 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 					dy = -dy;
 				if (dy < time_y_1)
 					time_y_1 = dy;
-
+				
 				if (time_x_1 < 0)
 				{
 					t = time_x_0;
@@ -163,7 +167,7 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 					dx = -dx;
 				if (dx < time_x_1)
 					time_x_1 = dx;
-
+				
 				if (dx == 0)
 				{
 					time_beg = time_y_0;
@@ -179,100 +183,103 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 				else
 				{
 					long time_x, time_y;
-
+					
 					time_x = (long)time_x_0 * (long)dy;
 					time_y = (long)time_y_0 * (long)dx;
 					time_beg = time_x < time_y ? time_y : time_x;
-
+					
 					time_x = (long)time_x_1 * (long)dy;
 					time_y = (long)time_y_1 * (long)dx;
 					time_end = time_x > time_y ? time_y : time_x;
-
+					
 					fract = (long)dx * (long)dy;
 				}
-
+				
 				if ((time_beg *= max_turns) < fract)
 					time_y_0 = 0;
 				else
-					time_y_0 = (SIZE)(time_beg / fract);
-
+					time_y_0 = (SDWORD)(time_beg / fract);
+				
 				if (time_end >= fract) /* just in case of overflow */
 					time_y_1 = max_turns - 1;
 				else
-					time_y_1 = (SIZE)((time_end * max_turns) / fract);
+					time_y_1 = (SDWORD)((time_end * max_turns) / fract);
 			}
-
+			
 			if (time_y_0 <= time_y_1)
 			{
 				if (margin_of_error != 0)
 					return ((COUNT)time_y_0 + 1);
 				else
 				{
-					POINT Pt0, Pt1;
+					DPOINT Pt0, Pt1;
 					VELOCITY_DESC Velocity0, Velocity1;
 					INTERSECT_CONTROL Control0, Control1;
-
-					Pt0 = ElementPtr0->current.location;
+					
+					Pt0.x = (SDWORD)ElementPtr0->current.location.x;
+					Pt0.y = (SDWORD)ElementPtr0->current.location.y;
 					Velocity0 = ElementPtr0->velocity;
 					Control0 = ElementPtr0->IntersectControl;
-
-					Pt1 = ElementPtr1->current.location;
+					
+					Pt1.x = (SDWORD)ElementPtr1->current.location.x;
+					Pt1.y = (SDWORD)ElementPtr1->current.location.y;
 					Velocity1 = ElementPtr1->velocity;
 					Control1 = ElementPtr1->IntersectControl;
-
+					
 					if (time_y_0)
 					{
-						GetNextVelocityComponents (&Velocity0, &dx_0, &dy_0, time_y_0);
+						GetNextVelocityComponentsSdword (&Velocity0, &dx_0, &dy_0, time_y_0);
 						Pt0.x += dx_0;
 						Pt0.y += dy_0;
 						Control0.EndPoint.x = WORLD_TO_DISPLAY (Pt0.x);
 						Control0.EndPoint.y = WORLD_TO_DISPLAY (Pt0.y);
 						
-						GetNextVelocityComponents (&Velocity1, &dx_1, &dy_1, time_y_0);
+						GetNextVelocityComponentsSdword (&Velocity1, &dx_1, &dy_1, time_y_0);
 						Pt1.x += dx_1;
 						Pt1.y += dy_1;
 						Control1.EndPoint.x = WORLD_TO_DISPLAY (Pt1.x);
 						Control1.EndPoint.y = WORLD_TO_DISPLAY (Pt1.y);
 					}
-
+					
 					do
 					{
 						TIME_VALUE when;
-
+						
 						++time_y_0;
-
-						GetNextVelocityComponents (&Velocity0, &dx_0, &dy_0, 1);
+						
+						GetNextVelocityComponentsSdword (&Velocity0, &dx_0, &dy_0, 1);
 						Pt0.x += dx_0;
 						Pt0.y += dy_0;
-
-						GetNextVelocityComponents (&Velocity1, &dx_1, &dy_1, 1);
+						
+						GetNextVelocityComponentsSdword (&Velocity1, &dx_1, &dy_1, 1);
 						Pt1.x += dx_1;
 						Pt1.y += dy_1;
-
+						
 						Control0.IntersectStamp.origin = Control0.EndPoint;
 						Control0.EndPoint.x = WORLD_TO_DISPLAY (Pt0.x);
 						Control0.EndPoint.y = WORLD_TO_DISPLAY (Pt0.y);
-
+						
 						Control1.IntersectStamp.origin = Control1.EndPoint;
 						Control1.EndPoint.x = WORLD_TO_DISPLAY (Pt1.x);
 						Control1.EndPoint.y = WORLD_TO_DISPLAY (Pt1.y);
-						when = DrawablesIntersect (&Control0,
-								&Control1, MAX_TIME_VALUE);
+						
+						when = DrawablesIntersect (&Control0, &Control1, MAX_TIME_VALUE);
+						
 						if (when)
 						{
 							if (when == 1
-									&& time_y_0 == 1
-									&& ((ElementPtr0->state_flags
-									| ElementPtr1->state_flags) & APPEARING))
+								&& time_y_0 == 1
+								&& ((ElementPtr0->state_flags
+									 | ElementPtr1->state_flags) & APPEARING))
 							{
 								when = 0;
 								Control0.EndPoint.x = WORLD_TO_DISPLAY (Pt0.x);
 								Control0.EndPoint.y = WORLD_TO_DISPLAY (Pt0.y);
-
+								
 								Control1.EndPoint.x = WORLD_TO_DISPLAY (Pt1.x);
 								Control1.EndPoint.y = WORLD_TO_DISPLAY (Pt1.y);
 							}
-
+							
 							if (when)
 								return ((COUNT)time_y_0);
 						}
@@ -281,7 +288,7 @@ PlotIntercept (ELEMENT *ElementPtr0, ELE
 			}
 		}
 	}
-
+	
 	return (0);
 }
 
@@ -289,24 +296,24 @@ static void
 InitCyborg (STARSHIP *StarShipPtr)
 {
 	COUNT Index, Divisor;
-
+	
 	Index = StarShipPtr->RaceDescPtr->characteristics.max_thrust
-			* StarShipPtr->RaceDescPtr->characteristics.thrust_increment;
+	* StarShipPtr->RaceDescPtr->characteristics.thrust_increment;
 	if ((Divisor = StarShipPtr->RaceDescPtr->characteristics.turn_wait
-			+ StarShipPtr->RaceDescPtr->characteristics.thrust_wait) > 0)
+		 + StarShipPtr->RaceDescPtr->characteristics.thrust_wait) > 0)
 		Index /= Divisor;
 	else
 		Index >>= 1;
 #ifdef PRINT_MI
 	{
 		char *shipName;
-
+		
 		shipName = GetStringAddress (
-				StarShipPtr->RaceDescPtr->ship_data.race_strings);
+									 StarShipPtr->RaceDescPtr->ship_data.race_strings);
 		log_add (log_Debug, "MI(%s) -- <%u:%u> = %u", shipName,
-				StarShipPtr->RaceDescPtr->characteristics.max_thrust *
-				StarShipPtr->RaceDescPtr->characteristics.thrust_increment,
-				Divisor, Index);
+				 StarShipPtr->RaceDescPtr->characteristics.max_thrust *
+				 StarShipPtr->RaceDescPtr->characteristics.thrust_increment,
+				 Divisor, Index);
 	}
 #endif /* PRINT_MI */
 	StarShipPtr->RaceDescPtr->cyborg_control.ManeuverabilityIndex = Index;
@@ -317,7 +324,7 @@ ship_movement (ELEMENT *ShipPtr, EVALUAT
 {
 	if (EvalDescPtr->which_turn == 0)
 		EvalDescPtr->which_turn = 1;
-
+	
 	switch (EvalDescPtr->MoveState)
 	{
 		case PURSUE:
@@ -336,37 +343,38 @@ ship_movement (ELEMENT *ShipPtr, EVALUAT
 	}
 }
 
+// JMS:GFX Made SIZEs SDWORDs and changed the GetNextVelocityComponents to GetNextVelocityComponentsSdword
 BOOLEAN
 ship_weapons (ELEMENT *ShipPtr, ELEMENT *OtherPtr, COUNT margin_of_error)
 {
-	SIZE delta_x, delta_y;
+	SDWORD delta_x, delta_y;
 	COUNT n, num_weapons;
 	ELEMENT Ship;
 	HELEMENT Weapon[6];
 	STARSHIP *StarShipPtr;
-
+	
 	if (OBJECT_CLOAKED (OtherPtr))
-		margin_of_error += DISPLAY_TO_WORLD (40);
-
+		margin_of_error += DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR); // JMS_GFX
+	
 	Ship = *ShipPtr;
-	GetNextVelocityComponents (&Ship.velocity,
-			&delta_x, &delta_y, 1);
+	GetNextVelocityComponentsSdword (&Ship.velocity, &delta_x, &delta_y, 1);
 	Ship.next.location.x =
-			Ship.current.location.x + delta_x;
+		Ship.current.location.x + delta_x;
 	Ship.next.location.y =
-			Ship.current.location.y + delta_y;
+		Ship.current.location.y + delta_y;
+	
 	Ship.current.location = Ship.next.location;
-
+	
 	GetElementStarShip (&Ship, &StarShipPtr);
 	num_weapons =
-			(*StarShipPtr->RaceDescPtr->init_weapon_func) (&Ship, Weapon);
-
+	(*StarShipPtr->RaceDescPtr->init_weapon_func) (&Ship, Weapon);
+	
 	if ((n = num_weapons))
 	{
 		HELEMENT *WeaponPtr, w;
 		//STARSHIP *StarShipPtr;
 		ELEMENT *EPtr;
-
+		
 		WeaponPtr = &Weapon[0];
 		do
 		{
@@ -381,20 +389,19 @@ ship_weapons (ELEMENT *ShipPtr, ELEMENT
 					InitIntersectEndPoint (EPtr);
 					InitIntersectFrame (EPtr);
 				}
-
-				if (PlotIntercept (EPtr, OtherPtr,
-						EPtr->life_span, margin_of_error))
+				
+				if (PlotIntercept (EPtr, OtherPtr, EPtr->life_span, margin_of_error))
 				{
 					UnlockElement (w);
 					break;
 				}
-
+				
 				UnlockElement (w);
 				FreeElement (w);
 			}
 			++WeaponPtr;
 		} while (--n);
-
+		
 		if ((num_weapons = n))
 		{
 			do
@@ -405,26 +412,30 @@ ship_weapons (ELEMENT *ShipPtr, ELEMENT
 			} while (--n);
 		}
 	}
-
+	
+	//if (num_weapons > 0)
+	//	log_add (log_Debug, "dx:%d, dy:%d, currx:%d, curry:%d, nextx:%d, nexty:%d", delta_x, delta_y, Ship.current.location.x, Ship.current.location.y, Ship.next.location.x, Ship.next.location.y);
+	
 	return (num_weapons > 0);
 }
 
 void
 ship_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
-		COUNT ConcernCounter)
+				   COUNT ConcernCounter)
 {
 	BOOLEAN ShipMoved, ShipFired;
 	COUNT margin_of_error;
 	STARSHIP *StarShipPtr;
-
+	EVALUATE_DESC *ObjectsOfConcernEWeapon;
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
-
+	
 	ShipMoved = TRUE;
 	if (ShipPtr->turn_wait == 0)
 		ShipMoved = FALSE;
 	if (ShipPtr->thrust_wait == 0)
 		ShipMoved = FALSE;
-
+	
 	ShipFired = TRUE;
 	if (StarShipPtr->weapon_counter == 0)
 	{
@@ -432,42 +443,49 @@ ship_intelligence (ELEMENT *ShipPtr, EVA
 		if (!(StarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON))
 			ShipFired = FALSE;
 	}
-
+	
 	if (StarShipPtr->control & AWESOME_RATING)
 		margin_of_error = 0;
 	else if (StarShipPtr->control & GOOD_RATING)
-		margin_of_error = DISPLAY_TO_WORLD (20);
+		margin_of_error = DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR); // JMS_GFX
 	else /* if (StarShipPtr->control & STANDARD_RATING) */
-		margin_of_error = DISPLAY_TO_WORLD (40);
-
+		margin_of_error = DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR); // JMS_GFX
+	
 	ObjectsOfConcern += ConcernCounter;
+	
+	ObjectsOfConcernEWeapon = ObjectsOfConcern - ConcernCounter + ENEMY_WEAPON_INDEX;
+	
 	while (ConcernCounter--)
 	{
 		--ObjectsOfConcern;
 		if (ObjectsOfConcern->ObjectPtr)
 		{
 			if (!ShipMoved
-					&& (ConcernCounter != ENEMY_WEAPON_INDEX
+				&& (ConcernCounter != ENEMY_WEAPON_INDEX
 					|| ObjectsOfConcern->MoveState == PURSUE
 					|| (ObjectsOfConcern->ObjectPtr->state_flags & CREW_OBJECT)
 					|| MANEUVERABILITY (
-							&StarShipPtr->RaceDescPtr->cyborg_control
-							) >= MEDIUM_SHIP))
+										&StarShipPtr->RaceDescPtr->cyborg_control
+										) >= RESOLUTION_COMPENSATED(MEDIUM_SHIP) // JMS_GFX
+					)
+				)
 			{
 				ship_movement (ShipPtr, ObjectsOfConcern);
 				ShipMoved = TRUE;
 			}
 			if (!ShipFired
-					&& (ConcernCounter == ENEMY_SHIP_INDEX
+				&& (ConcernCounter == ENEMY_SHIP_INDEX
 					|| (ConcernCounter == ENEMY_WEAPON_INDEX
-					&& ObjectsOfConcern->MoveState != AVOID
+						&& ObjectsOfConcern->MoveState != AVOID
 #ifdef NEVER
-					&& !(StarShipPtr->control & STANDARD_RATING)
-#endif /* NEVER */
-					)))
+						&& !(StarShipPtr->control & STANDARD_RATING)
+#endif /* NEVER */		
+						)
+					)
+				)
 			{
-				ShipFired = ship_weapons (ShipPtr,
-						ObjectsOfConcern->ObjectPtr, margin_of_error);
+				ShipFired = ship_weapons (ShipPtr,ObjectsOfConcern->ObjectPtr, margin_of_error);
+				
 				if (ShipFired)
 					StarShipPtr->ship_input_state |= WEAPON;
 			}
@@ -480,7 +498,7 @@ TurnShip (ELEMENT *ShipPtr, COUNT angle)
 {
 	COUNT f, ship_delta_facing;
 	STARSHIP *StarShipPtr;
-
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	f = StarShipPtr->ShipFacing;
 	ship_delta_facing = NORMALIZE_FACING (ANGLE_TO_FACING (angle) - f);
@@ -488,39 +506,39 @@ TurnShip (ELEMENT *ShipPtr, COUNT angle)
 	{
 		if (ship_delta_facing == ANGLE_TO_FACING (HALF_CIRCLE))
 			ship_delta_facing =
-					NORMALIZE_FACING (ship_delta_facing +
-					(TFB_Random () & 1 ?
-					ANGLE_TO_FACING (OCTANT >> 1) :
-					-ANGLE_TO_FACING (OCTANT >> 1)));
-
+			NORMALIZE_FACING (ship_delta_facing +
+							  (TFB_Random () & 1 ?
+							   ANGLE_TO_FACING (OCTANT >> 1) :
+							   -ANGLE_TO_FACING (OCTANT >> 1)));
+		
 		if (ship_delta_facing < ANGLE_TO_FACING (HALF_CIRCLE))
 		{
 			StarShipPtr->ship_input_state |= RIGHT;
 			++f;
 			ShipPtr->next.image.frame =
-					IncFrameIndex (ShipPtr->current.image.frame);
+			IncFrameIndex (ShipPtr->current.image.frame);
 		}
 		else
 		{
 			StarShipPtr->ship_input_state |= LEFT;
 			--f;
 			ShipPtr->next.image.frame =
-					DecFrameIndex (ShipPtr->current.image.frame);
+			DecFrameIndex (ShipPtr->current.image.frame);
 		}
-
+		
 #ifdef NOTYET
 		if (((StarShipPtr->ship_input_state & (LEFT | RIGHT))
-				^ (StarShipPtr->cur_status_flags & (LEFT | RIGHT))) == (LEFT | RIGHT))
+			 ^ (StarShipPtr->cur_status_flags & (LEFT | RIGHT))) == (LEFT | RIGHT))
 			StarShipPtr->ship_input_state &= ~(LEFT | RIGHT);
 		else
 #endif /* NOTYET */
 		{
 			StarShipPtr->ShipFacing = NORMALIZE_FACING (f);
-
+			
 			return (TRUE);
 		}
 	}
-
+	
 	return (FALSE);
 }
 
@@ -529,224 +547,237 @@ ThrustShip (ELEMENT *ShipPtr, COUNT angl
 {
 	BOOLEAN ShouldThrust;
 	STARSHIP *StarShipPtr;
-
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	if (StarShipPtr->ship_input_state & THRUST)
 		ShouldThrust = TRUE;
 	else if (NORMALIZE_FACING (ANGLE_TO_FACING (angle)
-			- ANGLE_TO_FACING (GetVelocityTravelAngle (&ShipPtr->velocity))) == 0
-			&& (StarShipPtr->cur_status_flags
-			& (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
-			&& !(StarShipPtr->cur_status_flags & SHIP_IN_GRAVITY_WELL))
+							   - ANGLE_TO_FACING (GetVelocityTravelAngle (&ShipPtr->velocity))) == 0
+			 && (StarShipPtr->cur_status_flags
+				 & (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
+			 && !(StarShipPtr->cur_status_flags & SHIP_IN_GRAVITY_WELL))
 		ShouldThrust = FALSE;
 	else
 	{
 		SIZE ship_delta_facing;
-
+		
 		ship_delta_facing =
-				NORMALIZE_FACING (ANGLE_TO_FACING (angle)
-				- StarShipPtr->ShipFacing + ANGLE_TO_FACING (QUADRANT));
+		NORMALIZE_FACING (ANGLE_TO_FACING (angle)
+						  - StarShipPtr->ShipFacing + ANGLE_TO_FACING (QUADRANT));
 		if (ship_delta_facing == ANGLE_TO_FACING (QUADRANT)
-				|| ((StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED)
+			|| ((StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED)
 				&& ship_delta_facing <= ANGLE_TO_FACING (HALF_CIRCLE)))
 			ShouldThrust = TRUE;
 		else
 			ShouldThrust = FALSE;
 	}
-
+	
 	if (ShouldThrust)
 	{
 		inertial_thrust (ShipPtr);
-
+		
 		StarShipPtr->ship_input_state |= THRUST;
 	}
-
+	
 	return (ShouldThrust);
 }
 
+// JMS:GFX Made SIZEs SDWORDs and changed the GetNextVelocityComponents to GetNextVelocityComponentsSdword
 void
 Pursue (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr)
 {
 	BYTE maneuver_state;
 	COUNT desired_thrust_angle, desired_turn_angle;
-	SIZE delta_x, delta_y;
-	SIZE ship_delta_x, ship_delta_y;
-	SIZE other_delta_x, other_delta_y;
+	SDWORD delta_x, delta_y;
+	SDWORD ship_delta_x, ship_delta_y;
+	SDWORD other_delta_x, other_delta_y;
 	ELEMENT *OtherObjPtr;
 	VELOCITY_DESC ShipVelocity, OtherVelocity;
-
+	COUNT distance_to_give_up_and_turn; // JMS
+	
 	ShipVelocity = ShipPtr->velocity;
-	GetNextVelocityComponents (&ShipVelocity,
-			&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
+	GetNextVelocityComponentsSdword (&ShipVelocity,
+		&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
 	ShipPtr->next.location.x =
-			ShipPtr->current.location.x + ship_delta_x;
+		ShipPtr->current.location.x + ship_delta_x;
 	ShipPtr->next.location.y =
-			ShipPtr->current.location.y + ship_delta_y;
-
+		ShipPtr->current.location.y + ship_delta_y;
+	
 	OtherObjPtr = EvalDescPtr->ObjectPtr;
+	
 	OtherVelocity = OtherObjPtr->velocity;
-	GetNextVelocityComponents (&OtherVelocity,
-			&other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
-
+	GetNextVelocityComponentsSdword (&OtherVelocity,
+							   &other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
+	
 	delta_x = (OtherObjPtr->current.location.x + other_delta_x)
-			- ShipPtr->next.location.x;
+		- ShipPtr->next.location.x;
 	delta_y = (OtherObjPtr->current.location.y + other_delta_y)
-			- ShipPtr->next.location.y;
+		- ShipPtr->next.location.y;
 	delta_x = WRAP_DELTA_X (delta_x);
 	delta_y = WRAP_DELTA_Y (delta_y);
 	desired_thrust_angle = ARCTAN (delta_x, delta_y);
-
+	
 	maneuver_state = 0;
 	if (ShipPtr->turn_wait == 0)
 		maneuver_state |= LEFT | RIGHT;
 	if (ShipPtr->thrust_wait == 0
-			&& ((OtherObjPtr->state_flags & PLAYER_SHIP)
+		&& ((OtherObjPtr->state_flags & PLAYER_SHIP)
 			|| elementsOfSamePlayer (OtherObjPtr, ShipPtr)
-			|| OtherObjPtr->preprocess_func == crew_preprocess))
+			|| OtherObjPtr->preprocess_func == crew_preprocess
+			)
+		)
 		maneuver_state |= THRUST;
-
+	
 	desired_turn_angle = NORMALIZE_ANGLE (desired_thrust_angle + HALF_CIRCLE);
-		/* other player's ship */
+	/* other player's ship */
 	if ((OtherObjPtr->state_flags & PLAYER_SHIP)
-			&& OtherObjPtr->mass_points <= MAX_SHIP_MASS)
+		&& OtherObjPtr->mass_points <= MAX_SHIP_MASS)
 	{
 		STARSHIP *StarShipPtr;
 		STARSHIP *EnemyStarShipPtr;
-
+		
 		GetElementStarShip (ShipPtr, &StarShipPtr);
 		GetElementStarShip (OtherObjPtr, &EnemyStarShipPtr);
 		if ((MANEUVERABILITY (
-				&StarShipPtr->RaceDescPtr->cyborg_control
-				) >= FAST_SHIP
-				&& WEAPON_RANGE (&StarShipPtr->RaceDescPtr->cyborg_control)
-				> CLOSE_RANGE_WEAPON)
-				|| (EvalDescPtr->which_turn >= 24
+							  &StarShipPtr->RaceDescPtr->cyborg_control
+							  ) >= RESOLUTION_COMPENSATED(FAST_SHIP) // JMS_GFX
+			 && WEAPON_RANGE (&StarShipPtr->RaceDescPtr->cyborg_control)
+			 > (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)) // JMS_GFX
+			|| (EvalDescPtr->which_turn >= 24
 				&& (StarShipPtr->RaceDescPtr->characteristics.max_thrust * 2 / 3 <
-				EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust
-				|| (EnemyStarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))))
+					EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust
+					|| (EnemyStarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))))
 		{
 			UWORD ship_flags;
-
+			
 			ship_flags = EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags;
-						/* you're maneuverable */
+			/* you're maneuverable */
 			if (MANEUVERABILITY (
-					&StarShipPtr->RaceDescPtr->cyborg_control
-					) >= MEDIUM_SHIP)
+				&StarShipPtr->RaceDescPtr->cyborg_control
+				) >= RESOLUTION_COMPENSATED(MEDIUM_SHIP)) // JMS_GFX
 			{
 				UWORD fire_flags;
 				COUNT facing;
-
+				
 				for (fire_flags = FIRES_FORE, facing = EvalDescPtr->facing;
-						fire_flags <= FIRES_LEFT;
-						fire_flags <<= 1, facing += QUADRANT)
+					 fire_flags <= FIRES_LEFT;
+					 fire_flags <<= 1, facing += QUADRANT)
 				{
 					if
-					(
-							/* he's dangerous in this direction */
-						(ship_flags & fire_flags)
-							/* he's facing direction you want to go */
-						&& NORMALIZE_ANGLE (
-						desired_turn_angle - facing + OCTANT
-						) <= QUADRANT
-						&& (
-							/* he's moving */
-						(other_delta_x != 0 || other_delta_y != 0)
-						&&
-							/* he's coasting backwards */
-						NORMALIZE_ANGLE (
-						(GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
-						- facing + (OCTANT + (OCTANT >> 1)))
-						<= ((OCTANT + (OCTANT >> 1)) << 1))
-					)
+						(
+						 /* he's dangerous in this direction */
+						 (ship_flags & fire_flags)
+						 /* he's facing direction you want to go */
+						 && NORMALIZE_ANGLE (
+							desired_turn_angle - facing + OCTANT) <= QUADRANT
+						 && (
+							 /* he's moving */
+							 (other_delta_x != 0 || other_delta_y != 0)
+							 &&
+							 /* he's coasting backwards */
+							 NORMALIZE_ANGLE (
+								(GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
+								- facing + (OCTANT + (OCTANT >> 1)))
+							 <= ((OCTANT + (OCTANT >> 1)) << 1))
+						 )
 					{
-							/* catch him on the back side */
+						/* catch him on the back side */
 						desired_thrust_angle = desired_turn_angle;
 						break;
 					}
 				}
 			}
-
+			
+			// This code prevents Kohr-Ah, Ur-Quan and ISD from turning around mid-chase while pursuing Earthling.
+			if (StarShipPtr->SpeciesID == (KOHR_AH_ID | UR_QUAN_ID)
+				&& EnemyStarShipPtr->SpeciesID == EARTHLING_ID 
+				&& !(EnemyStarShipPtr->cur_status_flags & (SHIP_BEYOND_MAX_SPEED | SHIP_IN_GRAVITY_WELL)))
+				distance_to_give_up_and_turn = 44;
+			else
+				distance_to_give_up_and_turn = 24;
+			
 			if (desired_thrust_angle != desired_turn_angle
-					&& (other_delta_x || other_delta_y)
-					&& EvalDescPtr->which_turn >= 24
-					&& NORMALIZE_ANGLE (desired_thrust_angle
-					- GetVelocityTravelAngle (&OtherVelocity)
-					+ OCTANT) <= QUADRANT
-					&& ((NORMALIZE_ANGLE (
-					GetVelocityTravelAngle (&OtherVelocity)
-					- GetVelocityTravelAngle (&ShipVelocity)
-					+ OCTANT) <= QUADRANT
-					&& (((StarShipPtr->cur_status_flags & SHIP_AT_MAX_SPEED)
-					&& !(StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))
-					|| (ship_flags & DONT_CHASE)))
+				&& (other_delta_x || other_delta_y)
+				&& EvalDescPtr->which_turn >= distance_to_give_up_and_turn
+				&& NORMALIZE_ANGLE (desired_thrust_angle
+									- GetVelocityTravelAngle (&OtherVelocity)
+									+ OCTANT) <= QUADRANT
+				&& ((NORMALIZE_ANGLE (
+									  GetVelocityTravelAngle (&OtherVelocity)
+									  - GetVelocityTravelAngle (&ShipVelocity)
+									  + OCTANT) <= QUADRANT
+					 && (((StarShipPtr->cur_status_flags & SHIP_AT_MAX_SPEED)
+						  && !(StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))
+						 || (ship_flags & DONT_CHASE)))
 					|| NORMALIZE_ANGLE (
-					desired_turn_angle
-					- FACING_TO_ANGLE (StarShipPtr->ShipFacing)
-					+ OCTANT) <= QUADRANT))
+										desired_turn_angle
+										- FACING_TO_ANGLE (StarShipPtr->ShipFacing)
+										+ OCTANT) <= QUADRANT))
 				desired_thrust_angle = desired_turn_angle;
 		}
 	}
-
+	
 	if (maneuver_state & (LEFT | RIGHT))
 		TurnShip (ShipPtr, desired_thrust_angle);
-
+	
 	if (maneuver_state & THRUST)
 		ThrustShip (ShipPtr, desired_thrust_angle);
 }
 
+// JMS:GFX Made SIZEs SDWORDs and changed the GetNextVelocityComponents to GetNextVelocityComponentsSdword
 void
 Entice (ELEMENT *ShipPtr, EVALUATE_DESC *EvalDescPtr)
 {
 	BYTE maneuver_state;
 	COUNT desired_thrust_angle, desired_turn_angle;
 	COUNT cone_of_fire, travel_angle;
-	SIZE delta_x, delta_y;
-	SIZE ship_delta_x, ship_delta_y;
-	SIZE other_delta_x, other_delta_y;
+	SDWORD delta_x, delta_y;
+	SDWORD ship_delta_x, ship_delta_y;
+	SDWORD other_delta_x, other_delta_y;
 	ELEMENT *OtherObjPtr;
 	VELOCITY_DESC ShipVelocity, OtherVelocity;
 	STARSHIP *StarShipPtr;
 	RACE_DESC *RDPtr;
-
+	
 	ShipVelocity = ShipPtr->velocity;
-	GetNextVelocityComponents (&ShipVelocity,
-			&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
+	GetNextVelocityComponentsSdword (&ShipVelocity,
+		&ship_delta_x, &ship_delta_y, EvalDescPtr->which_turn);
 	ShipPtr->next.location.x =
-			ShipPtr->current.location.x + ship_delta_x;
+		ShipPtr->current.location.x + ship_delta_x;
 	ShipPtr->next.location.y =
-			ShipPtr->current.location.y + ship_delta_y;
-
+		ShipPtr->current.location.y + ship_delta_y;
+	
 	OtherObjPtr = EvalDescPtr->ObjectPtr;
 	OtherVelocity = OtherObjPtr->velocity;
-	GetNextVelocityComponents (&OtherVelocity,
-			&other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
-
+	GetNextVelocityComponentsSdword (&OtherVelocity,
+		&other_delta_x, &other_delta_y, EvalDescPtr->which_turn);
+	
 	delta_x = (OtherObjPtr->current.location.x + other_delta_x)
-			- ShipPtr->next.location.x;
+		- ShipPtr->next.location.x;
 	delta_y = (OtherObjPtr->current.location.y + other_delta_y)
-			- ShipPtr->next.location.y;
+		- ShipPtr->next.location.y;
 	delta_x = WRAP_DELTA_X (delta_x);
 	delta_y = WRAP_DELTA_Y (delta_y);
 	desired_thrust_angle = ARCTAN (delta_x, delta_y);
-
+	
 	maneuver_state = 0;
 	if (ShipPtr->turn_wait == 0)
 		maneuver_state |= LEFT | RIGHT;
 	if (ShipPtr->thrust_wait == 0)
 		maneuver_state |= THRUST;
-
+	
 	delta_x = ship_delta_x - other_delta_x;
 	delta_y = ship_delta_y - other_delta_y;
 	travel_angle = ARCTAN (delta_x, delta_y);
 	desired_turn_angle = NORMALIZE_ANGLE (desired_thrust_angle + HALF_CIRCLE);
-
+	
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	RDPtr = StarShipPtr->RaceDescPtr;
 	if (EvalDescPtr->MoveState == AVOID)
 	{
 		desired_turn_angle =
-				NORMALIZE_ANGLE (desired_turn_angle - EvalDescPtr->facing);
-
+		NORMALIZE_ANGLE (desired_turn_angle - EvalDescPtr->facing);
+		
 		if (NORMALIZE_FACING (ANGLE_TO_FACING (desired_turn_angle)))
 		{
 			if (desired_turn_angle <= HALF_CIRCLE)
@@ -757,162 +788,156 @@ Entice (ELEMENT *ShipPtr, EVALUATE_DESC
 		else
 		{
 			desired_turn_angle = NORMALIZE_ANGLE (
-					FACING_TO_ANGLE (StarShipPtr->ShipFacing)
-					- EvalDescPtr->facing
-					);
+				FACING_TO_ANGLE (StarShipPtr->ShipFacing)
+				- EvalDescPtr->facing);
 			if ((desired_turn_angle & (HALF_CIRCLE - 1)) == 0)
 				desired_thrust_angle = TFB_Random () & 1 ? RIGHT : LEFT;
 			else
 				desired_thrust_angle = desired_turn_angle < HALF_CIRCLE ? RIGHT : LEFT;
 		}
-
+		
 		if (desired_thrust_angle == LEFT)
 		{
 #define FLANK_LEFT -QUADRANT
 #define SHIP_LEFT -OCTANT
 			desired_thrust_angle = EvalDescPtr->facing
-					+ FLANK_LEFT - (SHIP_LEFT >> 1);
+			+ FLANK_LEFT - (SHIP_LEFT >> 1);
 		}
 		else
 		{
 #define FLANK_RIGHT QUADRANT
 #define SHIP_RIGHT OCTANT
 			desired_thrust_angle = EvalDescPtr->facing
-					+ FLANK_RIGHT - (SHIP_RIGHT >> 1);
+			+ FLANK_RIGHT - (SHIP_RIGHT >> 1);
 		}
-
+		
 		desired_thrust_angle = NORMALIZE_ANGLE (desired_thrust_angle);
 	}
 	else if (GRAVITY_MASS (OtherObjPtr->mass_points))
 	{
 		COUNT planet_facing;
-
+		
 		planet_facing = NORMALIZE_FACING (ANGLE_TO_FACING (desired_thrust_angle));
-		cone_of_fire = NORMALIZE_FACING (
-				planet_facing
-				- StarShipPtr->ShipFacing
-				+ ANGLE_TO_FACING (QUADRANT));
-
+		cone_of_fire = NORMALIZE_FACING (planet_facing - StarShipPtr->ShipFacing
+			+ ANGLE_TO_FACING (QUADRANT));
+		
 		if (RDPtr->characteristics.thrust_increment !=
-				RDPtr->characteristics.max_thrust)
+			RDPtr->characteristics.max_thrust)
 			maneuver_state &= ~THRUST;
-
-				/* if not pointing towards planet */
+		
+		/* if not pointing towards planet */
 		if (cone_of_fire > ANGLE_TO_FACING (QUADRANT << 1))
 			desired_turn_angle = desired_thrust_angle;
-				/* if pointing directly at planet */
+		/* if pointing directly at planet */
 		else if (cone_of_fire == ANGLE_TO_FACING (QUADRANT)
-				&& NORMALIZE_FACING (ANGLE_TO_FACING (travel_angle)) != planet_facing)
+				 && NORMALIZE_FACING (ANGLE_TO_FACING (travel_angle)) != planet_facing)
 			desired_turn_angle = travel_angle;
 		else if (cone_of_fire == 0
-				|| cone_of_fire == ANGLE_TO_FACING (QUADRANT << 1)
-				|| (!(maneuver_state & THRUST)
-				&& (cone_of_fire < ANGLE_TO_FACING (OCTANT)
-				|| cone_of_fire > ANGLE_TO_FACING ((QUADRANT << 1) - OCTANT))))
+				 || cone_of_fire == ANGLE_TO_FACING (QUADRANT << 1)
+				 || (!(maneuver_state & THRUST)
+					 && (cone_of_fire < ANGLE_TO_FACING (OCTANT)
+						 || cone_of_fire > ANGLE_TO_FACING ((QUADRANT << 1) - OCTANT))))
 		{
 			desired_turn_angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 			if (NORMALIZE_ANGLE (desired_turn_angle
-					- travel_angle + QUADRANT) > HALF_CIRCLE)
+								 - travel_angle + QUADRANT) > HALF_CIRCLE)
 				desired_turn_angle = travel_angle;
 			if (ShipPtr->thrust_wait == 0)
 				maneuver_state |= THRUST;
 		}
-
+		
 		desired_thrust_angle = desired_turn_angle;
 	}
 	else
 	{
 		COUNT WRange;
-
+		
 		WRange = WEAPON_RANGE (
-				&RDPtr->cyborg_control
-				);
-
+							   &RDPtr->cyborg_control
+							   );
+		
 		cone_of_fire = NORMALIZE_ANGLE (desired_turn_angle
-				- EvalDescPtr->facing + OCTANT);
+										- EvalDescPtr->facing + OCTANT);
 		if (OtherObjPtr->state_flags & PLAYER_SHIP)
 		{
 			UWORD fire_flags, ship_flags;
 			COUNT facing;
 			STARSHIP *EnemyStarShipPtr;
-
+			
 			GetElementStarShip (OtherObjPtr, &EnemyStarShipPtr);
 			ship_flags = EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags;
 			for (fire_flags = FIRES_FORE, facing = EvalDescPtr->facing;
-					fire_flags <= FIRES_LEFT;
-					fire_flags <<= 1, facing += QUADRANT)
+				 fire_flags <= FIRES_LEFT;
+				 fire_flags <<= 1, facing += QUADRANT)
 			{
 				if
-				(
-						/* he's dangerous in this direction */
-					(ship_flags & fire_flags)
-						/* he's facing direction you want to go */
-					&& (cone_of_fire = NORMALIZE_ANGLE (
-					desired_turn_angle - facing + OCTANT
-					)) <= QUADRANT
-						/* he's moving */
-					&& ((other_delta_x != 0 || other_delta_y != 0)
-						/* he's coasting backwards */
-					&& NORMALIZE_ANGLE (
-					(GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
-					- facing + OCTANT) <= QUADRANT)
-				)
-				{
-						/* need to be close for a kill */
-					if (WRange < LONG_RANGE_WEAPON
-							&& EvalDescPtr->which_turn <= 32)
+					(
+					 /* he's dangerous in this direction */
+					 (ship_flags & fire_flags)
+					 /* he's facing direction you want to go */
+					 && (cone_of_fire = NORMALIZE_ANGLE (
+						desired_turn_angle - facing + OCTANT)) <= QUADRANT
+					 /* he's moving */
+					 && ((other_delta_x != 0 || other_delta_y != 0)
+						 /* he's coasting backwards */
+						 && NORMALIZE_ANGLE (
+											 (GetVelocityTravelAngle (&OtherVelocity) + HALF_CIRCLE)
+											 - facing + OCTANT) <= QUADRANT)
+					 )
+				{
+					/* need to be close for a kill */
+					if (WRange < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+						&& EvalDescPtr->which_turn <= 32)
 					{
 						/* catch him on the back side */
 						desired_thrust_angle = desired_turn_angle;
 						goto DoManeuver;
 					}
-
+					
 					break;
 				}
 			}
-
+			
 			if (EvalDescPtr->which_turn <= 8
-					&& RDPtr->characteristics.max_thrust <=
-					EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust)
+				&& RDPtr->characteristics.max_thrust <=
+				EnemyStarShipPtr->RaceDescPtr->characteristics.max_thrust)
 				goto DoManeuver;
 		}
-
+		
 		if
-		(
+			(
 #ifdef NOTYET
-			WRange < LONG_RANGE_WEAPON
-			&&
+			 WRange < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+			 &&
 #endif /* NOTYET */
-					/* not at full speed */
-			!(StarShipPtr->cur_status_flags
-			& (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
-			&& (PlotIntercept (
-					ShipPtr, OtherObjPtr, 40, CLOSE_RANGE_WEAPON << 1
-					)
+			 /* not at full speed */
+			 !(StarShipPtr->cur_status_flags
+			   & (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
+			 && (PlotIntercept (ShipPtr, OtherObjPtr, 40, (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR) << 1) // JMS_GFX
 #ifdef NOTYET
-			||
-			(
-					/* object's facing direction you want to go */
-				cone_of_fire <= QUADRANT
-					/* and you're basically going in that direction */
-				&& (travel_angle == FULL_CIRCLE
-				|| NORMALIZE_ANGLE (travel_angle
-				- desired_thrust_angle + QUADRANT) <= HALF_CIRCLE)
-					/* and object's in range */
-				&& PlotIntercept (ShipPtr, OtherObjPtr, 1, WRange)
-			)
+				 ||
+				 (
+				  /* object's facing direction you want to go */
+				  cone_of_fire <= QUADRANT
+				  /* and you're basically going in that direction */
+				  && (travel_angle == FULL_CIRCLE
+					  || NORMALIZE_ANGLE (travel_angle
+										  - desired_thrust_angle + QUADRANT) <= HALF_CIRCLE)
+				  /* and object's in range */
+				  && PlotIntercept (ShipPtr, OtherObjPtr, 1, WRange)
+				  )
 #endif /* NOTYET */
-			)
-		)
+				 )
+			 )
 		{
 			if
-			(
-					/* pointed straight at him */
-				NORMALIZE_ANGLE (desired_thrust_angle
-				- FACING_TO_ANGLE (StarShipPtr->ShipFacing) + OCTANT) <= QUADRANT
-					/* or not exposed to business end */
-				|| cone_of_fire > QUADRANT
-			)
+				(
+				 /* pointed straight at him */
+				 NORMALIZE_ANGLE (desired_thrust_angle
+								  - FACING_TO_ANGLE (StarShipPtr->ShipFacing) + OCTANT) <= QUADRANT
+				 /* or not exposed to business end */
+				 || cone_of_fire > QUADRANT
+				 )
 			{
 				desired_thrust_angle = desired_turn_angle;
 			}
@@ -920,78 +945,76 @@ Entice (ELEMENT *ShipPtr, EVALUATE_DESC
 			{
 #ifdef NOTYET
 				if
-				(
-					travel_angle != FULL_CIRCLE
-					&& NORMALIZE_ANGLE (travel_angle
-					- desired_turn_angle + OCTANT) <= QUADRANT
-				)
+					(
+					 travel_angle != FULL_CIRCLE
+					 && NORMALIZE_ANGLE (travel_angle
+										 - desired_turn_angle + OCTANT) <= QUADRANT
+					 )
 				{
 					desired_turn_angle =
-							NORMALIZE_ANGLE ((EvalDescPtr->facing + HALF_CIRCLE)
-							+ (travel_angle - desired_turn_angle));
+					NORMALIZE_ANGLE ((EvalDescPtr->facing + HALF_CIRCLE)
+									 + (travel_angle - desired_turn_angle));
 					if (!(maneuver_state & (LEFT | RIGHT)))
 						maneuver_state &= ~THRUST;
 				}
-
+				
 				if (maneuver_state & (LEFT | RIGHT))
 				{
 					TurnShip (ShipPtr, desired_turn_angle);
 					maneuver_state &= ~(LEFT | RIGHT);
 				}
 #endif /* NOTYET */
-
+				
 				desired_thrust_angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
-desired_turn_angle = desired_thrust_angle;
+				desired_turn_angle = desired_thrust_angle;
 			}
 		}
 		else if ((cone_of_fire = PlotIntercept (
-				ShipPtr, OtherObjPtr, 10, WRange
+												ShipPtr, OtherObjPtr, 10, WRange
 #ifdef OLD
-				- (WRange >> 3)
+												- (WRange >> 3)
 #else /* !OLD */
-				- (WRange >> 2)
+												- (WRange >> 2)
 #endif /* OLD */
-				)))
+												)))
 		{
 			if (RDPtr->characteristics.thrust_increment !=
-					RDPtr->characteristics.max_thrust
-							/* and already at full speed */
-					&& (StarShipPtr->cur_status_flags
+				RDPtr->characteristics.max_thrust
+				/* and already at full speed */
+				&& (StarShipPtr->cur_status_flags
 					& (SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED))
-							/* and facing away from enemy */
-					&& (NORMALIZE_ANGLE (desired_turn_angle
-					- ARCTAN (ship_delta_x, ship_delta_y)
-					+ (OCTANT + 2)) <= ((OCTANT + 2) << 1)
-							/* or not on collision course */
-					|| !PlotIntercept (
-							ShipPtr, OtherObjPtr, 30, CLOSE_RANGE_WEAPON << 1
-							)))
+				/* and facing away from enemy */
+				&& (NORMALIZE_ANGLE (desired_turn_angle
+									 - ARCTAN (ship_delta_x, ship_delta_y)
+									 + (OCTANT + 2)) <= ((OCTANT + 2) << 1)
+					/* or not on collision course */
+					|| !PlotIntercept (ShipPtr, OtherObjPtr, 30, (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR) << 1))) // JMS_GFX
 				maneuver_state &= ~THRUST;
-					/* veer off */
+			/* veer off */
 			else if (cone_of_fire == 1
-					|| RDPtr->characteristics.thrust_increment !=
-					RDPtr->characteristics.max_thrust)
+					 || RDPtr->characteristics.thrust_increment !=
+					 RDPtr->characteristics.max_thrust)
 			{
 				if (maneuver_state & (LEFT | RIGHT))
 				{
 					TurnShip (ShipPtr, desired_turn_angle);
 					maneuver_state &= ~(LEFT | RIGHT);
 				}
-
+				
 				if (NORMALIZE_ANGLE (desired_thrust_angle
-						- ARCTAN (ship_delta_x, ship_delta_y)
-						+ (OCTANT + 2)) <= ((OCTANT + 2) << 1))
+									 - ARCTAN (ship_delta_x, ship_delta_y)
+									 + (OCTANT + 2)) <= ((OCTANT + 2) << 1))
 					desired_thrust_angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 				else
 					desired_thrust_angle = desired_turn_angle;
 			}
 		}
 	}
-
+	
 DoManeuver:
 	if (maneuver_state & (LEFT | RIGHT))
 		TurnShip (ShipPtr, desired_thrust_angle);
-
+	
 	if (maneuver_state & THRUST)
 		ThrustShip (ShipPtr, desired_thrust_angle);
 }
@@ -1016,49 +1039,48 @@ tactical_intelligence (ComputerInputCont
 	STARSHIP *EnemyStarShipPtr;
 	RACE_DESC *RDPtr;
 	RACE_DESC *EnemyRDPtr;
-
+	
 	RDPtr = StarShipPtr->RaceDescPtr;
-
+	
 	if (RDPtr->cyborg_control.ManeuverabilityIndex == 0)
 		InitCyborg (StarShipPtr);
-
+	
 	LockElement (StarShipPtr->hShip, &ShipPtr);
 	if (RDPtr->ship_info.crew_level == 0
-			|| GetPrimType (&DisplayArray[ShipPtr->PrimIndex]) == NO_PRIM)
+		|| GetPrimType (&DisplayArray[ShipPtr->PrimIndex]) == NO_PRIM)
 	{
 		UnlockElement (StarShipPtr->hShip);
 		return (0);
 	}
-
+	
 	ShipMoved = TRUE;
 	/* Disable ship's special completely for the Standard AI */
 	if (StarShipPtr->control & STANDARD_RATING)
 		++StarShipPtr->special_counter;
-
+	
 #ifdef DEBUG_CYBORG
-if (!(ShipPtr->state_flags & FINITE_LIFE)
+	if (!(ShipPtr->state_flags & FINITE_LIFE)
 		&& ShipPtr->life_span == NORMAL_LIFE)
-	ShipPtr->life_span += 2; /* make ship invulnerable */
+		ShipPtr->life_span += 2; /* make ship invulnerable */
 #endif /* DEBUG_CYBORG */
 	Ship = *ShipPtr;
 	UnlockElement (StarShipPtr->hShip);
 	ShipFacing = StarShipPtr->ShipFacing;
-
+	
 	for (ConcernCounter = 0;
-			ConcernCounter <= FIRST_EMPTY_INDEX; ++ConcernCounter)
+		 ConcernCounter <= FIRST_EMPTY_INDEX; ++ConcernCounter)
 	{
 		ObjectsOfConcern[ConcernCounter].ObjectPtr = 0;
 		ObjectsOfConcern[ConcernCounter].MoveState = NO_MOVEMENT;
 		ObjectsOfConcern[ConcernCounter].which_turn = (COUNT)~0;
 	}
 	--ConcernCounter;
-
+	
 	UltraManeuverable = (BOOLEAN)(
-			RDPtr->characteristics.thrust_increment ==
-			RDPtr->characteristics.max_thrust
-			&& MANEUVERABILITY (&RDPtr->cyborg_control) >= MEDIUM_SHIP
-			);
-
+		RDPtr->characteristics.thrust_increment == RDPtr->characteristics.max_thrust
+		&& MANEUVERABILITY (&RDPtr->cyborg_control) >= RESOLUTION_COMPENSATED(MEDIUM_SHIP) // JMS_GFX
+		);
+	
 	if (Ship.turn_wait == 0)
 	{
 		ShipMoved = FALSE;
@@ -1069,65 +1091,65 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 		ShipMoved = FALSE;
 		StarShipPtr->ship_input_state &= ~THRUST;
 	}
-
+	
 	for (hElement = GetHeadElement ();
-			hElement != 0; hElement = hNextElement)
+		 hElement != 0; hElement = hNextElement)
 	{
 		EVALUATE_DESC ed;
-
+		
 		ed.MoveState = NO_MOVEMENT;
-
+		
 		LockElement (hElement, &ed.ObjectPtr);
 		hNextElement = GetSuccElement (ed.ObjectPtr);
 		if (CollisionPossible (ed.ObjectPtr, &Ship))
 		{
-			SIZE dx, dy;
-
+			SDWORD dx, dy;
+			
 			dx = ed.ObjectPtr->next.location.x
-					- Ship.next.location.x;
+				- Ship.next.location.x;
 			dy = ed.ObjectPtr->next.location.y
-					- Ship.next.location.y;
+				- Ship.next.location.y;
 			dx = WRAP_DELTA_X (dx);
 			dy = WRAP_DELTA_Y (dy);
 			if (GRAVITY_MASS (ed.ObjectPtr->mass_points))
 			{
 				COUNT maneuver_turn, ship_bounds;
-				RECT ship_footprint = {{0, 0}, {0, 0}};
-
+				RECT ship_footprint;
+				
 				if (UltraManeuverable)
 					maneuver_turn = 16;
-				else if (MANEUVERABILITY (&RDPtr->cyborg_control) <= MEDIUM_SHIP)
+				else if (MANEUVERABILITY (&RDPtr->cyborg_control) <= RESOLUTION_COMPENSATED(MEDIUM_SHIP)) // JMS_GFX
 					maneuver_turn = 48;
 				else
 					maneuver_turn = 32;
-
+				
 				GetFrameRect (SetAbsFrameIndex (
-						Ship.IntersectControl.IntersectStamp.frame, 0
-						), &ship_footprint);
+												Ship.IntersectControl.IntersectStamp.frame, 0
+												), &ship_footprint);
 				ship_bounds = (COUNT)(ship_footprint.extent.width
-						+ ship_footprint.extent.height);
-
+									  + ship_footprint.extent.height);
+				
 				if (!ShipMoved && (ed.which_turn =
-						PlotIntercept (ed.ObjectPtr, &Ship, maneuver_turn,
-						DISPLAY_TO_WORLD (30 + (ship_bounds * 3 /* << 2 */)))))
+								   PlotIntercept (ed.ObjectPtr, &Ship, maneuver_turn,
+												  DISPLAY_TO_WORLD ((30 << RESOLUTION_FACTOR) + (ship_bounds * 3 /* << 2 */))))) // JMS_GFX
 				{
 					if (ed.which_turn > 1
-							|| PlotIntercept (ed.ObjectPtr, &Ship, 1,
-							DISPLAY_TO_WORLD (35 + ship_bounds))
-							|| PlotIntercept (ed.ObjectPtr, &Ship,
-							maneuver_turn << 1,
-							DISPLAY_TO_WORLD (40 + ship_bounds)) > 1)
+						|| PlotIntercept (ed.ObjectPtr, &Ship, 1,
+										  DISPLAY_TO_WORLD ((35 << RESOLUTION_FACTOR) + ship_bounds)) // JMS_GFX
+						|| PlotIntercept (ed.ObjectPtr, &Ship,
+										  maneuver_turn << 1,
+										  DISPLAY_TO_WORLD ((40 << RESOLUTION_FACTOR) + ship_bounds)) > 1) // JMS_GFX
 					{
 						ed.facing = ARCTAN (-dx, -dy);
 						if (UltraManeuverable)
 							ed.MoveState = AVOID;
 						else // Try a gravity whip
 							ed.MoveState = ENTICE;
-
+						
 						ObjectsOfConcern[GRAVITY_MASS_INDEX] = ed;
 					}
 					else if (!UltraManeuverable &&
-							!IsVelocityZero (&Ship.velocity))
+							 !IsVelocityZero (&Ship.velocity))
 					{	// Try an orbital insertion, don't thrust
 						++Ship.thrust_wait;
 						if (Ship.turn_wait)
@@ -1141,54 +1163,56 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 				EnemyRDPtr = EnemyStarShipPtr->RaceDescPtr;
 				if (EnemyRDPtr->cyborg_control.ManeuverabilityIndex == 0)
 					InitCyborg (EnemyStarShipPtr);
-
-				ed.which_turn = WORLD_TO_TURN (
-						square_root ((long)dx * dx + (long)dy * dy));
-				if (ed.which_turn >
-						ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn)
+				
+				ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy)));
+				
+				//log_add(log_Debug,"SQR:%d (dx:%d), (dy:%d), norm:%d rezzed:%d", square_root ((long)dx * dx + (long)dy * dy), dx, dy, (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))), ed.which_turn);
+				
+				if ((ed.which_turn >> RESOLUTION_FACTOR) > ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn)
 				{
 					UnlockElement (hElement);
 					continue;
 				}
 				else if (ed.which_turn == 0)
 					ed.which_turn = 1;
-
+				
+				ed.which_turn >>= RESOLUTION_FACTOR; // JMS_GFX
+				
 				ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr = ed.ObjectPtr;
 				ObjectsOfConcern[ENEMY_SHIP_INDEX].facing =
 #ifdef MAYBE
-						OBJECT_CLOAKED (ed.ObjectPtr) ?
-						GetVelocityTravelAngle (&ed.ObjectPtr->velocity) :
+				OBJECT_CLOAKED (ed.ObjectPtr) ? GetVelocityTravelAngle (&ed.ObjectPtr->velocity) :
 #endif /* MAYBE */
-						FACING_TO_ANGLE (EnemyStarShipPtr->ShipFacing);
+				FACING_TO_ANGLE (EnemyStarShipPtr->ShipFacing);
 				ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn = ed.which_turn;
-
+				
 				if (ShipMoved
-						|| ed.ObjectPtr->mass_points > MAX_SHIP_MASS
-						|| (WEAPON_RANGE (&RDPtr->cyborg_control) < LONG_RANGE_WEAPON
-						&& (WEAPON_RANGE (&RDPtr->cyborg_control) <= CLOSE_RANGE_WEAPON
-						|| (WEAPON_RANGE (&EnemyRDPtr->cyborg_control) >= LONG_RANGE_WEAPON
-						&& (EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON))
-						|| (
+					|| ed.ObjectPtr->mass_points > MAX_SHIP_MASS
+					|| (WEAPON_RANGE (&RDPtr->cyborg_control) < (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+						&& (WEAPON_RANGE (&RDPtr->cyborg_control) <= (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)
+							|| (WEAPON_RANGE (&EnemyRDPtr->cyborg_control) >= (LONG_RANGE_WEAPON << RESOLUTION_FACTOR)
+								&& (EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON))
+							|| (
 #ifdef OLD
-						MANEUVERABILITY (&RDPtr->cyborg_control) <
-						MANEUVERABILITY (&EnemyRDPtr->cyborg_control)
+								MANEUVERABILITY (&RDPtr->cyborg_control) <
+								MANEUVERABILITY (&EnemyRDPtr->cyborg_control)
 #else /* !OLD */
-						RDPtr->characteristics.max_thrust <
-						EnemyRDPtr->characteristics.max_thrust
+								RDPtr->characteristics.max_thrust <
+								EnemyRDPtr->characteristics.max_thrust
 #endif /* !OLD */
-						&& WEAPON_RANGE (&RDPtr->cyborg_control) <
-						WEAPON_RANGE (&EnemyRDPtr->cyborg_control)))))
+								&& WEAPON_RANGE (&RDPtr->cyborg_control) <
+								WEAPON_RANGE (&EnemyRDPtr->cyborg_control)))))
 					ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = PURSUE;
 				else
 					ObjectsOfConcern[ENEMY_SHIP_INDEX].MoveState = ENTICE;
-
+				
 				if ((EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & IMMEDIATE_WEAPON)
-						&& ship_weapons (ed.ObjectPtr, &Ship, 0))
+					&& ship_weapons (ed.ObjectPtr, &Ship, 0))
 				{
 					ed.which_turn = 1;
 					ed.MoveState = AVOID;
 					ed.facing = ObjectsOfConcern[ENEMY_SHIP_INDEX].facing;
-
+					
 					ObjectsOfConcern[ENEMY_WEAPON_INDEX] = ed;
 				}
 			}
@@ -1196,64 +1220,49 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 			{
 				if (!(ed.ObjectPtr->state_flags & FINITE_LIFE))
 				{
-					ed.which_turn = WORLD_TO_TURN (
-							square_root ((long)dx * dx + (long)dy * dy)
-							);
-
-					if (ed.which_turn <
-							ObjectsOfConcern[FIRST_EMPTY_INDEX].which_turn)
+					ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX
+					
+					if (ed.which_turn < ObjectsOfConcern[FIRST_EMPTY_INDEX].which_turn)
 					{
 						ed.MoveState = PURSUE;
 						ed.facing = GetVelocityTravelAngle (
-								&ed.ObjectPtr->velocity
-								);
-
+									&ed.ObjectPtr->velocity);
+						
 						ObjectsOfConcern[FIRST_EMPTY_INDEX] = ed;
 					}
 				}
 			}
 			else if (!elementsOfSamePlayer (ed.ObjectPtr, &Ship)
-					&& ed.ObjectPtr->preprocess_func != crew_preprocess
-					&& ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn > 1
-					&& ed.ObjectPtr->life_span > 0)
+					 && ed.ObjectPtr->preprocess_func != crew_preprocess
+					 && ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn > 1
+					 && ed.ObjectPtr->life_span > 0)
 			{
 				GetElementStarShip (ed.ObjectPtr, &EnemyStarShipPtr);
 				EnemyRDPtr = EnemyStarShipPtr->RaceDescPtr;
 				if (((EnemyRDPtr->ship_info.ship_flags & SEEKING_WEAPON)
-						&& ed.ObjectPtr->next.image.farray !=
-						EnemyRDPtr->ship_data.special)
-						|| ((EnemyRDPtr->ship_info.ship_flags & SEEKING_SPECIAL)
+					 && ed.ObjectPtr->next.image.farray !=
+					 EnemyRDPtr->ship_data.special)
+					|| ((EnemyRDPtr->ship_info.ship_flags & SEEKING_SPECIAL)
 						&& ed.ObjectPtr->next.image.farray ==
 						EnemyRDPtr->ship_data.special))
 				{
 					if ((!(ed.ObjectPtr->state_flags & (FINITE_LIFE | CREW_OBJECT))
-							&& RDPtr->characteristics.max_thrust > DISPLAY_TO_WORLD (8))
-							|| NORMALIZE_ANGLE (GetVelocityTravelAngle (
-									&ed.ObjectPtr->velocity
-									) - ARCTAN (-dx, -dy)
-									+ QUADRANT) > HALF_CIRCLE)
+						 && RDPtr->characteristics.max_thrust > DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR)) // JMS_GFX
+						|| NORMALIZE_ANGLE (GetVelocityTravelAngle (
+							&ed.ObjectPtr->velocity
+							) - ARCTAN (-dx, -dy) + QUADRANT) > HALF_CIRCLE)
 						ed.which_turn = 0;
 					else
 					{
-						ed.which_turn = WORLD_TO_TURN (
-								square_root ((long)dx * dx + (long)dy * dy)
-								);
-
+						ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX;
+						
 						ed.MoveState = ENTICE;
-						if (UltraManeuverable)
-						{
-							if (ed.which_turn == 0)
-								ed.which_turn = 1;
-							else if (ed.which_turn > 16)
-								ed.which_turn = 0;
-						}
-						else if (ed.which_turn == 0)
+						
+						if (ed.which_turn == 0)
 							ed.which_turn = 1;
-						else if (ed.which_turn > 16
-								|| (MANEUVERABILITY (
-								&RDPtr->cyborg_control
-								) > MEDIUM_SHIP
-								&& ed.which_turn > 8))
+						/* Shiver: The cap on which_turn for seeking weapons raised from 16 to 20.
+						 The horrible cap of 8 for above-medium speed ships has been obliterated. */
+						else if (ed.which_turn > 20)
 							ed.which_turn = 0;
 					}
 				}
@@ -1262,44 +1271,41 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 				else
 				{
 					ed.which_turn =
-							PlotIntercept (ed.ObjectPtr,
-							&Ship, ed.ObjectPtr->life_span,
-							DISPLAY_TO_WORLD (40));
+					PlotIntercept (ed.ObjectPtr,
+						&Ship, ed.ObjectPtr->life_span,
+						DISPLAY_TO_WORLD (40 << RESOLUTION_FACTOR)); // JMS_GFX
 					ed.MoveState = AVOID;
 				}
-
+				
 				if (ed.which_turn > 0
-						&& (ed.which_turn <
+					&& (ed.which_turn <
 						ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn
 						|| (ed.which_turn ==
-						ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn
-						&& ed.MoveState == AVOID)))
+							ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn
+							&& ed.MoveState == AVOID)))
 				{
 					ed.facing = GetVelocityTravelAngle (
-							&ed.ObjectPtr->velocity
-							);
-
+									&ed.ObjectPtr->velocity);
+					
 					ObjectsOfConcern[ENEMY_WEAPON_INDEX] = ed;
 				}
 			}
 			else if ((ed.ObjectPtr->state_flags & CREW_OBJECT)
-					&& ((!(ed.ObjectPtr->state_flags & IGNORE_SIMILAR)
-					&& elementsOfSamePlayer (ed.ObjectPtr, &Ship))
-					|| ed.ObjectPtr->preprocess_func == crew_preprocess)
-					&& ObjectsOfConcern[CREW_OBJECT_INDEX].which_turn > 1)
+					 && ((!(ed.ObjectPtr->state_flags & IGNORE_SIMILAR)
+						  && elementsOfSamePlayer (ed.ObjectPtr, &Ship))
+						 || ed.ObjectPtr->preprocess_func == crew_preprocess)
+					 && ObjectsOfConcern[CREW_OBJECT_INDEX].which_turn > 1)
 			{
-				ed.which_turn = WORLD_TO_TURN (
-						square_root ((long)dx * dx + (long)dy * dy)
-						);
-
+				ed.which_turn = (WORLD_TO_TURN (square_root ((long)dx * dx + (long)dy * dy))) >> RESOLUTION_FACTOR; // JMS_GFX
+				
 				if (ed.which_turn == 0)
 					ed.which_turn = 1;
-
+				
 				if (ObjectsOfConcern[CREW_OBJECT_INDEX].which_turn >
-						ed.which_turn
-						&& (ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 32
+					ed.which_turn
+					&& (ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 32
 						|| (ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 8
-						&& StarShipPtr->hShip == ed.ObjectPtr->hTarget)))
+							&& StarShipPtr->hShip == ed.ObjectPtr->hTarget)))
 				{
 					ed.MoveState = PURSUE;
 					ed.facing = 0;
@@ -1309,17 +1315,17 @@ if (!(ShipPtr->state_flags & FINITE_LIFE
 		}
 		UnlockElement (hElement);
 	}
-
+	
 	RDPtr->cyborg_control.intelligence_func (&Ship, ObjectsOfConcern,
-			ConcernCounter);
+											 ConcernCounter);
 #ifdef DEBUG_CYBORG
-StarShipPtr->ship_input_state &= ~SPECIAL;
+	StarShipPtr->ship_input_state &= ~SPECIAL;
 #endif /* DEBUG_CYBORG */
-
+	
 	StarShipPtr->ShipFacing = ShipFacing;
 	{
 		BATTLE_INPUT_STATE InputState;
-
+		
 		InputState = 0;
 		if (StarShipPtr->ship_input_state & LEFT)
 			InputState |= BATTLE_LEFT;
@@ -1331,7 +1337,7 @@ StarShipPtr->ship_input_state &= ~SPECIA
 			InputState |= BATTLE_WEAPON;
 		if (StarShipPtr->ship_input_state & SPECIAL)
 			InputState |= BATTLE_SPECIAL;
-
+		
 		(void) context;
 		return (InputState);
 	}
diff -ruNp src.orig/uqm/element.h src/uqm/element.h
--- src.orig/uqm/element.h	2017-12-30 00:14:40 -0800
+++ src/uqm/element.h	2017-12-30 00:14:52 -0800
@@ -196,7 +196,7 @@ extern PRIMITIVE DisplayArray[MAX_DISPLA
 #define MAX_ENERGY_SIZE 42
 #define MAX_SHIP_MASS 10
 #define GRAVITY_MASS(m) ((m) > MAX_SHIP_MASS * 10)
-#define GRAVITY_THRESHOLD (COUNT)255
+#define GRAVITY_THRESHOLD (COUNT)(255 << RESOLUTION_FACTOR) // JMS_GFX
 
 #define OBJECT_CLOAKED(eptr) \
 		(GetPrimType (&GLOBAL (DisplayArray[(eptr)->PrimIndex])) >= NUM_PRIMS \
@@ -230,7 +230,7 @@ extern COUNT PlotIntercept (ELEMENT *Ele
 		ELEMENT *ElementPtr1, COUNT max_turns, COUNT margin_of_error);
 
 extern void InitGalaxy (void);
-extern void MoveGalaxy (VIEW_STATE view_state, SIZE dx, SIZE dy);
+extern void MoveGalaxy (VIEW_STATE view_state, SDWORD dx, SDWORD dy);
 
 extern BOOLEAN CalculateGravity (ELEMENT *ElementPtr);
 
diff -ruNp src.orig/uqm/encount.c src/uqm/encount.c
--- src.orig/uqm/encount.c	2017-12-30 00:14:40 -0800
+++ src/uqm/encount.c	2017-12-30 00:14:52 -0800
@@ -39,6 +39,7 @@
 #include "settings.h"
 #include "setup.h"
 #include "sounds.h"
+#include "util.h" // JMS: For SaveContextFrame()
 #include "libs/graphics/gfx_common.h"
 #include "libs/log.h"
 #include "libs/mathlib.h"
@@ -290,7 +291,7 @@ InitEncounter (void)
 
 //    t.baseline.x = SIS_SCREEN_WIDTH >> 1;
 	t.baseline.x = (SIS_SCREEN_WIDTH >> 1) + 1;
-	t.baseline.y = 10;
+	t.baseline.y = 10 << RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_CENTER;
 
 	SetContextFont (MicroFont);
@@ -302,7 +303,7 @@ InitEncounter (void)
 				// "ENCOUNTER IN"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
 		t.pStr = GAME_STRING (ENCOUNTER_STRING_BASE + 1);
 				// "DEEP SPACE"
 		t.CharCount = (COUNT)~0;
@@ -316,12 +317,12 @@ InitEncounter (void)
 				// "ENCOUNTER AT"
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
 		GetClusterName (CurStarDescPtr, buf);
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
-		t.baseline.y += 12;
+		t.baseline.y += 12 << RESOLUTION_FACTOR; // JMS_GFX
 		t.pStr = GLOBAL_SIS (PlanetName);
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
@@ -371,9 +372,14 @@ InitEncounter (void)
 						+ (long)s.origin.y * s.origin.y)
 						+ ((i / NUM_DISPLAY_PTS) * 18);
 
+				radius <<= RESOLUTION_FACTOR; // JMS_GFX
+
 				angle = ARCTAN (s.origin.x, s.origin.y);
-				s.origin.x = COSINE (angle, radius);
-				s.origin.y = SINE (angle, radius);
+				s.origin.x = (COSINE (angle, radius));
+				s.origin.y = (SINE (angle, radius));
+			} else {
+				s.origin.x <<= RESOLUTION_FACTOR; // JMS_GFX
+				s.origin.y <<= RESOLUTION_FACTOR; // JMS_GFX
 			}
 			s.frame = SetAbsFrameIndex (FragPtr->icons, 0);
 			GetFrameRect (s.frame, &r);
@@ -414,6 +420,7 @@ DrawFadeText (const UNICODE *str1, const
 	SIZE i;
 	DWORD TimeIn;
 	TEXT t1, t2;
+	RECT r1, r2;
 	static const Color fade_cycle[] =
 	{
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x0A, 0x0A), 0x1D),
@@ -426,13 +433,13 @@ DrawFadeText (const UNICODE *str1, const
 	};
 #define NUM_FADES (sizeof (fade_cycle) / sizeof (fade_cycle[0]))
 
-	t1.baseline.x = pRect->corner.x + 100;
-	t1.baseline.y = pRect->corner.y + 45;
+	t1.baseline.x = pRect->corner.x + (100 << RESOLUTION_FACTOR); // JMS_GFX
+	t1.baseline.y = pRect->corner.y + (45 << RESOLUTION_FACTOR); // JMS_GFX
 	t1.align = ALIGN_CENTER;
 	t1.pStr = str1;
 	t1.CharCount = (COUNT)~0;
 	t2 = t1;
-	t2.baseline.y += 11;
+	t2.baseline.y += 11 << RESOLUTION_FACTOR; // JMS_GFX
 	t2.pStr = str2;
 
 	FlushInput ();
@@ -465,9 +472,11 @@ DrawFadeText (const UNICODE *str1, const
 			TimeIn = GetTimeCounter ();
 		}
 		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
-		font_DrawText (&t1);
-		font_DrawText (&t2);
+				BUILD_COLOR_RGBA (0x50, 0x50, 0x50, 0xff));
+		TextRect(&t1, &r1, NULL);
+		TextRect(&t2, &r2, NULL);
+		DrawFilledRectangle (&r1);
+		DrawFilledRectangle (&r2);
 	}
 }
 
@@ -494,19 +503,19 @@ UninitEncounter (void)
 	else
 	{
 		BOOLEAN Sleepy;
-		SIZE VictoryState;
+		SIZE VictoryState, i;
 		COUNT RecycleAmount = 0;
-		SIZE i;
-		RECT r;
+		RECT r, save_r;
 		RECT scavenge_r = {{0, 0}, {0, 0}};
 		TEXT t;
-		STAMP ship_s;
+		STAMP ship_s, saveMetallicFrame;
 		const UNICODE *str1 = NULL;
 		const UNICODE *str2 = NULL;
 		StatMsgMode prevMsgMode;
 		UNICODE buf[80];
 		HSHIPFRAG hStarShip;
 		SHIP_FRAGMENT *FragPtr;
+
 		static const Color fade_ship_cycle[] =
 		{
 			BUILD_COLOR (MAKE_RGB15_INIT (0x07, 0x00, 0x00), 0x2F),
@@ -605,8 +614,8 @@ UninitEncounter (void)
 
 								DrawStatusMessage (NULL);
 								
-								ship_s.origin.x = scavenge_r.corner.x + 32;
-								ship_s.origin.y = scavenge_r.corner.y + 56;
+								ship_s.origin.x = scavenge_r.corner.x + (32 << RESOLUTION_FACTOR); // JMS_GFX
+								ship_s.origin.y = scavenge_r.corner.y + (56 << RESOLUTION_FACTOR); // JMS_GFX
 								ship_s.frame = IncFrameIndex (FragPtr->icons);
 								DrawStamp (&ship_s);
 								SetContextForeGroundColor (
@@ -618,13 +627,28 @@ UninitEncounter (void)
 								// XXX: this will not work with UTF-8 strings
 								strupr (buf);
 
-								t.baseline.x = scavenge_r.corner.x + 100;
-								t.baseline.y = scavenge_r.corner.y + 68;
+								// JMS: Handling the a-umlaut and o-umlaut characters
+								{
+									unsigned char *ptr;
+									ptr = (unsigned char*)buf;
+									while (*ptr) {
+										if (*ptr == 0xc3) {
+											ptr++;
+											if (*ptr == 0xb6 || *ptr == 0xa4) {
+												*ptr += 'A' - 'a';
+											}
+										}
+										ptr++;
+									}
+								}
+
+								t.baseline.x = scavenge_r.corner.x + (100 << RESOLUTION_FACTOR); // JMS_GFX
+								t.baseline.y = scavenge_r.corner.y + (68 << RESOLUTION_FACTOR); // JMS_GFX
 								t.align = ALIGN_CENTER;
 								t.pStr = buf;
 								t.CharCount = (COUNT)~0;
 								font_DrawText (&t);
-								t.baseline.y += 6;
+								t.baseline.y += 6 << RESOLUTION_FACTOR; // JMS_GFX
 								t.pStr = GAME_STRING (
 										ENCOUNTER_STRING_BASE + 3);
 										// "BATTLE GROUP"
@@ -634,6 +658,24 @@ UninitEncounter (void)
 								ship_s.frame = FragPtr->icons;
 
 								SetContextFont (MicroFont);
+
+								// JMS: Let's store the rectangle behind "Enemy ships destroyed" (before drawing the text on it).
+								if (RESOLUTION_FACTOR != 0)
+								{
+									// These values are inferred from DrawFadeText.
+									// However, they're not the same (100 and 45) because the text there is centered,
+									// but these rect coords are for the upper-left corner, not center.
+									save_r.corner.x = scavenge_r.corner.x + (70 << RESOLUTION_FACTOR); // JMS_GFX
+									save_r.corner.y = scavenge_r.corner.y + (35 << RESOLUTION_FACTOR); // JMS_GFX
+									
+									// These are wild-assed guesses.
+									save_r.extent.width  = 60 << RESOLUTION_FACTOR;
+									save_r.extent.height = 30 << RESOLUTION_FACTOR; 
+									
+									// Now that we have the size and placement of the rectangle, let's store it.
+									saveMetallicFrame = SaveContextFrame (&save_r);
+								}
+
 								str1 = GAME_STRING (
 										ENCOUNTER_STRING_BASE + 4);
 										// "Enemy Ships"
@@ -643,23 +685,23 @@ UninitEncounter (void)
 								DrawFadeText (str1, str2, TRUE, &scavenge_r);
 							}
 
-							r.corner.y = scavenge_r.corner.y + 9;
-							r.extent.height = 22;
+							r.corner.y = scavenge_r.corner.y + (9 << RESOLUTION_FACTOR); // JMS_GFX
+							r.extent.height = 22 << RESOLUTION_FACTOR; // JMS_GFX
 
 							SetContextForeGroundColor (BLACK_COLOR);
 
-							r.extent.width = 34;
+							r.extent.width = 34 << RESOLUTION_FACTOR; // JMS_GFX
 							r.corner.x = scavenge_r.corner.x +
 									scavenge_r.extent.width
-									- (10 + r.extent.width);
+									- ((10 << RESOLUTION_FACTOR) + r.extent.width); // JMS_GFX
 							DrawFilledRectangle (&r);
 
 							/* collect bounty ResUnits */
 							j = race_bounty[EncounterRace] >> 3;
 							RecycleAmount += j;
 							sprintf (buf, "%u", RecycleAmount);
-							t.baseline.x = r.corner.x + r.extent.width - 1;
-							t.baseline.y = r.corner.y + 14;
+							t.baseline.x = r.corner.x + r.extent.width - 1 - 5 * RESOLUTION_FACTOR; // JMS_GFX;
+							t.baseline.y = r.corner.y + (14 << RESOLUTION_FACTOR); // JMS_GFX
 							t.align = ALIGN_RIGHT;
 							t.pStr = buf;
 							t.CharCount = (COUNT)~0;
@@ -669,17 +711,17 @@ UninitEncounter (void)
 							DeltaSISGauges (0, 0, j);
 
 							if ((VictoryState++ - 1) % MAX_DEAD_DISPLAYED)
-								ship_s.origin.x += 17;
+								ship_s.origin.x += (17 << RESOLUTION_FACTOR); // JMS_GFX
 							else
 							{
 								SetContextForeGroundColor (BLACK_COLOR);
 
-								r.corner.x = scavenge_r.corner.x + 10;
-								r.extent.width = 104;
+								r.corner.x = scavenge_r.corner.x + (10 << RESOLUTION_FACTOR); // JMS_GFX
+								r.extent.width = (104 << RESOLUTION_FACTOR); // JMS_GFX
 								DrawFilledRectangle (&r);
 
-								ship_s.origin.x = r.corner.x + 2;
-								ship_s.origin.y = scavenge_r.corner.y + 12;
+								ship_s.origin.x = r.corner.x + (2 << RESOLUTION_FACTOR); // JMS_GFX
+								ship_s.origin.y = scavenge_r.corner.y + (12 << RESOLUTION_FACTOR); // JMS_GFX
 							}
 
 							if (Sleepy)
@@ -699,6 +741,20 @@ UninitEncounter (void)
 									Time = GetTimeCounter ();
 								}
 							}
+
+							if (RESOLUTION_FACTOR > 0) {
+								SetContextForeGroundColor (BLACK_COLOR);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+								DrawFilledStamp (&ship_s);
+							}
+
 							DrawStamp (&ship_s);
 						}
 					}
@@ -728,13 +784,13 @@ UninitEncounter (void)
 				if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 				{
 					SetContextForeGroundColor (BLACK_COLOR);
-					r.corner.x = scavenge_r.corner.x + 10;
-					r.extent.width = 132;
+					r.corner.x = scavenge_r.corner.x + (10 << RESOLUTION_FACTOR); // JMS_GFX
+					r.extent.width = 132 << RESOLUTION_FACTOR; // JMS_GFX
 					DrawFilledRectangle (&r);
 					sprintf (buf, "%u %s", RecycleAmount,
 							GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
 					t.baseline.x = r.corner.x + (r.extent.width >> 1);
-					t.baseline.y = r.corner.y + 14;
+					t.baseline.y = r.corner.y + (14 << RESOLUTION_FACTOR); // JMS_GFX
 					t.align = ALIGN_CENTER;
 					t.pStr = buf;
 					t.CharCount = (COUNT)~0;
@@ -746,10 +802,20 @@ UninitEncounter (void)
 							// "Debris"
 					str2 = GAME_STRING (ENCOUNTER_STRING_BASE + 7);
 							// "Scavenged"
+
+					// JMS: Now we draw the clean metallic frame to erase the "Enemy ships destroyed"
+					// text before drawing "debris scavenged."
+					if(RESOLUTION_FACTOR != 0)
+						DrawStamp (&saveMetallicFrame);
+
 					DrawFadeText (str1, str2, TRUE, &scavenge_r);
 					WaitForAnyButton (TRUE, ONE_SECOND * 2, FALSE);
 					if (!CurrentInputState.key[PlayerControls[0]][KEY_ESCAPE])
 						DrawFadeText (str1, str2, FALSE, &scavenge_r);
+
+					// JMS: The final cleanup of the "Debris scavenged". Without this, an ugly grey ghost-text would remain.
+					if(RESOLUTION_FACTOR != 0)
+						DrawStamp (&saveMetallicFrame);
 				}
 			}
 
diff -ruNp src.orig/uqm/flash.c src/uqm/flash.c
--- src.orig/uqm/flash.c	2017-12-30 00:14:40 -0800
+++ src/uqm/flash.c	2017-12-30 00:14:52 -0800
@@ -159,7 +159,7 @@ Flash_createOverlay (CONTEXT gfxContext,
 		context->rect.extent.width = 0;
 		context->rect.extent.height = 0;
 	} else
-		Flash_setOverlay (context, origin, overlay);
+		Flash_setOverlay (context, origin, overlay, FALSE);
 	
 	return context;
 }
@@ -453,18 +453,23 @@ Flash_getRect (FlashContext *context, RE
 	*rect = context->rect;
 }
 
+// JMS_GFX: The cleanup boolean can be used when changing between normal and hi-res modes.
+// It ensures that an ugly wrong-sized flash overlay from previous resolution is cleaned
+// from the flash process.
 void
-Flash_setOverlay (FlashContext *context, const POINT *origin, FRAME overlay)
+Flash_setOverlay (FlashContext *context, const POINT *origin, FRAME overlay, BOOLEAN cleanup)
 {
 	assert(context->type == FlashType_overlay);
 
-	if (context->started)
+	if (context->started && !cleanup)
 	{
 		Flash_drawFrame (context, context->original);
 		Flash_clearCache (context);
 	}
 	
-	context->u.overlay.frame = overlay;
+	if (!cleanup)
+		context->u.overlay.frame = overlay;
+
 	GetFrameRect (overlay, &context->rect);
 	context->rect.corner.x += origin->x;
 	context->rect.corner.y += origin->y;
diff -ruNp src.orig/uqm/flash.h src/uqm/flash.h
--- src.orig/uqm/flash.h	2017-12-30 00:14:40 -0800
+++ src/uqm/flash.h	2017-12-30 00:14:52 -0800
@@ -209,7 +209,7 @@ TimeCount Flash_nextTime (FlashContext *
 void Flash_setRect (FlashContext *context, const RECT *rect);
 void Flash_getRect (FlashContext *context, RECT *rect);
 void Flash_setOverlay(FlashContext *context, const POINT *origin,
-		FRAME overlay);
+		FRAME overlay, BOOLEAN cleanup); // JMS_GFX
 void Flash_preUpdate (FlashContext *context);
 void Flash_postUpdate (FlashContext *context);
 void Flash_setCacheSize (FlashContext *context, COUNT size);
diff -ruNp src.orig/uqm/fmv.c src/uqm/fmv.c
--- src.orig/uqm/fmv.c	2017-12-30 00:14:40 -0800
+++ src/uqm/fmv.c	2017-12-30 00:14:52 -0800
@@ -33,8 +33,7 @@
 void
 DoShipSpin (COUNT index, MUSIC_REF hMusic)
 {
-#ifdef WANT_SHIP_SPINS
-	char vnbuf[32];
+	char vnbuf[24]; // From 32 to 24
 	RECT old_r;
 
 	LoadIntoExtraScreen (NULL);
@@ -44,9 +43,9 @@ DoShipSpin (COUNT index, MUSIC_REF hMusi
 	FlushColorXForms ();
 #endif
 	
-	if (hMusic)
+	if (hMusic){
 		StopMusic ();
-
+	}
 	FreeHyperData ();
 
 	// TODO: It would be nice to have better resource names for these.
@@ -61,15 +60,11 @@ DoShipSpin (COUNT index, MUSIC_REF hMusi
 	DrawFromExtraScreen (NULL);
 	SetContextClipRect (&old_r);
 
-	if (hMusic)
+	if (hMusic){
 		PlayMusic (hMusic, TRUE, 1);
-		
+	}
 	SleepThreadUntil (FadeScreen (FadeAllToColor, ONE_SECOND / 4));
 	FlushColorXForms ();
-#else
-	(void) index;  /* Satisfy compiler */
-	(void) hMusic;  /* Satisfy compiler */
-#endif  /* WANT_SHIP_SPINS */
 }
 
 void
@@ -81,7 +76,19 @@ SplashScreen (void (* DoProcessing)(DWOR
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 120));
 	SetContext (ScreenContext);
 	s.origin.x = s.origin.y = 0;
-	s.frame = CaptureDrawable (LoadGraphic (TITLE_ANIM));
+
+	//DC: Title Splashscreen.
+	if (resolutionFactor < 1) {
+		printf("Loading 1x Splashscreen\n");
+		s.frame = CaptureDrawable (LoadGraphic (TITLE_ANIM));
+	} else if (resolutionFactor == 1) {
+		printf("Loading 2x Splashscreen\n");
+		s.frame = CaptureDrawable (LoadGraphic (TITLE_2X));
+	} else if(resolutionFactor > 1) {
+		printf("Loading 4x Splashscreen\n");
+		s.frame = CaptureDrawable (LoadGraphic (TITLE_4X));
+	}
+
 	DrawStamp (&s);
 	DestroyDrawable (ReleaseDrawable (s.frame));
 
@@ -129,6 +136,20 @@ Victory (void)
 		
 	FadeScreen (FadeAllToBlack, 0);
 }
+ 
+void
+Logo (void)
+{
+	ShowPresentation (LOGOPRES_STRTAB);
+	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
+}
+
+void
+Drumall (void)
+{
+	ShowPresentation (DRUMALLPRES_STRTAB);
+	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND / 2));
+}
 
 
 
diff -ruNp src.orig/uqm/fmv.h src/uqm/fmv.h
--- src.orig/uqm/fmv.h	2017-12-30 00:14:40 -0800
+++ src/uqm/fmv.h	2017-12-30 00:14:52 -0800
@@ -25,12 +25,12 @@
 extern "C" {
 #endif
 
-#define WANT_SHIP_SPINS
-
 extern void SplashScreen (void (* DoProcessing)(DWORD TimeOut));
 extern void Introduction (void);
 extern void Victory (void);
 extern void DoShipSpin (COUNT index, MUSIC_REF hMusic);
+extern void Logo (void);
+extern void Drumall (void);
 
 extern BOOLEAN ShowPresentation (RESOURCE presentation);
 
diff -ruNp src.orig/uqm/galaxy.c src/uqm/galaxy.c
--- src.orig/uqm/galaxy.c	2017-12-30 00:14:40 -0800
+++ src/uqm/galaxy.c	2017-12-30 00:14:52 -0800
@@ -41,8 +41,8 @@ extern PRIM_LINKS DisplayLinks;
 			+ MED_STAR_COUNT \
 			+ SML_STAR_COUNT)
 
-POINT SpaceOrg;
-static POINT log_star_array[NUM_STARS];
+DPOINT SpaceOrg;
+static DPOINT log_star_array[NUM_STARS];
 
 #define NUM_STAR_PLANES 3
 
@@ -50,9 +50,9 @@ typedef struct
 {
 	COUNT min_star_index;
 	COUNT num_stars;
-	POINT *star_array;
-	POINT *pmin_star;
-	POINT *plast_star;
+	DPOINT *star_array;
+	DPOINT *pmin_star;
+	DPOINT *plast_star;
 } STAR_BLOCK;
 
 STAR_BLOCK StarBlock[NUM_STAR_PLANES] =
@@ -87,7 +87,7 @@ SortStarBlock (STAR_BLOCK *pStarBlock)
 		{
 			if (pStarBlock->star_array[i].y > pStarBlock->star_array[j].y)
 			{
-				POINT temp;
+				DPOINT temp;
 
 				temp = pStarBlock->star_array[i];
 				pStarBlock->star_array[i] = pStarBlock->star_array[j];
@@ -103,11 +103,11 @@ SortStarBlock (STAR_BLOCK *pStarBlock)
 }
 
 static void
-WrapStarBlock (SIZE plane, SIZE dx, SIZE dy)
+WrapStarBlock (SIZE plane, SDWORD dx, SDWORD dy)
 {
 	COUNT i;
-	POINT *ppt;
-	SIZE offs_y;
+	DPOINT *ppt;
+	SDWORD offs_y;
 	COUNT num_stars;
 	STAR_BLOCK *pStarBlock;
 
@@ -237,8 +237,9 @@ void
 InitGalaxy (void)
 {
 	COUNT i, factor;
-	POINT *ppt;
+	DPOINT *ppt;
 	PRIM_LINKS Links;
+	BOOLEAN HSorQS = (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1 ? FALSE : TRUE);
 
 	log_add (log_Debug, "InitGalaxy(): transition_width = %d, "
 			"transition_height = %d",
@@ -255,28 +256,40 @@ InitGalaxy (void)
 		if (i == BIG_STAR_COUNT || i == BIG_STAR_COUNT + MED_STAR_COUNT)
 			++factor;
 
-		ppt->x = (COORD)((UWORD)TFB_Random () % SPACE_WIDTH) << factor;
-		ppt->y = (COORD)((UWORD)TFB_Random () % SPACE_HEIGHT) << factor;
+		ppt->x = (SDWORD)((UWORD)TFB_Random () % SPACE_WIDTH) << factor;
+		ppt->y = (SDWORD)((UWORD)TFB_Random () % SPACE_HEIGHT) << factor;
 
 		if (i < BIG_STAR_COUNT + MED_STAR_COUNT)
 		{
 			SetPrimType (&DisplayArray[p], STAMP_PRIM);
 			SetPrimColor (&DisplayArray[p],
 					BUILD_COLOR (MAKE_RGB15 (0x0B, 0x0B, 0x1F), 0x09));
-			DisplayArray[p].Object.Stamp.frame = stars_in_space;
+			// JMS_GFX: This was originally only "DisplayArray[p].Object.Stamp.frame = stars_in_space;"
+			if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				DisplayArray[p].Object.Stamp.frame = stars_in_space;
+			else
+				DisplayArray[p].Object.Stamp.frame = stars_in_quasispace;
 		}
 		else
 		{
-			SetPrimType (&DisplayArray[p], POINT_PRIM);
-			if (!inHQSpace ())
-				SetPrimColor (&DisplayArray[p],
-						BUILD_COLOR (MAKE_RGB15 (0x15, 0x15, 0x15), 0x07));
-			else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
-				SetPrimColor (&DisplayArray[p],
-						BUILD_COLOR (MAKE_RGB15 (0x14, 0x00, 0x00), 0x8C));
-			else
-				SetPrimColor (&DisplayArray[p],
-						BUILD_COLOR (MAKE_RGB15 (0x00, 0x0E, 0x00), 0x8C));
+			if(RESOLUTION_FACTOR > 0){
+				// In HD the starpoints in HS and QS are images
+				SetPrimType (&DisplayArray[p], STAMP_PRIM);
+				if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE){
+					SetPrimType (&DisplayArray[p], POINT_PRIM);
+					SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x15, 0x15, 0x15), 0x07));
+				} else
+					DisplayArray[p].Object.Stamp.frame = SetAbsFrameIndex (StarPoints, HSorQS);
+			} else {
+				// Pixel starpoints in original res
+				SetPrimType (&DisplayArray[p], POINT_PRIM);
+				if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+					SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x15, 0x15, 0x15), 0x07));
+				else if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+					SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x14, 0x00, 0x00), 0x8C));
+				else
+					SetPrimColor (&DisplayArray[p], BUILD_COLOR (MAKE_RGB15 (0x00, 0x0E, 0x00), 0x8C));
+			}
 		}
 
 		InsertPrim (&Links, p, GetPredLink (Links));
@@ -288,7 +301,7 @@ InitGalaxy (void)
 }
 
 static BOOLEAN
-CmpMovePoints (const POINT *pt1, const POINT *pt2, SIZE dx, SIZE dy,
+CmpMovePoints (const POINT *pt1, const DPOINT *pt2, SDWORD dx, SDWORD dy,
 			   SIZE reduction)
 {
 	if (optMeleeScale == TFB_SCALE_STEP)
@@ -304,7 +317,7 @@ CmpMovePoints (const POINT *pt1, const P
 }
 
 void
-MoveGalaxy (VIEW_STATE view_state, SIZE dx, SIZE dy)
+MoveGalaxy (VIEW_STATE view_state, SDWORD dx, SDWORD dy)
 {
 	PRIMITIVE *pprim;
 	static const COUNT star_counts[] =
@@ -317,14 +330,19 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 
 	if (view_state != VIEW_STABLE)
 	{
-		COUNT reduction;
-		COUNT i;
-		COUNT iss;
-		POINT *ppt;
+		COUNT reduction, i, iss;
+		DPOINT *ppt;
+		FRAME tempframe;
 		int wrap_around;
 
 		reduction = zoom_out;
 
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+			tempframe = stars_in_space;
+		else
+			tempframe = stars_in_quasispace;
+
 		if (view_state == VIEW_CHANGE)
 		{
 			if (inHQSpace ())
@@ -334,7 +352,7 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 					for (i = star_counts[iss]; i > 0; --i, ++pprim)
 					{
 						pprim->Object.Stamp.frame =	SetAbsFrameIndex (
-								stars_in_space,
+								tempframe,
 									(COUNT)(TFB_Random () & 31)
 									+ star_frame_ofs[iss]);
 					}
@@ -343,7 +361,7 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 			else
 			{
 				GRAPHICS_PRIM star_object[2];
-				FRAME star_frame[2];
+				FRAME star_frame[9]; // JMS_GFX: was 2. Added extra frames for more star .pngs.
 
 				star_frame[0] = IncFrameIndex (stars_in_space);
 				star_frame[1] = stars_in_space;
@@ -366,20 +384,65 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 					star_object[1] = POINT_PRIM;
 					if (reduction > (1 << ZOOM_SHIFT))
 					{
-						star_object[0] = POINT_PRIM;
+						// JMS_GFX: In hi-res modes, Closest stars are images when zoomed out.
+						if (RESOLUTION_FACTOR == 0)
+							star_object[0] = POINT_PRIM;
+						else
+						{
+							star_object[0] = STAMP_PRIM;
+							star_object[1] = STAMP_PRIM;
+							star_frame[0] = stars_in_space;
+							star_frame[1] = IncFrameIndex (stars_in_space);
+							
+						}
 					}
 					else
 					{
 						star_object[0] = STAMP_PRIM;
+						star_object[1] = STAMP_PRIM;
 					}
 				}
 
-				for (iss = 0, pprim = DisplayArray; iss < 2; ++iss)
+				// Normal handling of stars in 320x240.
+				if (RESOLUTION_FACTOR == 0)
 				{
-					for (i = star_counts[iss]; i > 0; --i, ++pprim)
+					for (iss = 0, pprim = DisplayArray; iss < 2; ++iss)
+					{
+						for (i = star_counts[iss]; i > 0; --i, ++pprim)
+						{
+							SetPrimType (pprim, star_object[iss]);
+							pprim->Object.Stamp.frame = star_frame[iss];
+						}
+					}
+				}
+				
+				// JMS_GFX: Advanced handling of stars in hi-res modes.
+				// Basically, draw a BIG star .png when zoomed close in
+				// medium-sized when at med distance and a small .png when far away.
+				else
+				{
+					COUNT zoomlevel;
+					COUNT med_sml_zoom_limit = optMeleeScale == TFB_SCALE_STEP ? 0 : (1 << (ZOOM_SHIFT + 1));
+					
+					if (reduction == MAX_ZOOM_OUT)
+						zoomlevel = 0;
+					else if (reduction <= med_sml_zoom_limit)
+						zoomlevel = 6;
+					else
+						zoomlevel = 3;
+					
+					for (i = 3; i < 9; i++)
+					{
+						star_frame[i] = SetAbsFrameIndex (stars_in_space, i);
+					}
+				
+					for (iss = 0, pprim = DisplayArray; iss < 2; ++iss)
 					{
-						SetPrimType (pprim, star_object[iss]);
-						pprim->Object.Stamp.frame = star_frame[iss];
+						for (i = star_counts[iss]; i > 0; --i, ++pprim)
+						{
+							SetPrimType (pprim, star_object[iss]);
+							pprim->Object.Stamp.frame = star_frame[iss + zoomlevel];
+						}
 					}
 				}
 			}
@@ -417,10 +480,10 @@ MoveGalaxy (VIEW_STATE view_state, SIZE
 		}
 		else
 		{
-			dx = (COORD)(LOG_SPACE_WIDTH >> 1)
+			dx = (SDWORD)(LOG_SPACE_WIDTH >> 1)
 					- (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1)
 					- MAX_VIS_REDUCTION));
-			dy = (COORD)(LOG_SPACE_HEIGHT >> 1)
+			dy = (SDWORD)(LOG_SPACE_HEIGHT >> 1)
 					- (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1)
 					- MAX_VIS_REDUCTION));
 			if (optMeleeScale == TFB_SCALE_STEP)
diff -ruNp src.orig/uqm/gameev.c src/uqm/gameev.c
--- src.orig/uqm/gameev.c	2017-12-30 00:14:40 -0800
+++ src/uqm/gameev.c	2017-12-30 00:14:52 -0800
@@ -29,9 +29,9 @@
 #include "libs/compiler.h"
 #include "libs/log.h"
 #include "libs/mathlib.h"
-
+#include "options.h"
 #include <stdlib.h>
-
+#include "setup.h"
 
 static int arilou_entrance_event (int arg);
 static int arilou_exit_event (int arg);
@@ -134,11 +134,11 @@ eventIdNumToStr (int eventNum)
 }
 
 void
-AddInitialGameEvents (void)
-{
+AddInitialGameEvents (void) {	
+	COUNT kohrah_winning_years = optCheatMode ? YEARS_TO_KOHRAH_VICTORY + 25 : YEARS_TO_KOHRAH_VICTORY;
 	AddEvent (RELATIVE_EVENT, 0, 1, 0, HYPERSPACE_ENCOUNTER_EVENT);
 	AddEvent (ABSOLUTE_EVENT, 3, 17, START_YEAR, ARILOU_ENTRANCE_EVENT);
-	AddEvent (RELATIVE_EVENT, 0, 0, YEARS_TO_KOHRAH_VICTORY,
+	AddEvent (RELATIVE_EVENT, 0, 0, kohrah_winning_years,
 			KOHR_AH_VICTORIOUS_EVENT);
 	AddEvent (RELATIVE_EVENT, 0, 0, 0, SLYLANDRO_RAMP_UP);
 }
@@ -654,6 +654,9 @@ kohr_ah_genocide_event (int arg)
 			speed = 1;
 		else if (speed > 255)
 			speed = 255;
+ 
+		if (optCheatMode)
+			speed = 0;
 
 		SET_GAME_STATE (KOHR_AH_FRENZY, 1);
 		SET_GAME_STATE (KOHR_AH_VISITS, 0);
@@ -694,6 +697,7 @@ spathi_shield_event (int arg)
 		if (SpathiPtr->actual_strength)
 		{
 			SetRaceAllied (SPATHI_SHIP, FALSE);
+			RemoveEscortShips (SPATHI_SHIP);
 			SET_GAME_STATE (SPATHI_SHIELDED_SELVES, 1);
 			SpathiPtr->actual_strength = 0;
 		}
@@ -708,76 +712,63 @@ spathi_shield_event (int arg)
 static int
 advance_ilwrath_mission (int arg)
 {
-	BYTE ThraddState;
-	HFLEETINFO hIlwrath, hThradd;
-	FLEET_INFO *IlwrathPtr;
-	FLEET_INFO *ThraddPtr;
-
-	hIlwrath = GetStarShipFromIndex (&GLOBAL (avail_race_q), ILWRATH_SHIP);
-	IlwrathPtr = LockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
-	hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
-	ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+	COUNT MaddLength = 128; // 128
+	SIZE strength_loss;
+	BYTE ThraddState = GET_GAME_STATE (THRADD_MISSION);
+	HFLEETINFO	hIlwrath = GetStarShipFromIndex (&GLOBAL (avail_race_q), ILWRATH_SHIP),
+				hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
+	FLEET_INFO	*IlwrathPtr = LockFleetInfo (&GLOBAL (avail_race_q), hIlwrath), 
+				*ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
 
-	if (IlwrathPtr->loc.x == ((2500 + 2535) >> 1)
-			&& IlwrathPtr->loc.y == ((8070 + 8358) >> 1))
-	{
+	if (IlwrathPtr->loc.x == ((2500 + 2535) >> 1) && IlwrathPtr->loc.y == ((8070 + 8358) >> 1)) {
 		IlwrathPtr->actual_strength = 0;
-		ThraddPtr->actual_strength = 0;
-		IlwrathPtr->allied_state = DEAD_GUY;
-		ThraddPtr->allied_state = DEAD_GUY;
-	}
-	else if (IlwrathPtr->actual_strength)
-	{
-		if (!GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH)
-				&& (IlwrathPtr->dest_loc.x != 2500
-				|| IlwrathPtr->dest_loc.y != 8070))
-		{
-			SetRaceDest (ILWRATH_SHIP, 2500, 8070, 90,
-					ADVANCE_ILWRATH_MISSION);
-		}
-		else
-		{
-#define MADD_LENGTH 128
-			SIZE strength_loss;
-
-			if (IlwrathPtr->days_left == 0)
-			{	/* arrived for battle */
+		IlwrathPtr->allied_state = DEAD_GUY;	
+		if(ThraddPtr->allied_state != GOOD_GUY || !optThraddStory){
+			ThraddPtr->actual_strength = 0;
+			ThraddPtr->allied_state = DEAD_GUY;
+		}
+	} else if (IlwrathPtr->actual_strength) {
+		if (!GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH) && (IlwrathPtr->dest_loc.x != 2500 || IlwrathPtr->dest_loc.y != 8070)) {
+			SetRaceDest (ILWRATH_SHIP, 2500, 8070, 90, ADVANCE_ILWRATH_MISSION); // 90
+		} else {
+			if (IlwrathPtr->days_left == 0) {	/* arrived for battle */
 				SET_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 1);
 				SET_GAME_STATE (HELIX_UNPROTECTED, 1);
 				strength_loss = (SIZE)IlwrathPtr->actual_strength;
-				IlwrathPtr->growth = (BYTE)(-strength_loss / MADD_LENGTH);
-				IlwrathPtr->growth_fract =
-						(BYTE)(((strength_loss % MADD_LENGTH) << 8) / MADD_LENGTH);
-				SetRaceDest (ILWRATH_SHIP,
-						(2500 + 2535) >> 1, (8070 + 8358) >> 1,
-						MADD_LENGTH - 1, ADVANCE_ILWRATH_MISSION);
-
-				strength_loss = (SIZE)ThraddPtr->actual_strength;
-				ThraddPtr->growth = (BYTE)(-strength_loss / MADD_LENGTH);
-				ThraddPtr->growth_fract =
-						(BYTE)(((strength_loss % MADD_LENGTH) << 8) / MADD_LENGTH);
-
-				SET_GAME_STATE (THRADD_VISITS, 0);
-				if (ThraddPtr->allied_state == GOOD_GUY)
-					SetRaceAllied (THRADDASH_SHIP, FALSE);
-			}
-
-			ThraddState = GET_GAME_STATE (THRADD_MISSION);
-			if (ThraddState == 0 || ThraddState > 3)
-			{	/* never went to Kohr-Ah or returned */
-				SetRaceDest (THRADDASH_SHIP,
-						(2500 + 2535) >> 1, (8070 + 8358) >> 1,
-						IlwrathPtr->days_left + 1, (BYTE)~0);
-			}
-			else if (ThraddState < 3)
-			{	/* recall on the double */
-				SetRaceDest (THRADDASH_SHIP, 2535, 8358, 10,
-						ADVANCE_THRADD_MISSION);
+				IlwrathPtr->growth = (BYTE)(-strength_loss / MaddLength);
+				IlwrathPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
+				SetRaceDest (ILWRATH_SHIP, 2517, 8214, MaddLength - 1, ADVANCE_ILWRATH_MISSION);
+
+				if (ThraddPtr->allied_state == GOOD_GUY && optThraddStory){
+					strength_loss = (SIZE)(ThraddPtr->actual_strength * 0.25); // Smarterer math
+					ThraddPtr->growth = (BYTE)(-strength_loss / MaddLength);
+					ThraddPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
+					ThraddPtr->growth_err_term = 255 >> 1;
+				} else {
+					SET_GAME_STATE (THRADD_VISITS, 0);
+					strength_loss = (SIZE)ThraddPtr->actual_strength;
+					ThraddPtr->growth = (BYTE)(-strength_loss / MaddLength);
+					ThraddPtr->growth_fract = (BYTE)(((strength_loss % MaddLength) << 8) / MaddLength);
+				}
+			}
+
+			if (ThraddState == 0 || ThraddState > 3) {	/* never went to Kohr-Ah or returned */
+				SetRaceDest (THRADDASH_SHIP, (2500 + 2535) >> 1, (8070 + 8358) >> 1, IlwrathPtr->days_left + 1, (BYTE)~0);
+			} else if (ThraddState < 3) {	/* recall on the double */
+				SetRaceDest (THRADDASH_SHIP, 2535, 8358, 10, ADVANCE_THRADD_MISSION);
 				SET_GAME_STATE (THRADD_MISSION, 3);
 			}
 		}
 	}
-
+	if(ThraddPtr->allied_state == GOOD_GUY && !IlwrathPtr->actual_strength && optThraddStory){		
+		ThraddPtr->growth = 0;
+		ThraddPtr->growth_fract = 0;
+		SET_GAME_STATE (ILWRATH_FIGHT_THRADDASH, 0);		
+		SetRaceDest (THRADDASH_SHIP, 2535, 8358, 3, (BYTE)~0);
+		if(!GET_GAME_STATE(AQUA_HELIX)){
+			SET_GAME_STATE (HELIX_UNPROTECTED, 0);
+		}
+	}
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hThradd);
 	UnlockFleetInfo (&GLOBAL (avail_race_q), hIlwrath);
 	
diff -ruNp src.orig/uqm/gameinp.c src/uqm/gameinp.c
--- src.orig/uqm/gameinp.c	2017-12-30 00:14:40 -0800
+++ src/uqm/gameinp.c	2017-12-30 00:14:52 -0800
@@ -32,10 +32,11 @@
 #include "libs/inplib.h"
 #include "libs/timelib.h"
 #include "libs/threadlib.h"
+#include "setup.h"
 
-
-#define ACCELERATION_INCREMENT (ONE_SECOND / 12)
-#define MENU_REPEAT_DELAY (ONE_SECOND / 2)
+// MB: Updated menu delay values so it no longer takes an age to (a) fill up your fuel tanks (b) fill up your crew (c) search through your saved games.
+#define ACCELERATION_INCREMENT (ONE_SECOND / 28)
+#define MENU_REPEAT_DELAY (ONE_SECOND / 3)
 
 
 typedef struct
@@ -426,10 +427,24 @@ ControlInputToBattleInput (const int *ke
 		InputState |= BATTLE_LEFT;
 	if (keyState[KEY_RIGHT])
 		InputState |= BATTLE_RIGHT;
-	if (keyState[KEY_WEAPON])
+	if (keyState[KEY_WEAPON]){
+		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+			(((PlayerControl[0] & COMPUTER_CONTROL) && PlayerControl[1] & HUMAN_CONTROL) || 
+			((PlayerControl[1] & COMPUTER_CONTROL) && PlayerControl[0] & HUMAN_CONTROL))))
+		{
+			resetEnergyBattle();
+		}
 		InputState |= BATTLE_WEAPON;
-	if (keyState[KEY_SPECIAL])
+	}
+	if (keyState[KEY_SPECIAL]){
+		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+			(((PlayerControl[0] & COMPUTER_CONTROL) && PlayerControl[1] & HUMAN_CONTROL) || 
+			((PlayerControl[1] & COMPUTER_CONTROL) && PlayerControl[0] & HUMAN_CONTROL))))
+		{
+			resetEnergyBattle();
+		}
 		InputState |= BATTLE_SPECIAL;
+	}
 	if (keyState[KEY_ESCAPE])
 		InputState |= BATTLE_ESCAPE;
 	if (keyState[KEY_DOWN])
diff -ruNp src.orig/uqm/gameopt.c src/uqm/gameopt.c
--- src.orig/uqm/gameopt.c	2017-12-30 00:14:40 -0800
+++ src/uqm/gameopt.c	2017-12-30 00:14:52 -0800
@@ -38,9 +38,9 @@
 
 extern FRAME PlayFrame;
 
-#define MAX_SAVED_GAMES 50
-#define SUMMARY_X_OFFS 14
-#define SUMMARY_SIDE_OFFS 7
+#define MAX_SAVED_GAMES 100
+#define SUMMARY_X_OFFS (14 << RESOLUTION_FACTOR) // JMS_GFX
+#define SUMMARY_SIDE_OFFS (7 << RESOLUTION_FACTOR) // JMS_GFX
 #define SAVES_PER_PAGE 5
 
 #define MAX_NAME_SIZE  SIS_NAME_SIZE
@@ -59,7 +59,7 @@ ConfirmSaveLoad (STAMP *MsgStamp)
 	GetContextClipRect (&clip_r);
 
 	t.baseline.x = clip_r.extent.width >> 1;
-	t.baseline.y = (clip_r.extent.height >> 1) + 3;
+	t.baseline.y = (clip_r.extent.height >> 1) + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	if (MsgStamp)
@@ -69,20 +69,27 @@ ConfirmSaveLoad (STAMP *MsgStamp)
 		t.pStr = GAME_STRING (SAVEGAME_STRING_BASE + 1);
 				// "Loading . . ."
 	TextRect (&t, &r, NULL);
-	r.corner.x -= 4;
-	r.corner.y -= 4;
-	r.extent.width += 8;
-	r.extent.height += 8;
+	r.corner.x -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.width += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height += 8 << RESOLUTION_FACTOR; // JMS_GFX
 	if (MsgStamp)
 	{
 		*MsgStamp = SaveContextFrame (&r);
 	}
-	DrawStarConBox (&r, 2,
-			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
-			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
-			TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+	if (RESOLUTION_FACTOR == 0) {
+		DrawStarConBox (&r, 2,
+						BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
+						BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
+						TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+	} else {
+		DrawStarConBox (&r, 2,
+						PCMENU_TOP_LEFT_BORDER_COLOR,
+						PCMENU_BOTTOM_RIGHT_BORDER_COLOR,
+						TRUE, PCMENU_BACKGROUND_COLOR);
+		SetContextForeGroundColor (PCMENU_SELECTION_TEXT_COLOR);
+	}
 	font_DrawText (&t);
 }
 
@@ -165,7 +172,6 @@ FeedbackSetting (BYTE which_setting)
 					GAME_STRING (NAMING_STRING_BASE + 0));
 			break;
 	}
-
 	DrawStatusMessage (buf);
 }
 
@@ -173,26 +179,6 @@ FeedbackSetting (BYTE which_setting)
 #define DDSHS_EDIT     1
 #define DDSHS_BLOCKCUR 2
 
-static const RECT captainNameRect = {
-	/* .corner = */ {
-		/* .x = */ 3,
-		/* .y = */ 10
-	}, /* .extent = */ {
-		/* .width = */ SHIP_NAME_WIDTH - 2,
-		/* .height = */ SHIP_NAME_HEIGHT
-	}
-};
-static const RECT shipNameRect = {
-	/* .corner = */ {
-		/* .x = */ 2,
-		/* .y = */ 20
-	}, /* .extent = */ {
-		/* .width = */ SHIP_NAME_WIDTH,
-		/* .height = */ SHIP_NAME_HEIGHT
-	}
-};
-
-
 static BOOLEAN
 DrawNameString (bool nameCaptain, UNICODE *Str, COUNT CursorPos,
 		COUNT state)
@@ -203,11 +189,17 @@ DrawNameString (bool nameCaptain, UNICOD
 	FONT Font;
 
 	{
+		r.extent.height = SHIP_NAME_HEIGHT;
+
 		if (nameCaptain)
 		{	// Naming the captain
 			Font = TinyFont;
-			r = captainNameRect;
-			lf.baseline.x = r.corner.x + (r.extent.width >> 1) - 1;
+			r.corner.x = RES_STAT_SCALE(3) - RES_CASE(0,3,5); // JMS_GFX
+			r.corner.y = RES_CASE(10,20,32); // JMS_GFX
+			r.extent.width = SHIP_NAME_WIDTH - RES_CASE(2,1,0);		// JMS_GFX
+			r.extent.height += RESOLUTION_FACTOR; // JMS_GFX
+			lf.baseline.x = (STATUS_WIDTH >> 1) - RES_CASE(1,0,-1);
+			lf.baseline.y = r.corner.y + r.extent.height - RES_CASE(1,4,3);
 
 			BackGround = BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09);
 			ForeGround = BUILD_COLOR (MAKE_RGB15 (0x0A, 0x1F, 0x1F), 0x0B);
@@ -215,14 +207,16 @@ DrawNameString (bool nameCaptain, UNICOD
 		else
 		{	// Naming the flagship
 			Font = StarConFont;
-			r = shipNameRect;
+			r.corner.x = RES_CASE(2,3,5); // JMS_GFX
+			r.corner.y = RES_CASE(20,40,63); // JMS_GFX
+			r.extent.width = SHIP_NAME_WIDTH;
+			r.extent.height += RES_CASE(0,0,1); // JMS_GFX
 			lf.baseline.x = r.corner.x + (r.extent.width >> 1);
+			lf.baseline.y = r.corner.y + r.extent.height - RES_CASE(1,4,3); // JMS_GFX
 
 			BackGround = BUILD_COLOR (MAKE_RGB15 (0x0F, 0x00, 0x00), 0x2D);
 			ForeGround = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x0A, 0x00), 0x7D);
 		}
-
-		lf.baseline.y = r.corner.y + r.extent.height - 1;
 		lf.align = ALIGN_CENTER;
 	}
 
@@ -311,17 +305,65 @@ OnNameChange (TEXTENTRY_STATE *pTES)
 }
 
 static void
-NameCaptainOrShip (bool nameCaptain)
+NameCaptainOrShip (bool nameCaptain, bool gamestart)
 {
 	UNICODE buf[MAX_NAME_SIZE] = "";
 	TEXTENTRY_STATE tes;
 	UNICODE *Setting;
+	COUNT CursPos = 0; // JMS
+	RECT r; // JMS
+
+	// JMS: This should only be invoked when starting a new game.
+	// It prints a prompt window to the center of the screen, urging
+	// the player to name his captain and ship.
+	if (gamestart)
+	{
+		RECT clip_r;
+		TEXT t;
+		
+		SetContext (ScreenContext);
+		SetContextFont (StarConFont);
+		GetContextClipRect (&clip_r);
+		
+		t.baseline.x = clip_r.extent.width >> 1;
+		t.baseline.y = (clip_r.extent.height >> 1) + (3 << RESOLUTION_FACTOR); // JMS_GFX
+		t.align = ALIGN_CENTER;
+		t.CharCount = (COUNT)~0;
+		
+		if (nameCaptain) {
+			// "Captain, what is your name?"
+			t.pStr = GAME_STRING (NAMING_STRING_BASE + 4);
+			strcpy (buf,  GAME_STRING (NAMING_STRING_BASE + 3)); // "Zelnick"
+			CursPos = strlen(GAME_STRING (NAMING_STRING_BASE + 3));
+		} else {
+			// "What is the name of your flagship?"
+			t.pStr = GAME_STRING (NAMING_STRING_BASE + 5);
+			strcpy (buf, GAME_STRING (NAMING_STRING_BASE + 2)); // "Vindicator"
+			CursPos = strlen(GAME_STRING (NAMING_STRING_BASE + 2));
+		}
+		
+		TextRect (&t, &r, NULL);
+		r.corner.x -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.y -= 4 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.width += 8 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height += 8 << RESOLUTION_FACTOR; // JMS_GFX
+		
+		DrawStarConBox (&r, 2,
+						BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19),
+						BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F),
+						TRUE, BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
+		SetContextForeGroundColor (
+								   BUILD_COLOR (MAKE_RGB15 (0x14, 0x14, 0x14), 0x0F));
+		font_DrawText (&t);
+	}
 
-	SetFlashRect (nameCaptain ? &captainNameRect : &shipNameRect);
+	SetFlashRect (NULL);
 
-	DrawNameString (nameCaptain, buf, 0, DDSHS_EDIT);
+	DrawNameString (nameCaptain, buf, CursPos, DDSHS_EDIT);
 
-	DrawStatusMessage (GAME_STRING (NAMING_STRING_BASE + 0));
+	if (!gamestart) {
+		DrawStatusMessage (GAME_STRING (NAMING_STRING_BASE + 0));
+	}
 
 	if (nameCaptain)
 	{
@@ -337,7 +379,7 @@ NameCaptainOrShip (bool nameCaptain)
 	// text entry setup
 	tes.Initialized = FALSE;
 	tes.BaseStr = buf;
-	tes.CursorPos = 0;
+	tes.CursorPos = CursPos;
 	tes.CbParam = (void*) nameCaptain;
 	tes.ChangeCallback = OnNameChange;
 	tes.FrameCallback = 0;
@@ -349,10 +391,19 @@ NameCaptainOrShip (bool nameCaptain)
 
 	SetFlashRect (SFR_MENU_3DO);
 
-	DrawNameString (nameCaptain, buf, 0, DDSHS_NORMAL);
+	DrawNameString (nameCaptain, buf, CursPos, DDSHS_NORMAL);
 
 	if (namingCB)
 		namingCB ();
+
+	// JMS: This clears the captain or ship naming prompt.
+	if (gamestart) {
+		SetContext (ScreenContext);
+		DrawStarConBox (&r, 2,
+			BLACK_COLOR, BLACK_COLOR, TRUE, BLACK_COLOR);
+	}
+
+	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 }
 
 static BOOLEAN
@@ -370,21 +421,21 @@ DrawSaveNameString (UNICODE *Str, COUNT
 	snprintf (fullStr, sizeof fullStr, "%s%s", dateStr, Str);
 
 	SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33));
-	r.extent.width = 15;
+	r.extent.width = 15 << RESOLUTION_FACTOR; // JMS_GFX
 	if (MAX_SAVED_GAMES > 99)
-		r.extent.width += 5;
-	r.extent.height = 11;
-	r.corner.x = 8;
-	r.corner.y = (160 + ((gameIndex % SAVES_PER_PAGE) * 13));
+		r.extent.width += 5 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = 11 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.x = 8 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = (160 + ((gameIndex % SAVES_PER_PAGE) * 13)) << RESOLUTION_FACTOR; // JMS_GFX
 	DrawRectangle (&r);
 
-	r.extent.width = (204 - SAFE_X);
-	r.corner.x = (30 + SAFE_X);
+	r.extent.width = (204 - SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.x = (30 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 	DrawRectangle (&r);
 
 	Font = TinyFont;
-	lf.baseline.x = r.corner.x + 3;
-	lf.baseline.y = r.corner.y + 8;
+	lf.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR); // JMS_GFX
+	lf.baseline.y = r.corner.y + RES_CASE(8,14,29); // JMS_GFX
 
 	BackGround = BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33);
 	ForeGround = BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01);
@@ -402,8 +453,8 @@ DrawSaveNameString (UNICODE *Str, COUNT
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
 
-		t.baseline.x = r.corner.x + 3;
-		t.baseline.y = r.corner.y + 8;
+		t.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR);
+		t.baseline.y = r.corner.y + (8 << RESOLUTION_FACTOR); // JMS_GFX
 		t.align = ALIGN_LEFT;
 		t.pStr = Str;
 		t.CharCount = (COUNT)~0;
@@ -504,10 +555,10 @@ NameSaveGame (COUNT gameIndex, UNICODE *
 	tes.CbParam = gIndex;
 	tes.ChangeCallback = OnSaveNameChange;
 	tes.FrameCallback = 0;
-	r.extent.width = (204 - SAFE_X);
-	r.extent.height = 11;
-	r.corner.x = (30 + SAFE_X);
-	r.corner.y = (160 + ((gameIndex % SAVES_PER_PAGE) * 13));
+	r.extent.width = (RES_SCALE(204) - SAFE_X);
+	r.extent.height = RES_SCALE(11);
+	r.corner.x = (RES_SCALE(30) + SAFE_X);
+	r.corner.y = (RES_SCALE(160) + ((gameIndex % SAVES_PER_PAGE) * RES_SCALE(13)));
 	SetFlashRect (&r);
 
 	if (!DoTextEntry (&tes))
@@ -532,6 +583,28 @@ NameSaveGame (COUNT gameIndex, UNICODE *
 		return (FALSE);
 }
 
+// JMS: This is for naming captain and ship at game start.
+void AskNameForCaptainAndShip(void)
+{
+	// Give sounds for arrows and enter.
+	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+
+	// Erase the intro graphics (that are still hidden in the black fade).
+	SetContext (ScreenContext);
+	SetContextBackGroundColor (BLACK_COLOR);
+	ClearDrawable ();
+
+	// Enable graphics so the prompt for captain naming will be visible.
+	FadeScreen (FadeAllToColor, ONE_SECOND / 2);
+	
+	// Name the captain and the ship.
+	NameCaptainOrShip (true, true);
+	NameCaptainOrShip (false, true);
+	
+	// Re-fade to black before loading the first IP graphics.
+	FadeScreen (FadeAllToBlack, ONE_SECOND / 2);
+}
+
 void
 SetNamingCallback (NamingCallback *callback)
 {
@@ -572,7 +645,7 @@ DoSettings (MENU_STATE *pMS)
 				break;
 			case CHANGE_CAPTAIN_SETTING:
 			case CHANGE_SHIP_SETTING:
-				NameCaptainOrShip (pMS->CurState == CHANGE_CAPTAIN_SETTING);
+				NameCaptainOrShip (pMS->CurState == CHANGE_CAPTAIN_SETTING, false);
 				break;
 			default:
 				if (cur_speed++ < NUM_COMBAT_SPEEDS - 1)
@@ -630,7 +703,7 @@ DrawBlankSavegameDisplay (PICK_GAME_STAT
 {
 	STAMP s;
 
-	s.origin.x = 0;
+	s.origin.x = 0 - (RESOLUTION_FACTOR >> 1); // JMS_GFX
 	s.origin.y = 0;
 	s.frame = SetAbsFrameIndex (pickState->SummaryFrame,
 			GetFrameCount (pickState->SummaryFrame) - 1);
@@ -670,9 +743,9 @@ DrawSavegameCargo (SIS_STATE *sisState)
 		BUILD_COLOR (MAKE_RGB15_INIT (0x14, 0x00, 0x14), 0x05),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x19), 0x00),
 	};
-#define ELEMENT_ORG_Y      17
-#define ELEMENT_SPACING_Y  12
-#define ELEMENT_SPACING_X  36
+#define ELEMENT_ORG_Y      (17 << RESOLUTION_FACTOR) // JMS_GFX
+#define ELEMENT_SPACING_Y  (12 << RESOLUTION_FACTOR) // JMS_GFX
+#define ELEMENT_SPACING_X  (36 << RESOLUTION_FACTOR) // JMS_GFX
 
 	SetContext (SpaceContext);
 	BatchGraphics ();
@@ -681,11 +754,11 @@ DrawSavegameCargo (SIS_STATE *sisState)
 	// setup element icons
 	s.frame = SetAbsFrameIndex (MiscDataFrame,
 			(NUM_SCANDOT_TRANSITIONS << 1) + 3);
-	s.origin.x = 7 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 3;
+	s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + (10 << RESOLUTION_FACTOR); // JMS_GFX
 	s.origin.y = ELEMENT_ORG_Y;
 	// setup element amounts
-	t.baseline.x = 33 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 3;
-	t.baseline.y = ELEMENT_ORG_Y + 3;
+	t.baseline.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + ELEMENT_SPACING_X;
+	t.baseline.y = ELEMENT_ORG_Y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 
@@ -697,7 +770,7 @@ DrawSavegameCargo (SIS_STATE *sisState)
 			s.origin.x += ELEMENT_SPACING_X;
 			s.origin.y = ELEMENT_ORG_Y;
 			t.baseline.x += ELEMENT_SPACING_X;
-			t.baseline.y = ELEMENT_ORG_Y + 3;
+			t.baseline.y = ELEMENT_ORG_Y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 		}
 		// draw element icon
 		DrawStamp (&s);
@@ -712,13 +785,13 @@ DrawSavegameCargo (SIS_STATE *sisState)
 	}
 
 	// draw Bio icon
-	s.origin.x = 24 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS;
-	s.origin.y = 68;
+	s.origin.x = (24 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS; // JMS_GFX
+	s.origin.y = 68 << RESOLUTION_FACTOR; // JMS_GFX
 	s.frame = SetAbsFrameIndex (s.frame, 68);
 	DrawStamp (&s);
 	// print Bio amount
-	t.baseline.x = 50 + SUMMARY_X_OFFS;
-	t.baseline.y = s.origin.y + 3;
+	t.baseline.x = (50 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS; // JMS_GFX
+	t.baseline.y = s.origin.y + (3 << RESOLUTION_FACTOR); // JMS_GFX
 	SetContextForeGroundColor (cargo_color[i]);
 	snprintf (buf, sizeof buf, "%u", sisState->TotalBioMass);
 	t.CharCount = (COUNT)~0;
@@ -765,10 +838,9 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		// Hack StatusContext so we can use standard SIS display funcs
 		GetContextClipRect (&OldRect);
 		r.corner.x = SIS_ORG_X + ((SIS_SCREEN_WIDTH - STATUS_WIDTH) >> 1) +
-				SAFE_X - 16 + SUMMARY_X_OFFS;
-//		r.corner.x = SIS_ORG_X + ((SIS_SCREEN_WIDTH - STATUS_WIDTH) >> 1);
-		r.corner.y = SIS_ORG_Y;
-		r.extent.width = STATUS_WIDTH;
+				SAFE_X - (16 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + RES_CASE(0,0,6); // JMS_GFX
+		r.corner.y = SIS_ORG_Y; // JMS_GFX
+		r.extent.width = STATUS_WIDTH + 2 * RESOLUTION_FACTOR; // JMS_GFX
 		r.extent.height = STATUS_HEIGHT;
 		SetContextClipRect (&r);
 
@@ -788,12 +860,12 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 
 		SetContext (SpaceContext);
 		// draw devices
-		s.origin.y = 13;
+		s.origin.y = 13 << RESOLUTION_FACTOR; // JMS_GFX
 		for (i = 0; i < 4; ++i)
 		{
 			COUNT j;
 
-			s.origin.x = 140 + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS;
+			s.origin.x = (140 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS + RES_CASE(0,10,110); // JMS_GFX
 			for (j = 0; j < 4; ++j)
 			{
 				COUNT devIndex = (i * 4) + j;
@@ -803,20 +875,20 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 							+ pSD->DeviceList[devIndex]);
 					DrawStamp (&s);
 				}
-				s.origin.x += 18;
+				s.origin.x += 18 << RESOLUTION_FACTOR; // JMS_GFX
 			}
-			s.origin.y += 18;
+			s.origin.y += 18 << RESOLUTION_FACTOR; // JMS_GFX
 		}
 
 		SetContextFont (StarConFont);
-		t.baseline.x = 173 + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS;
+		t.baseline.x = (173 << RESOLUTION_FACTOR) + SUMMARY_X_OFFS + SUMMARY_SIDE_OFFS + RES_CASE(0,15,110); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
 		if (pSD->Flags & AFTER_BOMB_INSTALLED)
 		{
 			// draw the bomb and the escape pod
-			s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + 6;
+			s.origin.x = SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS + (6 << RESOLUTION_FACTOR); // JMS_GFX
 			s.origin.y = 0;
 			s.frame = SetRelFrameIndex (pickState->SummaryFrame, 0);
 			DrawStamp (&s);
@@ -832,8 +904,8 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			SetContext (RadarContext);
 			// Hack RadarContext so we can use standard Lander display funcs
 			GetContextClipRect (&OldRect);
-			r.corner.x = SIS_ORG_X + 10 + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS;
-			r.corner.y = SIS_ORG_Y + 84;
+			r.corner.x = SIS_ORG_X + RES_CASE(10,20,70) + SUMMARY_X_OFFS - SUMMARY_SIDE_OFFS; // JMS_GFX
+			r.corner.y = SIS_ORG_Y + (84 << RESOLUTION_FACTOR); // JMS_GFX
 			r.extent = OldRect.extent;
 			SetContextClipRect (&r);
 			// draw the lander with upgrades
@@ -842,13 +914,13 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 			SetContext (SpaceContext);
 
 			snprintf (buf, sizeof buf, "%u", pSD->SS.ResUnits);
-			t.baseline.y = 102;
+			t.baseline.y = 102 << RESOLUTION_FACTOR; // JMS_GFX
 			SetContextForeGroundColor (
 					BUILD_COLOR (MAKE_RGB15 (0x10, 0x00, 0x10), 0x01));
 			font_DrawText (&t);
 			t.CharCount = (COUNT)~0;
 		}
-		t.baseline.y = 126;
+		t.baseline.y = 126 << RESOLUTION_FACTOR; // JMS_GFX
 		snprintf (buf, sizeof buf, "%u",
 				MAKE_WORD (pSD->MCreditLo, pSD->MCreditHi));
 		SetContextForeGroundColor (
@@ -856,8 +928,8 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		font_DrawText (&t);
 
 		// print the location
-		t.baseline.x = 6;
-		t.baseline.y = 139 + 6;
+		t.baseline.x = 6 << RESOLUTION_FACTOR; // JMS_GFX
+		t.baseline.y = ((139 + 6) << RESOLUTION_FACTOR) + RES_CASE(0,3,0); // JMS_GFX;
 		t.align = ALIGN_LEFT;
 		t.pStr = buf;
 		starPt.x = LOGX_TO_UNIVERSE (pSD->SS.log_x);
@@ -902,8 +974,7 @@ DrawSavegameSummary (PICK_GAME_STATE *pi
 		t.CharCount = (COUNT)~0;
 		font_DrawText (&t);
 		t.align = ALIGN_CENTER;
-		t.baseline.x = SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - 4
-				+ (SIS_TITLE_WIDTH >> 1);
+		t.baseline.x = SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - (4 << RESOLUTION_FACTOR) + (SIS_TITLE_WIDTH >> 1); // JMS_GFX
 		switch (pSD->Activity)
 		{
 			case IN_STARBASE:
@@ -940,20 +1011,18 @@ DrawGameSelection (PICK_GAME_STATE *pick
 {
 	RECT r;
 	TEXT t;
-	COUNT i;
-	COUNT curSlot;
-	UNICODE buf[256];
-	UNICODE buf2[80];
+	COUNT i, curSlot;
+	UNICODE buf[256], buf2[80], *SaveName;
 
 	BatchGraphics ();
 
 	SetContextFont (TinyFont);
 
 	// Erase the selection menu
-	r.extent.width = 240;
-	r.extent.height = 65;
-	r.corner.x = 1;
-	r.corner.y = 160;
+	r.extent.width = 240 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = 65 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.x = 1 << RESOLUTION_FACTOR; // JMS_GFX
+	r.corner.y = 160 << RESOLUTION_FACTOR; // JMS_GFX
 	SetContextForeGroundColor (BLACK_COLOR);
 	DrawFilledRectangle (&r);
 
@@ -968,28 +1037,31 @@ DrawGameSelection (PICK_GAME_STATE *pick
 	{
 		SUMMARY_DESC *desc = &pickState->summary[curSlot];
 
+		// JMS_GFX: In hi-res modes, the dark blue is brighter because otherwise
+		// the thinner lines/text would be hard to see.
 		SetContextForeGroundColor ((curSlot == selSlot) ?
-				(BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33)):
-				(BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01)));
-		r.extent.width = 15;
+				(BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x1B), 0x33)): 
+				( RESOLUTION_FACTOR == 0 ?
+				(BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x14), 0x01)) : (BUILD_COLOR (MAKE_RGB15 (0x00, 0x00, 0x19), 0x01))));
+		r.extent.width = 15 << RESOLUTION_FACTOR; // JMS_GFX
 		if (MAX_SAVED_GAMES > 99)
-			r.extent.width += 5;
-		r.extent.height = 11;
-		r.corner.x = 8;
-		r.corner.y = 160 + (i * 13);
+			r.extent.width += 5 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 11 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.x = 8 << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.y = (160 + (i * 13)) << RESOLUTION_FACTOR; // JMS_GFX
 		DrawRectangle (&r);
 
-		t.baseline.x = r.corner.x + 3;
-		t.baseline.y = r.corner.y + 8;
+		t.baseline.x = r.corner.x + RES_CASE(3,8,18); // JMS_GFX
+		t.baseline.y = r.corner.y + RES_CASE(8,14,29); // JMS_GFX
 		snprintf (buf, sizeof buf, (MAX_SAVED_GAMES > 99) ? "%03u" : "%02u",
 				curSlot);
 		font_DrawText (&t);
 
-		r.extent.width = 204 - SAFE_X;
-		r.corner.x = 30 + SAFE_X;
+		r.extent.width = (204 - SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
+		r.corner.x = (30 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 		DrawRectangle (&r);
 
-		t.baseline.x = r.corner.x + 3;
+		t.baseline.x = r.corner.x + (3 << RESOLUTION_FACTOR); // JMS_GFX
 		if (desc->year_index == 0)
 		{
 			utf8StringCopy (buf, sizeof buf,
@@ -1050,6 +1122,21 @@ DoPickGame (MENU_STATE *pMS)
 		pSD = &pickState->summary[pMS->CurState];
 		if (pickState->saving || pSD->year_index)
 		{	// valid slot
+			DWORD LoadFuelScaled = loadFuel / FUEL_TANK_SCALE;
+			DWORD TankCapacityScaled = GetFuelTankCapacity() / FUEL_TANK_SCALE;
+
+			if(optInfiniteRU)
+				GLOBAL_SIS (ResUnits) = oldRU;
+
+			if(optInfiniteFuel){
+				if(loadFuel <= GetFuelTankCapacity())
+					GLOBAL_SIS (FuelOnBoard) = loadFuel;
+				else {
+					GLOBAL_SIS (ResUnits) += (LoadFuelScaled - TankCapacityScaled) * GLOBAL (FuelCost);
+					GLOBAL_SIS (FuelOnBoard) = GetFuelTankCapacity();
+				}
+			}
+
 			PlayMenuSound (MENU_SOUND_SUCCESS);
 			pickState->success = TRUE;
 			return FALSE;
diff -ruNp src.orig/uqm/gameopt.h src/uqm/gameopt.h
--- src.orig/uqm/gameopt.h	2017-12-30 00:14:40 -0800
+++ src/uqm/gameopt.h	2017-12-30 00:14:52 -0800
@@ -28,6 +28,7 @@ extern BOOLEAN GameOptions (void);
 
 typedef void (NamingCallback) (void);
 extern void SetNamingCallback (NamingCallback *);
+extern void AskNameForCaptainAndShip(void);
 
 #if defined(__cplusplus)
 }
diff -ruNp src.orig/uqm/gamestr.h src/uqm/gamestr.h
--- src.orig/uqm/gamestr.h	2017-12-30 00:14:40 -0800
+++ src/uqm/gamestr.h	2017-12-30 00:14:52 -0800
@@ -29,7 +29,7 @@
 extern "C" {
 #endif
 
-#define STAR_STRING_COUNT       133
+#define STAR_STRING_COUNT       149
 #define DEVICE_STRING_COUNT      29
 #define CARGO_STRING_COUNT       10
 #define ELEMENTS_STRING_COUNT   133
@@ -37,11 +37,11 @@ extern "C" {
 #define STAR_NUMBER_COUNT        14
 #define PLANET_NUMBER_COUNT      33
 #define MONTHS_STRING_COUNT      12
-#define FEEDBACK_STRING_COUNT     2
+#define FEEDBACK_STRING_COUNT     5
 #define STARBASE_STRING_COUNT     5
 #define ENCOUNTER_STRING_COUNT    8
 #define NAVIGATION_STRING_COUNT   6
-#define NAMING_STRING_COUNT       4
+#define NAMING_STRING_COUNT       6
 #define MELEE_STRING_COUNT        9
 #define SAVEGAME_STRING_COUNT     5
 #define OPTION_STRING_COUNT       5
@@ -50,7 +50,8 @@ extern "C" {
 #define FLAGSHIP_STRING_COUNT    13
 #define ORBITSCAN_STRING_COUNT   19
 #define MAINMENU_STRING_COUNT    55
-#define NETMELEE_STRING_COUNT    19
+#define NETMELEE_STRING_COUNT    34
+#define BIOLOGICAL_STRING_COUNT  26
 
 enum {
 	STAR_STRING_BASE       = 0,
@@ -75,8 +76,9 @@ enum {
 	ORBITSCAN_STRING_BASE  = FLAGSHIP_STRING_BASE + FLAGSHIP_STRING_COUNT,
 	MAINMENU_STRING_BASE   = ORBITSCAN_STRING_BASE + ORBITSCAN_STRING_COUNT,
 	NETMELEE_STRING_BASE   = MAINMENU_STRING_BASE + MAINMENU_STRING_COUNT,
+	BIOLOGICAL_STRING_BASE = NETMELEE_STRING_BASE + NETMELEE_STRING_COUNT,
 
-	GAMESTR_COUNT          = NETMELEE_STRING_BASE + NETMELEE_STRING_COUNT
+	GAMESTR_COUNT          = BIOLOGICAL_STRING_BASE + BIOLOGICAL_STRING_COUNT
 };
 
 
diff -ruNp src.orig/uqm/globdata.c src/uqm/globdata.c
--- src.orig/uqm/globdata.c	2017-12-30 00:14:40 -0800
+++ src/uqm/globdata.c	2017-12-30 00:14:52 -0800
@@ -33,10 +33,10 @@
 #include "gamestr.h"
 #include "libs/scriptlib.h"
 #include "libs/log.h"
-
+#include "options.h"
 #include <assert.h>
 #include <stdlib.h>
-
+#include "uqmdebug.h"
 
 static void CreateRadar (void);
 
@@ -45,7 +45,6 @@ FRAME PlayFrame;
 
 GLOBDATA GlobData;
 
-
 // Pre: 0 <= bits <= 32
 // This function is necessary because expressions such as '(1 << bits) - 1'
 // or '~(~0 << bits)' may shift by 32 bits, which is undefined (for 32 bits
@@ -323,7 +322,7 @@ LoadSC2Data (void)
 
 	CreateRadar ();
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_HYPERSPACE)
+	if (inHQSpace())
 	{
 		GLOBAL (ShipStamp.origin.x) =
 				GLOBAL (ShipStamp.origin.y) = -1;
@@ -469,6 +468,23 @@ InitGameStructures (void)
 	GLOBAL_SIS (ModuleSlots[8]) = STORAGE_BAY;
 	GLOBAL_SIS (ModuleSlots[1]) = FUEL_TANK;
 	GLOBAL_SIS (FuelOnBoard) = 10 * FUEL_TANK_SCALE;
+ 
+	if (optHeadStart){
+		GLOBAL_SIS (ModuleSlots[7]) = STORAGE_BAY;
+		GLOBAL_SIS (ElementAmounts[COMMON]) = 178;
+		GLOBAL_SIS (ElementAmounts[CORROSIVE]) = 66;
+		GLOBAL_SIS (ElementAmounts[BASE_METAL]) = 378;
+		GLOBAL_SIS (ElementAmounts[PRECIOUS]) = 29;
+		GLOBAL_SIS (ElementAmounts[RADIOACTIVE]) = 219;
+		GLOBAL_SIS (ElementAmounts[EXOTIC]) = 5;
+		GLOBAL_SIS (TotalElementMass) = 875;
+		SET_GAME_STATE (FOUND_PLUTO_SPATHI, 2);
+		SET_GAME_STATE (KNOW_SPATHI_PASSWORD, 1);
+		SET_GAME_STATE (MOONBASE_ON_SHIP, 1);
+		SET_GAME_STATE (MOONBASE_DESTROYED, 1);
+	}
+
+	loadGameCheats();
 
 	InitQueue (&GLOBAL (built_ship_q),
 			MAX_BUILT_SHIPS, sizeof (SHIP_FRAGMENT));
@@ -482,7 +498,7 @@ InitGameStructures (void)
 
 	GLOBAL_SIS (ResUnits) = 0;
 	GLOBAL (CrewCost) = 3;
-	GLOBAL (FuelCost) = 20;
+	GLOBAL (FuelCost) = FUEL_COST_RU; // JMS: Was 20
 	GLOBAL (ModuleCost[PLANET_LANDER]) = 500 / MODULE_COST_SCALE;
 	GLOBAL (ModuleCost[FUSION_THRUSTER]) = 500 / MODULE_COST_SCALE;
 	GLOBAL (ModuleCost[TURNING_JETS]) = 500 / MODULE_COST_SCALE;
@@ -503,6 +519,12 @@ InitGameStructures (void)
 	SetRaceAllied (HUMAN_SHIP, TRUE);
 	CloneShipFragment (HUMAN_SHIP, &GLOBAL (built_ship_q), 0);
 
+	if(optHeadStart){
+		AddEscortShips (SPATHI_SHIP, 1);
+		/* Make the Eluder escort captained by Fwiffo alone */
+		SetEscortCrewComplement (SPATHI_SHIP, 1, NAME_OFFSET + NUM_CAPTAINS_NAMES); // NAME_OFFSET + NUM_CAPTAINS_NAMES = 21 by the way.
+	}
+
 	GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (SOL_X);
 	GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (SOL_Y);
 	CurStarDescPtr = 0;
diff -ruNp src.orig/uqm/globdata.h src/uqm/globdata.h
--- src.orig/uqm/globdata.h	2017-12-30 00:14:40 -0800
+++ src/uqm/globdata.h	2017-12-30 00:14:52 -0800
@@ -93,8 +93,40 @@ typedef DWORD LDAS_FLAGS;
 #define LDASF_NONE           ((LDAS_FLAGS)      0 )
 #define LDASF_USE_ALTERNATE  ((LDAS_FLAGS)(1 << 0))
 
+// BW: had to move that from commglue.h to here because now LOCDATA features it
+typedef enum {
+	ARILOU_CONVERSATION,
+	CHMMR_CONVERSATION,
+	COMMANDER_CONVERSATION,
+	ORZ_CONVERSATION,
+	PKUNK_CONVERSATION,
+	SHOFIXTI_CONVERSATION,
+	SPATHI_CONVERSATION,
+	SUPOX_CONVERSATION,
+	THRADD_CONVERSATION,
+	UTWIG_CONVERSATION,
+	VUX_CONVERSATION,
+	YEHAT_CONVERSATION,
+	MELNORME_CONVERSATION,
+	DRUUGE_CONVERSATION,
+	ILWRATH_CONVERSATION,
+	MYCON_CONVERSATION,
+	SLYLANDRO_CONVERSATION,
+	UMGAH_CONVERSATION,
+	URQUAN_CONVERSATION,
+	ZOQFOTPIK_CONVERSATION,
+	SYREEN_CONVERSATION,
+	BLACKURQ_CONVERSATION,
+	TALKING_PET_CONVERSATION,
+	SLYLANDRO_HOME_CONVERSATION,
+	URQUAN_DRONE_CONVERSATION,
+	YEHAT_REBEL_CONVERSATION,
+	INVALID_CONVERSATION,
+} CONVERSATION;
+
 typedef struct
 {
+	CONVERSATION AlienConv;
 	void (*init_encounter_func) (void);
 			/* Called when entering communications */
 	void (*post_encounter_func) (void);
@@ -307,8 +339,8 @@ START_GAME_STATE
 	ADD_GAME_STATE (MOONBASE_DESTROYED, 1)
 	ADD_GAME_STATE (WILL_DESTROY_BASE, 1)
 
-	ADD_GAME_STATE (ARTIFACT_2_ON_SHIP, 1)
-	ADD_GAME_STATE (ARTIFACT_3_ON_SHIP, 1)
+	ADD_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP, 1)
+	ADD_GAME_STATE (GLOWING_ROD_ON_SHIP, 1)
 
 	ADD_GAME_STATE (KOHR_AH_KILLED_ALL, 1)
 
@@ -846,8 +878,104 @@ START_GAME_STATE
 	ADD_GAME_STATE (COLONY_GRPOFFS, 32)
 	ADD_GAME_STATE (SAMATRA_GRPOFFS, 32)
 
+	// JMS: It is allowed for the autopilot to engage
+	ADD_GAME_STATE (AUTOPILOT_OK, 1)
+
+	// JMS: Quasispace portal name flags
+	ADD_GAME_STATE (KNOW_QS_PORTAL_0, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_1, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_2, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_3, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_4, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_5, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_6, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_7, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_8, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_9, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_10, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_11, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_12, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_13, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_14, 1)
+	ADD_GAME_STATE (KNOW_QS_PORTAL_15, 1)
+
 END_GAME_STATE
 
+// JMS: For making array of Quasispace portal name flags
+#define QS_PORTALS_KNOWN \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_0)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_1)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_2)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_3)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_4)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_5)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_6)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_7)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_8)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_9)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_10)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_11)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_12)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_13)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_14)), \
+	(GET_GAME_STATE (KNOW_QS_PORTAL_15)),
+
+// JMS: For making array of Quasispace portal name flags
+#define SET_QS_PORTAL_KNOWN(val) \
+	switch (val)	\
+	{				\
+	case 0:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_0, 1);\
+		break; \
+	case 1:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_1, 1);\
+		break; \
+	case 2:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_2, 1);\
+		break; \
+	case 3:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_3, 1);\
+		break; \
+	case 4:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_4, 1);\
+		break; \
+	case 5:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_5, 1);\
+		break; \
+	case 6:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_6, 1);\
+		break; \
+	case 7:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_7, 1);\
+		break; \
+	case 8:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_8, 1);\
+		break; \
+	case 9:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_9, 1);\
+		break; \
+	case 10:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_10, 1);\
+		break; \
+	case 11:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_11, 1);\
+		break; \
+	case 12:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_12, 1);\
+		break; \
+	case 13:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_13, 1);\
+		break; \
+	case 14:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_14, 1);\
+		break; \
+	case 15:			\
+		SET_GAME_STATE (KNOW_QS_PORTAL_15, 1);\
+		break; \
+	default: \
+	break;\
+	}
+
 // Values for GAME_STATE.glob_flags:
 #define COMBAT_SPEED_SHIFT 6
 #define COMBAT_SPEED_MASK (((1 << 2) - 1) << COMBAT_SPEED_SHIFT)
diff -ruNp src.orig/uqm/gravity.c src/uqm/gravity.c
--- src.orig/uqm/gravity.c	2017-12-30 00:14:40 -0800
+++ src/uqm/gravity.c	2017-12-30 00:14:52 -0800
@@ -96,7 +96,7 @@ CalculateGravity (ELEMENT *ElementPtr)
 #ifdef NEVER
 					COUNT magnitude;
 
-#define DIFUSE_GRAVITY 175
+#define DIFUSE_GRAVITY (175 << RESOLUTION_FACTOR) // JMS_GFX: Because of the ifdef NEVER this is actually never run. Well, changed it for consistency
 					dist_squared += (DWORD)abs_dx * (DIFUSE_GRAVITY << 1)
 							+ (DWORD)abs_dy * (DIFUSE_GRAVITY << 1)
 							+ ((DWORD)(DIFUSE_GRAVITY * DIFUSE_GRAVITY) << 1);
@@ -104,7 +104,7 @@ CalculateGravity (ELEMENT *ElementPtr)
 							* GRAVITY_THRESHOLD) / dist_squared)) == 0)
 						magnitude = 1;
 
-#define MAX_MAGNITUDE 6
+#define MAX_MAGNITUDE (6 << RESOLUTION_FACTOR) // JMS_GFX: Because of the ifdef NEVER this is actually never run. Well, changed it for consistency
 					else if (magnitude > MAX_MAGNITUDE)
 						magnitude = MAX_MAGNITUDE;
 					log_add (log_Debug, "magnitude = %u", magnitude);
@@ -126,8 +126,8 @@ CalculateGravity (ELEMENT *ElementPtr)
 
 						angle = ARCTAN (dx, dy);
 						DeltaVelocityComponents (&TestElementPtr->velocity,
-								COSINE (angle, WORLD_TO_VELOCITY (1)),
-								SINE (angle, WORLD_TO_VELOCITY (1)));
+								COSINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR)),
+								SINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR))); // JMS_GFX
 						if (TestElementPtr->state_flags & PLAYER_SHIP)
 						{
 							STARSHIP *StarShipPtr;
diff -ruNp src.orig/uqm/grpinfo.c src/uqm/grpinfo.c
--- src.orig/uqm/grpinfo.c	2017-12-30 00:14:40 -0800
+++ src/uqm/grpinfo.c	2017-12-30 00:14:52 -0800
@@ -272,8 +272,8 @@ BuildGroups (void)
 		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hFleet);
 		hNextFleet = _GetSuccLink (FleetPtr);
 
-		if ((encounter_radius = FleetPtr->actual_strength)
-				&& (i = EncounterPercent[Index]))
+		if (((encounter_radius = FleetPtr->actual_strength)
+				&& (i = EncounterPercent[Index])))
 		{
 			SIZE dx, dy;
 			DWORD d_squared;
@@ -332,7 +332,10 @@ BuildGroups (void)
 						i = 4;
 					}
 
-					BestPercent = i;
+					// JMS: No Ur-Quan or Kohr-Ah at Zoqfot home system.
+					if (!(CurStarDescPtr->Index == ZOQFOT_DEFINED && (FleetPtr->SpeciesID == UR_QUAN_ID || FleetPtr->SpeciesID == KOHR_AH_ID)))
+						BestPercent = i;
+
 					BestIndex = Index;
 				}
 			}
diff -ruNp src.orig/uqm/grpinfo.h src/uqm/grpinfo.h
--- src.orig/uqm/grpinfo.h	2017-12-30 00:14:40 -0800
+++ src/uqm/grpinfo.h	2017-12-30 00:14:52 -0800
@@ -57,6 +57,9 @@ typedef struct
 	POINT loc;
 
 	FRAME melee_icon;
+	
+	// JMS: direction memory prevents jittering of battle group icons when they change direction they're flying to.
+	BYTE lastDirection;
 } IP_GROUP;
 
 enum
diff -ruNp src.orig/uqm/hyper.c src/uqm/hyper.c
--- src.orig/uqm/hyper.c	2017-12-30 00:14:40 -0800
+++ src/uqm/hyper.c	2017-12-30 00:14:52 -0800
@@ -39,14 +39,20 @@
 #include "setup.h"
 #include "sounds.h"
 #include "options.h"
+#include "libs/gfxlib.h"
 #include "libs/graphics/gfx_common.h"
+#include "libs/graphics/drawable.h"
 #include "libs/mathlib.h"
-
+#include "libs/log.h"
 
 #define XOFFS ((RADAR_SCAN_WIDTH + (UNIT_SCREEN_WIDTH << 2)) >> 1)
 #define YOFFS ((RADAR_SCAN_HEIGHT + (UNIT_SCREEN_HEIGHT << 2)) >> 1)
 
-static FRAME hyperstars[3];
+static FRAME npcbubble;			// BW: animated bubble
+static FRAME quasiportal;       // JMS: animated quasispace portal in hyperspace
+static FRAME Falayalaralfali;        // JMS: Arilou homeworld in quasispace
+static FRAME hyperholes[3];		// BW: One for each flavour of space
+static FRAME hyperstars[4];
 static COLORMAP hypercmaps[2];
 static BYTE fuel_ticks;
 static COUNT hyper_dx, hyper_dy, hyper_extra;
@@ -65,9 +71,9 @@ enum HyperMenuItems
 
 
 void
-MoveSIS (SIZE *pdx, SIZE *pdy)
+MoveSIS (SDWORD *pdx, SDWORD *pdy)
 {
-	SIZE new_dx, new_dy;
+	SDWORD new_dx, new_dy;
 
 	new_dx = *pdx;
 	GLOBAL_SIS (log_x) -= new_dx;
@@ -146,7 +152,9 @@ MoveSIS (SIZE *pdx, SIZE *pdy)
 		if (cur_fuel_ticks > (COUNT)fuel_ticks)
 		{
 #ifndef TESTING
-			DeltaSISGauges (0, fuel_ticks - cur_fuel_ticks, 0);
+			if (!optInfiniteFuel)
+				DeltaSISGauges (0, fuel_ticks - cur_fuel_ticks, 0);
+			
 #endif /* TESTING */
 			if (cur_fuel_ticks > 0x00FF)
 			{
@@ -285,12 +293,30 @@ check_hyperspace_encounter (void)
 void
 FreeHyperData (void)
 {
+	if (RESOLUTION_FACTOR > 0) {
+		DestroyDrawable (ReleaseDrawable (hyperholes[1]));
+		hyperholes[1] = 0;
+		DestroyDrawable (ReleaseDrawable (hyperholes[2]));
+		hyperholes[2] = 0;
+		// BW: TODO left out for demo
+		// DestroyDrawable (ReleaseDrawable (hyperspacesuns));
+		// hyperspacesuns = 0;
+		DestroyDrawable (ReleaseDrawable (npcbubble));
+		npcbubble = 0;
+		DestroyDrawable (ReleaseDrawable (quasiportal));
+		quasiportal = 0;
+		DestroyDrawable (ReleaseDrawable (Falayalaralfali));
+		Falayalaralfali = 0;
+	}
+	
 	DestroyDrawable (ReleaseDrawable (hyperstars[0]));
 	hyperstars[0] = 0;
 	DestroyDrawable (ReleaseDrawable (hyperstars[1]));
 	hyperstars[1] = 0;
 	DestroyDrawable (ReleaseDrawable (hyperstars[2]));
 	hyperstars[2] = 0;
+	DestroyDrawable (ReleaseDrawable (hyperstars[3]));
+	hyperstars[3] = 0;
 
 	DestroyColorMap (ReleaseColorMap (hypercmaps[0]));
 	hypercmaps[0] = 0;
@@ -301,16 +327,29 @@ FreeHyperData (void)
 static void
 LoadHyperData (void)
 {
-	if (hyperstars[0] == 0)
-	{
+	if (RESOLUTION_FACTOR > 0) {
+		if (hyperholes[1] == 0) {
+			hyperholes[1] = CaptureDrawable (
+				LoadGraphic (HYPERHOLES_MASK_PMAP_ANIM));
+			hyperholes[2] = CaptureDrawable (
+				LoadGraphic (ARIHOLES_MASK_PMAP_ANIM));
+			hyperstars[3] = CaptureDrawable (
+				LoadGraphic (ARI_AMBIENT_MASK_PMAP_ANIM));
+		}
+		npcbubble = CaptureDrawable (LoadGraphic (NPCBUBBLE_MASK_PMAP_ANIM));
+		quasiportal = CaptureDrawable (LoadGraphic (QUASIPORTAL_MASK_PMAP_ANIM));
+        Falayalaralfali  = CaptureDrawable (LoadGraphic (FALAYALARALFALI_MASK_PMAP_ANIM));
+	}
+	
+	if (hyperstars[0] == 0) {
 		hyperstars[0] = CaptureDrawable (
 				LoadGraphic (AMBIENT_MASK_PMAP_ANIM));
 		hyperstars[1] = CaptureDrawable (
 				LoadGraphic (HYPERSTARS_MASK_PMAP_ANIM));
-		hypercmaps[0] = CaptureColorMap (LoadColorMap (HYPER_COLOR_TAB));
-
 		hyperstars[2] = CaptureDrawable (
 				LoadGraphic (ARISPACE_MASK_PMAP_ANIM));
+
+		hypercmaps[0] = CaptureColorMap (LoadColorMap (HYPER_COLOR_TAB));		
 		hypercmaps[1] = CaptureColorMap (LoadColorMap (ARISPACE_COLOR_TAB));
 	}
 }
@@ -328,11 +367,17 @@ LoadHyperspace (void)
 
 	LoadHyperData ();
 	{
-		FRAME F;
+		FRAME F, FQ;
 		
 		F = hyperstars[0];
 		hyperstars[0] = stars_in_space;
 		stars_in_space = F;
+
+		if (RESOLUTION_FACTOR > 0) {
+			FQ = hyperstars[3];
+			hyperstars[3] = stars_in_quasispace;
+			stars_in_quasispace = FQ;
+		}
 	}
 
 	if (!(LastActivity & CHECK_LOAD))
@@ -381,11 +426,17 @@ BOOLEAN
 FreeHyperspace (void)
 {
 	{
-		FRAME F;
+		FRAME F, FQ;
 		
 		F = hyperstars[0];
 		hyperstars[0] = stars_in_space;
 		stars_in_space = F;
+
+		if (RESOLUTION_FACTOR > 0) {
+			FQ = hyperstars[3];
+			hyperstars[3] = stars_in_quasispace;
+			stars_in_quasispace = FQ;
+		}
 	}
 //    FreeHyperData ();
 
@@ -467,11 +518,24 @@ InterplanetaryTransition (ELEMENT *Eleme
 
 		ElementToUniverse (ElementPtr, &pt);
 		CurStarDescPtr = FindStar (NULL, &pt, 5, 5);
+
+		// JMS: Debugging helpers
+		/*{
+			STAR_DESC *SDPtr, *SDPtr2;
+			SDPtr = CurStarDescPtr;
+			SDPtr2 = FindStar (NULL, &pt, 500, 500);
+			log_add(log_Debug, "SDPtr.x %d, SDPtr.y %d SDPtr2.x %d, SDPtr2.y %d, pt.x %d pt.y %d", 
+				SDPtr->star_pt.x, SDPtr->star_pt.y, SDPtr2->star_pt.x, SDPtr2->star_pt.y, pt.x, pt.y);
+		}*/
+
 		if (CurStarDescPtr->star_pt.x == ARILOU_HOME_X
 				&& CurStarDescPtr->star_pt.y == ARILOU_HOME_Y)
 		{
 			// Meet the Arilou.
 			GLOBAL (CurrentActivity) |= START_ENCOUNTER;
+
+			// JMS: The arilou homeworld name can now be shown on QS map.
+			SET_GAME_STATE (KNOW_QS_PORTAL_15, 1);
 		}
 		else
 		{
@@ -484,6 +548,10 @@ InterplanetaryTransition (ELEMENT *Eleme
 			GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX (portal_pt[index].x);
 			GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY (portal_pt[index].y);
 
+			// JMS: This QS portal's HS coordinates are revealed on QS map
+			// the next time the player visits QS.
+			SET_QS_PORTAL_KNOWN(index);
+
 			SET_GAME_STATE (ARILOU_SPACE_SIDE, 0);
 		}
 	}
@@ -531,6 +599,25 @@ unhyper_transition (ELEMENT *ElementPtr)
 {
 	COUNT frame_index;
 
+	// JMS: If leaving interplanetary on autopilot, always arrive HS with
+	// the ship's nose pointed into correct direction.
+	if ((GLOBAL (autopilot)).x != ~0 && (GLOBAL (autopilot)).y != ~0) {
+		STARSHIP *StarShipPtr;
+		POINT universe;
+		SIZE facing;
+		SDWORD udx = 0, udy = 0;
+			
+		GetElementStarShip (ElementPtr, &StarShipPtr);
+		universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+		universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+		udx = (GLOBAL (autopilot)).x - universe.x;
+		udy = -((GLOBAL (autopilot)).y - universe.y);
+			
+		facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (udx, udy)));
+		StarShipPtr->ShipFacing = facing;
+		SetElementStarShip(ElementPtr, StarShipPtr);
+	}
+
 	ElementPtr->state_flags |= CHANGING;
 
 	frame_index = GetFrameIndex (ElementPtr->current.image.frame);
@@ -625,6 +712,25 @@ hyper_transition (ELEMENT *ElementPtr)
 	else
 	{
 		COUNT frame_index;
+		
+		// JMS: If leaving interplanetary on autopilot, always arrive HS with
+		// the ship's nose pointed into correct direction.
+		if ((GLOBAL (autopilot)).x != ~0 && (GLOBAL (autopilot)).y != ~0) {
+			STARSHIP *StarShipPtr;
+			POINT universe;
+			SIZE facing;
+			SDWORD udx = 0, udy = 0;
+			
+			GetElementStarShip (ElementPtr, &StarShipPtr);
+			universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+			universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+			udx = (GLOBAL (autopilot)).x - universe.x;
+			udy = -((GLOBAL (autopilot)).y - universe.y);
+			
+			facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (udx, udy)));
+			StarShipPtr->ShipFacing = facing;
+			SetElementStarShip(ElementPtr, StarShipPtr);
+		}
 
 		frame_index = GetFrameIndex (ElementPtr->current.image.frame);
 		if (frame_index-- <= ANGLE_TO_FACING (FULL_CIRCLE))
@@ -819,24 +925,40 @@ AddAmbientElement (void)
 
 		rand_val = TFB_Random ();
 		dy = LOWORD (rand_val);
-		dx = (SIZE)(LOBYTE (dy) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
-		dy = (SIZE)(HIBYTE (dy) % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
-		HyperSpaceElementPtr->current.location.x = (LOG_SPACE_WIDTH >> 1)
-				+ DISPLAY_TO_WORLD (dx);
-		HyperSpaceElementPtr->current.location.y = (LOG_SPACE_HEIGHT >> 1)
-				+ DISPLAY_TO_WORLD (dy);
-		HyperSpaceElementPtr->current.image.farray = &stars_in_space;
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0) {
+			dx = (SIZE)(LOBYTE (dy) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
+			dy = (SIZE)(HIBYTE (dy) % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
+			HyperSpaceElementPtr->current.image.farray = &stars_in_space;
+		} else {
+			dx = (SIZE)((HIWORD (rand_val)) % SPACE_WIDTH) - (SPACE_WIDTH >> 1);
+			dy = (SIZE)(dy % SPACE_HEIGHT) - (SPACE_HEIGHT >> 1);
+			
+			if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				HyperSpaceElementPtr->current.image.farray = &stars_in_space;
+			else
+				HyperSpaceElementPtr->current.image.farray = &stars_in_quasispace;
+		}
+		
+		HyperSpaceElementPtr->current.location.x = (LOG_SPACE_WIDTH >> 1) + DISPLAY_TO_WORLD (dx);
+		HyperSpaceElementPtr->current.location.y = (LOG_SPACE_HEIGHT >> 1) + DISPLAY_TO_WORLD (dy);
 
 		if (HIWORD (rand_val) & 7)
 		{
 			HyperSpaceElementPtr->life_span = 14;
-			HyperSpaceElementPtr->current.image.frame = stars_in_space;
+			if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				HyperSpaceElementPtr->current.image.frame = stars_in_space;
+			else
+				HyperSpaceElementPtr->current.image.frame = stars_in_quasispace;
 		}
 		else
 		{
 			HyperSpaceElementPtr->life_span = 12;
-			HyperSpaceElementPtr->current.image.frame =
-					SetAbsFrameIndex (stars_in_space, 14);
+			if (RESOLUTION_FACTOR == 0 || (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (stars_in_space, 14);
+			else
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (stars_in_quasispace, 14);
 		}
 
 		UnlockElement (hHyperSpaceElement);
@@ -871,8 +993,16 @@ encounter_transition (ELEMENT *ElementPt
 			f = IncFrameIndex (ElementPtr->current.image.frame);
 			if (f != ElementPtr->current.image.farray[0])
 				ElementPtr->next.image.frame = f;
-			else
-				ElementPtr->death_func = NULL;
+			else {
+ 				ElementPtr->death_func = NULL;
+				// BW: the bubble has reached full size so we start animation
+				if (RESOLUTION_FACTOR > 0) {
+					ElementPtr->current.image.farray = &npcbubble;
+					ElementPtr->next.image.farray = &npcbubble;
+					ElementPtr->current.image.frame = SetAbsFrameIndex(npcbubble, 0);
+					ElementPtr->next.image.frame = SetAbsFrameIndex(npcbubble, 0);
+				}
+			}
 		}
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
@@ -1067,13 +1197,19 @@ AddEncounterElement (ENCOUNTER *Encounte
 		}
 		else
 		{
-			ElementPtr->current.image.frame =
-					DecFrameIndex (ElementPtr->current.image.farray[0]);
+			if (RESOLUTION_FACTOR > 0) {
+				ElementPtr->current.image.farray = &npcbubble;
+				ElementPtr->next.image.farray = &npcbubble;
+				ElementPtr->current.image.frame = SetAbsFrameIndex(npcbubble, 0);
+				ElementPtr->next.image.frame = SetAbsFrameIndex(npcbubble, 0);
+			} else {
+				ElementPtr->current.image.frame = DecFrameIndex (ElementPtr->current.image.farray[0]);
+			}
 		}
 
 		ElementPtr->turn_wait = VORTEX_WAIT;
 		ElementPtr->preprocess_func = NULL;
-		ElementPtr->postprocess_func = NULL;
+		ElementPtr->postprocess_func = NULL; // decorate_vortex;
 		ElementPtr->collision_func = encounter_collision;
 
 		SetUpElement (ElementPtr);
@@ -1235,6 +1371,10 @@ ProcessEncounter (ENCOUNTER *EncounterPt
 		EncounterPtr->loc_pt.x = LOGX_TO_UNIVERSE (EncounterPtr->log_x);
 		EncounterPtr->loc_pt.y = LOGY_TO_UNIVERSE (EncounterPtr->log_y);
 
+		// BW: Animate the NPC bubble in hi-res modes.
+		if (RESOLUTION_FACTOR > 0)
+			ElementPtr->next.image.frame = IncFrameIndex (ElementPtr->current.image.frame);
+
 		encounter_radius = EncounterPtr->radius + (GRID_OFFSET >> 1);
 		delta_x = EncounterPtr->loc_pt.x - EncounterPtr->origin.x;
 		if (delta_x < 0)
@@ -1344,6 +1484,10 @@ ProcessEncounters (POINT *puniverse, COO
 	}
 }
 
+#define NUM_HOLES_FRAMES 32 // BW
+#define NUM_SUNS_FRAMES 32 // BW
+#define NUM_QUASIPORTAL_IN_HS_FRAMES 30 // JMS
+
 void
 SeedUniverse (void)
 {
@@ -1357,6 +1501,10 @@ SeedUniverse (void)
 	HELEMENT hHyperSpaceElement;
 	ELEMENT *HyperSpaceElementPtr;
 
+	static COUNT frameCounter; // BW
+	
+	frameCounter++; // BW
+
 	universe.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
 	universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
 
@@ -1479,17 +1627,34 @@ SeedUniverse (void)
 				ey = -ey;
 
 			if (ex > (XOFFS / NUM_RADAR_SCREENS)
-					|| ey > (YOFFS / NUM_RADAR_SCREENS))
-				continue;
+				|| ey > (YOFFS / NUM_RADAR_SCREENS))
+			continue;
 
 			hHyperSpaceElement = AllocHyperElement (&SD[i].star_pt);
 			if (hHyperSpaceElement == 0)
 				continue;
 
 			LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
-			HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+			if (RESOLUTION_FACTOR == 0
+				|| (SD[i].Index < 22 && arilouSpaceSide <= 1)
+				|| (SD[i].Index < 4 && arilouSpaceSide > 1))
+			{
+				// The QS portal is still growing (Or when playing in 1x resolution).
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
 					hyperstars[1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1)],
 					SD[i].Index);
+			} else if (arilouSpaceSide > 1) {
+				// QS. The QS portal has done its growing animation: in 2x and 4x res switch to the full-size anim.
+				HyperSpaceElementPtr->current.image.frame =
+					SetAbsFrameIndex (quasiportal, frameCounter % NUM_HOLES_FRAMES);
+				HyperSpaceElementPtr->current.image.farray = &hyperholes[2];
+			} else {
+				// HS. The QS portal has done its growing animation: in 2x and 4x res switch to the full-size anim.
+				HyperSpaceElementPtr->current.image.frame =
+					SetAbsFrameIndex (quasiportal, frameCounter % NUM_QUASIPORTAL_IN_HS_FRAMES);
+				HyperSpaceElementPtr->current.image.farray = &quasiportal;
+			}
+
 			HyperSpaceElementPtr->preprocess_func = NULL;
 			HyperSpaceElementPtr->postprocess_func = NULL;
 			HyperSpaceElementPtr->collision_func = arilou_space_collision;
@@ -1516,6 +1681,7 @@ SeedUniverse (void)
 		while ((SDPtr = FindStar (SDPtr, &universe, XOFFS, YOFFS)))
 		{
 			BYTE star_type;
+			int which_spaces_star_gfx;
 
 			ex = SDPtr->star_pt.x - universe.x;
 			if (ex < 0)
@@ -1527,35 +1693,140 @@ SeedUniverse (void)
 					|| ey > (YOFFS / NUM_RADAR_SCREENS))
 				continue;
 
-			hHyperSpaceElement = AllocHyperElement (&SDPtr->star_pt);
-			if (hHyperSpaceElement == 0)
-				continue;
-
 			star_type = SDPtr->Type;
 
-			LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
-			HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
-					hyperstars[1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1)],
+			if (RESOLUTION_FACTOR == 0) {
+				hHyperSpaceElement = AllocHyperElement (&SDPtr->star_pt);
+				if (hHyperSpaceElement == 0)
+					continue;
+				
+				LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+				which_spaces_star_gfx = 1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1);
+				
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+					hyperstars[which_spaces_star_gfx],
 					STAR_TYPE (star_type) * NUM_STAR_COLORS
 					+ STAR_COLOR (star_type));
-			HyperSpaceElementPtr->preprocess_func = NULL;
-			HyperSpaceElementPtr->postprocess_func = NULL;
-			HyperSpaceElementPtr->collision_func = hyper_collision;
-
-			SetUpElement (HyperSpaceElementPtr);
-
-			if (SDPtr == CurStarDescPtr
-					&& GET_GAME_STATE (PORTAL_COUNTER) == 0)
-				HyperSpaceElementPtr->death_func = hyper_death;
-			else
-			{
-				HyperSpaceElementPtr->death_func = NULL;
-				HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
-						DecFrameIndex (stars_in_space);
+				
+				HyperSpaceElementPtr->preprocess_func = NULL;
+				HyperSpaceElementPtr->postprocess_func = NULL;
+				HyperSpaceElementPtr->collision_func = hyper_collision;
+				
+				SetUpElement (HyperSpaceElementPtr);
+				
+				if (SDPtr == CurStarDescPtr
+				    && GET_GAME_STATE (PORTAL_COUNTER) == 0)
+					HyperSpaceElementPtr->death_func = hyper_death;
+				else
+				{
+					HyperSpaceElementPtr->death_func = NULL;
+					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
+					DecFrameIndex (stars_in_space);
+				}
+				UnlockElement (hHyperSpaceElement);
+				
+				InsertElement (hHyperSpaceElement, GetHeadElement ());
+			} else {
+				// BW: first the actual star
+				if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1 
+					|| ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY))
+				{
+					hHyperSpaceElement = AllocHyperElement (&SDPtr->star_pt);
+					if (hHyperSpaceElement == 0)
+						continue;
+				
+					LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+				
+					// JMS_GFX: Draw stars in hyperspace.
+					if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+					{
+						// The color, then the size and finally
+						// the frame offset for the actual animation
+						HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+						hyperspacesuns, STAR_COLOR (star_type) * NUM_STAR_TYPES * NUM_SUNS_FRAMES
+						+ STAR_TYPE (star_type) * NUM_SUNS_FRAMES
+						+ frameCounter % NUM_SUNS_FRAMES);
+					
+						HyperSpaceElementPtr->current.image.farray = &hyperspacesuns;
+						HyperSpaceElementPtr->death_func = NULL;
+					}
+					// JMS_GFX: Draw Arilou homeworld in quasispace.
+					else if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY)
+					{
+						// JMS_GFX: Draw Arilou homeworld in quasispace | Serosis: Draw *animated* Arilou homeworld
+						HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (Falayalaralfali, frameCounter % NUM_HOLES_FRAMES);
+						HyperSpaceElementPtr->current.image.farray = &Falayalaralfali;
+					}
+					HyperSpaceElementPtr->death_func = NULL;
+					HyperSpaceElementPtr->preprocess_func = NULL;
+					HyperSpaceElementPtr->postprocess_func = NULL;
+					HyperSpaceElementPtr->collision_func = hyper_collision;
+				
+					SetUpElement (HyperSpaceElementPtr);
+				
+					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame = DecFrameIndex (stars_in_space);
+				
+					UnlockElement (hHyperSpaceElement);
+				
+					InsertElement (hHyperSpaceElement, GetHeadElement ());
+				
+					// JMS_GFX: Don't draw hole for arilou homeworld - it already has a nice planet gfx.
+					if ((GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1) && STAR_COLOR (star_type) == YELLOW_BODY && RESOLUTION_FACTOR == 0)
+						continue;
+				
+				}
+				
+				// BW: and then the animated hyperspace portal
+				hHyperSpaceElement = AllocHyperElement (&SDPtr->star_pt);
+				if (hHyperSpaceElement == 0)
+					continue;
+				
+				LockElement (hHyperSpaceElement, &HyperSpaceElementPtr);
+				which_spaces_star_gfx = 1 + (GET_GAME_STATE (ARILOU_SPACE_SIDE) >> 1);
+				
+				// Most holes go 100, 150, 200 or 150, 200, 250
+				HyperSpaceElementPtr->current.image.frame = SetAbsFrameIndex (
+					hyperholes[which_spaces_star_gfx],
+					STAR_TYPE (star_type) * NUM_HOLES_FRAMES);
+				
+				// Green, orange and yellow need bigger holes
+				if (STAR_COLOR (star_type) == GREEN_BODY 
+					|| STAR_COLOR (star_type) == ORANGE_BODY 
+					|| STAR_COLOR (star_type) == YELLOW_BODY)
+					HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+						HyperSpaceElementPtr->current.image.frame,
+						NUM_HOLES_FRAMES);
+				
+				// Super giant blue needs a bigger hole
+				if (STAR_COLOR (star_type) == BLUE_BODY 
+					&& STAR_TYPE (star_type) == SUPER_GIANT_STAR)
+					HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+						HyperSpaceElementPtr->current.image.frame,
+						NUM_HOLES_FRAMES);
+				
+				// The actual animation
+				HyperSpaceElementPtr->current.image.frame = SetRelFrameIndex (
+					HyperSpaceElementPtr->current.image.frame,
+					frameCounter % NUM_HOLES_FRAMES);
+
+				HyperSpaceElementPtr->current.image.farray = &hyperholes[which_spaces_star_gfx];
+				HyperSpaceElementPtr->preprocess_func = NULL;
+				HyperSpaceElementPtr->postprocess_func = NULL;
+				HyperSpaceElementPtr->collision_func = hyper_collision;
+				
+				SetUpElement (HyperSpaceElementPtr);
+				
+				if ((SDPtr == CurStarDescPtr && GET_GAME_STATE (PORTAL_COUNTER) == 0)) {
+					HyperSpaceElementPtr->death_func = hyper_death;
+				} else {
+					HyperSpaceElementPtr->death_func = NULL;
+					HyperSpaceElementPtr->IntersectControl.IntersectStamp.frame =
+					DecFrameIndex (stars_in_space);
+				}
+				UnlockElement (hHyperSpaceElement);
+				
+				InsertElement (hHyperSpaceElement, GetHeadElement ());	
 			}
-			UnlockElement (hHyperSpaceElement);
-
-			InsertElement (hHyperSpaceElement, GetHeadElement ());
 		}
 		ProcessEncounters (&universe, ox, oy);
 	}
@@ -1662,6 +1933,8 @@ DoHyperspaceMenu (MENU_STATE *pMS)
 			StarMap ();
 			return FALSE;
 		case NAVIGATION:
+			if(RESOLUTION_FACTOR == 1)				
+				DrawSubmenu (0);
 			return FALSE;
 	}
 
diff -ruNp src.orig/uqm/hyper.h src/uqm/hyper.h
--- src.orig/uqm/hyper.h	2017-12-30 00:14:40 -0800
+++ src/uqm/hyper.h	2017-12-30 00:14:52 -0800
@@ -29,8 +29,8 @@ extern "C" {
 
 #define NUM_RADAR_SCREENS 12
 
-#define RADAR_SCAN_WIDTH (UNIT_SCREEN_WIDTH * NUM_RADAR_SCREENS)
-#define RADAR_SCAN_HEIGHT (UNIT_SCREEN_HEIGHT * NUM_RADAR_SCREENS)
+#define RADAR_SCAN_WIDTH ((UNIT_SCREEN_WIDTH * NUM_RADAR_SCREENS) >> RESOLUTION_FACTOR)
+#define RADAR_SCAN_HEIGHT ((UNIT_SCREEN_HEIGHT * NUM_RADAR_SCREENS) >> RESOLUTION_FACTOR)
 
 // Hyperspace coordinates of the naturally occuring portal into QuasiSpace
 #define ARILOU_SPACE_X   438
@@ -41,8 +41,8 @@ extern "C" {
 #define QUASI_SPACE_Y  5000
 
 // QuasiSpace coordinates of the Arilou home world
-#define ARILOU_HOME_X  (QUASI_SPACE_X + ((RADAR_SCAN_WIDTH >> 1) * 3))
-#define ARILOU_HOME_Y  (QUASI_SPACE_Y + ((RADAR_SCAN_HEIGHT >> 1) * 3))
+#define ARILOU_HOME_X 6134 // (QUASI_SPACE_X + ((RADAR_SCAN_WIDTH >> 1) * 3))
+#define ARILOU_HOME_Y 5900 // (QUASI_SPACE_Y + ((RADAR_SCAN_HEIGHT >> 1) * 3))
 
 // HyperSpace coordinates of the locations where the QuasiSpace portals
 // take you.
@@ -74,7 +74,7 @@ extern "C" {
 extern BOOLEAN LoadHyperspace (void);
 extern BOOLEAN FreeHyperspace (void);
 extern void SeedUniverse (void);
-extern void MoveSIS (SIZE *pdx, SIZE *pdy);
+extern void MoveSIS (SDWORD *pdx, SDWORD *pdy);
 
 extern void FreeHyperData (void);
 extern void check_hyperspace_encounter (void);
diff -ruNp src.orig/uqm/ifontres.h src/uqm/ifontres.h
--- src.orig/uqm/ifontres.h	2017-12-30 00:14:40 -0800
+++ src/uqm/ifontres.h	2017-12-30 00:14:52 -0800
@@ -4,9 +4,20 @@
 
 #define LANDER_FONT "font.lander"
 #define MICRO_FONT "font.micro"
+#define NANO_FONT "font.nano"
 #define PLAYER_FONT "font.player"
 #define PT13AA_FONT "credits.font.pt13"
 #define PT17AA_FONT "credits.font.pt17"
 #define PT45AA_FONT "credits.font.pt45"
 #define STARCON_FONT "font.starcon"
 #define TINY_FONT "font.tiny"
+#define TINY_FALLBACK_TO1X_FONT "font.tinyfallbackto1x"
+#define TINY_FALLBACK_TO2X_FONT "font.tinyfallbackto2x"
+#define TINY_FALLBACK_TO4X_FONT "font.tinyfallbackto4x"
+#define PLYR_FALLBACK_TO1X_FONT "font.plyrfallbackto1x"
+#define PLYR_FALLBACK_TO2X_FONT "font.plyrfallbackto2x"
+#define PLYR_FALLBACK_TO4X_FONT "font.plyrfallbackto4x"
+#define SCON_FALLBACK_TO1X_FONT "font.sconfallbackto1x"
+#define SCON_FALLBACK_TO2X_FONT "font.sconfallbackto2x"
+#define SCON_FALLBACK_TO4X_FONT "font.sconfallbackto4x"
+#define COMPUTER_FONT "comm.computer.font"
diff -ruNp src.orig/uqm/igfxres.h src/uqm/igfxres.h
--- src.orig/uqm/igfxres.h	2017-12-30 00:14:40 -0800
+++ src/uqm/igfxres.h	2017-12-30 00:14:52 -0800
@@ -5,6 +5,8 @@
 #define ACTIVITY_ANIM "graphics.activity"
 #define AMBIENT_MASK_PMAP_ANIM "graphics.ambient"
 #define AQUA_MASK_PMAP_ANIM "graphics.aquahelix"
+#define ARI_AMBIENT_MASK_PMAP_ANIM "graphics.ambientquasispace"
+#define ARIHOLES_MASK_PMAP_ANIM "graphics.quasiholes"
 #define ARISPACE_MASK_PMAP_ANIM "graphics.quasispace"
 #define ASTEROID_BIG_MASK_PMAP_ANIM "graphics.asteroid.large"
 #define ASTEROID_MED_MASK_PMAP_ANIM "graphics.asteroid.medium"
@@ -17,14 +19,45 @@
 #define BOOM_MED_MASK_PMAP_ANIM "graphics.boom.medium"
 #define BOOM_SML_MASK_PMAP_ANIM "graphics.boom.small"
 #define BURV_BCS_MASK_PMAP_ANIM "graphics.burvixcaster"
+#define CALLISTO_MASK_ANIM "graphics.callistomask"
 #define CANNISTER_MASK_PMAP_ANIM "graphics.lifecan"
+#define CONSTELLATIONS_MASK_PMAP_ANIM "graphics.constellations"
 #define CREDITS_BACK_ANIM "credits.background"
+#define CREW_BIG_MASK_PMAP_ANIM "graphics.crew.large"
+#define CREW_MED_MASK_PMAP_ANIM "graphics.crew.medium"
+#define CREW_SML_MASK_PMAP_ANIM "graphics.crew.small"
 #define EARTH_MASK_ANIM "graphics.earthmask"
 #define EGG_CASE_MASK_PMAP_ANIM "graphics.eggcase"
+#define EUROPA_MASK_ANIM "graphics.europamask"
+#define FALAYALARALFALI_MASK_PMAP_ANIM "graphics.falayalaralfali"
 #define FLAGSTAT_MASK_PMAP_ANIM "graphics.flagshipstatus"
 #define FONTGRAD_PMAP_ANIM "graphics.fontgradient"
+#define GANYMEDE_MASK_ANIM "graphics.ganymedemask"
+#define HYPERHOLES_MASK_PMAP_ANIM "graphics.hyperholes"
 #define HYPERSTARS_MASK_PMAP_ANIM "graphics.hyperstars"
+#define HYPERSUNS_MASK_PMAP_ANIM "graphics.hypersuns"
+#define IO_MASK_ANIM "graphics.iomask"
+#define IONS_BIG_MASK_PMAP_ANIM "graphics.ions.large"
+#define IONS_MED_MASK_PMAP_ANIM "graphics.ions.medium"
+#define IONS_SML_MASK_PMAP_ANIM "graphics.ions.small"
 #define IPBKGND_MASK_PMAP_ANIM "graphics.orbitbackground"
+#define IP_CALLISTO_MASK_ANIM "graphics.ipcallistomask"
+#define IP_EARTH_MASK_ANIM "graphics.ipearthmask"
+#define IP_EUROPA_MASK_ANIM "graphics.ipeuropamask"
+#define IP_GANYMEDE_MASK_ANIM "graphics.ipganymedemask"
+#define IP_IO_MASK_ANIM "graphics.ipiomask"
+#define IP_JUPITER_MASK_ANIM "graphics.ipjupitermask"
+#define IP_LUNA_MASK_ANIM "graphics.iplunamask"
+#define IP_MARS_MASK_ANIM "graphics.ipmarsmask"
+#define IP_MERCURY_MASK_ANIM "graphics.ipmercurymask"
+#define IP_NEPTUNE_MASK_ANIM "graphics.ipneptunemask"
+#define IP_PLUTO_MASK_ANIM "graphics.ipplutomask"
+#define IP_SATURN_MASK_ANIM "graphics.ipsaturnmask"
+#define IP_TITAN_MASK_ANIM "graphics.iptitanmask"
+#define IP_TRITON_MASK_ANIM "graphics.iptritonmask"
+#define IP_URANUS_MASK_ANIM "graphics.ipuranusmask"
+#define IP_VENUS_MASK_ANIM "graphics.ipvenusmask"
+#define JUPITER_MASK_ANIM "graphics.jupitermask"
 #define LANDER_FONTEFF_PMAP_ANIM "graphics.landerfonteffect"
 #define LANDER_LAUNCH_MASK_PMAP_ANIM "graphics.landerlaunch"
 #define LANDER_MASK_PMAP_ANIM "graphics.lander"
@@ -58,13 +91,21 @@
 #define LIFE24_MASK_PMAP_ANIM "graphics.life.24"
 #define LIFE25_MASK_PMAP_ANIM "graphics.life.25"
 #define LIGHTNING_MASK_ANIM "graphics.lightning"
+#define LUNA_MASK_ANIM "graphics.lunamask"
 #define MAIDENS_MASK_PMAP_ANIM "graphics.maidens"
+#define MARS_MASK_ANIM "graphics.marsmask"
 #define MELEE_PICK_MASK_PMAP_ANIM "graphics.meleepickship"
 #define MELEE_SCREEN_PMAP_ANIM "graphics.meleemenu"
 #define MENUBKG_PMAP_ANIM "graphics.setupmenu"
+#define MENUBKG_PMAP_ANIM2X "graphics.setupmenu2x"
+#define MENUBKG_PMAP_ANIM4X "graphics.setupmenu4x"
+#define MERCURY_MASK_ANIM "graphics.mercurymask"
 #define MISCDATA_MASK_PMAP_ANIM "graphics.miscdata"
 #define MODULES_PMAP_ANIM "graphics.modulesmenu"
 #define MOONBASE_MASK_PMAP_ANIM "graphics.moonbase"
+#define NEBULAE_PMAP_ANIM "graphics.nebulae"
+#define NEPTUNE_MASK_ANIM "graphics.neptunemask"
+#define NPCBUBBLE_MASK_PMAP_ANIM "graphics.npcbubble"
 #define ORBENTER_PMAP_ANIM "graphics.orbitenter"
 #define ORBIT_VIEW_ANIM "graphics.orbview"
 #define ORBPLAN_MASK_PMAP_ANIM "graphics.planets"
@@ -247,10 +288,15 @@
 #define PLANET58_MED_MASK_PMAP_ANIM "planet.yellowgas.medium"
 #define PLANET58_SML_MASK_PMAP_ANIM "planet.yellowgas.small"
 #define PLAYMENU_ANIM "graphics.playmenu"
+#define PLUTO_MASK_ANIM "graphics.plutomask"
 #define QUAKE_MASK_PMAP_ANIM "graphics.quake"
+#define QUASIPORTAL_MASK_PMAP_ANIM "graphics.quasiportal"
 #define RESTART_PMAP_ANIM "graphics.newgame"
+#define RESTART_PMAP_ANIM2x "graphics.newgame2x"
+#define RESTART_PMAP_ANIM4x "graphics.newgame4x"
 #define RUINS_MASK_PMAP_ANIM "graphics.ruins"
 #define SAMATRA_BIG_MASK_PMAP_ANIM "planet.samatra.large"
+#define SATURN_MASK_ANIM "graphics.saturnmask"
 #define SC2_PICK_PMAP_ANIM "graphics.pickship"
 #define SEGUE_PMAP_ANIM "graphics.segue"
 #define SHIELDED_BIG_MASK_PMAP_ANIM "planet.slaveshield.large"
@@ -264,11 +310,25 @@
 #define SPAPLUTO_MASK_PMAP_ANIM "graphics.fwiffo"
 #define STARBASE_ANIM "graphics.starbase"
 #define STAR_MASK_PMAP_ANIM "graphics.stars"
+#define STARPOINT_MASK_PMAP_ANIM "graphics.starpoints"
 #define STATUS_MASK_PMAP_ANIM "graphics.status"
+#define SUBMENU_MASK_PMAP_ANIM "graphics.submenu"
+#define SUNBLUE_MASK_PMAP_ANIM "graphics.truespacesunblue"
+#define SUNGREEN_MASK_PMAP_ANIM "graphics.truespacesungreen"
+#define SUNORANGE_MASK_PMAP_ANIM "graphics.truespacesunorange"
+#define SUNRED_MASK_PMAP_ANIM "graphics.truespacesunred"
+#define SUNWHITE_MASK_PMAP_ANIM "graphics.truespacesunwhite"
+#define SUNYELLOW_MASK_PMAP_ANIM "graphics.truespacesunyellow"
 #define SUN_DEVICE_MASK_PMAP_ANIM "graphics.sundevice"
 #define SUN_MASK_PMAP_ANIM "graphics.truespacesun"
 #define TAALO_DEVICE_MASK_PMAP_ANIM "graphics.taalodevice"
+#define TITAN_MASK_ANIM "graphics.titanmask"
 #define TITLE_ANIM "graphics.title"
+#define TITLE_2X "graphics.title2x"
+#define TITLE_4X "graphics.title4x"
+#define TRITON_MASK_ANIM "graphics.tritonmask"
 #define UMGAH_BCS_MASK_PMAP_ANIM "graphics.umgahcaster"
+#define URANUS_MASK_ANIM "graphics.uranusmask"
 #define VAULT_MASK_PMAP_ANIM "graphics.syreenvault"
+#define VENUS_MASK_ANIM "graphics.venusmask"
 #define WRECK_MASK_PMAP_ANIM "graphics.urquanwreck"
diff -ruNp src.orig/uqm/imusicre.h src/uqm/imusicre.h
--- src.orig/uqm/imusicre.h	2017-12-30 00:14:40 -0800
+++ src/uqm/imusicre.h	2017-12-30 00:14:52 -0800
@@ -6,7 +6,9 @@
 #define CREDITS_MUSIC "music.credits"
 #define HYPERSPACE_MUSIC "music.hyperspace"
 #define IP_MUSIC "music.space"
-#define MAINMENU_MUSIC "music.mainmenu"
+#define MAINMENU1_MUSIC "music.mainmenu1"
+#define MAINMENU2_MUSIC "music.mainmenu2"
+#define MAINMENU3_MUSIC "music.mainmenu3"
 #define MELEE_MUSIC "music.meleemenu"
 #define ORBIT1_MUSIC "music.orbit1"
 #define ORBIT2_MUSIC "music.orbit2"
diff -ruNp src.orig/uqm/init.c src/uqm/init.c
--- src.orig/uqm/init.c	2017-12-30 00:14:40 -0800
+++ src/uqm/init.c	2017-12-30 00:14:52 -0800
@@ -37,6 +37,10 @@
 
 
 FRAME stars_in_space;
+FRAME StarPoints;
+FRAME stars_in_quasispace; // JMS_GFX
+FRAME crew_dots[NUM_VIEWS]; // JMS_GFX
+FRAME ion_trails[NUM_VIEWS]; // JMS_GFX
 FRAME asteroid[NUM_VIEWS];
 FRAME blast[NUM_VIEWS];
 FRAME explosion[NUM_VIEWS];
@@ -121,6 +125,27 @@ InitSpace (void)
 		if (stars_in_space == NULL)
 			return FALSE;
 
+		if(RESOLUTION_FACTOR > 0){
+			StarPoints = CaptureDrawable (
+					LoadGraphic (STARPOINT_MASK_PMAP_ANIM));
+			if (StarPoints == NULL)
+				return FALSE;
+		}
+
+		// JMS_GFX
+		if (!load_animation (crew_dots,
+								CREW_BIG_MASK_PMAP_ANIM,
+								CREW_MED_MASK_PMAP_ANIM,
+								CREW_SML_MASK_PMAP_ANIM))
+			return FALSE;
+        
+		// JMS_GFX
+		if (!load_animation (ion_trails,
+							IONS_BIG_MASK_PMAP_ANIM,
+							IONS_MED_MASK_PMAP_ANIM,
+							IONS_SML_MASK_PMAP_ANIM))
+			return FALSE;
+
 		if (!load_animation (explosion,
 				BOOM_BIG_MASK_PMAP_ANIM,
 				BOOM_MED_MASK_PMAP_ANIM,
@@ -152,8 +177,14 @@ UninitSpace (void)
 		free_image (explosion);
 		free_image (asteroid);
 
+		// JMS_GFX
+		free_image (crew_dots);
+		free_image (ion_trails);
+
 		DestroyDrawable (ReleaseDrawable (stars_in_space));
+		DestroyDrawable (ReleaseDrawable (StarPoints));
 		stars_in_space = 0;
+		StarPoints = 0;
 	}
 }
 
diff -ruNp src.orig/uqm/init.h src/uqm/init.h
--- src.orig/uqm/init.h	2017-12-30 00:14:40 -0800
+++ src/uqm/init.h	2017-12-30 00:14:52 -0800
@@ -19,6 +19,7 @@
 
 #include "libs/gfxlib.h"
 #include "libs/reslib.h"
+#include "units.h"
 
 #if defined(__cplusplus)
 extern "C" {
@@ -28,6 +29,10 @@ extern "C" {
 #define NUM_SIDES 2
 
 extern FRAME stars_in_space;
+extern FRAME StarPoints;
+extern FRAME stars_in_quasispace; // JMS_GFX
+extern FRAME crew_dots[NUM_VIEWS]; // JMS_GFX
+extern FRAME ion_trails[NUM_VIEWS]; // JMS_GFX
 
 extern BOOLEAN InitSpace (void);
 extern void UninitSpace (void);
diff -ruNp src.orig/uqm/intel.h src/uqm/intel.h
--- src.orig/uqm/intel.h	2017-12-30 00:14:40 -0800
+++ src/uqm/intel.h	2017-12-30 00:14:52 -0800
@@ -39,6 +39,29 @@ extern "C" {
 #define MEDIUM_SHIP 45
 #define SLOW_SHIP 25
 
+// JMS_GFX
+#define CLOSE_RANGE_WEAPON_2XRES DISPLAY_TO_WORLD (100)
+#define LONG_RANGE_WEAPON_2XRES DISPLAY_TO_WORLD (2000)
+
+// JMS_GFX: Multiplied by 2*2=4 because of the way the ManeuverabilityIndex
+// is calculated in InitCyborg () (cyborg.c).
+#define FAST_SHIP_2XRES 600
+#define MEDIUM_SHIP_2XRES 180
+#define SLOW_SHIP_2XRES 100
+
+// JMS_GFX
+#define CLOSE_RANGE_WEAPON_4XRES DISPLAY_TO_WORLD (200)
+#define LONG_RANGE_WEAPON_4XRES DISPLAY_TO_WORLD (4000)
+
+// JMS_GFX: Multiplied by 4*4=16 because of the way the ManeuverabilityIndex
+// is calculated in InitCyborg () (cyborg.c).
+#define FAST_SHIP_4XRES 2400
+#define MEDIUM_SHIP_4XRES 720
+#define SLOW_SHIP_4XRES 400
+
+// JMS_GFX
+#define RESOLUTION_COMPENSATED(speed) ((speed << RESOLUTION_FACTOR) << RESOLUTION_FACTOR)
+
 enum
 {
 	ENEMY_SHIP_INDEX = 0,
diff -ruNp src.orig/uqm/intro.c src/uqm/intro.c
--- src.orig/uqm/intro.c	2017-12-30 00:14:40 -0800
+++ src/uqm/intro.c	2017-12-30 00:14:53 -0800
@@ -179,10 +179,12 @@ Present_UnbatchGraphics (PRESENTATION_IN
 static void
 Present_GenerateSIS (PRESENTATION_INPUT_STATE* pPIS)
 {
-#define MODULE_YOFS_P  (-79)
+#define MODULE_YOFS_P  (((-79) << RESOLUTION_FACTOR) + RES_CASE(0,-34,-94)) // JMS_GFX
 #define DRIVE_TOP_Y_P  (DRIVE_TOP_Y + MODULE_YOFS_P)
 #define JET_TOP_Y_P    (JET_TOP_Y + MODULE_YOFS_P)
 #define MODULE_TOP_Y_P (MODULE_TOP_Y + MODULE_YOFS_P)
+#define MODULE_TOP_X_P (MODULE_TOP_X + RES_CASE(0,18,0))
+#define JET_DRIVE_EXTRA_X RES_CASE(0,5,-3)
 	CONTEXT	OldContext;
 	FRAME SisFrame;
 	FRAME ModuleFrame;
@@ -220,7 +222,7 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 		piece = GLOBAL_SIS (DriveSlots[slot]);
 		if (piece < EMPTY_SLOT)
 		{
-			s.origin.x = DRIVE_TOP_X;
+			s.origin.x = DRIVE_TOP_X + JET_DRIVE_EXTRA_X;
 			s.origin.y = DRIVE_TOP_Y_P;
 			s.origin.x += slot * SHIP_PIECE_OFFSET;
 			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
@@ -232,7 +234,7 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 		piece = GLOBAL_SIS (JetSlots[slot]);
 		if (piece < EMPTY_SLOT)
 		{
-			s.origin.x = JET_TOP_X;
+			s.origin.x = JET_TOP_X + JET_DRIVE_EXTRA_X;
 			s.origin.y = JET_TOP_Y_P;
 			s.origin.x += slot * SHIP_PIECE_OFFSET;
 			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
@@ -244,7 +246,7 @@ Present_GenerateSIS (PRESENTATION_INPUT_
 		piece = GLOBAL_SIS (ModuleSlots[slot]);
 		if (piece < EMPTY_SLOT)
 		{
-			s.origin.x = MODULE_TOP_X;
+			s.origin.x = MODULE_TOP_X_P;
 			s.origin.y = MODULE_TOP_Y_P;
 			s.origin.x += slot * SHIP_PIECE_OFFSET;
 			s.frame = SetAbsFrameIndex (ModuleFrame, piece);
@@ -351,6 +353,9 @@ DoPresentation (void *pIS)
 			int w, h;
 			if (2 == sscanf (pStr, "%d %d", &w, &h))
 			{
+				w <<= RESOLUTION_FACTOR; // JMS_GFX
+				h <<= RESOLUTION_FACTOR; // JMS_GFX
+
 				pPIS->clip_r.extent.width = w;
 				pPIS->clip_r.extent.height = h;
 				/* center on screen */
@@ -383,6 +388,78 @@ DoPresentation (void *pIS)
 			}
 
 			SetContextFont (*pFont);
+		}		
+		else if (strcmp (Opcode, "FONT1X") == 0 && RESOLUTION_FACTOR == 0)
+		{	/* set and/or load a font */
+			int index;
+			FONT *pFont;
+			
+			assert (sizeof (pPIS->Buffer) >= 256);
+			
+			pPIS->Buffer[0] = '\0';
+			if (1 > sscanf (pStr, "%d %255[^\n]", &index, pPIS->Buffer) ||
+				index < 0 || index >= MAX_FONTS)
+			{
+				log_add (log_Warning, "Bad FONT command '%s'", pStr);
+				continue;
+			}
+			pFont = &pPIS->Fonts[index];
+			
+			if (pPIS->Buffer[0])
+			{	/* asked to load a font */
+				if (*pFont)
+					DestroyFont (*pFont);
+				*pFont = LoadFontFile (pPIS->Buffer);
+			}
+			SetContextFont (*pFont);
+		}
+		else if (strcmp (Opcode, "FONT2X") == 0 && RESOLUTION_FACTOR == 1)
+		{	/* set and/or load a font */
+			int index;
+			FONT *pFont;
+			
+			assert (sizeof (pPIS->Buffer) >= 256);
+			
+			pPIS->Buffer[0] = '\0';
+			if (1 > sscanf (pStr, "%d %255[^\n]", &index, pPIS->Buffer) ||
+				index < 0 || index >= MAX_FONTS)
+			{
+				log_add (log_Warning, "Bad FONT command '%s'", pStr);
+				continue;
+			}
+			pFont = &pPIS->Fonts[index];
+			
+			if (pPIS->Buffer[0])
+			{	/* asked to load a font */
+				if (*pFont)
+					DestroyFont (*pFont);
+				*pFont = LoadFontFile (pPIS->Buffer);
+			}
+			SetContextFont (*pFont);;
+		}
+		else if (strcmp (Opcode, "FONT4X") == 0 && RESOLUTION_FACTOR == 2)
+		{	/* set and/or load a font */
+			int index;
+			FONT *pFont;
+			
+			assert (sizeof (pPIS->Buffer) >= 256);
+			
+			pPIS->Buffer[0] = '\0';
+			if (1 > sscanf (pStr, "%d %255[^\n]", &index, pPIS->Buffer) ||
+				index < 0 || index >= MAX_FONTS)
+			{
+				log_add (log_Warning, "Bad FONT command '%s'", pStr);
+				continue;
+			}
+			pFont = &pPIS->Fonts[index];
+			
+			if (pPIS->Buffer[0])
+			{	/* asked to load a font */
+				if (*pFont)
+					DestroyFont (*pFont);
+				*pFont = LoadFontFile (pPIS->Buffer);
+			}
+			SetContextFont (*pFont);
 		}
 		else if (strcmp (Opcode, "ANI") == 0)
 		{	/* set ani */
@@ -391,6 +468,27 @@ DoPresentation (void *pIS)
 				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
 			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
 		}
+		else if (strcmp (Opcode, "ANI1X") == 0 && RESOLUTION_FACTOR == 0)
+		{	/* set ani */
+			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
+			if (pPIS->Frame)
+				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
+			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
+		}
+		else if (strcmp (Opcode, "ANI2X") == 0 && RESOLUTION_FACTOR == 1)
+		{	/* set ani */
+			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
+			if (pPIS->Frame)
+				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
+			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
+		}
+		else if (strcmp (Opcode, "ANI4X") == 0 && RESOLUTION_FACTOR == 2)
+		{	/* set ani */
+			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
+			if (pPIS->Frame)
+				DestroyDrawable (ReleaseDrawable (pPIS->Frame));
+			pPIS->Frame = CaptureDrawable (LoadGraphicFile (pPIS->Buffer));
+		}
 		else if (strcmp (Opcode, "MUSIC") == 0)
 		{	/* set music */
 			utf8StringCopy (pPIS->Buffer, sizeof (pPIS->Buffer), pStr);
@@ -473,6 +571,9 @@ DoPresentation (void *pIS)
 			{
 				TEXT t;
 
+				x <<= RESOLUTION_FACTOR; // JMS_GFX
+				y <<= RESOLUTION_FACTOR; // JMS_GFX
+
 				t.align = ALIGN_CENTER;
 				t.pStr = pPIS->Buffer;
 				t.CharCount = (COUNT)~0;
@@ -603,6 +704,9 @@ DoPresentation (void *pIS)
 				y = 0;
 			}
 
+			x <<= RESOLUTION_FACTOR; // JMS_GFX
+			y <<= RESOLUTION_FACTOR; // JMS_GFX
+
 			s.frame = NULL;
 			if (draw_what == PRES_DRAW_INDEX)
 			{	/* draw stamp by index */
@@ -679,6 +783,11 @@ DoPresentation (void *pIS)
 			{
 				LINE l;
 
+				x1 <<= RESOLUTION_FACTOR; // JMS_GFX
+				y1 <<= RESOLUTION_FACTOR; // JMS_GFX
+				x2 <<= RESOLUTION_FACTOR; // JMS_GFX
+				y2 <<= RESOLUTION_FACTOR; // JMS_GFX
+
 				l.first.x = x1;
 				l.first.y = y1;
 				l.second.x = x2;
diff -ruNp src.orig/uqm/ipdisp.c src/uqm/ipdisp.c
--- src.orig/uqm/ipdisp.c	2017-12-30 00:14:40 -0800
+++ src/uqm/ipdisp.c	2017-12-30 00:14:53 -0800
@@ -237,12 +237,14 @@ ip_group_preprocess (ELEMENT *ElementPtr
 	if (task <= ON_STATION)
 #endif /* NEVER */
 	{
-		BOOLEAN Transition;
+		BOOLEAN Transition, isOrbiting;
 		SIZE dx, dy;
 		SIZE delta_x, delta_y;
 		COUNT angle;
+		FRAME suggestedFrame; // JMS
 
 		Transition = FALSE;
+		isOrbiting = FALSE;
 		if (task == FLEE)
 		{
 			dest_pt.x = GroupPtr->loc.x << 1;
@@ -257,11 +259,13 @@ ip_group_preprocess (ELEMENT *ElementPtr
 		{
 			if (GroupPtr->dest_loc == IPNL_INTERCEPT_PLAYER)
 				dest_pt = GLOBAL (ip_location);
+			// ship is circling around a planet.
 			else
 			{
 				COUNT orbit_dist;
 				POINT org;
 
+				isOrbiting = TRUE;
 				if (task != ON_STATION)
 				{
 					orbit_dist = ORBIT_RADIUS;
@@ -448,6 +452,22 @@ CheckGetAway:
 				}
 			}
 		}
+		
+		//BW : make IP ships face the direction they're going into
+		suggestedFrame = SetAbsFrameIndex(ElementPtr->next.image.farray[0], 1 + NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))));
+		
+		// JMS: Direction memory prevents jittering of battle group icons when they are orbiting a planet (and not chasing the player ship).		
+		if (isOrbiting)
+		{
+			// This works because ships always orbit planets clockwise.
+			if (GroupPtr->lastDirection < NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)))
+				|| GroupPtr->lastDirection == 15)
+				ElementPtr->next.image.frame = suggestedFrame;
+		}
+		else
+			ElementPtr->next.image.frame = suggestedFrame;
+		
+		GroupPtr->lastDirection = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)));
 	}
 
 	radius = zoomRadiusForLocation (group_loc);
diff -ruNp src.orig/uqm/istrtab.h src/uqm/istrtab.h
--- src.orig/uqm/istrtab.h	2017-12-30 00:14:40 -0800
+++ src/uqm/istrtab.h	2017-12-30 00:14:53 -0800
@@ -19,6 +19,7 @@
 #define BOMB_STRTAB "text.utwigbomb"
 #define BURV_BCS_STRTAB "text.burvixcaster"
 #define BURV_RUINS_STRTAB "text.burvixeseruins"
+#define CALLISTO_COLOR_TAB "planet.callisto.colortable"
 #define CARBIDE_COLOR_TAB "planet.carbide.colortable"
 #define CARBIDE_XLAT_TAB "planet.carbide.translatetable"
 #define CHLORINE_COLOR_TAB "planet.chlorine.colortable"
@@ -37,15 +38,19 @@
 #define CYANIC_XLAT_TAB "planet.cyanic.translatetable"
 #define CYA_GAS_COLOR_TAB "planet.cyangas.colortable"
 #define CYA_GAS_XLAT_TAB "planet.cyangas.translatetable"
+#define DEIMOS_COLOR_TAB "planet.deimos.colortable"
+#define DRUMALLPRES_STRTAB "slides.drumall"
 #define DRUUGE_RUINS_STRTAB "text.sphere"
 #define DUST_COLOR_TAB "planet.dust.colortable"
 #define DUST_XLAT_TAB "planet.dust.translatetable"
 #define EGG_CASE_STRTAB "text.eggcase"
 #define EMERALD_COLOR_TAB "planet.emerald.colortable"
 #define EMERALD_XLAT_TAB "planet.emerald.translatetable"
+#define EUROPA_COLOR_TAB "planet.europa.colortable"
 #define FINALPRES_STRTAB "slides.ending"
 #define FLUORESCENT_COLOR_TAB "planet.fluorescent.colortable"
 #define FLUORESCENT_XLAT_TAB "planet.fluorescent.translatetable"
+#define GANYMEDE_COLOR_TAB "planet.ganymede.colortable"
 #define GREEN_COLOR_TAB "planet.green.colortable"
 #define GREEN_XLAT_TAB "planet.green.translatetable"
 #define GRN_GAS_COLOR_TAB "planet.greengas.colortable"
@@ -61,12 +66,16 @@
 #define INFRARED_COLOR_TAB "planet.infrared.colortable"
 #define INFRARED_XLAT_TAB "planet.infrared.translatetable"
 #define INTROPRES_STRTAB "slides.intro"
+#define IO_COLOR_TAB "planet.io.colortable"
 #define IODINE_COLOR_TAB "planet.iodine.colortable"
 #define IODINE_XLAT_TAB "planet.iodine.translatetable"
 #define IPSUN_COLOR_MAP "colortable.truespace"
 #define JOYSTICK_ALPHA_STRTAB "text.joyalpha"
+#define JUPITER_COLOR_TAB "planet.jupiter.colortable"
 #define LANTHANIDE_COLOR_TAB "planet.lanthanide.colortable"
 #define LANTHANIDE_XLAT_TAB "planet.lanthanide.translatetable"
+#define LOGOPRES_STRTAB "slides.logo"
+#define LUNA_COLOR_TAB "planet.luna.colortable"
 #define MAGMA_COLOR_TAB "planet.magma.colortable"
 #define MAGMA_XLAT_TAB "planet.magma.translatetable"
 #define MAGNETIC_COLOR_TAB "planet.magnetic.colortable"
@@ -74,9 +83,12 @@
 #define MAIDENS_STRTAB "text.maidens"
 #define MAROON_COLOR_TAB "planet.maroon.colortable"
 #define MAROON_XLAT_TAB "planet.maroon.translatetable"
+#define MARS_COLOR_TAB "planet.mars.colortable"
+#define MERCURY_COLOR_TAB "planet.mercury.colortable"
 #define METAL_COLOR_TAB "planet.metal.colortable"
 #define METAL_XLAT_TAB "planet.metal.translatetable"
 #define MOONBASE_STRTAB "text.moonbase"
+#define NEPTUNE_COLOR_TAB "planet.neptune.colortable"
 #define NOBLE_COLOR_TAB "planet.noble.colortable"
 #define NOBLE_XLAT_TAB "planet.noble.translatetable"
 #define OOLITE_COLOR_TAB "planet.oolite.colortable"
@@ -90,7 +102,9 @@
 #define ORGANIC_XLAT_TAB "planet.organic.translatetable"
 #define PELLUCID_COLOR_TAB "planet.pellucid.colortable"
 #define PELLUCID_XLAT_TAB "planet.pellucid.translatetable"
+#define PHOBOS_COLOR_TAB "planet.phobos.colortable"
 #define PKUNK_RUINS_STRTAB "text.spindle"
+#define PLUTO_COLOR_TAB "planet.pluto.colortable"
 #define PLUTONIC_COLOR_TAB "planet.plutonic.colortable"
 #define PLUTONIC_XLAT_TAB "planet.plutonic.translatetable"
 #define PRIMORDIAL_COLOR_TAB "planet.primordial.colortable"
@@ -114,12 +128,14 @@
 #define RUINS_STRTAB "text.ruins"
 #define SAPPHIRE_COLOR_TAB "planet.sapphire.colortable"
 #define SAPPHIRE_XLAT_TAB "planet.sapphire.translatetable"
+#define SATURN_COLOR_TAB "planet.saturn.colortable"
 #define SELENIC_COLOR_TAB "planet.selenic.colortable"
 #define SELENIC_XLAT_TAB "planet.selenic.translatetable"
 #define SETUP_MENU_STRTAB "text.setupmenu"
 #define SHATTERED_COLOR_TAB "planet.shattered.colortable"
 #define SHATTERED_XLAT_TAB "planet.shattered.translatetable"
 #define SPAPLUTO_STRTAB "text.fwiffo"
+#define SPECIAL_CMAP_XLAT_TAB "planet.specialcolormap.translatetable"
 #define STARCON_COLOR_MAP "colortable.main"
 #define STARCON_GAME_STRINGS "text.starcon"
 #define SUN_DEVICE_STRTAB "text.sundevice"
@@ -129,16 +145,20 @@
 #define TAALO_DEVICE_STRTAB "text.taalodevice"
 #define TELLURIC_COLOR_TAB "planet.telluric.colortable"
 #define TELLURIC_XLAT_TAB "planet.telluric.translatetable"
+#define TITAN_COLOR_TAB "planet.titan.colortable"
 #define TREASURE_COLOR_TAB "planet.treasure.colortable"
 #define TREASURE_XLAT_TAB "planet.treasure.translatetable"
+#define TRITON_COLOR_TAB "planet.triton.colortable"
 #define ULTRAMARINE_COLOR_TAB "planet.ultramarine.colortable"
 #define ULTRAMARINE_XLAT_TAB "planet.ultramarine.translatetable"
 #define ULTRAVIOLET_COLOR_TAB "planet.ultraviolet.colortable"
 #define ULTRAVIOLET_XLAT_TAB "planet.ultraviolet.translatetable"
 #define UMGAH_BCS_STRTAB "text.umgahcaster"
+#define URANUS_COLOR_TAB "planet.uranus.colortable"
 #define UREA_COLOR_TAB "planet.urea.colortable"
 #define UREA_XLAT_TAB "planet.urea.translatetable"
 #define VAULT_STRTAB "text.syreenvault"
+#define VENUS_COLOR_TAB "planet.venus.colortable"
 #define VINYLOGOUS_COLOR_TAB "planet.vinylogous.colortable"
 #define VINYLOGOUS_XLAT_TAB "planet.vinylogous.translatetable"
 #define VIO_GAS_COLOR_TAB "planet.violetgas.colortable"
diff -ruNp src.orig/uqm/load.c src/uqm/load.c
--- src.orig/uqm/load.c	2017-12-30 00:14:40 -0800
+++ src/uqm/load.c	2017-12-30 00:14:53 -0800
@@ -266,6 +266,9 @@ LoadEncounter (ENCOUNTER *EncounterPtr,
 	// Load the stuff after the BRIEF_SHIP_INFO array
 	read_32s (fh, &EncounterPtr->log_x);
 	read_32s (fh, &EncounterPtr->log_y);
+
+	EncounterPtr->log_x <<= RESOLUTION_FACTOR;
+	EncounterPtr->log_y <<= RESOLUTION_FACTOR;
 }
 
 static void
@@ -293,6 +296,7 @@ static BOOLEAN
 LoadGameState (GAME_STATE *GSPtr, void *fh)
 {
 	DWORD magic;
+	BYTE res_scale; // JMS
 	read_32 (fh, &magic);
 	if (magic != GLOBAL_STATE_TAG)
 	{
@@ -307,10 +311,26 @@ LoadGameState (GAME_STATE *GSPtr, void *
 	read_8   (fh, &GSPtr->glob_flags);
 	read_8   (fh, &GSPtr->CrewCost);
 	read_8   (fh, &GSPtr->FuelCost);
+	// JMS: Now that we have read the fuelcost, we can compare it
+	// to the correct value. Fuel cost is always FUEL_COST_RU, and if
+	// the savefile tells otherwise, we have read it with the wrong method
+	// (The savegame is from vanilla UQM and we've been reading it as if it
+	// were UQM-HD save.)
+	//
+	// At this point we must then cease reading the savefile, close it
+	// and re-open it again, this time using the vanilla-reading method.
+	if (GSPtr->FuelCost != FUEL_COST_RU)
+		return FALSE;
 	read_a8  (fh, GSPtr->ModuleCost, NUM_MODULES);
 	read_a8  (fh, GSPtr->ElementWorth, NUM_ELEMENT_CATEGORIES);
 	read_16  (fh, &GSPtr->CurrentActivity);
 
+	// JMS
+	if (LOBYTE (GSPtr->CurrentActivity) != IN_INTERPLANETARY)
+		res_scale = RESOLUTION_FACTOR;
+	else
+		res_scale = 0;
+
 	LoadClockState (&GSPtr->GameClock, fh);
 
 	read_16s (fh, &GSPtr->autopilot.x);
@@ -324,6 +344,9 @@ LoadGameState (GAME_STATE *GSPtr, void *
 	read_8   (fh, &GSPtr->ip_planet);
 	read_8   (fh, &GSPtr->in_orbit);
 
+	// JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->ShipStamp.origin.x <<= RESOLUTION_FACTOR; 
+	GSPtr->ShipStamp.origin.y <<= RESOLUTION_FACTOR; 
 	/* VELOCITY_DESC velocity */
 	read_16  (fh, &GSPtr->velocity.TravelAngle);
 	read_16s (fh, &GSPtr->velocity.vector.width);
@@ -335,6 +358,15 @@ LoadGameState (GAME_STATE *GSPtr, void *
 	read_16s (fh, &GSPtr->velocity.incr.width);
 	read_16s (fh, &GSPtr->velocity.incr.height);
 
+	// JMS: Let's make savegames work even between different resolution modes.
+	GSPtr->velocity.vector.width  <<= res_scale; 
+	GSPtr->velocity.vector.height <<= res_scale; 
+	GSPtr->velocity.fract.width	  <<= res_scale; 
+	GSPtr->velocity.fract.height  <<= res_scale; 
+	GSPtr->velocity.error.width	  <<= res_scale; 
+	GSPtr->velocity.error.height  <<= res_scale; 
+	GSPtr->velocity.incr.width	  <<= res_scale; 
+	GSPtr->velocity.incr.height	  <<= res_scale; 
 	read_32 (fh, &magic);
 	if (magic != GAME_STATE_TAG)
 	{
@@ -401,7 +433,12 @@ LoadSisState (SIS_STATE *SSPtr, void *fp
 			read_str (fp, SSPtr->PlanetName, SIS_NAME_SIZE) != 1
 		)
 		return FALSE;
-	return TRUE;
+ 	else {
+		// JMS: Let's make savegames work even between different resolution modes.
+		SSPtr->log_x <<= RESOLUTION_FACTOR;
+		SSPtr->log_y <<= RESOLUTION_FACTOR;
+		return TRUE;
+	}
 }
 
 static BOOLEAN
@@ -438,7 +475,8 @@ LoadSummary (SUMMARY_DESC *SummPtr, void
 			read_8  (fp, &SummPtr->NumShips) != 1 ||
 			read_8  (fp, &SummPtr->NumDevices) != 1 ||
 			read_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS) != 1 ||
-			read_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1
+			read_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES) != 1 ||
+			read_8  (fp, &SummPtr->res_factor) != 1 // JMS: This'll help making saves between different resolutions compatible.		
 		)
 		return FALSE;
 	
@@ -457,6 +495,11 @@ LoadSummary (SUMMARY_DESC *SummPtr, void
 		if (skip_8 (fp, remaining) != 1)
 			return FALSE;
 	}
+
+	// JMS: UQM-HD saves have an extra piece of padding to compensate for the
+	// added res_factor in SummPtr.
+	//read_8 (fp, NULL); /* padding */
+
 	return TRUE;
 }
 
@@ -773,7 +816,8 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 			}
 			break;
 		case STAR_TAG:
-			LoadStarDesc (&SD, in_fp);
+			LoadStarDesc (&SD, in_fp);			
+			loadGameCheats();
 			break;
 		case NPC_SHIP_Q_TAG:
 			LoadShipQueue (in_fp, &GLOBAL (npc_built_ship_q), chunkSize);
@@ -825,4 +869,4 @@ LoadGame (COUNT which_game, SUMMARY_DESC
 		NextActivity |= START_INTERPLANETARY;
 
 	return TRUE;
-}
+}
\ No newline at end of file
diff -ruNp src.orig/uqm/load_legacy.c src/uqm/load_legacy.c
--- src.orig/uqm/load_legacy.c	2017-12-30 00:14:40 -0800
+++ src/uqm/load_legacy.c	2017-12-30 00:14:53 -0800
@@ -114,8 +114,8 @@ static const GameStateBitMap legacyGameS
 	{ "URQUAN_MESSED_UP", 1 },
 	{ "MOONBASE_DESTROYED", 1 },
 	{ "WILL_DESTROY_BASE", 1 },
-	{ "ARTIFACT_2_ON_SHIP", 1 },
-	{ "ARTIFACT_3_ON_SHIP", 1 },
+	{ "WIMBLIS_TRIDENT_ON_SHIP", 1 },
+	{ "GLOWING_ROD_ON_SHIP", 1 },
 	{ "KOHR_AH_KILLED_ALL", 1 },
 	{ "STARBASE_YACK_STACK1", 1 },
 	{ "DISCUSSED_PORTAL_SPAWNER", 1 },
@@ -882,10 +882,10 @@ LoadGameState (GAME_STATE *GSPtr, DECODE
 	DummyLoadQueue (&GSPtr->built_ship_q, fh);
 
 	{
-		size_t numBytes = (NUM_GAME_STATE_BITS + 7) >> 3;
+		size_t numBytes = ((NUM_GAME_STATE_BITS - 17) + 7) >> 3;
 		BYTE *buf;
 
-		assert (numBytes % 4 == 3);
+		// assert (numBytes % 4 == 3);
 				// We should have one byte padding.
 		buf = HMalloc (numBytes);
 		if (buf != NULL)
@@ -1169,7 +1169,7 @@ LoadLegacyGame (COUNT which_game, SUMMAR
 	}
 
 	LoadStarDesc (&SD, fh);
-
+	loadGameCheats();
 	cclose (fh);
 	res_CloseResFile (in_fp);
 
diff -ruNp src.orig/uqm/menu.c src/uqm/menu.c
--- src.orig/uqm/menu.c	2017-12-30 00:14:40 -0800
+++ src/uqm/menu.c	2017-12-30 00:14:53 -0800
@@ -76,7 +76,7 @@ static UNICODE pm_fuel_str[128];
 static void
 DrawPCMenu (BYTE beg_index, BYTE end_index, BYTE NewState, BYTE hilite, RECT *r)
 {
-#define PC_MENU_HEIGHT 8
+#define PC_MENU_HEIGHT (RES_STAT_SCALE(8)) // JMS_GFX
 	BYTE pos;
 	COUNT i;
 	int num_items;
@@ -98,7 +98,7 @@ DrawPCMenu (BYTE beg_index, BYTE end_ind
 	OldFont = SetContextFont (StarConFont);
 	t.align = ALIGN_LEFT;
 	t.baseline.x = r->corner.x + 2;
-	t.baseline.y = r->corner.y + PC_MENU_HEIGHT -1;
+	t.baseline.y = r->corner.y + PC_MENU_HEIGHT - (1 << RESOLUTION_FACTOR);// - RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	r->corner.x++;
@@ -115,7 +115,7 @@ DrawPCMenu (BYTE beg_index, BYTE end_ind
 			
 			// Draw the background of the selection.
 			SetContextForeGroundColor (PCMENU_SELECTION_BACKGROUND_COLOR);
-			r->corner.y = t.baseline.y - PC_MENU_HEIGHT + 2;
+			r->corner.y = t.baseline.y - PC_MENU_HEIGHT + RES_STAT_SCALE(2); // + RESOLUTION_FACTOR; // JMS_GFX
 			r->extent.height = PC_MENU_HEIGHT - 1;
 			DrawFilledRectangle (r);
 
@@ -503,7 +503,7 @@ DrawMenuStateStrings (BYTE beg_index, SW
 	s.origin.x = RADAR_X - r.corner.x;
 	s.origin.y = RADAR_Y - r.corner.y;
 	r.corner.x = s.origin.x - 1;
-	r.corner.y = s.origin.y - 11;
+	r.corner.y = s.origin.y - (11 << RESOLUTION_FACTOR); // JMS_GFX
 	r.extent.width = RADAR_WIDTH + 2;
 	BatchGraphics ();
 	SetContextForeGroundColor (
@@ -548,7 +548,15 @@ DrawMenuStateStrings (BYTE beg_index, SW
 					break;
 			}
 		}
-		r.extent.height = RADAR_HEIGHT + 11;
+		r.extent.height = RADAR_HEIGHT + (11 << RESOLUTION_FACTOR); // JMS_GFX
+
+		// JMS_GFX: This is to fix the two-line high outfit module texts.
+		// They weren't completely erased in 640x480 when exiting module selection.
+		if (RESOLUTION_FACTOR == 1) {
+			r.corner.y -= 7;
+			r.extent.height += 7;
+		}
+
 		DrawPCMenu (beg_index, end_index, (BYTE)NewState, hilite, &r);
 		s.frame = 0;
 	}
@@ -558,10 +566,10 @@ DrawMenuStateStrings (BYTE beg_index, SW
 		{
 			r.corner.x -= 1;
 			r.extent.width += 1;
-			r.extent.height = RADAR_HEIGHT + 11;
+			r.extent.height = RADAR_HEIGHT + (11 << RESOLUTION_FACTOR); // JMS_GFX
 		}
 		else
-			r.extent.height = 11;
+			r.extent.height = 11 << RESOLUTION_FACTOR;
 		DrawFilledRectangle (&r);
 	}
 	if (s.frame)
@@ -601,3 +609,21 @@ DrawMenuStateStrings (BYTE beg_index, SW
 	PostUpdateFlashRect ();
 }
 
+void
+DrawSubmenu (BYTE Visible)
+{
+	STAMP s;
+	CONTEXT OldContext;
+	
+	OldContext = SetContext (ScreenContext);
+
+	s.origin.x = 0;
+	s.origin.y = 0;
+
+	s.frame = SetAbsFrameIndex (SubmenuFrame, Visible);
+
+	DrawStamp (&s);
+	
+	SetContext (OldContext);
+}
+
diff -ruNp src.orig/uqm/menustat.h src/uqm/menustat.h
--- src.orig/uqm/menustat.h	2017-12-30 00:14:40 -0800
+++ src/uqm/menustat.h	2017-12-30 00:14:53 -0800
@@ -123,6 +123,7 @@ enum
 
 extern BOOLEAN DoMenuChooser (MENU_STATE *pMS, BYTE BaseState);
 extern void DrawMenuStateStrings (BYTE beg_index, SWORD NewState);
+extern void DrawSubmenu (BYTE Visible);
 
 #if defined(__cplusplus)
 }
diff -ruNp src.orig/uqm/misc.c src/uqm/misc.c
--- src.orig/uqm/misc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/misc.c	2017-12-30 00:14:53 -0800
@@ -25,7 +25,9 @@
 #include "sounds.h"
 #include "weapon.h"
 #include "libs/mathlib.h"
-
+#include "options.h" // For God Mode invincibility
+#include "settings.h"
+#include "intel.h"
 
 void
 spawn_planet (void)
@@ -86,8 +88,13 @@ spawn_rubble (ELEMENT *AsteroidElementPt
 		RubbleElementPtr->turn_wait = RubbleElementPtr->next_turn = 0;
 		SetPrimType (&DisplayArray[RubbleElementPtr->PrimIndex], STAMP_PRIM);
 		RubbleElementPtr->current.image.farray = asteroid;
-		RubbleElementPtr->current.image.frame =
-				SetAbsFrameIndex (asteroid[0], ANGLE_TO_FACING (FULL_CIRCLE));
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0)
+			RubbleElementPtr->current.image.frame = SetAbsFrameIndex (asteroid[0], ANGLE_TO_FACING (FULL_CIRCLE));
+		else
+			RubbleElementPtr->current.image.frame = SetAbsFrameIndex (asteroid[0], 29);
+
 		RubbleElementPtr->current.location = AsteroidElementPtr->current.location;
 		RubbleElementPtr->preprocess_func = animation_preprocess;
 		RubbleElementPtr->death_func = spawn_asteroid;
@@ -109,9 +116,13 @@ asteroid_preprocess (ELEMENT *ElementPtr
 			--frame_index;
 		else
 			++frame_index;
-		ElementPtr->next.image.frame =
-				SetAbsFrameIndex (ElementPtr->current.image.frame,
-				NORMALIZE_FACING (frame_index));
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0)
+			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, NORMALIZE_FACING (frame_index));
+		else
+			ElementPtr->next.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, frame_index % 30);
+
 		ElementPtr->state_flags |= CHANGING;
 
 		ElementPtr->turn_wait = (unsigned char)(ElementPtr->thrust_wait & ((1 << 7) - 1));
@@ -194,6 +205,13 @@ spawn_asteroid (ELEMENT *ElementPtr)
 void
 do_damage (ELEMENT *ElementPtr, SIZE damage)
 {
+	// God Mode, borrowed from the UQM-HD debug invincibility code
+	if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+		(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
+		((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
+	{
+		damage = 0;
+	}
 	if (ElementPtr->state_flags & PLAYER_SHIP)
 	{
 		if (!DeltaCrew (ElementPtr, -damage))
@@ -251,7 +269,7 @@ crew_preprocess (ELEMENT *ElementPtr)
 
 	if (hTarget)
 	{
-#define CREW_DELTA SCALED_ONE
+#define CREW_DELTA (SCALED_ONE << RESOLUTION_FACTOR)
 		SIZE delta;
 		ELEMENT *ShipPtr;
 
@@ -323,7 +341,7 @@ AbandonShip (ELEMENT *ShipPtr, ELEMENT *
 		dx = dy = 0;
 	else
 	{
-#define MORE_THAN_ENOUGH 100
+#define MORE_THAN_ENOUGH (100 << RESOLUTION_FACTOR) // JMS_GFX
 		direction += HALF_CIRCLE;
 		dx = COSINE (direction, MORE_THAN_ENOUGH);
 		dy = SINE (direction, MORE_THAN_ENOUGH);
@@ -342,11 +360,19 @@ AbandonShip (ELEMENT *ShipPtr, ELEMENT *
 		CrewPtr->hit_points = 1;
 		CrewPtr->state_flags = APPEARING | FINITE_LIFE | CREW_OBJECT;
 		CrewPtr->life_span = CREW_LIFE;
-		SetPrimType (&DisplayArray[CrewPtr->PrimIndex], POINT_PRIM);
+		if (RESOLUTION_FACTOR == 0) {
+			SetPrimType (&DisplayArray[CrewPtr->PrimIndex], POINT_PRIM);
+			CrewPtr->current.image.frame = DecFrameIndex (stars_in_space);
+			CrewPtr->current.image.farray = &stars_in_space;
+		} else {
+			SetPrimType (&DisplayArray[CrewPtr->PrimIndex], STAMPFILL_PRIM);
+			CrewPtr->current.image.frame = SetAbsFrameIndex (crew_dots[0], 0);
+			CrewPtr->current.image.farray = crew_dots;
+		}
 		SetPrimColor (&DisplayArray[CrewPtr->PrimIndex],
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02));
-		CrewPtr->current.image.frame = DecFrameIndex (stars_in_space);
-		CrewPtr->current.image.farray = &stars_in_space;
+		/*CrewPtr->current.image.frame = DecFrameIndex (stars_in_space);
+		CrewPtr->current.image.farray = &stars_in_space;*/
 		CrewPtr->preprocess_func = crew_preprocess;
 		CrewPtr->collision_func = crew_collision;
 
diff -ruNp src.orig/uqm/oscill.c src/uqm/oscill.c
--- src.orig/uqm/oscill.c	2017-12-30 00:14:40 -0800
+++ src/uqm/oscill.c	2017-12-30 00:14:53 -0800
@@ -24,7 +24,7 @@
 #include "libs/graphics/drawable.h"
 #include "libs/sound/sound.h"
 #include "libs/sound/trackplayer.h"
-
+#include "libs/log.h"
 
 static FRAME scope_frame;
 static int scope_init = 0;
@@ -71,13 +71,20 @@ void
 DrawOscilloscope (void)
 {
 	STAMP s;
-	BYTE scope_data[128];
+	BYTE scope_data[192]; // JMS_GFX: was 128... FIXME:This is a hack: GraphForeGroundStream would really require this to be
+							// less than 256. This "fix" messes up how the oscilloscope looks, but it works for now
+							// (doesn't get caught in asserts). We need to fix this later.
 
+	// BW: fixed. With narrow status panel at 4x, scope width (and data) are never more than 192.
 	if (oscillDisabled)
 		return;
 
-	assert ((size_t)scopeSize.width <= sizeof scope_data);
-	assert (scopeSize.height < 256);
+	//log_add(log_Debug, "(size_t)scopeSize.width %lu, sizeof(scope_data) %lu", (size_t)scopeSize.width, sizeof(scope_data));
+	
+	assert ((size_t)scopeSize.width <= sizeof(scope_data));
+	assert (scopeSize.height < 256); // JMS_GFX: Was 256. FIXME:This is a hack: GraphForeGroundStream would really require this to be
+	// less than 256. This "fix" messes up how the oscilloscope looks, but it works for now
+	// (doesn't get caught in asserts). We need to fix this later.
 
 	if (GraphForegroundStream (scope_data, scopeSize.width, scopeSize.height,
 			usingSpeech))
diff -ruNp src.orig/uqm/outfit.c src/uqm/outfit.c
--- src.orig/uqm/outfit.c	2017-12-30 00:14:40 -0800
+++ src/uqm/outfit.c	2017-12-30 00:14:53 -0800
@@ -34,6 +34,8 @@
 		// for xxx_DISASTER
 #include "libs/graphics/gfx_common.h"
 
+// How manyeth .png in the module.ani file is the first lander shield.
+#define SHIELD_LOCATION_IN_MODULE_ANI (RES_CASE(5,9,9))
 
 enum
 {
@@ -55,11 +57,11 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 	OldContext = SetContext (StatusContext);
 	GetContextClipRect (&r);
 	s.origin.x = RADAR_X - r.corner.x;
-	s.origin.y = RADAR_Y - r.corner.y;
+	s.origin.y = RADAR_Y - r.corner.y - 19 * RESOLUTION_FACTOR; // JMS_GFX;
 	r.corner.x = s.origin.x - 1;
 	r.corner.y = s.origin.y - 11;
 	r.extent.width = RADAR_WIDTH + 2;
-	r.extent.height = 11;
+	r.extent.height = 11 + 20 * RESOLUTION_FACTOR; // JMS_GFX;
 	BatchGraphics ();
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
@@ -67,6 +69,7 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 	if (NewModule >= EMPTY_SLOT)
 	{
 		r.corner = s.origin;
+		r.corner.y += 19 * RESOLUTION_FACTOR; // JMS_GFX
 		r.extent.width = RADAR_WIDTH;
 		r.extent.height = RADAR_HEIGHT;
 		SetContextForeGroundColor (
@@ -80,16 +83,25 @@ DrawModuleStrings (MENU_STATE *pMS, BYTE
 
 		s.frame = SetAbsFrameIndex (pMS->CurFrame, NewModule);
 		DrawStamp (&s);
-		t.baseline.x = s.origin.x + RADAR_WIDTH - 2;
-		t.baseline.y = s.origin.y + RADAR_HEIGHT - 2;
+		t.baseline.x = s.origin.x + RADAR_WIDTH - RES_STAT_SCALE(2) - RESOLUTION_FACTOR;
+		t.baseline.y = s.origin.y + RADAR_HEIGHT - RES_STAT_SCALE(2) + 14 * RESOLUTION_FACTOR; // JMS_GFX;
 		t.align = ALIGN_RIGHT;
 		t.CharCount = (COUNT)~0;
 		t.pStr = buf;
 		sprintf (buf, "%u",
 				GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
+
+		if ((GLOBAL_SIS (ResUnits)) > (DWORD)((GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE))) {
+			sprintf (buf, "%u", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
+			SetContextForeGroundColor (
+					BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
+		} else {
+			sprintf (buf, "(%u)", GLOBAL (ModuleCost[NewModule]) * MODULE_COST_SCALE);
+			SetContextForeGroundColor (
+					BUILD_COLOR (MAKE_RGB15 (0x1F, 0x00, 0x00), 0x02));
+		}
+
 		SetContextFont (TinyFont);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
 		font_DrawText (&t);
 	}
 	UnbatchGraphics ();
@@ -113,7 +125,7 @@ RedistributeFuel (void)
 		// If we're less than the fuel level, draw fuel.
 		if (GLOBAL_SIS (FuelOnBoard) < FuelVolume)
 		{
-			r.extent.width = 3;
+			r.extent.width = (3 << RESOLUTION_FACTOR) + RES_CASE(0,2,6); // JMS_GFX
 			DrawPoint (&r.corner);
 			r.corner.x += r.extent.width + 1;
 			DrawPoint (&r.corner);
@@ -123,7 +135,7 @@ RedistributeFuel (void)
 		}
 		else // Otherwise, draw an empty bar.
 		{
-			r.extent.width = 5;
+			r.extent.width = 5 << RESOLUTION_FACTOR; // JMS_GFX
 			SetContextForeGroundColor (
 					BUILD_COLOR (MAKE_RGB15 (0x0B, 0x00, 0x00), 0x2E));
 		}
@@ -135,9 +147,9 @@ RedistributeFuel (void)
 	GLOBAL_SIS (FuelOnBoard) = FuelVolume;
 }
 
-#define LANDER_X 24
-#define LANDER_Y 67
-#define LANDER_WIDTH 15
+#define LANDER_X ((24 << RESOLUTION_FACTOR) + RES_CASE(0,2,0)) // JMS_GFX
+#define LANDER_Y (67 << RESOLUTION_FACTOR) // JMS_GFX
+#define LANDER_WIDTH ((15 << RESOLUTION_FACTOR) - RES_CASE(0,2,0)) // JMS_GFX
 
 static void
 DisplayLanders (MENU_STATE *pMS)
@@ -148,7 +160,8 @@ DisplayLanders (MENU_STATE *pMS)
 	if (GET_GAME_STATE (CHMMR_BOMB_STATE) == 3)
 	{
 		s.origin.x = s.origin.y = 0;
-		s.frame = DecFrameIndex (s.frame);
+		s.frame = SetAbsFrameIndex (pMS->ModuleFrame,
+			GetFrameCount (pMS->ModuleFrame) - SHIELD_LOCATION_IN_MODULE_ANI + 4);
 		DrawStamp (&s);
 	}
 	else
@@ -243,13 +256,13 @@ DoInstallModule (MENU_STATE *pMS)
 	else if (select || cancel)
 	{
 		new_slot_piece = pMS->CurState;
+
 		if (select)
 		{
 			if (new_slot_piece < EMPTY_SLOT)
 			{
-				if (GLOBAL_SIS (ResUnits) <
-						(DWORD)(GLOBAL (ModuleCost[new_slot_piece])
-						* MODULE_COST_SCALE))
+
+				if (GLOBAL_SIS (ResUnits) < (DWORD)(GLOBAL (ModuleCost[new_slot_piece]) * MODULE_COST_SCALE))
 				{	// not enough RUs to build
 					PlayMenuSound (MENU_SOUND_FAILURE);
 					return (TRUE);
@@ -279,8 +292,15 @@ DoInstallModule (MENU_STATE *pMS)
 							? FUEL_TANK_CAPACITY : HEFUEL_TANK_CAPACITY);
 					if (GLOBAL_SIS (FuelOnBoard) > volume + FUEL_RESERVE)
 					{	// fuel tank still needed for the fuel on board
-						PlayMenuSound (MENU_SOUND_FAILURE);
-						return (TRUE);
+						if(!optInfiniteFuel){
+							PlayMenuSound (MENU_SOUND_FAILURE);
+							return (TRUE);
+						} else {
+							if (old_slot_piece == FUEL_TANK)
+								DeltaSISGauges(0,-FUEL_TANK_CAPACITY,0);
+							else
+								DeltaSISGauges(0,-HEFUEL_TANK_CAPACITY,0);
+						}
 					}
 				}
 				else if (old_slot_piece == STORAGE_BAY)
@@ -478,6 +498,12 @@ DoInstallModule (MENU_STATE *pMS)
 				else
 					w = SHIP_PIECE_OFFSET;
 
+				// JMS_GFX
+				if (NewState != PLANET_LANDER && NewState != FUSION_THRUSTER 
+					&& NewState != TURNING_JETS && NewState != EMPTY_SLOT + 0
+					 && NewState != EMPTY_SLOT + 1 && NewState != EMPTY_SLOT + 3)
+					w += RES_CASE(0,1,1);
+
 				w *= (NewItem - pMS->delta_item);
 				pMS->flash_rect0.corner.x += w;
 				pMS->delta_item = NewItem;
@@ -491,35 +517,35 @@ InitFlash:
 				{
 					case PLANET_LANDER:
 					case EMPTY_SLOT + 3:
-						pMS->flash_rect0.corner.x = LANDER_X - 1;
-						pMS->flash_rect0.corner.y = LANDER_Y - 1;
-						pMS->flash_rect0.extent.width = 11 + 2;
-						pMS->flash_rect0.extent.height = 13 + 2;
+						pMS->flash_rect0.corner.x = LANDER_X - 1 + RES_CASE(0,50,114); // JMS_GFX
+						pMS->flash_rect0.corner.y = LANDER_Y - 1 + RES_CASE(0,24,65); // JMS_GFX
+						pMS->flash_rect0.extent.width = (11 + 2) << RESOLUTION_FACTOR; // JMS_GFX
+						pMS->flash_rect0.extent.height = (13 + 2) << RESOLUTION_FACTOR; // JMS_GFX;
 
 						w = LANDER_WIDTH;
 						break;
 					case FUSION_THRUSTER:
 					case EMPTY_SLOT + 0:
-						pMS->flash_rect0.corner.x = DRIVE_TOP_X - 1;
-						pMS->flash_rect0.corner.y = DRIVE_TOP_Y - 1;
-						pMS->flash_rect0.extent.width = 8;
-						pMS->flash_rect0.extent.height = 6;
+						pMS->flash_rect0.corner.x = DRIVE_TOP_X - 1 - RES_CASE(0,4,5);
+						pMS->flash_rect0.corner.y = DRIVE_TOP_Y - 1 + RES_CASE(0,69,146);
+						pMS->flash_rect0.extent.width = 8 << RESOLUTION_FACTOR; // JMS_GFX;
+						pMS->flash_rect0.extent.height = (6 << RESOLUTION_FACTOR) - RES_CASE(0,0,2); // JMS_GFX;
 
 						break;
 					case TURNING_JETS:
 					case EMPTY_SLOT + 1:
-						pMS->flash_rect0.corner.x = JET_TOP_X - 1;
-						pMS->flash_rect0.corner.y = JET_TOP_Y - 1;
-						pMS->flash_rect0.extent.width = 9;
-						pMS->flash_rect0.extent.height = 10;
+						pMS->flash_rect0.corner.x = JET_TOP_X - 1 - RES_CASE(0,3,3);
+						pMS->flash_rect0.corner.y = JET_TOP_Y - 1 + RES_CASE(0,90,185);
+						pMS->flash_rect0.extent.width = 9 << RESOLUTION_FACTOR; // JMS_GFX;
+						pMS->flash_rect0.extent.height = (10 << RESOLUTION_FACTOR) + RES_CASE(0,0,4); // JMS_GFX;
 
 						break;
 					default:
-						pMS->flash_rect0.corner.x = MODULE_TOP_X - 1;
+						pMS->flash_rect0.corner.x = MODULE_TOP_X - 1 + RES_CASE(0,0,2);
 						pMS->flash_rect0.corner.y = MODULE_TOP_Y - 1;
-						pMS->flash_rect0.extent.width = SHIP_PIECE_OFFSET + 2;
-						pMS->flash_rect0.extent.height = 34;
-
+						pMS->flash_rect0.extent.width = SHIP_PIECE_OFFSET + 2 - RES_CASE(0,1,1);
+						pMS->flash_rect0.extent.height = (34 << RESOLUTION_FACTOR) + RES_CASE(0,0,9); // JMS_GFX;
+						w += RES_CASE(0,1,1);
 						break;
 				}
 
@@ -534,7 +560,10 @@ InitFlash:
 			else
 				SetFlashRect (&pMS->flash_rect0);
 		}
-	}
+	}	
+
+	if(optInfiniteFuel)
+		DeltaSISGauges(0,GetFuelTankCapacity(),0);
 
 	return (TRUE);
 }
@@ -675,7 +704,7 @@ DoOutfit (MENU_STATE *pMS)
 				ShieldFlags = GET_GAME_STATE (LANDER_SHIELDS);
 
 				s.frame = SetAbsFrameIndex (pMS->ModuleFrame,
-						GetFrameCount (pMS->ModuleFrame) - 5);
+						GetFrameCount (pMS->ModuleFrame) - SHIELD_LOCATION_IN_MODULE_ANI);
 				if (ShieldFlags & (1 << EARTHQUAKE_DISASTER))
 					DrawStamp (&s);
 				s.frame = IncFrameIndex (s.frame);
@@ -783,7 +812,9 @@ ExitOutfit:
 
 		if (pMS->CurState == OUTFIT_DOFUEL)
 		{
-			ChangeFuelQuantity ();
+			if(!optInfiniteFuel)
+				ChangeFuelQuantity ();
+
 			SleepThread (ONE_SECOND / 30);
 		}
 		else
diff -ruNp src.orig/uqm/pickship.c src/uqm/pickship.c
--- src.orig/uqm/pickship.c	2017-12-30 00:14:40 -0800
+++ src/uqm/pickship.c	2017-12-30 00:14:53 -0800
@@ -33,17 +33,16 @@
 #include "sounds.h"
 #include "libs/mathlib.h"
 
-
 #define NUM_PICK_SHIP_ROWS 2
 #define NUM_PICK_SHIP_COLUMNS 6
 
-#define ICON_WIDTH 16
-#define ICON_HEIGHT 16
+#define ICON_WIDTH (16 << RESOLUTION_FACTOR) // JMS_GFX
+#define ICON_HEIGHT (16 << RESOLUTION_FACTOR) // JMS_GFX
 
-#define FLAGSHIP_X_OFFS 65
-#define FLAGSHIP_Y_OFFS 4
-#define FLAGSHIP_WIDTH 22
-#define FLAGSHIP_HEIGHT 48
+#define FLAGSHIP_X_OFFS (65 << RESOLUTION_FACTOR) // JMS_GFX
+#define FLAGSHIP_Y_OFFS (4 << RESOLUTION_FACTOR) // JMS_GFX
+#define FLAGSHIP_WIDTH (22 << RESOLUTION_FACTOR) // JMS_GFX
+#define FLAGSHIP_HEIGHT (48 << RESOLUTION_FACTOR) // JMS_GFX
 
 static BOOLEAN
 DoPickBattleShip (MENU_STATE *pMS)
@@ -129,15 +128,15 @@ ChangeSelection:
 			else
 			{
 				new_col = pMS->first_item.x;
-				pMS->flash_rect0.corner.x = 5 + pMS->flash_rect1.corner.x - 2
-						+ ((ICON_WIDTH + 4) * new_col);
+				pMS->flash_rect0.corner.x = (5 << RESOLUTION_FACTOR) + pMS->flash_rect1.corner.x - 2
+						+ ((ICON_WIDTH + (4 << RESOLUTION_FACTOR)) * new_col); // JMS_GFX
 				if (new_col > (NUM_PICK_SHIP_COLUMNS >> 1))
 				{
 					--new_col;
 					pMS->flash_rect0.corner.x += FLAGSHIP_WIDTH - ICON_WIDTH;
 				}
-				pMS->flash_rect0.corner.y = 16 + pMS->flash_rect1.corner.y - 2
-						+ ((ICON_HEIGHT + 4) * pMS->first_item.y);
+				pMS->flash_rect0.corner.y = (16 << RESOLUTION_FACTOR) + pMS->flash_rect1.corner.y - 2
+					+ ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR)) * pMS->first_item.y); // JMS_GFX
 				pMS->flash_rect0.extent.width = ICON_WIDTH + 4;
 				pMS->flash_rect0.extent.height = ICON_HEIGHT + 4;
 
@@ -167,10 +166,10 @@ ChangeSelection:
 			pMS->CurFrame = (FRAME)hBattleShip;
 
 			SetContextForeGroundColor (BLACK_COLOR);
-			r.corner.x = pMS->flash_rect1.corner.x + 6;
-			r.corner.y = pMS->flash_rect1.corner.y + 5;
-			r.extent.width = ((ICON_WIDTH + 4) * 3) - 4;
-			r.extent.height = 7;
+			r.corner.x = pMS->flash_rect1.corner.x + (6 << RESOLUTION_FACTOR) - 2*RESOLUTION_FACTOR; // JMS_GFX
+			r.corner.y = pMS->flash_rect1.corner.y + (5 << RESOLUTION_FACTOR) - 2*RESOLUTION_FACTOR; // JMS_GFX
+			r.extent.width = ((ICON_WIDTH + (4 << RESOLUTION_FACTOR)) * 3) - (4 << RESOLUTION_FACTOR) + 2*RESOLUTION_FACTOR;  // JMS_GFX
+			r.extent.height = 7 << RESOLUTION_FACTOR; // JMS_GFX
 			DrawFilledRectangle (&r);
 
 			if (hBattleShip == 0)
@@ -184,7 +183,7 @@ ChangeSelection:
 				SetContextFont (TinyFont);
 
 				t.baseline.x = r.corner.x + (r.extent.width >> 1);
-				t.baseline.y = r.corner.y + (r.extent.height - 1);
+				t.baseline.y = r.corner.y + (r.extent.height - (1 << RESOLUTION_FACTOR)) - 2*RESOLUTION_FACTOR; // JMS_GFX
 				t.align = ALIGN_CENTER;
 
 				StarShipPtr = LockStarShip (&race_q[0], hBattleShip);
@@ -215,9 +214,10 @@ ChangeSelection:
 				SetContextForeGroundColor (BLACK_COLOR);
 			}
 
-			r.corner.x += (ICON_WIDTH + 4)
-					* ((NUM_PICK_SHIP_COLUMNS >> 1) + 1)
-					+ FLAGSHIP_WIDTH - ICON_WIDTH;
+			r.extent.width -= 2*RESOLUTION_FACTOR; // JMS_GFX
+			r.corner.x += (ICON_WIDTH + (4 << RESOLUTION_FACTOR))
+				* ((NUM_PICK_SHIP_COLUMNS >> 1) + 1)
+					+ FLAGSHIP_WIDTH - ICON_WIDTH; // JMS_GFX
 			DrawFilledRectangle (&r);
 
 			if (crew_level)
@@ -348,10 +348,10 @@ GetEncounterStarShip (STARSHIP *LastStar
 				}
 				else
 				{	// Player ran away
-					if (GLOBAL_SIS (FuelOnBoard) > RUN_AWAY_FUEL_COST)
+					if (GLOBAL_SIS (FuelOnBoard) > RUN_AWAY_FUEL_COST && !optInfiniteFuel)
 						GLOBAL_SIS (FuelOnBoard) -= RUN_AWAY_FUEL_COST;
 					else
-						GLOBAL_SIS (FuelOnBoard) = 0;
+						GLOBAL_SIS (FuelOnBoard) = (optInfiniteFuel ? GLOBAL_SIS (FuelOnBoard) : 0);
 				}
 			}
 			return 0;
@@ -388,7 +388,7 @@ GetEncounterStarShip (STARSHIP *LastStar
 void
 DrawArmadaPickShip (BOOLEAN draw_salvage_frame, RECT *pPickRect)
 {
-#define PICK_NAME_HEIGHT 6
+#define PICK_NAME_HEIGHT (6 << RESOLUTION_FACTOR); // JMS_GFX
 	//COUNT i;
 	HSTARSHIP hBattleShip, hNextShip;
 	STARSHIP *StarShipPtr;
@@ -433,7 +433,7 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 	DrawStamp (&s);
 
 	t.baseline.x = pick_r.corner.x + (pick_r.extent.width >> 1);
-	t.baseline.y = pick_r.corner.y + pick_r.extent.height - 5;
+	t.baseline.y = pick_r.corner.y + pick_r.extent.height - (5 << RESOLUTION_FACTOR) - 2 * RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GLOBAL_SIS (ShipName);
 	t.CharCount = (COUNT)~0;
@@ -456,14 +456,14 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 			ship_index = StarShipPtr->index;
 
 			s.origin.x = pick_r.corner.x
-					+ (5 + ((ICON_WIDTH + 4)
-					* (ship_index % NUM_PICK_SHIP_COLUMNS)));
+					+ ((5 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (4 << RESOLUTION_FACTOR))
+				       * (ship_index % NUM_PICK_SHIP_COLUMNS))); // JMS_GFX
 			if ((ship_index % NUM_PICK_SHIP_COLUMNS) >=
 					(NUM_PICK_SHIP_COLUMNS >> 1))
-				s.origin.x += FLAGSHIP_WIDTH + 4;
+				s.origin.x += FLAGSHIP_WIDTH + (4 << RESOLUTION_FACTOR); // JMS_GFX
 			s.origin.y = pick_r.corner.y
-					+ (16 + ((ICON_HEIGHT + 4)
-					* (ship_index / NUM_PICK_SHIP_COLUMNS)));
+					+ ((16 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (4 << RESOLUTION_FACTOR))
+					* (ship_index / NUM_PICK_SHIP_COLUMNS))); // JMS_GFX
 			s.frame = StarShipPtr->icons;
 			r.corner = s.origin;
 			SetContextForeGroundColor (BLACK_COLOR);
@@ -474,7 +474,12 @@ DrawArmadaPickShip (BOOLEAN draw_salvage
 				if (StarShipPtr->SpeciesID == NO_ID)
 				{
 					/* Dead ship - mark with an X. */
-					s.origin.x -= 1;
+					s.origin.x -= (1 << RESOLUTION_FACTOR); // JMS_GFX
+					
+					// JMS_GFX
+					if (RESOLUTION_FACTOR > 0)
+						s.origin.y -= (1 << RESOLUTION_FACTOR);
+
 					s.frame = SetAbsFrameIndex (StatusFrame, 3);
 					DrawStamp (&s);
 				}
diff -ruNp src.orig/uqm/plandata.c src/uqm/plandata.c
--- src.orig/uqm/plandata.c	2017-12-30 00:14:40 -0800
+++ src/uqm/plandata.c	2017-12-30 00:14:53 -0800
@@ -18,6 +18,7 @@
 
 #include "gendef.h"
 #include "resinst.h"
+#include "hyper.h" // JMS: For ARILOU_HOME_X and Y
 #include "planets/planets.h"
 #include "planets/elemdata.h"
 
@@ -537,37 +538,37 @@ STAR_DESC starmap_array[] =
 	// QuasiSpace locations
 #define VORTEX_SCALE 20
 	{{(-12* VORTEX_SCALE) + 5000, (-21 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 133},
 	{{( 1 * VORTEX_SCALE) + 5000, (-20 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 134},
 	{{(-16 * VORTEX_SCALE) + 5000, (-18 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 135},
 	{{( 8 * VORTEX_SCALE) + 5000, (-17 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 136},
 	{{( 3 * VORTEX_SCALE) + 5000, (-13 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 137},
 	{{(-21 * VORTEX_SCALE) + 5000, (-4 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 138},
 	{{(-4 * VORTEX_SCALE) + 5000, (-4 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 139},
 	{{(-12 * VORTEX_SCALE) + 5000, (-2 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 140},
 	{{(-26 * VORTEX_SCALE) + 5000, (2 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 141},
 	{{(-17 * VORTEX_SCALE) + 5000, (7 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 142},
 	{{(10 * VORTEX_SCALE) + 5000, (7 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 143},
 	{{(15 * VORTEX_SCALE) + 5000, (14 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 144},
 	{{(22 * VORTEX_SCALE) + 5000, (16 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 145},
 	{{(-6 * VORTEX_SCALE) + 5000, (19 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 146},
 	{{(10 * VORTEX_SCALE) + 5000, (20 * VORTEX_SCALE) + 5000},
-			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 132},
+			MAKE_STAR (DWARF_STAR, WHITE_BODY, -1), 0, 0, 147},
 
-	{{6134, 5900}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 0, 132},
+	{{ARILOU_HOME_X, ARILOU_HOME_Y}, MAKE_STAR (DWARF_STAR, YELLOW_BODY, -1), 0, 0, 148},
 
 	{{MAX_X_UNIVERSE << 1, MAX_Y_UNIVERSE << 1}, 0, 0, 0, 0},
 };
diff -ruNp src.orig/uqm/planets/calc.c src/uqm/planets/calc.c
--- src.orig/uqm/planets/calc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/calc.c	2017-12-30 00:14:53 -0800
@@ -207,14 +207,20 @@ CalcTemp (SYSTEM_INFO *SysInfoPtr, SIZE
 }
 
 static COUNT
-CalcRotation (PLANET_INFO *PlanetInfoPtr)
+CalcRotation (PLANET_INFO *PlanetInfoPtr, PLANET_DESC *planet)
 {
-	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT)
-		return CalcFromBase (80, 80);
-	else if (LOBYTE (RandomContext_Random (SysGenRNG)) % 10 == 0)
-		return CalcFromBase (50 * 240, 200 * 240);
-	else
-		return CalcFromBase (150, 150);
+	COUNT period;
+	if (PLANSIZE (PlanetInfoPtr->PlanDataPtr->Type) == GAS_GIANT) {
+		period = ((COUNT)CalcFromBase (80, 80));
+	} else if (LOBYTE (RandomContext_Random (SysGenRNG)) % 10 == 0) {
+		period = ((COUNT)CalcFromBase ((UWORD)50 * 240, (UWORD)200 * 240));
+	} else {
+		period = ((COUNT)CalcFromBase (150, 150));
+	} // BW 2011: Research shows that most major moons have a synchronous rotation
+	if (planet->pPrevDesc != pSolarSysState->SunDesc) {
+		period = ((COUNT)(FULL_CIRCLE * 240 / planet->orb_speed));
+	}
+	return period;
 }
 
 static SIZE
@@ -446,7 +452,7 @@ DoPlanetaryAnalysis (SYSTEM_INFO *SysInf
 				break;
 		}
 
-		SysInfoPtr->PlanetInfo.RotationPeriod = CalcRotation (&SysInfoPtr->PlanetInfo);
+		SysInfoPtr->PlanetInfo.RotationPeriod = CalcRotation (&SysInfoPtr->PlanetInfo, pPlanetDesc);
 		SysInfoPtr->PlanetInfo.SurfaceGravity = CalcGravity (&SysInfoPtr->PlanetInfo);
 		SysInfoPtr->PlanetInfo.AxialTilt = CalcTilt ();
 		if ((SysInfoPtr->PlanetInfo.Tectonics =
diff -ruNp src.orig/uqm/planets/cargo.c src/uqm/planets/cargo.c
--- src.orig/uqm/planets/cargo.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/cargo.c	2017-12-30 00:14:53 -0800
@@ -30,20 +30,20 @@
 		// for GetFrameBounds()
 
 
-#define ELEMENT_ORG_Y      35
+#define ELEMENT_ORG_Y      RES_STAT_SCALE(35) // JMS_GFX
 #define FREE_ORG_Y         (ELEMENT_ORG_Y + (NUM_ELEMENT_CATEGORIES \
 							* ELEMENT_SPACING_Y))
-#define BIO_ORG_Y          119
-#define ELEMENT_SPACING_Y  9
+#define BIO_ORG_Y          RES_STAT_SCALE(119) // JMS_GFX
+#define ELEMENT_SPACING_Y  RES_STAT_SCALE(9) // JMS_GFX
 
-#define ELEMENT_COL_0      7
-#define ELEMENT_COL_1      32
-#define ELEMENT_COL_2      58
+#define ELEMENT_COL_0      RES_STAT_SCALE(7) // JMS_GFX
+#define ELEMENT_COL_1      RES_STAT_SCALE(32) // JMS_GFX
+#define ELEMENT_COL_2      RES_STAT_SCALE(58) // JMS_GFX
 
-#define ELEMENT_SEL_ORG_X  (ELEMENT_COL_0 + 7 + 5)
-#define ELEMENT_SEL_WIDTH  (ELEMENT_COL_2 - ELEMENT_SEL_ORG_X + 1)
+#define ELEMENT_SEL_ORG_X  (ELEMENT_COL_0 + RES_STAT_SCALE(7 + 5)) // JMS_GFX
+#define ELEMENT_SEL_WIDTH  (ELEMENT_COL_2 - ELEMENT_SEL_ORG_X + RES_STAT_SCALE(1)) // JMS_GFX
 
-#define TEXT_BASELINE      6
+#define TEXT_BASELINE      RES_STAT_SCALE(6) // JMS_GFX
 
 
 void
@@ -57,19 +57,19 @@ ShowRemainingCapacity (void)
 	OldContext = SetContext (StatusContext);
 	SetContextFont (TinyFont);
 
-	r.corner.x = 40;
+	r.corner.x = RES_STAT_SCALE(40); // JMS_GFX
 	r.corner.y = FREE_ORG_Y;
 
 	snprintf (buf, sizeof buf, "%u",
 			GetStorageBayCapacity () - GLOBAL_SIS (TotalElementMass));
-	t.baseline.x = ELEMENT_COL_2 + 1;
+	t.baseline.x = ELEMENT_COL_2 + RES_STAT_SCALE(1); // JMS_GFX
 	t.baseline.y = r.corner.y + TEXT_BASELINE;
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
-	r.extent.width = t.baseline.x - r.corner.x + 1;
-	r.extent.height = ELEMENT_SPACING_Y - 2;
+	r.extent.width = t.baseline.x - r.corner.x + RES_STAT_SCALE(1); // JMS_GFX
+	r.extent.height = ELEMENT_SPACING_Y - RES_STAT_SCALE(2); // JMS_GFX
 
 	BatchGraphics ();
 	// erase previous free amount
@@ -92,7 +92,7 @@ DrawElementAmount (COUNT element, bool s
 
 	r.corner.x = ELEMENT_SEL_ORG_X;
 	r.extent.width = ELEMENT_SEL_WIDTH;
-	r.extent.height = ELEMENT_SPACING_Y - 2;
+	r.extent.height = ELEMENT_SPACING_Y - RES_STAT_SCALE(2); // JMS_GFX
 
 	if (element == NUM_ELEMENT_CATEGORIES)
 		r.corner.y = BIO_ORG_Y;
@@ -142,20 +142,20 @@ DrawCargoDisplay (void)
 	COORD cy;
 	COUNT i;
 
-	r.corner.x = 2;
-	r.extent.width = FIELD_WIDTH + 1;
-	r.corner.y = 20;
+	r.corner.x = RES_CASE(2,2,3); // JMS_GFX
+	r.corner.y = RES_STAT_SCALE(20) - RES_CASE(0,1,0); // JMS_GFX
+	r.extent.width = FIELD_WIDTH + 1; // JMS_GFX
 	// XXX: Shouldn't the height be 1 less? This draws the bottom border
 	//   1 pixel too low. Or if not, why do we need another box anyway?
-	r.extent.height = 129 - r.corner.y;
+	r.extent.height = RES_STAT_SCALE(129) - r.corner.y + RES_CASE(0,6,19); // JMS_GFX
 	DrawStarConBox (&r, 1,
 			SHADOWBOX_MEDIUM_COLOR, SHADOWBOX_DARK_COLOR,
 			TRUE, CARGO_BACK_COLOR);
 
 	// draw the "CARGO" title
 	SetContextFont (StarConFont);
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = 27;
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_STAT_SCALE(1); // JMS_GFX
+	t.baseline.y = RES_STAT_SCALE(27); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GAME_STRING (CARGO_STRING_BASE);
 	t.CharCount = (COUNT)~0;
@@ -166,15 +166,20 @@ DrawCargoDisplay (void)
 
 	s.frame = SetAbsFrameIndex (MiscDataFrame,
 			(NUM_SCANDOT_TRANSITIONS * 2) + 3);
+	if (RESOLUTION_FACTOR == 2)
+		s.frame = SetRelFrameIndex (s.frame, -1); // JMS_GFX
+
 	r.corner.x = ELEMENT_COL_0;
 	r.extent = GetFrameBounds (s.frame);
-	s.origin.x = r.corner.x + (r.extent.width >> 1);
+	r.extent.width -= RES_CASE(0,5,7); // JMS_GFX
+	r.extent.height -= RES_CASE(0,5,8); // JMS_GFX
+	s.origin.x = r.corner.x + (r.extent.width >> 1) - RES_CASE(0,1,4); // JMS_GFX
 
 	cy = ELEMENT_ORG_Y;
 
 	// print element column headings
 	t.align = ALIGN_RIGHT;
-	t.baseline.y = cy - 1;
+	t.baseline.y = cy - RES_STAT_SCALE(1); // JMS_GFX
 	t.CharCount = (COUNT)~0;
 
 	SetContextForeGroundColor (CARGO_WORTH_COLOR);
@@ -190,12 +195,12 @@ DrawCargoDisplay (void)
 	for (i = 0; i < NUM_ELEMENT_CATEGORIES; ++i, cy += ELEMENT_SPACING_Y)
 	{
 		// erase background under an element icon
-		SetContextForeGroundColor (BLACK_COLOR);
+		SetContextForeGroundColor (CARGO_BACK_COLOR); // Serosis: Was actually supposed to be black
 		r.corner.y = cy;
 		DrawFilledRectangle (&r);
 
 		// draw an element icon
-		s.origin.y = r.corner.y + (r.extent.height >> 1);
+		s.origin.y = r.corner.y + (r.extent.height >> 1) - RES_CASE(0,1,5);
 		DrawStamp (&s);
 		s.frame = SetRelFrameIndex (s.frame, 5);
 
@@ -203,7 +208,7 @@ DrawCargoDisplay (void)
 	}
 
 	// erase background under the Bio icon
-	SetContextForeGroundColor (BLACK_COLOR);
+	SetContextForeGroundColor (CARGO_BACK_COLOR); // Serosis: Was actually supposed to be black
 	r.corner.y = BIO_ORG_Y;
 	DrawFilledRectangle (&r);
 
@@ -216,15 +221,15 @@ DrawCargoDisplay (void)
 	DrawElementAmount (NUM_ELEMENT_CATEGORIES, false);
 
 	// draw the line over the Bio amount
-	r.corner.x = 4;
-	r.corner.y = BIO_ORG_Y - 2;
-	r.extent.width = FIELD_WIDTH - 3;
+	r.corner.x = RES_STAT_SCALE(4); // JMS_GFX
+	r.corner.y = BIO_ORG_Y - RES_STAT_SCALE(2); // JMS_GFX
+	r.extent.width = FIELD_WIDTH - RES_CASE(3,10,17); // JMS_GFX
 	r.extent.height = 1;
 	SetContextForeGroundColor (CARGO_SELECTED_BACK_COLOR);
 	DrawFilledRectangle (&r);
 
 	// print "Free"
-	t.baseline.x = 5;
+	t.baseline.x = RES_STAT_SCALE(5); // JMS_GFX
 	t.baseline.y = FREE_ORG_Y + TEXT_BASELINE;
 	t.align = ALIGN_LEFT;
 	t.pStr = GAME_STRING (CARGO_STRING_BASE + 1);
diff -ruNp src.orig/uqm/planets/devices.c src/uqm/planets/devices.c
--- src.orig/uqm/planets/devices.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/devices.c	2017-12-30 00:14:53 -0800
@@ -38,6 +38,9 @@
 #include "planets.h"
 		// for SaveSolarSysLocation() and tests
 #include "libs/strlib.h"
+#include "../../options.h"
+#include "libs/graphics/gfx_common.h"
+                // for scaling down devices in 4x
 
 
 // If DEBUG_DEVICES is defined, the device list shown in the game will
@@ -45,24 +48,24 @@
 // devices the player actually possesses.
 //#define DEBUG_DEVICES
 
-#define DEVICE_ICON_WIDTH  16
-#define DEVICE_ICON_HEIGHT 16
+#define DEVICE_ICON_WIDTH  RES_STAT_SCALE(16) // JMS_GFX
+#define DEVICE_ICON_HEIGHT RES_STAT_SCALE(16) // JMS_GFX
 
-#define DEVICE_ORG_Y       33
-#define DEVICE_SPACING_Y   (DEVICE_ICON_HEIGHT + 2)
+#define DEVICE_ORG_Y       RES_STAT_SCALE(33) // JMS_GFX
+#define DEVICE_SPACING_Y   (DEVICE_ICON_HEIGHT + RES_STAT_SCALE(2)) // JMS_GFX
 
-#define DEVICE_COL_0       4
-#define DEVICE_COL_1       40
+#define DEVICE_COL_0       RES_STAT_SCALE(4) // JMS_GFX
+#define DEVICE_COL_1       RES_STAT_SCALE(40) // JMS_GFX
 
 #define DEVICE_SEL_ORG_X  (DEVICE_COL_0 + DEVICE_ICON_WIDTH)
-#define DEVICE_SEL_WIDTH  (FIELD_WIDTH + 1 - DEVICE_SEL_ORG_X + 1)
+#define DEVICE_SEL_WIDTH  (FIELD_WIDTH + RES_CASE(2,0,6) - DEVICE_SEL_ORG_X) // JMS_GFX
 
-#define ICON_OFS_Y         1
-#define NAME_OFS_Y         2
-#define TEXT_BASELINE      6
-#define TEXT_SPACING_Y     7
+#define ICON_OFS_Y         RES_CASE(1,4,11) // JMS_GFX
+#define NAME_OFS_Y         RES_STAT_SCALE(2) // JMS_GFX
+#define TEXT_BASELINE      RES_STAT_SCALE(6) // JMS_GFX
+#define TEXT_SPACING_Y     RES_STAT_SCALE(7) // JMS_GFX
 
-#define MAX_VIS_DEVICES    ((129 - DEVICE_ORG_Y) / DEVICE_SPACING_Y)
+#define MAX_VIS_DEVICES    ((RES_STAT_SCALE(129) - DEVICE_ORG_Y) / DEVICE_SPACING_Y) // JMS_GFX
 
 
 typedef enum
@@ -89,8 +92,8 @@ EraseDevicesBackground (void)
 {
 	RECT r;
 
-	r.corner.x = 2 + 1;
-	r.extent.width = FIELD_WIDTH + 1 - 2;
+	r.corner.x = RES_STAT_SCALE(2 + 1); // JMS_GFX
+	r.extent.width = FIELD_WIDTH - RES_STAT_SCALE(1); // JMS_GFX
 	r.corner.y = DEVICE_ORG_Y;
 	r.extent.height = MAX_VIS_DEVICES * DEVICE_SPACING_Y;
 	SetContextForeGroundColor (DEVICES_BACK_COLOR);
@@ -108,8 +111,8 @@ DrawDevice (COUNT device, COUNT pos, boo
 	t.baseline.x = DEVICE_COL_1;
 
 	r.extent.width = DEVICE_SEL_WIDTH;
-	r.extent.height = TEXT_SPACING_Y * 2;
-	r.corner.x = DEVICE_SEL_ORG_X;
+	r.extent.height = (TEXT_SPACING_Y * 2) + RES_CASE(0,4,0);
+	r.corner.x = DEVICE_SEL_ORG_X - RES_CASE(0,0,8);
 
 	// draw line background
 	r.corner.y = DEVICE_ORG_Y + pos * DEVICE_SPACING_Y + NAME_OFS_Y;
@@ -141,20 +144,20 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 	COORD cy;
 	COUNT i;
 
-	r.corner.x = 2;
-	r.corner.y = 20;
-	r.extent.width = FIELD_WIDTH + 1;
+	r.corner.x = RES_CASE(2,2,3); // JMS_GFX
+	r.corner.y = RES_STAT_SCALE(20) - RES_CASE(0,1,0); // JMS_GFX
+	r.extent.width = FIELD_WIDTH + 1; // JMS_GFX
 	// XXX: Shouldn't the height be 1 less? This draws the bottom border
 	//   1 pixel too low. Or if not, why do we need another box anyway?
-	r.extent.height = 129 - r.corner.y;
+	r.extent.height = RES_STAT_SCALE(129) - r.corner.y + RES_CASE(0,6,19); // JMS_GFX
 	DrawStarConBox (&r, 1,
 			SHADOWBOX_MEDIUM_COLOR, SHADOWBOX_DARK_COLOR,
 			TRUE, DEVICES_BACK_COLOR);
 
 	// print the "DEVICES" title
 	SetContextFont (StarConFont);
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = r.corner.y + 7;
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_STAT_SCALE(1); // JMS_GFX
+	t.baseline.y = r.corner.y + RES_STAT_SCALE(7); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GAME_STRING (DEVICE_STRING_BASE);
 	t.CharCount = (COUNT)~0;
@@ -176,7 +179,17 @@ DrawDevicesDisplay (DEVICES_STATE *devSt
 		s.origin.y = cy + ICON_OFS_Y;
 		s.frame = SetAbsFrameIndex (MiscDataFrame,
 				77 + devState->list[devIndex]);
-		DrawStamp (&s);
+		
+		if (RESOLUTION_FACTOR < 2) {
+			DrawStamp (&s);			
+		} else {
+			int oldMode, oldScale;
+			oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
+			oldScale = SetGraphicScale ((int)(GSCALE_IDENTITY / 2));
+			DrawStamp (&s);
+			SetGraphicScale (oldScale);
+			SetGraphicScaleMode (oldMode);
+		}
 
 		DrawDevice (devState->list[devIndex], i, false);
 	}
@@ -449,7 +462,9 @@ InvokeDevice (BYTE which_device)
 				/* No DeltaSISGauges because the flagship picture
 				 * is currently obscured.
 				 */
-				GLOBAL_SIS (FuelOnBoard) -= PORTAL_FUEL_COST;
+				if (!optInfiniteFuel)
+					GLOBAL_SIS (FuelOnBoard) -= PORTAL_FUEL_COST;
+
 				SET_GAME_STATE (PORTAL_COUNTER, 1);
 				return DEVICE_SUCCESS;
 			}
@@ -561,10 +576,10 @@ InventoryDevices (BYTE *pDeviceMap, COUN
 				DeviceState = GET_GAME_STATE (ROSY_SPHERE_ON_SHIP);
 				break;
 			case ARTIFACT_2_DEVICE:
-				DeviceState = GET_GAME_STATE (ARTIFACT_2_ON_SHIP);
+				DeviceState = GET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP);
 				break;
 			case ARTIFACT_3_DEVICE:
-				DeviceState = GET_GAME_STATE (ARTIFACT_3_ON_SHIP);
+				DeviceState = GET_GAME_STATE (GLOWING_ROD_ON_SHIP);
 				break;
 			case SUN_EFFICIENCY_DEVICE:
 				DeviceState = GET_GAME_STATE (SUN_DEVICE_ON_SHIP);
diff -ruNp src.orig/uqm/planets/generate/genand.c src/uqm/planets/generate/genand.c
--- src.orig/uqm/planets/generate/genand.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/generate/genand.c	2017-12-30 00:14:53 -0800
@@ -68,6 +68,7 @@ GenerateAndrosynth_generatePlanets (SOLA
 			COSINE (angle, solarSys->PlanetDesc[1].radius);
 	solarSys->PlanetDesc[1].location.y =
 			SINE (angle, solarSys->PlanetDesc[1].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[1], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genburv.c src/uqm/planets/generate/genburv.c
--- src.orig/uqm/planets/generate/genburv.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/generate/genburv.c	2017-12-30 00:14:53 -0800
@@ -69,6 +69,7 @@ GenerateBurvixese_generatePlanets (SOLAR
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	return true;
 }
 
@@ -91,6 +92,7 @@ GenerateBurvixese_generateMoons (SOLARSY
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genchmmr.c src/uqm/planets/generate/genchmmr.c
--- src.orig/uqm/planets/generate/genchmmr.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/generate/genchmmr.c	2017-12-30 00:14:53 -0800
@@ -83,6 +83,7 @@ GenerateChmmr_generateMoons (SOLARSYS_ST
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/gencol.c src/uqm/planets/generate/gencol.c
--- src.orig/uqm/planets/generate/gencol.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/generate/gencol.c	2017-12-30 00:14:53 -0800
@@ -97,6 +97,8 @@ GenerateColony_generatePlanets (SOLARSYS
 	pMinPlanet->location.x = COSINE (angle, pMinPlanet->radius);
 	pMinPlanet->location.y = SINE (angle, pMinPlanet->radius);
 	pMinPlanet->data_index = WATER_WORLD | PLANET_SHIELDED;
+	pMinPlanet->alternate_colormap = NULL;
+	ComputeSpeed(pMinPlanet, FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/gendru.c src/uqm/planets/generate/gendru.c
--- src.orig/uqm/planets/generate/gendru.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/generate/gendru.c	2017-12-30 00:14:53 -0800
@@ -69,6 +69,7 @@ GenerateDruuge_generatePlanets (SOLARSYS
 	++solarSys->SunDesc[0].NumPlanets;
 
 	solarSys->PlanetDesc[0].data_index = DUST_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 50L / 100;
 	solarSys->PlanetDesc[0].NumPlanets = 0;
 	angle = HALF_CIRCLE - OCTANT;
@@ -79,6 +80,7 @@ GenerateDruuge_generatePlanets (SOLARSYS
 	solarSys->PlanetDesc[0].rand_seed = MAKE_DWORD (
 			solarSys->PlanetDesc[0].location.x,
 			solarSys->PlanetDesc[0].location.y);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genilw.c src/uqm/planets/generate/genilw.c
--- src.orig/uqm/planets/generate/genilw.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/generate/genilw.c	2017-12-30 00:14:53 -0800
@@ -69,6 +69,7 @@ GenerateIlwrath_generatePlanets (SOLARSY
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genmyc.c src/uqm/planets/generate/genmyc.c
--- src.orig/uqm/planets/generate/genmyc.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/generate/genmyc.c	2017-12-30 00:14:53 -0800
@@ -78,6 +78,7 @@ GenerateMycon_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genorz.c src/uqm/planets/generate/genorz.c
--- src.orig/uqm/planets/generate/genorz.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/generate/genorz.c	2017-12-30 00:14:53 -0800
@@ -67,6 +67,7 @@ GenerateOrz_generatePlanets (SOLARSYS_ST
 	if (CurStarDescPtr->Index == ORZ_DEFINED)
 	{
 		solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 156L / 100;
 		solarSys->PlanetDesc[0].NumPlanets = 0;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -75,6 +76,7 @@ GenerateOrz_generatePlanets (SOLARSYS_ST
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/genpet.c src/uqm/planets/generate/genpet.c
--- src.orig/uqm/planets/generate/genpet.c	2017-12-30 00:14:40 -0800
+++ src/uqm/planets/generate/genpet.c	2017-12-30 00:14:53 -0800
@@ -28,6 +28,7 @@
 #include "../../setup.h"
 #include "../../state.h"
 #include "libs/mathlib.h"
+#include "../../../options.h"
 
 
 static bool GenerateTalkingPet_generatePlanets (SOLARSYS_STATE *solarSys);
@@ -73,6 +74,7 @@ GenerateTalkingPet_generatePlanets (SOLA
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
@@ -241,7 +243,9 @@ ZapToUrquanEncounter (void)
 		dx = (SIZE)square_root ((long)dx * dx + (long)dy * dy)
 				+ (FUEL_TANK_SCALE >> 1);
 
-		DeltaSISGauges (0, -dx, 0);
+		if (!optInfiniteFuel)
+			DeltaSISGauges (0, -dx, 0);
+
 		if (GLOBAL_SIS (FuelOnBoard) < 5 * FUEL_TANK_SCALE)
 		{
 			dx = ((5 + ((COUNT)TFB_Random () % 5)) * FUEL_TANK_SCALE)
diff -ruNp src.orig/uqm/planets/generate/genpku.c src/uqm/planets/generate/genpku.c
--- src.orig/uqm/planets/generate/genpku.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/genpku.c	2017-12-30 00:14:53 -0800
@@ -62,6 +62,7 @@ GeneratePkunk_generatePlanets (SOLARSYS_
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 104L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -70,6 +71,7 @@ GeneratePkunk_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genrain.c src/uqm/planets/generate/genrain.c
--- src.orig/uqm/planets/generate/genrain.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/genrain.c	2017-12-30 00:14:53 -0800
@@ -54,6 +54,7 @@ GenerateRainbowWorld_generatePlanets (SO
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = RAINBOW_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 0;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 50L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -66,6 +67,7 @@ GenerateRainbowWorld_generatePlanets (SO
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/gensam.c src/uqm/planets/generate/gensam.c
--- src.orig/uqm/planets/generate/gensam.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/gensam.c	2017-12-30 00:14:53 -0800
@@ -156,6 +156,7 @@ GenerateSaMatra_generateMoons (SOLARSYS_
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/gensly.c src/uqm/planets/generate/gensly.c
--- src.orig/uqm/planets/generate/gensly.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/gensly.c	2017-12-30 00:14:53 -0800
@@ -49,6 +49,7 @@ GenerateSlylandro_generatePlanets (SOLAR
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[3].data_index = RED_GAS_GIANT;
+	solarSys->PlanetDesc[3].alternate_colormap = NULL;
 	solarSys->PlanetDesc[3].NumPlanets = 1;
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/gensol.c src/uqm/planets/generate/gensol.c
--- src.orig/uqm/planets/generate/gensol.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/gensol.c	2017-12-30 00:14:53 -0800
@@ -28,7 +28,9 @@
 #include "../../nameref.h"
 #include "../../state.h"
 #include "libs/mathlib.h"
-
+#include "options.h"
+#include "../../setup.h"
+#include <math.h>
 
 static bool GenerateSol_initNpcs (SOLARSYS_STATE *solarSys);
 static bool GenerateSol_reinitNpcs (SOLARSYS_STATE *solarSys);
@@ -113,7 +115,7 @@ GenerateSol_generatePlanets (SOLARSYS_ST
 	solarSys->SunDesc[0].NumPlanets = 9;
 	for (planetI = 0; planetI < 9; ++planetI)
 	{
-		COUNT angle;
+		//COUNT angle;
 		DWORD rand_val;
 		UWORD word_val;
 		PLANET_DESC *pCurDesc = &solarSys->PlanetDesc[planetI];
@@ -121,61 +123,80 @@ GenerateSol_generatePlanets (SOLARSYS_ST
 		pCurDesc->rand_seed = RandomContext_Random (SysGenRNG);
 		rand_val = pCurDesc->rand_seed;
 		word_val = LOWORD (rand_val);
-		angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
+		//angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
+		pCurDesc->angle = NORMALIZE_ANGLE ((COUNT)HIBYTE (word_val));
 
 		switch (planetI)
 		{
 			case 0: /* MERCURY */
 				pCurDesc->data_index = METAL_WORLD;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = MERCURY_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 39L / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 1: /* VENUS */
 				pCurDesc->data_index = PRIMORDIAL_WORLD;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = VENUS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 72L / 100;
 				pCurDesc->NumPlanets = 0;
-				angle = NORMALIZE_ANGLE (FULL_CIRCLE - angle);
+				pCurDesc->angle = NORMALIZE_ANGLE (FULL_CIRCLE - pCurDesc->angle);
 				break;
 			case 2: /* EARTH */
 				pCurDesc->data_index = WATER_WORLD | PLANET_SHIELDED;
+				pCurDesc->alternate_colormap = NULL;
 				pCurDesc->radius = EARTH_RADIUS;
 				pCurDesc->NumPlanets = 2;
 				break;
 			case 3: /* MARS */
 				pCurDesc->data_index = DUST_WORLD;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = MARS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 152L / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 4: /* JUPITER */
 				pCurDesc->data_index = RED_GAS_GIANT;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = JUPITER_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 500L /* 520L */ / 100;
 				pCurDesc->NumPlanets = 4;
 				break;
 			case 5: /* SATURN */
 				pCurDesc->data_index = ORA_GAS_GIANT;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = SATURN_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 750L /* 952L */ / 100;
 				pCurDesc->NumPlanets = 1;
 				break;
 			case 6: /* URANUS */
 				pCurDesc->data_index = GRN_GAS_GIANT;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = URANUS_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1000L /* 1916L */ / 100;
 				pCurDesc->NumPlanets = 0;
 				break;
 			case 7: /* NEPTUNE */
 				pCurDesc->data_index = BLU_GAS_GIANT;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = NEPTUNE_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1250L /* 2999L */ / 100;
 				pCurDesc->NumPlanets = 1;
 				break;
 			case 8: /* PLUTO */
 				pCurDesc->data_index = PELLUCID_WORLD;
+				if (solTexturesPresent)
+					pCurDesc->alternate_colormap = PLUTO_COLOR_TAB;
 				pCurDesc->radius = EARTH_RADIUS * 1550L /* 3937L */ / 100;
 				pCurDesc->NumPlanets = 0;
-				angle = FULL_CIRCLE - OCTANT;
+				pCurDesc->angle = FULL_CIRCLE - OCTANT;
 				break;
 		}
 
-		pCurDesc->location.x = COSINE (angle, pCurDesc->radius);
-		pCurDesc->location.y = SINE (angle, pCurDesc->radius);
+		pCurDesc->orb_speed = FULL_CIRCLE / (365.25 * pow((float)pCurDesc->radius / EARTH_RADIUS, 1.5));
+		pCurDesc->location.x = COSINE (pCurDesc->angle, pCurDesc->radius);
+		pCurDesc->location.y = SINE (pCurDesc->angle, pCurDesc->radius);
 	}
 
 	return true;
@@ -204,9 +225,12 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 					COSINE (angle, solarSys->MoonDesc[0].radius);
 			solarSys->MoonDesc[0].location.y =
 					SINE (angle, solarSys->MoonDesc[0].radius);
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 11.46;
 
 			/* Luna: */
 			solarSys->MoonDesc[1].data_index = SELENIC_WORLD;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[1].alternate_colormap = LUNA_COLOR_TAB;
 			solarSys->MoonDesc[1].radius = MIN_MOON_RADIUS
 					+ (MAX_MOONS - 1) * MOON_DELTA;
 			rand_val = RandomContext_Random (SysGenRNG);
@@ -215,24 +239,45 @@ GenerateSol_generateMoons (SOLARSYS_STAT
 					COSINE (angle, solarSys->MoonDesc[1].radius);
 			solarSys->MoonDesc[1].location.y =
 					SINE (angle, solarSys->MoonDesc[1].radius);
+			solarSys->MoonDesc[1].orb_speed = FULL_CIRCLE / 29;
 			break;
 		}
 		case 4: /* moons of JUPITER */
 			solarSys->MoonDesc[0].data_index = RADIOACTIVE_WORLD;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[0].alternate_colormap = IO_COLOR_TAB;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 1.77;
 					/* Io */
 			solarSys->MoonDesc[1].data_index = HALIDE_WORLD;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[1].alternate_colormap = EUROPA_COLOR_TAB;
+			solarSys->MoonDesc[1].orb_speed = FULL_CIRCLE / 3.55;
 					/* Europa */
 			solarSys->MoonDesc[2].data_index = CYANIC_WORLD;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[2].alternate_colormap = GANYMEDE_COLOR_TAB;
+			solarSys->MoonDesc[2].orb_speed = FULL_CIRCLE / 7.16;
 					/* Ganymede */
 			solarSys->MoonDesc[3].data_index = PELLUCID_WORLD;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[3].alternate_colormap = CALLISTO_COLOR_TAB;
+			solarSys->MoonDesc[3].orb_speed = FULL_CIRCLE / 16.69;
 					/* Callisto */
 			break;
 		case 5: /* moons of SATURN */
 			solarSys->MoonDesc[0].data_index = ALKALI_WORLD;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[0].alternate_colormap = TITAN_COLOR_TAB;
+			solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS
+					+ (MAX_MOONS - 1) * MOON_DELTA;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / 15.95;
 					/* Titan */
 			break;
 		case 7: /* moons of NEPTUNE */
 			solarSys->MoonDesc[0].data_index = VINYLOGOUS_WORLD;
+			if (solTexturesPresent)
+				solarSys->MoonDesc[0].alternate_colormap = TRITON_COLOR_TAB;
+			solarSys->MoonDesc[0].orb_speed = FULL_CIRCLE / -5.88;
 					/* Triton */
 			break;
 	}
@@ -405,8 +450,44 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
 				CalcGravity (&solarSys->SysInfo.PlanetInfo);
-		LoadPlanet (planetNr == 2 ?
-				CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)) : NULL);
+		
+		if (solTexturesPresent){
+			switch (planetNr) {
+				case 0: /* MERCURY */
+					LoadPlanet (CaptureDrawable (LoadGraphic (MERCURY_MASK_ANIM)));
+					break;
+				case 1: /* VENUS */
+					LoadPlanet (CaptureDrawable (LoadGraphic (VENUS_MASK_ANIM)));
+					break;
+				case 2: /* EARTH */
+					LoadPlanet (CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)));
+					break;
+				case 3: /* MARS */
+					LoadPlanet (CaptureDrawable (LoadGraphic (MARS_MASK_ANIM)));
+					break;
+				case 4: /* JUPITER*/
+					LoadPlanet (CaptureDrawable (LoadGraphic (JUPITER_MASK_ANIM)));
+					break;
+				case 5: /* SATURN*/
+					LoadPlanet (CaptureDrawable (LoadGraphic (SATURN_MASK_ANIM)));
+					break;
+				case 6: /* URANUS */
+					LoadPlanet (CaptureDrawable (LoadGraphic (URANUS_MASK_ANIM)));
+					break;
+				case 7: /* NEPTUNE */
+					LoadPlanet (CaptureDrawable (LoadGraphic (NEPTUNE_MASK_ANIM)));
+					break;
+				case 8: /* PLUTO */
+					LoadPlanet (CaptureDrawable (LoadGraphic (PLUTO_MASK_ANIM)));
+					break;
+				default:
+					LoadPlanet (NULL);
+					break;
+			}
+		} else {
+			LoadPlanet (planetNr == 2 ?
+					CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM)) : NULL);			
+		}
 	}
 	else
 	{
@@ -508,7 +589,40 @@ GenerateSol_generateOrbital (SOLARSYS_ST
 
 		solarSys->SysInfo.PlanetInfo.SurfaceGravity =
 				CalcGravity (&solarSys->SysInfo.PlanetInfo);
-		LoadPlanet (NULL);
+		
+		if (solTexturesPresent){
+			switch (planetNr) {
+				case 2: /* moons of EARTH */
+					if (moonNr == 1)
+						LoadPlanet (CaptureDrawable (LoadGraphic (LUNA_MASK_ANIM)));
+					else
+						LoadPlanet (NULL);
+					break;
+				case 4: /* moons of JUPITER */
+					switch (moonNr) {
+						case 0: /* Io */
+							LoadPlanet (CaptureDrawable (LoadGraphic (IO_MASK_ANIM)));
+							break;
+						case 1: /* Europa */
+							LoadPlanet (CaptureDrawable (LoadGraphic (EUROPA_MASK_ANIM)));
+							break;
+						case 2: /* Ganymede */
+							LoadPlanet (CaptureDrawable (LoadGraphic (GANYMEDE_MASK_ANIM)));
+							break;
+						case 3: /* Callisto */
+							LoadPlanet (CaptureDrawable (LoadGraphic (CALLISTO_MASK_ANIM)));
+							break;
+					}
+					break;
+				case 5: /* moon of Saturn: Titan */
+					LoadPlanet (CaptureDrawable (LoadGraphic (TITAN_MASK_ANIM)));
+					break;
+				case 7: /* moon of NEPTUNE: Triton */
+				default:
+					LoadPlanet (CaptureDrawable (LoadGraphic (TRITON_MASK_ANIM)));
+					break;
+			}
+		}
 	}
 
 	return true;
@@ -530,8 +644,8 @@ GenerateSol_generateEnergy (const SOLARS
 
 		if (info)
 		{
-			info->loc_pt.x = 20;
-			info->loc_pt.y = MAP_HEIGHT - 8;
+			info->loc_pt.x = 20 << RESOLUTION_FACTOR;
+			info->loc_pt.y = MAP_HEIGHT - (8 << RESOLUTION_FACTOR);
 		}
 
 		return 1; // only matters when count is requested
@@ -623,8 +737,7 @@ init_probe (void)
 
 	if (!GET_GAME_STATE (PROBE_MESSAGE_DELIVERED)
 			&& GetGroupInfo (GLOBAL (BattleGroupRef), GROUP_INIT_IP)
-			&& (hGroup = GetHeadLink (&GLOBAL (ip_group_q))))
-	{
+			&& (hGroup = GetHeadLink (&GLOBAL (ip_group_q)))) {
 		IP_GROUP *GroupPtr;
 
 		GroupPtr = LockIpGroup (&GLOBAL (ip_group_q), hGroup);
@@ -637,9 +750,9 @@ init_probe (void)
 		UnlockIpGroup (&GLOBAL (ip_group_q), hGroup);
 
 		return 1;
-	}
-	else
+	} else {
 		return 0;
+	}
 }
 
 static void
diff -ruNp src.orig/uqm/planets/generate/genspa.c src/uqm/planets/generate/genspa.c
--- src.orig/uqm/planets/generate/genspa.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/genspa.c	2017-12-30 00:14:53 -0800
@@ -78,10 +78,11 @@ GenerateSpathi_generatePlanets (SOLARSYS
 	pMinPlanet->location.x = COSINE (angle, pMinPlanet->radius);
 	pMinPlanet->location.y = SINE (angle, pMinPlanet->radius);
 	pMinPlanet->data_index = WATER_WORLD;
+	pMinPlanet->alternate_colormap = NULL;
 	if (GET_GAME_STATE (SPATHI_SHIELDED_SELVES))
 		pMinPlanet->data_index |= PLANET_SHIELDED;
 	pMinPlanet->NumPlanets = 1;
-
+	ComputeSpeed(pMinPlanet, FALSE, 1);
 	return true;
 }
 
@@ -101,12 +102,14 @@ GenerateSpathi_generateMoons (SOLARSYS_S
 #endif /* NOTYET */
 
 		solarSys->MoonDesc[0].data_index = PELLUCID_WORLD;
+		solarSys->MoonDesc[0].alternate_colormap = NULL;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS + MOON_DELTA;
 		angle = NORMALIZE_ANGLE (LOWORD (RandomContext_Random (SysGenRNG)));
 		solarSys->MoonDesc[0].location.x =
 				COSINE (angle, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (angle, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/gensup.c src/uqm/planets/generate/gensup.c
--- src.orig/uqm/planets/generate/gensup.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/gensup.c	2017-12-30 00:14:53 -0800
@@ -62,6 +62,7 @@ GenerateSupox_generatePlanets (SOLARSYS_
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 2;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 152L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -70,6 +71,7 @@ GenerateSupox_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/gensyr.c src/uqm/planets/generate/gensyr.c
--- src.orig/uqm/planets/generate/gensyr.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/gensyr.c	2017-12-30 00:14:53 -0800
@@ -50,6 +50,7 @@ GenerateSyreen_generatePlanets (SOLARSYS
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = WATER_WORLD | PLANET_SHIELDED;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 
 	return true;
@@ -63,11 +64,13 @@ GenerateSyreen_generateMoons (SOLARSYS_S
 	if (matchWorld (solarSys, planet, 0, MATCH_PLANET))
 	{
 		solarSys->MoonDesc[0].data_index = HIERARCHY_STARBASE;
+		solarSys->MoonDesc[0].alternate_colormap = NULL;
 		solarSys->MoonDesc[0].radius = MIN_MOON_RADIUS;
 		solarSys->MoonDesc[0].location.x =
 				COSINE (QUADRANT, solarSys->MoonDesc[0].radius);
 		solarSys->MoonDesc[0].location.y =
 				SINE (QUADRANT, solarSys->MoonDesc[0].radius);
+		ComputeSpeed(&solarSys->MoonDesc[0], TRUE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/genthrad.c src/uqm/planets/generate/genthrad.c
--- src.orig/uqm/planets/generate/genthrad.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/genthrad.c	2017-12-30 00:14:53 -0800
@@ -29,6 +29,7 @@
 #include "../../setup.h"
 #include "../../state.h"
 #include "libs/mathlib.h"
+#include "../../../options.h"
 
 
 static bool GenerateThraddash_generatePlanets (SOLARSYS_STATE *solarSys);
@@ -67,6 +68,7 @@ GenerateThraddash_generatePlanets (SOLAR
 	if (CurStarDescPtr->Index == AQUA_HELIX_DEFINED)
 	{
 		solarSys->PlanetDesc[0].data_index = PRIMORDIAL_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 65L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
 				solarSys->PlanetDesc[0].location.y);
@@ -74,10 +76,12 @@ GenerateThraddash_generatePlanets (SOLAR
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	else  /* CurStarDescPtr->Index == THRADD_DEFINED */
 	{
 		solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].NumPlanets = 0;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 98L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -86,6 +90,7 @@ GenerateThraddash_generatePlanets (SOLAR
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	return true;
 }
@@ -188,6 +193,10 @@ static bool
 GenerateThraddash_pickupEnergy (SOLARSYS_STATE *solarSys, PLANET_DESC *world,
 		COUNT whichNode)
 {
+	HFLEETINFO hThradd = GetStarShipFromIndex (&GLOBAL (avail_race_q), THRADDASH_SHIP);
+	FLEET_INFO *ThraddPtr = LockFleetInfo (&GLOBAL (avail_race_q), hThradd);
+	SIZE strength_loss;
+
 	if (CurStarDescPtr->Index == THRADD_DEFINED
 			&& matchWorld (solarSys, world, 0, MATCH_PLANET))
 	{
@@ -208,6 +217,14 @@ GenerateThraddash_pickupEnergy (SOLARSYS
 		SET_GAME_STATE (AQUA_HELIX, 1);
 		SET_GAME_STATE (AQUA_HELIX_ON_SHIP, 1);
 		SET_GAME_STATE (HELIX_UNPROTECTED, 1);
+		if (GET_GAME_STATE (ILWRATH_FIGHT_THRADDASH) && optThraddStory){
+			SetRaceAllied (THRADDASH_SHIP, FALSE);
+			RemoveEscortShips (THRADDASH_SHIP);
+			strength_loss = (SIZE)(ThraddPtr->actual_strength);
+			ThraddPtr->growth = (BYTE)(-strength_loss / ThraddPtr->days_left);
+			ThraddPtr->growth_fract = (BYTE)(((strength_loss % ThraddPtr->days_left) << 8) / ThraddPtr->days_left);
+			SET_GAME_STATE (THRADD_VISITS, 0);
+		}
 
 		return true; // picked up
 	}
diff -ruNp src.orig/uqm/planets/generate/gentrap.c src/uqm/planets/generate/gentrap.c
--- src.orig/uqm/planets/generate/gentrap.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/gentrap.c	2017-12-30 00:14:53 -0800
@@ -50,6 +50,7 @@ GenerateTrap_generatePlanets (SOLARSYS_S
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = TELLURIC_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 203L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -58,6 +59,7 @@ GenerateTrap_generatePlanets (SOLARSYS_S
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genutw.c src/uqm/planets/generate/genutw.c
--- src.orig/uqm/planets/generate/genutw.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/genutw.c	2017-12-30 00:14:53 -0800
@@ -85,6 +85,7 @@ GenerateUtwig_generatePlanets (SOLARSYS_
 	if (CurStarDescPtr->Index == UTWIG_DEFINED)
 	{
 		solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].NumPlanets = 1;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 174L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -93,6 +94,7 @@ GenerateUtwig_generatePlanets (SOLARSYS_
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 
 	return true;
diff -ruNp src.orig/uqm/planets/generate/genvux.c src/uqm/planets/generate/genvux.c
--- src.orig/uqm/planets/generate/genvux.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/genvux.c	2017-12-30 00:14:53 -0800
@@ -77,6 +77,7 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 				// called. Is it safe to remove one, or does this change
 				// the RNG so that the outcome is different?
 		solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
+		solarSys->PlanetDesc[0].alternate_colormap = NULL;
 		solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 212L / 100;
 		angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
 				solarSys->PlanetDesc[0].location.y);
@@ -84,15 +85,18 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 				COSINE (angle, solarSys->PlanetDesc[0].radius);
 		solarSys->PlanetDesc[0].location.y =
 				SINE (angle, solarSys->PlanetDesc[0].radius);
+		ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 	}
 	else
 	{
 		if (CurStarDescPtr->Index == VUX_DEFINED)
 		{
 			solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
+			solarSys->PlanetDesc[0].alternate_colormap = NULL;
 			solarSys->PlanetDesc[0].NumPlanets = 1;
 			solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 42L / 100;
 			angle = HALF_CIRCLE + OCTANT;
+			ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 		}
 		else /* if (CurStarDescPtr->Index == VUX_BEAST_DEFINED) */
 		{
@@ -103,8 +107,10 @@ GenerateVux_generatePlanets (SOLARSYS_ST
 
 			angle = HALF_CIRCLE - OCTANT;
 			solarSys->PlanetDesc[0].data_index = WATER_WORLD;
+			solarSys->PlanetDesc[0].alternate_colormap = NULL;
 			solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 110L / 100;
 			solarSys->PlanetDesc[0].NumPlanets = 0;
+			ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 		}
 
 		solarSys->PlanetDesc[0].location.x =
diff -ruNp src.orig/uqm/planets/generate/genyeh.c src/uqm/planets/generate/genyeh.c
--- src.orig/uqm/planets/generate/genyeh.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/genyeh.c	2017-12-30 00:14:53 -0800
@@ -68,6 +68,7 @@ GenerateYehat_generatePlanets (SOLARSYS_
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/generate/genzoq.c src/uqm/planets/generate/genzoq.c
--- src.orig/uqm/planets/generate/genzoq.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/generate/genzoq.c	2017-12-30 00:14:53 -0800
@@ -70,6 +70,7 @@ GenerateZoqFotPik_generatePlanets (SOLAR
 	GenerateDefault_generatePlanets (solarSys);
 
 	solarSys->PlanetDesc[0].data_index = REDUX_WORLD;
+	solarSys->PlanetDesc[0].alternate_colormap = NULL;
 	solarSys->PlanetDesc[0].NumPlanets = 1;
 	solarSys->PlanetDesc[0].radius = EARTH_RADIUS * 138L / 100;
 	angle = ARCTAN (solarSys->PlanetDesc[0].location.x,
@@ -78,6 +79,7 @@ GenerateZoqFotPik_generatePlanets (SOLAR
 			COSINE (angle, solarSys->PlanetDesc[0].radius);
 	solarSys->PlanetDesc[0].location.y =
 			SINE (angle, solarSys->PlanetDesc[0].radius);
+	ComputeSpeed(&solarSys->PlanetDesc[0], FALSE, 1);
 
 	return true;
 }
diff -ruNp src.orig/uqm/planets/gentopo.c src/uqm/planets/gentopo.c
--- src.orig/uqm/planets/gentopo.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/gentopo.c	2017-12-30 00:14:53 -0800
@@ -50,8 +50,14 @@ DeltaTopography (COUNT num_iterations, S
 		w1 = LOWORD (rand_val);
 		w2 = HIWORD (rand_val);
 
-		LineDDA0.x_top = LOBYTE (w1) % width;
-		LineDDA0.x_bot = HIBYTE (w1) % width;
+		LineDDA0.x_top = (LOBYTE (w1) % ORIGINAL_MAP_WIDTH) * width / ORIGINAL_MAP_WIDTH;
+		LineDDA0.x_bot = (HIBYTE (w1) % ORIGINAL_MAP_WIDTH) * width / ORIGINAL_MAP_WIDTH;
+		//LineDDA0.x_top = w1 % width; // JMS_GFX: Replaced previous lines with these: BYTE is too small for 640x480 sized maps.
+		//LineDDA0.x_bot = w2 % width; // Using w1 and w2 to get difference between top and bottom.
+		// BW: reinstate previous method and adapt it for higher res.
+		// Overusing w1 and w2 was hampering randomness.
+		// Now planets will look the same no matter what the res is.
+
 		LineDDA0.delta_x = (LineDDA0.x_bot - LineDDA0.x_top) << 1;
 		if (LineDDA0.delta_x >= 0)
 			LineDDA0.x_incr = 1;
@@ -65,8 +71,8 @@ DeltaTopography (COUNT num_iterations, S
 		else
 			LineDDA0.error_term = -(delta_y >> 1);
 
-		LineDDA1.x_top = (LOBYTE (w2) % (width - 1)) + LineDDA0.x_top + 1;
-		LineDDA1.x_bot = (HIBYTE (w2) % (width - 1)) + LineDDA0.x_bot + 1;
+		LineDDA1.x_top = (LOBYTE (w2) % (ORIGINAL_MAP_WIDTH - 1)) * width / ORIGINAL_MAP_WIDTH + LineDDA0.x_top + 1;
+		LineDDA1.x_bot = (HIBYTE (w2) % (ORIGINAL_MAP_WIDTH - 1)) * width / ORIGINAL_MAP_WIDTH + LineDDA0.x_bot + 1;
 		LineDDA1.delta_x = (LineDDA1.x_bot - LineDDA1.x_top) << 1;
 		if (LineDDA1.delta_x >= 0)
 			LineDDA1.x_incr = 1;
diff -ruNp src.orig/uqm/planets/lander.c src/uqm/planets/lander.c
--- src.orig/uqm/planets/lander.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/lander.c	2017-12-30 00:14:53 -0800
@@ -34,7 +34,8 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
-
+#include "options.h"
+#include "uqm/menustat.h"
 
 //define SPIN_ON_LAUNCH to let the planet spin while
 // the lander animation is playing
@@ -63,8 +64,6 @@ struct LanderInputState {
 FRAME LanderFrame[8];
 static SOUND LanderSounds;
 MUSIC_REF LanderMusic;
-#define NUM_ORBIT_THEMES 5
-static MUSIC_REF OrbitMusic[NUM_ORBIT_THEMES];
 
 const LIFEFORM_DESC CreatureData[] =
 {
@@ -114,10 +113,9 @@ const LIFEFORM_DESC CreatureData[] =
 			// Bug-Eyed Bait
 	{SPEED_MOTIONLESS | DANGER_WEAK, MAKE_BYTE (8, 5)},
 			// Goo Burger
-
 	{SPEED_MOTIONLESS | DANGER_MONSTROUS, MAKE_BYTE (1, 1)},
 			// Evil One
-	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (0, 1)},
+	{BEHAVIOR_UNPREDICTABLE | SPEED_SLOW | DANGER_HARMLESS, MAKE_BYTE (1, 1)}, // ? was 0, 1
 			// Brainbox Bulldozers
 	{BEHAVIOR_HUNT | AWARENESS_HIGH | SPEED_FAST | DANGER_MONSTROUS, MAKE_BYTE (15, 15)},
 			// Zex's Beauty
@@ -149,7 +147,7 @@ extern PRIM_LINKS DisplayLinks;
 #define ADD_AT_END (1 << 4)
 #define REPAIR_COUNT (0xf)
 
-#define LANDER_SPEED_DENOM 10
+#define LANDER_SPEED_DENOM (10) // JMS_GFX
 
 static BYTE lander_flags;
 static POINT curLanderLoc;
@@ -263,15 +261,16 @@ object_animation (ELEMENT *ElementPtr)
 			else if (ElementPtr->mass_points == EARTHQUAKE_DISASTER)
 			{
 				SIZE s;
+				SIZE frame_amount = 14; // JMS_GFX
 
-				if (frame_index >= 13)
+				if (frame_index >= (frame_amount-1))
 					s = 0;
 				else
-					s = (14 - frame_index) >> 1;
+					s = (frame_amount - frame_index) >> 1;
 				// XXX: Was 0x8000 the background flag on 3DO?
 				//SetPrimColor (pPrim, BUILD_COLOR (0x8000 | MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
 				SetPrimColor (pPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
-				if (frame_index == 13)
+				if (frame_index == (frame_amount - 1))
 					PlaySound (SetAbsSoundIndex (LanderSounds, EARTHQUAKE_DISASTER),
 							NotPositional (), NULL, GAME_SOUND_PRIORITY);
 			}
@@ -291,8 +290,8 @@ object_animation (ELEMENT *ElementPtr)
 					angle = FACING_TO_ANGLE (ElementPtr->facing);
 					LockElement (hLavaElement, &LavaElementPtr);
 					LavaElementPtr->next.location = ElementPtr->next.location;
-					LavaElementPtr->next.location.x += COSINE (angle, 4);
-					LavaElementPtr->next.location.y += SINE (angle, 4);
+					LavaElementPtr->next.location.x += COSINE (angle, 4 << RESOLUTION_FACTOR); // JMS_GFX
+					LavaElementPtr->next.location.y += SINE (angle, 4 << RESOLUTION_FACTOR); // JMS_GFX
 					if (LavaElementPtr->next.location.y < 0)
 						LavaElementPtr->next.location.y = 0;
 					else if (LavaElementPtr->next.location.y >= (MAP_HEIGHT << MAG_SHIFT))
@@ -412,6 +411,7 @@ object_animation (ELEMENT *ElementPtr)
 						speed = WORLD_TO_VELOCITY (2 * 1) * 9 / 10;
 						break;
 				}
+				speed = speed << RESOLUTION_FACTOR; // JMS_GFX
 
 				SetVelocityComponents (&ElementPtr->velocity,
 						COSINE (angle, speed), SINE (angle, speed));
@@ -451,8 +451,12 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 		shieldHit &= 1 << which_disaster;
 		if (!shieldHit || TFB_Random () % 100 >= 95)
 		{	// No shield, or it did not help
-			shieldHit = 0;
-			--crew_left;
+			if (!optGodMode) {
+				shieldHit = 0; 
+				--crew_left; 
+			}
+			else 
+				shieldHit = 1; 
 		}
 
 		damage_index = DAMAGE_CYCLE;
@@ -466,8 +470,16 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 				NotPositional (), NULL, GAME_SOUND_PRIORITY);
 	}
 
-	s.origin.x = 11 + (6 * (crew_delta % NUM_CREW_COLS));
-	s.origin.y = 35 - (6 * (crew_delta / NUM_CREW_COLS));
+	if (RESOLUTION_FACTOR == 0) {
+		s.origin.x = ((11 + ((6 << RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)))); // JMS_GFX
+		s.origin.y = (35 - (6 * (crew_delta / NUM_CREW_COLS))) << RESOLUTION_FACTOR; // JMS_GFX
+	} else if (RESOLUTION_FACTOR == 1) {
+		s.origin.x = ((23 + ((6 << RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)))); // JMS_GFX
+		s.origin.y = 1 + ((35 - (6 * (crew_delta / NUM_CREW_COLS))) << RESOLUTION_FACTOR); // JMS_GFX
+	} else {
+		s.origin.x = 32 + ((9 * RESOLUTION_FACTOR) * (crew_delta % NUM_CREW_COLS)); // JMS_GFX
+		s.origin.y = (52 * RESOLUTION_FACTOR - (9 * RESOLUTION_FACTOR * (crew_delta / NUM_CREW_COLS))); // JMS_GFX
+	}
 
 	OldContext = SetContext (RadarContext);
 	DrawStamp (&s);
@@ -477,9 +489,11 @@ DeltaLanderCrew (SIZE crew_delta, COUNT
 static void
 FillLanderHold (PLANETSIDE_DESC *pPSD, COUNT scan, COUNT NumRetrieved)
 {
-	COUNT start_count;
+	COUNT start_count, tmpholdint;
 	STAMP s;
 	CONTEXT OldContext;
+	SIZE  rounding_error_startcount = 0; // JMS_GFX
+	SIZE  rounding_error_numretrieved = 0; // JMS_GFX
 
 	PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_PICKUP),
 			NotPositional (), NULL, GAME_SOUND_PRIORITY);
@@ -491,26 +505,53 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 		s.frame = SetAbsFrameIndex (LanderFrame[0], 41);
 
 		pPSD->BiologicalLevel += NumRetrieved;
-	}
-	else
-	{
+	} else {
 		start_count = pPSD->ElementLevel;
 		pPSD->ElementLevel += NumRetrieved;
+
+		rounding_error_startcount = (start_count % 2);
+		rounding_error_numretrieved = (pPSD->ElementLevel % 2);
+
 		if (GET_GAME_STATE (IMPROVED_LANDER_CARGO))
-		{
-			start_count >>= 1;
-			NumRetrieved = (pPSD->ElementLevel >> 1) - start_count;
-		}
+			NumRetrieved = (pPSD->ElementLevel >> 1) - (start_count >> 1);
 
 		s.frame = SetAbsFrameIndex (LanderFrame[0], 43);
 	}
 
+	tmpholdint = ((start_count + NumRetrieved) * MAX_HOLD_BARS / MAX_SCROUNGED)
+			- ((start_count * MAX_HOLD_BARS / MAX_SCROUNGED) + (NumRetrieved *
+			MAX_HOLD_BARS / MAX_SCROUNGED));
+	start_count = start_count * MAX_HOLD_BARS / MAX_SCROUNGED;
+	NumRetrieved = (NumRetrieved * MAX_HOLD_BARS / MAX_SCROUNGED) + tmpholdint;
+
+	start_count *= RES_STAT_SCALE(1); // JMS_GFX
+	
+	if (scan == MINERAL_SCAN && GET_GAME_STATE (IMPROVED_LANDER_CARGO))
+	{
+		start_count >>= 1;
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 1)
+			start_count += rounding_error_startcount;
+	}
+
 	s.origin.x = 0;
 	s.origin.y = -(int)start_count;
 	if (!(start_count & 1))
 		s.frame = IncFrameIndex (s.frame);
 
-	OldContext = SetContext (RadarContext);
+	OldContext = SetContext (RadarContext);	
+	
+	// JMS_GFX
+	if (scan == MINERAL_SCAN && GET_GAME_STATE (IMPROVED_LANDER_CARGO) && RESOLUTION_FACTOR > 0)
+	{
+		NumRetrieved *= RES_STAT_SCALE(1);
+		NumRetrieved >>= 1;
+		
+		if (RESOLUTION_FACTOR == 1)
+			NumRetrieved += rounding_error_numretrieved;
+	}
+
 	while (NumRetrieved--)
 	{
 		if (start_count++ & 1)
@@ -518,43 +559,99 @@ FillLanderHold (PLANETSIDE_DESC *pPSD, C
 		else
 			s.frame = DecFrameIndex (s.frame);
 		DrawStamp (&s);
-		--s.origin.y;
+		s.origin.y -= RES_STAT_SCALE(1); // JMS_GFX
 	}
 	SetContext (OldContext);
 }
 
 // returns true iff the node was picked up.
 static bool
-pickupMineralNode (PLANETSIDE_DESC *pPSD, COUNT NumRetrieved,
+pickupNode (PLANETSIDE_DESC *pPSD, COUNT NumRetrieved,
 		ELEMENT *ElementPtr, const INTERSECT_CONTROL *LanderControl,
-		const INTERSECT_CONTROL *ElementControl)
+		const INTERSECT_CONTROL *ElementControl, COUNT Scan)
 {
 	BYTE EType;
-	UNICODE ch;
-	UNICODE *pStr;
+	UNICODE ch, *pStr;
+	COUNT *Amount, Max, Offset;
+	BOOLEAN PartialPickup;
+
+	Amount = &pPSD->BiologicalLevel;
+	Max = MAX_SCROUNGED;
+	EType = ElementPtr->thrust_wait;
+	Offset = BIOLOGICAL_STRING_BASE;
+
+	if (Scan != BIOLOGICAL_SCAN){
+		Amount = &pPSD->ElementLevel;
+		Max = pPSD->MaxElementLevel;
+		EType = ElementPtr->turn_wait;
+		Offset = ELEMENTS_STRING_BASE;
+	}
 
-	if (pPSD->ElementLevel >= pPSD->MaxElementLevel)
-	{
+	// JMS: The rest of partially scavenged minerals stay on the surface.
+	PartialPickup = FALSE;
+
+	if (*Amount >= Max) {
 		// Lander full
 		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_FULL),
 				NotPositional (), NULL, GAME_SOUND_PRIORITY);
 		return false;
 	}
 
-	if (pPSD->ElementLevel + NumRetrieved > pPSD->MaxElementLevel)
-	{
+	if (*Amount + NumRetrieved > Max) {
+		SIZE which_node;
+		COUNT oldsize = ElementPtr->mass_points;
+
 		// Deposit could only be picked up partially.
-		NumRetrieved = (COUNT)(pPSD->MaxElementLevel - pPSD->ElementLevel);
+		NumRetrieved = (COUNT)(Max - *Amount);
+
+		if (Scan != BIOLOGICAL_SCAN && optPartialPickup){
+			// JMS: Subtract the scavenged kilotons from the mineral deposit.
+			// The rest will stay on the surface.
+			ElementPtr->mass_points -= NumRetrieved;
+		
+			// JMS: This makes the mineral deposit subtraction keep  
+			// in effect even after leaving & re-entering the planet.
+			which_node = HIBYTE (ElementPtr->scan_node) - 1;
+			pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[MINERAL_SCAN][which_node] = NumRetrieved;
+		
+			// JMS: If the deposit was large and its amount now equates to a smaller
+			// deposit, change its graphics.
+			if ((oldsize > 22 && ElementPtr->mass_points <= 22)
+				|| (oldsize > 15 && ElementPtr->mass_points <= 15))
+			{
+				PRIMITIVE *pPrim = &DisplayArray[ElementPtr->PrimIndex];
+				BYTE gfx_index_change = 0;
+			
+				if (oldsize > 22 && ElementPtr->mass_points <= 15)
+					gfx_index_change = 2;
+				else
+					gfx_index_change = 1;
+			
+				// Change the scan screen gfx.
+				ElementPtr->current.image.frame = SetRelFrameIndex (
+					ElementPtr->current.image.frame, (2 - gfx_index_change));
+				ElementPtr->next.image.frame = ElementPtr->current.image.frame;
+
+				// Notify the engine that the scan screen gfx should be updated.
+				ElementPtr->state_flags |= CHANGING;
+				SET_GAME_STATE (PLANETARY_CHANGE, 1);
+			
+				// Change the surface screen gfx.
+				pPrim->Object.Stamp.frame = SetRelFrameIndex (pPrim->Object.Stamp.frame, -gfx_index_change);
+			}
+		
+			PartialPickup = TRUE;
+		}
 	}
 
-	FillLanderHold (pPSD, MINERAL_SCAN, NumRetrieved);
+	FillLanderHold (pPSD, Scan, NumRetrieved);
 
-	EType = ElementPtr->turn_wait;
-	pPSD->ElementAmounts[ElementCategory (EType)] += NumRetrieved;
+	if (Scan != BIOLOGICAL_SCAN)
+		pPSD->ElementAmounts[ElementCategory (EType)] += NumRetrieved;
 
 	pPSD->NumFrames = NUM_TEXT_FRAMES;
 	sprintf (pPSD->AmountBuf, "%u", NumRetrieved);
-	pStr = GAME_STRING (EType + ELEMENTS_STRING_BASE);
+	pStr = GAME_STRING (EType + Offset);
 
 	pPSD->MineralText[0].baseline.x = (SURFACE_WIDTH >> 1)
 			+ (ElementControl->EndPoint.x - LanderControl->EndPoint.x);
@@ -565,13 +662,10 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 
 	while ((ch = *pStr++) && ch != ' ')
 		;
-	if (ch == '\0')
-	{
+	if (ch == '\0') {
 		pPSD->MineralText[1].CharCount = (COUNT)~0;
 		pPSD->MineralText[2].CharCount = 0;
-	}
-	else  /* ch == ' ' */
-	{
+	} else {  /* ch == ' ' */
 		// Name contains a space. Print over
 		// two lines.
 		pPSD->MineralText[1].CharCount = utf8StringCountN(
@@ -580,29 +674,54 @@ pickupMineralNode (PLANETSIDE_DESC *pPSD
 		pPSD->MineralText[2].CharCount = (COUNT)~0;
 	}
 
-	return true;
+	// JMS
+	return (PartialPickup ? false : true);
 }
 
-static bool
-pickupBioNode (PLANETSIDE_DESC *pPSD, COUNT NumRetrieved)
+static void
+ExplodeCritter (ELEMENT *ElementPtr)
 {
-	if (pPSD->BiologicalLevel >= MAX_SCROUNGED)
-	{
-		// Lander is full.
-		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_FULL),
-				NotPositional (), NULL, GAME_SOUND_PRIORITY);
-		return false;
-	}
-
-	if (pPSD->BiologicalLevel + NumRetrieved > MAX_SCROUNGED)
+	HELEMENT hExplosionElement;
+	SIZE temp_which_node;
+				
+	hExplosionElement = AllocElement ();
+	if (hExplosionElement)
 	{
-		// Node could only be picked up partially.
-		NumRetrieved = (COUNT)(MAX_SCROUNGED - pPSD->BiologicalLevel);
+		ELEMENT *ExplosionElementPtr;
+		LockElement (hExplosionElement, &ExplosionElementPtr);
+					
+		ExplosionElementPtr->mass_points = DEATH_EXPLOSION;
+		ExplosionElementPtr->state_flags = FINITE_LIFE;
+		ExplosionElementPtr->playerNr = PS_NON_PLAYER;
+		ExplosionElementPtr->next.location = ElementPtr->next.location;
+		ExplosionElementPtr->preprocess_func = object_animation;
+		ExplosionElementPtr->turn_wait = MAKE_BYTE (2, 2);
+		ExplosionElementPtr->life_span = EXPLOSION_LIFE * (LONIBBLE (ExplosionElementPtr->turn_wait));
+					
+		SetPrimType (&DisplayArray[ExplosionElementPtr->PrimIndex], STAMP_PRIM);
+		DisplayArray[ExplosionElementPtr->PrimIndex].Object.Stamp.frame = SetAbsFrameIndex (LanderFrame[0], 46);
+
+		// JMS: This keeps track of the explosion frames. Normally explosion occurs only once (lander explodes).
+		// If we don't zero this variable here, the explosion anim can run only once properly and would
+		// get stuck in the last frame after that on all the subsequent explosions.
+		explosion_index = 0;
+					
+		UnlockElement (hExplosionElement);
+		InsertElement (hExplosionElement, GetHeadElement ());
+					
+		PlaySound (SetAbsSoundIndex (LanderSounds, LANDER_DESTROYED), NotPositional (), NULL, GAME_SOUND_PRIORITY + 1);
+					
+		ElementPtr->state_flags |= DISAPPEARING; // JMS: Delete the critter frame
+		ElementPtr->mass_points = 0;			 // JMS: Make sure critter/explosion doesn't give biodata.
+					
+		// JMS: This marks the exploded critter "collected". (even though there was no biodata to collect).
+		// This ensures the critter isn't resurrected when visiting the planet next time.
+		temp_which_node = HIBYTE (ElementPtr->scan_node) - 1;
+		pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] |= (1L << temp_which_node); // Mark this bio blip's state as "collected".
+		//pSolarSysState->CurNode = (COUNT)~0; // GenerateLifeForms will update the states of ALL bio-blips when run.
+		//callGenerateForScanType (pSolarSysState, pSolarSysState->pOrbitalDesc, &pSolarSysState->CurNode, BIOLOGICAL_SCAN); // Re-run GenerateLifeForms so the changed state takes effect
+		SET_GAME_STATE (PLANETARY_CHANGE, 1); // Save the changes to the file containing the states of all lifeforms.
 	}
-
-	FillLanderHold (pPSD, BIOLOGICAL_SCAN, NumRetrieved);
-
-	return true;
 }
 
 static void
@@ -618,10 +737,22 @@ shotCreature (ELEMENT *ElementPtr, BYTE
 	--ElementPtr->hit_points;
 	if (ElementPtr->hit_points == 0)
 	{
-		// Can creature.
-		ElementPtr->mass_points = value;
-		DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
-				pSolarSysState->PlanetSideFrame[0];
+		// Brainbox bulldozers (Tractors at moon) explode.
+		if ((ElementPtr->mass_points & ~CREATURE_AWARE) == 24)
+		{
+			ExplodeCritter (ElementPtr);
+		}
+		// Can other creatures.
+		else
+		{
+			// stash the type of creature in the
+			// thrust_wait field.  It seems to be unused
+			// by the game for anything at this point
+			ElementPtr->thrust_wait = ElementPtr->mass_points & ~CREATURE_AWARE;
+			ElementPtr->mass_points = value;
+			DisplayArray[ElementPtr->PrimIndex].Object.Stamp.frame =
+			pSolarSysState->PlanetSideFrame[0];
+		}
 	}
 	else if (CreatureData[ElementPtr->mass_points & ~CREATURE_AWARE]
 			.Attributes & SPEED_MASK)
@@ -632,8 +763,8 @@ shotCreature (ELEMENT *ElementPtr, BYTE
 				LanderControl->IntersectStamp.frame) -
 				ANGLE_TO_FACING (FULL_CIRCLE));
 		DeltaVelocityComponents (&ElementPtr->velocity,
-				COSINE (angle, WORLD_TO_VELOCITY (1)),
-				SINE (angle, WORLD_TO_VELOCITY (1)));
+				COSINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR)),
+				SINE (angle, WORLD_TO_VELOCITY (1 << RESOLUTION_FACTOR))); // JMS_GFX
 		ElementPtr->thrust_wait = 0;
 		ElementPtr->mass_points |= CREATURE_AWARE;
 	}
@@ -732,7 +863,11 @@ CheckObjectCollision (COUNT index)
 						{
 							case EARTHQUAKE_DISASTER:
 							case LAVASPOT_DISASTER:
-								if (TFB_Random () % 100 < 25)
+								if (scan == LAVASPOT_DISASTER 
+									&& RESOLUTION_FACTOR == 2 
+									&& TFB_Random () % 100 < 9)
+									DeltaLanderCrew (-1, scan);
+								else if (TFB_Random () % 100 < 25)
 									DeltaLanderCrew (-1, scan);
 								break;
 						}
@@ -810,13 +945,8 @@ CheckObjectCollision (COUNT index)
 						case ENERGY_SCAN:
 							break;
 						case MINERAL_SCAN:
-							if (!pickupMineralNode (pPSD, NumRetrieved,
-									ElementPtr, &LanderControl,
-									&ElementControl))
-								continue;
-							break;
 						case BIOLOGICAL_SCAN:
-							if (!pickupBioNode (pPSD, NumRetrieved))
+							if (!pickupNode (pPSD, NumRetrieved, ElementPtr, &LanderControl, &ElementControl, scan))
 								continue;
 							break;
 					}
@@ -860,16 +990,23 @@ lightning_process (ELEMENT *ElementPtr)
 		else
 		{
 			SIZE s;
-			
-			// XXX: Color cycling is largely unused, because the color
-			//   never actually changes RGB values (see MAKE_RGB15 below).
-			//   This did, however, work in DOS SC2 version (fade effect).
-			s = 7 - ((SIZE)ElementPtr->cycle - (SIZE)ElementPtr->life_span);
-			if (s < 0)
-				s = 0;
-			// XXX: Was 0x8000 the background flag on 3DO?
-			//SetPrimColor (pPrim, BUILD_COLOR (0x8000 | MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
-			SetPrimColor (pPrim, BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x1F), s));
+#define NUM_CYCLES 8
+			static const Color color_tab[] =
+			{
+				BUILD_COLOR (MAKE_RGB15_INIT (0x11, 0x11, 0x11), 0x18),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x13, 0x13, 0x13), 0x17),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x15, 0x15, 0x15), 0x15),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x17, 0x17, 0x17), 0x14),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x19, 0x19, 0x19), 0x13),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x1B, 0x1B, 0x1B), 0x12),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x1D, 0x1D, 0x1D), 0x10),
+				BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x1F, 0x1F), 0x0f),
+			};
+
+			s = ElementPtr->life_span;
+			if (s > NUM_CYCLES - 1)
+				s = NUM_CYCLES - 1;
+			SetPrimColor (pPrim, color_tab[s]);
 
 			if (ElementPtr->mass_points == LIGHTNING_DISASTER)
 			{
@@ -916,14 +1053,26 @@ AddLightning (void)
 
 		rand_val = TFB_Random ();
 		LightningElementPtr->life_span = 10 + (HIWORD (rand_val) % 10) + 1;
-		LightningElementPtr->next.location.x = (curLanderLoc.x
+
+		if (RESOLUTION_FACTOR == 0) {
+			LightningElementPtr->next.location.x = (curLanderLoc.x
 				+ ((MAP_WIDTH << MAG_SHIFT) - ((SURFACE_WIDTH >> 1) - 6))
 				+ (LOBYTE (rand_val) % (SURFACE_WIDTH - 12))
 				) % (MAP_WIDTH << MAG_SHIFT);
-		LightningElementPtr->next.location.y = (curLanderLoc.y
+			LightningElementPtr->next.location.y = (curLanderLoc.y
 				+ ((MAP_HEIGHT << MAG_SHIFT) - ((SURFACE_HEIGHT >> 1) - 6))
 				+ (HIBYTE (rand_val) % (SURFACE_HEIGHT - 12))
 				) % (MAP_HEIGHT << MAG_SHIFT);
+		} else {
+			LightningElementPtr->next.location.x = (curLanderLoc.x
+				+ ((MAP_WIDTH << MAG_SHIFT) - ((SURFACE_WIDTH >> 1) - 6))
+				+ (rand_val % (SURFACE_WIDTH - (12 << RESOLUTION_FACTOR)))
+				) % (MAP_WIDTH << MAG_SHIFT);
+			LightningElementPtr->next.location.y = (curLanderLoc.y
+				+ ((MAP_HEIGHT << MAG_SHIFT) - ((SURFACE_HEIGHT >> 1) - 6))
+				+ (rand_val % (SURFACE_HEIGHT - (12 << RESOLUTION_FACTOR)))
+				) % (MAP_HEIGHT << MAG_SHIFT);
+		}
 
 		LightningElementPtr->cycle = LightningElementPtr->life_span;
 		
@@ -974,7 +1123,7 @@ AddGroundDisaster (COUNT which_disaster)
 
 		if (which_disaster == EARTHQUAKE_DISASTER)
 		{
-			SetPrimType (pPrim, STAMPFILL_PRIM);
+			SetPrimType (pPrim, STAMP_PRIM); // JMS: was STAMPFILL_PRIM (this rendered it totally white).
 			pPrim->Object.Stamp.frame = LanderFrame[1];
 			GroundDisasterElementPtr->turn_wait = MAKE_BYTE (2, 2);
 		}
@@ -1230,15 +1379,11 @@ ScrollPlanetSide (SIZE dx, SIZE dy, int
 			pPSD->MineralText[0].baseline.x -= dx;
 			pPSD->MineralText[0].baseline.y -= dy;
 			font_DrawText (&pPSD->MineralText[0]);
-			pPSD->MineralText[1].baseline.x =
-					pPSD->MineralText[0].baseline.x;
-			pPSD->MineralText[1].baseline.y =
-					pPSD->MineralText[0].baseline.y + 7;
+			pPSD->MineralText[1].baseline.x = pPSD->MineralText[0].baseline.x;
+			pPSD->MineralText[1].baseline.y = pPSD->MineralText[0].baseline.y + (7 << RESOLUTION_FACTOR); // JMS_GFX
 			font_DrawText (&pPSD->MineralText[1]);
-			pPSD->MineralText[2].baseline.x =
-					pPSD->MineralText[1].baseline.x;
-			pPSD->MineralText[2].baseline.y =
-					pPSD->MineralText[1].baseline.y + 7;
+			pPSD->MineralText[2].baseline.x = pPSD->MineralText[1].baseline.x;
+			pPSD->MineralText[2].baseline.y = pPSD->MineralText[1].baseline.y + (7 << RESOLUTION_FACTOR); // JMS_GFX
 			font_DrawText (&pPSD->MineralText[2]);
 		}
 	}
@@ -1268,7 +1413,7 @@ animationInterframe (TimeCount *TimeIn,
 }
 
 static void
-AnimateLaunch (FRAME farray)
+AnimateLaunch (FRAME farray, BOOLEAN landing)
 {
 	RECT r;
 	STAMP s;
@@ -1290,7 +1435,7 @@ AnimateLaunch (FRAME farray)
 		NextTime = GetTimeCounter () + (ONE_SECOND / 22);
 
 		BatchGraphics ();
-		RepairBackRect (&r);
+		RepairBackRect (&r, TRUE);
 #ifdef SPIN_ON_LAUNCH
 		RotatePlanetSphere (FALSE);
 #else
@@ -1305,7 +1450,9 @@ AnimateLaunch (FRAME farray)
 		SleepThreadUntil (NextTime);
 	}
 
-	RepairBackRect (&r);
+	// This clears the last lander return / launch) anim frame from the planet window.
+	if (RESOLUTION_FACTOR == 0 || !landing)
+		RepairBackRect (&r, FALSE);
 }
 
 static void
@@ -1379,16 +1526,21 @@ static void
 InitPlanetSide (POINT pt)
 {
 	// Adjust landing location by a random jitter.
-#define RANDOM_MISS 64
+#define RANDOM_MISS (64 << RESOLUTION_FACTOR) // JMS_GFX
+	if(!optGodMode){
+		pt.x -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
+		pt.y -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
+	} else { 
+		pt.x -= 0;
+		pt.y -= 0;
+	}
 	// Jitter the X landing point.
-	pt.x -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
 	if (pt.x < 0)
 		pt.x += (MAP_WIDTH << MAG_SHIFT);
 	else if (pt.x >= (MAP_WIDTH << MAG_SHIFT))
 		pt.x -= (MAP_WIDTH << MAG_SHIFT);
 
 	// Jitter the Y landing point.
-	pt.y -= RANDOM_MISS - TFB_Random () % (RANDOM_MISS << 1);
 	if (pt.y < 0)
 		pt.y = 0;
 	else if (pt.y >= (MAP_HEIGHT << MAG_SHIFT))
@@ -1471,9 +1623,9 @@ LanderFire (SIZE facing)
 
 	angle = FACING_TO_ANGLE (facing);
 	SetVelocityComponents (
-			&WeaponElementPtr->velocity,
-			COSINE (angle, WORLD_TO_VELOCITY (2 * 3)) + wdx,
-			SINE (angle, WORLD_TO_VELOCITY (2 * 3)) + wdy);
+		&WeaponElementPtr->velocity,
+		COSINE (angle, WORLD_TO_VELOCITY ((2 * 3) << RESOLUTION_FACTOR)) + wdx,
+		SINE (angle, WORLD_TO_VELOCITY ((2 * 3) << RESOLUTION_FACTOR)) + wdy); // JMS_GFX
 
 	UnlockElement (hWeaponElement);
 
@@ -1542,11 +1694,11 @@ DoPlanetSide (LanderInputState *pMS)
 
 		angle = FACING_TO_ANGLE (GetFrameIndex (LanderFrame[0]));
 		landerSpeedNumer = GET_GAME_STATE (IMPROVED_LANDER_SPEED) ?
-				WORLD_TO_VELOCITY (2 * 14) :
-				WORLD_TO_VELOCITY (2 * 8);
+			WORLD_TO_VELOCITY (2 * (16 << RESOLUTION_FACTOR)) :
+			WORLD_TO_VELOCITY (2 * (8 << RESOLUTION_FACTOR));
 
 #ifdef FAST_FAST
-landerSpeedNumer = WORLD_TO_VELOCITY (48);
+landerSpeedNumer = WORLD_TO_VELOCITY (48 << RESOLUTION_FACTOR); // JMS
 #endif
 
 		SetVelocityComponents (&GLOBAL (velocity),
@@ -1609,11 +1761,11 @@ landerSpeedNumer = WORLD_TO_VELOCITY (48
 
 				angle = FACING_TO_ANGLE (index);
 				landerSpeedNumer = GET_GAME_STATE (IMPROVED_LANDER_SPEED) ?
-						WORLD_TO_VELOCITY (2 * 14) :
-						WORLD_TO_VELOCITY (2 * 8);
+					WORLD_TO_VELOCITY ((2 * 16) << RESOLUTION_FACTOR) :
+					WORLD_TO_VELOCITY ((2 * 8) << RESOLUTION_FACTOR);
 
 #ifdef FAST_FAST
-landerSpeedNumer = WORLD_TO_VELOCITY (48);
+landerSpeedNumer = WORLD_TO_VELOCITY (48 << RESOLUTION_FACTOR);
 #endif
 
 				SetVelocityComponents (&GLOBAL (velocity),
@@ -1729,6 +1881,11 @@ ReturnToOrbit (void)
 
 	SetTransitionSource (&r);
 	BatchGraphics ();
+	
+	// JMS: This will hide the table of mineral values on the status bar.
+	if (optSubmenu)
+		DrawSubmenu (0);
+
 	DrawStarBackGround ();
 	DrawPlanetSurfaceBorder ();
 	RedrawSurfaceScan (NULL);
@@ -1747,7 +1904,7 @@ IdlePlanetSide (LanderInputState *inputS
 	while (GetTimeCounter () < TimeOut)
 	{
 		// 10 to clear the lander off of the screen
-		ScrollPlanetSide (0, 0, -(SURFACE_HEIGHT / 2 + 10));
+		ScrollPlanetSide (0, 0, -(SURFACE_HEIGHT / 2 + (10 << RESOLUTION_FACTOR))); // JMS_GFX
 		SleepThreadUntil (inputState->NextTime);
 		inputState->NextTime += PLANET_SIDE_RATE;
 	}
@@ -1758,20 +1915,32 @@ LandingTakeoffSequence (LanderInputState
 {
 // We cannot solve a quadratic equation in a macro, so use a sensible max
 #define MAX_OFFSETS  20
-// 10 to clear the lander off of the screen
-#define DISTANCE_COVERED  (SURFACE_HEIGHT / 2 + 10)
+#define MAX_OFFSETS_4X 400 // JMS_GFX
+// 10 << RESOLUTION_FACTOR to clear the lander off of the screen
+#define DISTANCE_COVERED  (SURFACE_HEIGHT / 2 + (10 << RESOLUTION_FACTOR))
 	int landingOfs[MAX_OFFSETS];
 	int start;
 	int end;
 	int delta;
 	int index;
+	int max_offsets; // JMS_GFX
+	int landingOfs4x[MAX_OFFSETS_4X]; // JMS_GFX
 
 	// Produce smooth acceleration deltas from a simple 1..x progression
 	delta = 0;
-	for (index = 0; index < MAX_OFFSETS && delta < DISTANCE_COVERED; ++index)
+	// JMS_GFX: At 4x resolution we run out of default offsets. -> Use larger offset value.
+	max_offsets = MAX_OFFSETS;
+	if (RESOLUTION_FACTOR == 2) 
+		max_offsets = MAX_OFFSETS_4X;
+
+	for (index = 0; index < max_offsets && delta < DISTANCE_COVERED; ++index)
 	{
 		delta += index + 1;
-		landingOfs[index] = -delta;
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 2)
+			landingOfs4x[index] = -delta;
+		else
+			landingOfs[index] = -delta;
 	}
 	assert (delta >= DISTANCE_COVERED && "Increase MAX_OFFSETS!");
 
@@ -1794,7 +1963,12 @@ LandingTakeoffSequence (LanderInputState
 	// Draw the landing/takeoff lander positions
 	for (index = start; index != end; index += delta)
 	{
-		ScrollPlanetSide (0, 0, landingOfs[index]);
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 2)
+			ScrollPlanetSide (0, 0, landingOfs4x[index]);
+		else
+			ScrollPlanetSide (0, 0, landingOfs[index]);
+
 		SleepThreadUntil (inputState->NextTime);
 		inputState->NextTime += PLANET_SIDE_RATE;
 	}
@@ -1928,7 +2102,11 @@ PlanetSide (POINT planetLoc)
 	explosion_index = 0;
 
 	AnimateLanderWarmup ();
-	AnimateLaunch (LanderFrame[5]);
+	AnimateLaunch (LanderFrame[5], TRUE);
+
+	if (optSubmenu)
+		DrawSubmenu (1);
+
 	InitPlanetSide (planetLoc);
 
 	landerInputState.NextTime = GetTimeCounter () + PLANET_SIDE_RATE;
@@ -1957,7 +2135,7 @@ PlanetSide (POINT planetLoc)
 
 			LandingTakeoffSequence (&landerInputState, FALSE);
 			ReturnToOrbit ();
-			AnimateLaunch (LanderFrame[6]);
+			AnimateLaunch (LanderFrame[6], FALSE);
 			
 			DeltaSISGauges (crew_left, 0, 0);
 
@@ -2076,9 +2254,8 @@ InitLander (BYTE LanderFlags)
 		if ((int)free_space < (int)(MAX_SCROUNGED << capacity_shift))
 		{
 			r.corner.x = 1;
-			r.extent.width = 4;
-			r.extent.height = MAX_SCROUNGED
-					- (free_space >> capacity_shift) + 1;
+			r.extent.width = RES_STAT_SCALE(4) + RESOLUTION_FACTOR; // JMS_GFX
+			r.extent.height = RES_STAT_SCALE(MAX_HOLD_BARS - ((free_space >> capacity_shift) * MAX_HOLD_BARS / MAX_SCROUNGED) + 2);
 			SetContextForeGroundColor (BLACK_COLOR);
 			DrawFilledRectangle (&r);
 		}
diff -ruNp src.orig/uqm/planets/orbits.c src/uqm/planets/orbits.c
--- src.orig/uqm/planets/orbits.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/orbits.c	2017-12-30 00:14:53 -0800
@@ -21,7 +21,8 @@
 #include "libs/compiler.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
-
+#include "../clock.h"
+#include <math.h>
 
 //#define DEBUG_ORBITS
 
@@ -469,6 +470,21 @@ YellowDistribution (BYTE which_world)
 #define SUPERGIANT_ROCK_DIST SCALE_RADIUS (16)
 #define SUPERGIANT_GASG_DIST SCALE_RADIUS (33)
 
+void ComputeSpeed(PLANET_DESC *planet, BOOLEAN GeneratingMoons, UWORD rand_val)
+{
+	//BW : empiric values, which would give roughly correct
+	// rotation periods for most moons in the solar system
+	if (GeneratingMoons) {
+		planet->orb_speed = FULL_CIRCLE / (29 * pow((double)planet->radius / (MIN_MOON_RADIUS + (MAX_MOONS - 1) * MOON_DELTA), 1.5));
+		if ((planet->pPrevDesc->data_index & ~PLANET_SHIELDED) >= FIRST_GAS_GIANT)
+			planet->orb_speed *= 2;
+		if (!(rand_val % 7))
+			planet->orb_speed = - planet->orb_speed;
+	} else {
+		planet->orb_speed = FULL_CIRCLE / (ONE_YEAR * pow((double)planet->radius / EARTH_RADIUS, 1.5));
+	}
+}
+
 void
 FillOrbits (SOLARSYS_STATE *system, BYTE NumPlanets,
 		PLANET_DESC *pBaseDesc, BOOLEAN TypesDefined)
@@ -525,8 +541,7 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 	while (NumPlanets--)
 	{
 		BYTE chance;
-		DWORD rand_val;
-		COUNT min_radius, angle;
+		DWORD rand_val, min_radius, angle;
 		SIZE delta_r;
 		PLANET_DESC *pLocPD;
 
@@ -539,6 +554,9 @@ char scolor[] = {'B', 'G', 'O', 'R', 'W'
 				pPD->data_index =
 						(BYTE)(HIBYTE (LOWORD (rand_val)) % MaxPlanet);
 
+			// JMS: This exists for special colormaps of Sol system planets.
+			pPD->alternate_colormap = NULL;
+
 			chance = PLANET_NEVER;
 			switch (StarColor)
 			{
@@ -597,10 +615,22 @@ RelocatePlanet:
 		}
 
 		rand_val = RandomContext_Random (SysGenRNG);
-		angle = NORMALIZE_ANGLE (LOWORD (rand_val));
-		pPD->location.x = COSINE (angle, pPD->radius);
-		pPD->location.y = SINE (angle, pPD->radius);
-		pPD->rand_seed = MAKE_DWORD (pPD->location.x, pPD->location.y);
+		// Initial angle & coordinates as in Vanilla UQM
+		// Still used to compute rand_seed and the position
+		// of the planet at the start of the game
+		pPD->angle = NORMALIZE_ANGLE (LOWORD (rand_val));
+		pPD->location.x = COSINE (pPD->angle, pPD->radius);
+		pPD->location.y = SINE (pPD->angle, pPD->radius);
+		if (GeneratingMoons) {
+		pPD->rand_seed = MAKE_DWORD (
+		     COSINE (pPD->angle, pPD->radius >> RESOLUTION_FACTOR),
+		     SINE (pPD->angle, pPD->radius >> RESOLUTION_FACTOR));
+		} else {
+			pPD->rand_seed = MAKE_DWORD (pPD->location.x, pPD->location.y);
+		}
+		// Angle is kept for reference but location will be adjusted
+		// to take orbiting into account
+		ComputeSpeed(pPD, GeneratingMoons, HIWORD (rand_val));
 
 		++pPD;
 	}
diff -ruNp src.orig/uqm/planets/oval.c src/uqm/planets/oval.c
--- src.orig/uqm/planets/oval.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/oval.c	2017-12-30 00:14:53 -0800
@@ -133,7 +133,7 @@ DrawOval (RECT *pRect, BYTE num_off_pixe
 		if (quad_visible & (1 << x))
 		{
 			SetPrimNextLink (&prim[x], StartPrim);
-			SetPrimType (&prim[x], POINT_PRIM);
+			SetPrimType (&prim[x], POINT_PRIM); // Orbit dots
 			SetPrimColor (&prim[x], _get_context_fg_color ());
 
 			StartPrim = x;
diff -ruNp src.orig/uqm/planets/pl_stuff.c src/uqm/planets/pl_stuff.c
--- src.orig/uqm/planets/pl_stuff.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/pl_stuff.c	2017-12-30 00:14:53 -0800
@@ -24,7 +24,7 @@
 #include "libs/mathlib.h"
 #include "scan.h"
 #include "options.h"
-
+#include "libs/log.h"
 #include <math.h>
 
 
@@ -38,6 +38,9 @@ static int rotDirection;
 static bool throbShield;
 static int rotPointIndex;
 
+static int rotwidth;
+static int rotheight;
+
 // Draw the planet sphere and any extra graphic (like a shield) if present
 void
 DrawPlanetSphere (int x, int y)
@@ -70,10 +73,13 @@ DrawDefaultPlanetSphere (void)
 }
 
 void
-InitSphereRotation (int direction, BOOLEAN shielded)
+InitSphereRotation (int direction, BOOLEAN shielded, COUNT width, COUNT height)
 {
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 
+	rotwidth = width;
+	rotheight = height;
+
 	rotDirection = direction;
 	rotPointIndex = 0;
 	throbShield = shielded && optWhichShield == OPT_3DO;
@@ -93,7 +99,7 @@ InitSphereRotation (int direction, BOOLE
 	// Render the first sphere/shield frame
 	// Prepare will set the next one
 	rotFrameIndex = 1;
-	PrepareNextRotationFrame ();
+	PrepareNextRotationFrame (NULL, NULL, TRUE);
 }
 
 void
@@ -110,33 +116,77 @@ UninitSphereRotation (void)
 }
 
 void
-PrepareNextRotationFrame (void)
-{
-	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
-
+PrepareNextRotationFrame (PLANET_DESC *pPlanetDesc, SIZE frameCounter, BOOLEAN inOrbit)
+{		
+	PLANET_ORBIT *Orbit = inOrbit ? &pSolarSysState->Orbit : &pPlanetDesc->orbit;
+
+	if (!inOrbit){
+		COUNT framerate;
+		int oldPointIndex = pPlanetDesc->rotPointIndex;
+		// Go to next point, taking care of wraparounds
+
+		// No need to rotate planets that are off screen
+		if (pPlanetDesc->radius > 4 * pSolarSysState->SunDesc[0].radius)
+			return;
+
+		// Optimization : the smallest worlds are rotated only once in a while
+		// The framerate is fine-tuned so that the planet is updated
+		// when the landscape has moved 1 pixel approximately
+		switch (pPlanetDesc->size) {
+			case 3: framerate = 15;
+				break;
+			case 4: framerate = 10;
+				break;
+			case 7: framerate = 4;
+				break;
+			case 11: framerate = 2;
+				break;
+			default: framerate = 1;
+				break;
+		}
+		if ((frameCounter % framerate) != 0)
+			return;
+
+		// BW: account for rotation period
+		pPlanetDesc->rotPointIndex = (int)(fmod(pPlanetDesc->rot_speed * daysElapsed(), pPlanetDesc->rotwidth));
+		if (pPlanetDesc->rotPointIndex < 0)
+			pPlanetDesc->rotPointIndex += pPlanetDesc->rotwidth;
+
+		// Nothing to do if there has been no visible rotation
+		if (pPlanetDesc->rotPointIndex == oldPointIndex)
+			return;
+	}
 	// Generate the next rotation frame
 	// We alternate between the frames because we do not call FlushGraphics()
 	// The frame we just drew may not have made it to the screen yet
-	rotFrameIndex ^= 1;
-
-	// Go to next point, taking care of wraparounds
-	rotPointIndex += rotDirection;
-	if (rotPointIndex < 0)
-		rotPointIndex = MAP_WIDTH - 1;
-	else if (rotPointIndex >= MAP_WIDTH)
-		rotPointIndex = 0;
+	if (inOrbit){
+		rotPointIndex += rotDirection;
+		if (rotPointIndex < 0)
+			rotPointIndex = rotwidth - 1;
+		else if (rotPointIndex >= rotwidth)
+			rotPointIndex = 0;
+	} else {
+		pPlanetDesc->rotFrameIndex ^= 1;
+	}
 
 	// prepare the next sphere frame
-	Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, rotFrameIndex);
-	RenderPlanetSphere (Orbit->SphereFrame, rotPointIndex, throbShield);
-	
-	if (throbShield)
-	{	// prepare the next shield throb frame
-		Orbit->ObjectFrame = SetAbsFrameIndex (Orbit->ObjectFrame,
-				rotFrameIndex);
-		SetShieldThrobEffect (Orbit->WorkFrame, rotPointIndex,
-				Orbit->ObjectFrame);
+	if(inOrbit){
+		Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, rotFrameIndex);
+		RenderPlanetSphere (Orbit, Orbit->SphereFrame, rotPointIndex, pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED, throbShield, rotwidth, rotheight, (rotheight >> 1) - RESOLUTION_FACTOR); // RADIUS
+		if (throbShield)
+		{	// prepare the next shield throb frame
+			Orbit->ObjectFrame = SetAbsFrameIndex (Orbit->ObjectFrame,
+					rotFrameIndex);
+			SetShieldThrobEffect (Orbit->WorkFrame, rotPointIndex,
+					Orbit->ObjectFrame);
+		}	
+	} else {		
+		Orbit->SphereFrame = SetAbsFrameIndex (Orbit->SphereFrame, pPlanetDesc->rotFrameIndex);
+		RenderPlanetSphere (Orbit, Orbit->SphereFrame, pPlanetDesc->rotPointIndex, pPlanetDesc->data_index & PLANET_SHIELDED, FALSE, pPlanetDesc->rotwidth, pPlanetDesc->rotheight, (pPlanetDesc->rotheight >> 1) - RESOLUTION_FACTOR); // RADIUS
+		Orbit->SphereFrame->image->dirty = TRUE;
 	}
+	// BW: slightly hacky but, in DrawTexturedBody, the call
+	// to DrawStamp won't re-blit the frame unless scale has changed.
 }
 
 #define ZOOM_RATE  24
@@ -196,7 +246,7 @@ ZoomInPlanetSphere (void)
 
 		BatchGraphics ();
 		if (i > 0)
-			RepairBackRect (&repairRect);
+			RepairBackRect (&repairRect, FALSE);
 
 		oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
 		oldScale = SetGraphicScale ((int)(base * scale + 0.5));
@@ -209,7 +259,7 @@ ZoomInPlanetSphere (void)
 		repairRect.corner.x = pt.x + frameRect.corner.x;
 		repairRect.corner.y = pt.y + frameRect.corner.y;
 
-		PrepareNextRotationFrame ();
+		PrepareNextRotationFrame (NULL, NULL, TRUE);
 
 		SleepThreadUntil (NextTime);
 	}
@@ -227,7 +277,7 @@ RotatePlanetSphere (BOOLEAN keepRate)
 	NextTime = Now + PLANET_ROTATION_RATE;
 	DrawDefaultPlanetSphere ();
 
-	PrepareNextRotationFrame ();
+	PrepareNextRotationFrame (NULL, NULL, TRUE);
 }
 
 static void
diff -ruNp src.orig/uqm/planets/plandata.h src/uqm/planets/plandata.h
--- src.orig/uqm/planets/plandata.h	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/plandata.h	2017-12-30 00:14:53 -0800
@@ -279,6 +279,16 @@ typedef struct
 	DWORD ScanSeed[NUM_SCAN_TYPES];
 	DWORD ScanRetrieveMask[NUM_SCAN_TYPES];
 
+	// JMS: This stores the amount of partially scavenged minerals.
+	//
+	// How it works: When the mineral deposits are generated in scan.c, first the deposit
+	// is given its normal kiloton-size (decided by pseudo-random number). Then, the value
+	// stored in this list is subtracted from the initial value.
+	// There can be max DWORD = 32 mineral deposits on the planet, thus the 32.
+	//
+	// This can be later made to support also partially scavenged biodata.
+	BYTE  PartiallyScavengedList[NUM_SCAN_TYPES][32];
+
 	STRING DiscoveryString;
 	FONT LanderFont;
 	FRAME LanderFontEff;
@@ -301,6 +311,17 @@ extern UWORD CalcGravity (const PLANET_I
 #define COLD_THRESHOLD -40
 #define HOT_THRESHOLD 100
 
+#define SOL_COLOR_TABS \
+	MERCURY_COLOR_TAB, \
+	VENUS_COLOR_TAB, \
+	EARTH_COLOR_TAB, \
+	MARS_COLOR_TAB, \
+	JUPITER_COLOR_TAB, \
+	SATURN_COLOR_TAB, \
+	URANUS_COLOR_TAB, \
+	NEPTUNE_COLOR_TAB, \
+	PLUTO_COLOR_TAB
+
 /*------------------------------ Global Data ------------------------------ */
 
 #define NO_TECTONICS 0
diff -ruNp src.orig/uqm/planets/planets.c src/uqm/planets/planets.c
--- src.orig/uqm/planets/planets.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/planets.c	2017-12-30 00:14:53 -0800
@@ -233,7 +233,11 @@ DrawOrbitalDisplay (DRAW_ORBITAL_MODE Mo
 	UnbatchGraphics ();
 
 	// for later RepairBackRect()
-	LoadIntoExtraScreen (&r);
+	// JMS_GFX
+	if (RESOLUTION_FACTOR == 0)
+		LoadIntoExtraScreen (&r);
+	else
+		LoadIntoExtraScreen_Fs (&r);
 }
 
 // Initialise the surface graphics, and start the planet music.
@@ -266,7 +270,7 @@ LoadPlanet (FRAME SurfDefFrame)
 	StopMusic ();
 
 	pPlanetDesc = pSolarSysState->pOrbitalDesc;
-	GeneratePlanetSurface (pPlanetDesc, SurfDefFrame);
+	GeneratePlanetSurface (pPlanetDesc, SurfDefFrame, MAP_WIDTH, MAP_HEIGHT, TRUE);
 	SetPlanetMusic (pPlanetDesc->data_index & ~PLANET_SHIELDED);
 	GeneratePlanetSide ();
 
@@ -287,7 +291,7 @@ LoadPlanet (FRAME SurfDefFrame)
 void
 FreePlanet (void)
 {
-	COUNT i;
+	COUNT i, j;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 
 	UninitSphereRotation ();
@@ -330,6 +334,19 @@ FreePlanet (void)
 	Orbit->TopoColors = NULL;
 	HFree (Orbit->ScratchArray);
 	Orbit->ScratchArray = NULL;
+	if (Orbit->map_rotate && Orbit->light_diff)
+	{
+		for (j=0 ; j < MAP_HEIGHT+1 ; j++)
+		{
+			HFree (Orbit->map_rotate[j]);
+			HFree (Orbit->light_diff[j]);
+		}
+	}
+
+	HFree (Orbit->map_rotate);
+	Orbit->map_rotate = NULL;
+	HFree (Orbit->light_diff);
+	Orbit->light_diff = NULL;
 
 	DestroyStringTable (ReleaseStringTable (
 			pSolarSysState->SysInfo.PlanetInfo.DiscoveryString
diff -ruNp src.orig/uqm/planets/planets.h src/uqm/planets/planets.h
--- src.orig/uqm/planets/planets.h	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/planets.h	2017-12-30 00:14:53 -0800
@@ -23,6 +23,15 @@
 
 #define END_INTERPLANETARY START_INTERPLANETARY
 
+#define ORBITING_PLANETS optOrbitingPlanets
+#define TEXTURED_PLANETS optTexturedPlanets
+#define ROTATING_PLANETS TEXTURED_PLANETS
+// ROTATING_PLANETS should always be defined TRUE if TEXTURED_PLANETS is.
+#define ONE_YEAR 365.25
+#ifndef M_PI
+#define M_PI 3.141592653589
+#endif
+
 enum PlanetScanTypes
 {
 	MINERAL_SCAN = 0,
@@ -33,7 +42,9 @@ enum PlanetScanTypes
 };
 
 #define MAP_WIDTH SIS_SCREEN_WIDTH
-#define MAP_HEIGHT (75 - SAFE_Y)
+#define MAP_HEIGHT RES_CASE(75,150,330) // JMS_GFX
+#define ORIGINAL_MAP_WIDTH 242			// JMS_GFX
+#define ORIGINAL_MAP_HEIGHT 75			// JMS_GFX
 
 enum
 {
@@ -54,7 +65,8 @@ enum
 	LANDER_DESTROYED
 };
 
-#define MAX_SCROUNGED 50 /* max lander can hold */
+#define MAX_SCROUNGED 50 /* max units lander can hold (was 64 in SC2 DOS) */
+#define MAX_HOLD_BARS 50 /* number of bars on the lander screen */
 
 #define SCALE_RADIUS(r) ((r) << 6)
 #define UNSCALE_RADIUS(r) ((r) >> 6)
@@ -69,18 +81,18 @@ enum
 
 #define NUM_SCANDOT_TRANSITIONS 4
 
-#define MIN_MOON_RADIUS 35
-#define MOON_DELTA 20
+#define MIN_MOON_RADIUS (35 << RESOLUTION_FACTOR) // JMS_GFX
+#define MOON_DELTA (20 << RESOLUTION_FACTOR) // JMS_GFX
 
 #define MAX_SUNS 1
 #define MAX_PLANETS 16
 #define MAX_MOONS 4
 
-#define MAP_BORDER_HEIGHT  5
+#define MAP_BORDER_HEIGHT  RES_CASE(5,10,10) // JMS_GFX
 #define SCAN_SCREEN_HEIGHT (SIS_SCREEN_HEIGHT - MAP_HEIGHT - MAP_BORDER_HEIGHT)
 
 #define PLANET_ROTATION_TIME (ONE_SECOND * 12)
-#define PLANET_ROTATION_RATE (PLANET_ROTATION_TIME / MAP_WIDTH)
+#define PLANET_ROTATION_RATE (PLANET_ROTATION_TIME / ORIGINAL_MAP_WIDTH) // JMS_GFX
 // XXX: -9 to match the original, but why? I have no idea
 #define PLANET_ORG_Y ((SCAN_SCREEN_HEIGHT - 9) / 2)
 
@@ -101,6 +113,41 @@ typedef struct solarsys_state SOLARSYS_S
 #include "lifeform.h"
 #include "plandata.h"
 #include "sundata.h"
+ 
+typedef struct 
+{
+	POINT p[4];
+	DWORD m[4];
+} MAP3D_POINT;
+
+struct planet_orbit
+{
+	FRAME TopoZoomFrame;
+			// 4x scaled topo image for planet-side
+	SBYTE  *lpTopoData;
+			// normal topo data; expressed in elevation levels
+			// data is signed for planets other than gas giants
+			// transformed to light variance map for 3d planet
+	FRAME SphereFrame;
+			// rotating 3d planet frames (current and next)
+	FRAME ObjectFrame;
+			// any extra planetary object (shield, atmo, rings)
+			// automatically drawn if present
+	FRAME TintFrame;
+			// tinted topo images for current scan type (dynamic)
+	Color TintColor;
+			// the color of the last used tint
+	Color *TopoColors;
+			// RGBA version of topo image; for 3d planet
+	Color *ScratchArray;
+			// temp RGBA data for whatever transforms (nuked often)
+	FRAME WorkFrame;
+			// any extra frame workspace (for dynamic objects)
+	// BW: extra stuff for animated IP
+	DWORD **light_diff;
+	MAP3D_POINT **map_rotate;
+	// doubly dynamically allocated depending on map size
+};
 
 #if defined(__cplusplus)
 extern "C" {
@@ -113,7 +160,10 @@ struct planet_desc
 	BYTE data_index;
 	BYTE NumPlanets;
 	SIZE radius;
+	COUNT angle;
 	POINT location;
+	double orb_speed;
+	double rot_speed;
 
 	Color temp_color;
 	COUNT NextIndex;
@@ -121,6 +171,12 @@ struct planet_desc
 
 	PLANET_DESC *pPrevDesc;
 			// The Sun or planet that this world is orbiting around.
+	// BW : new stuff for animated solar systems
+	PLANET_ORBIT orbit;
+	COUNT size;
+	int rotFrameIndex, rotPointIndex, rotDirection, rotwidth, rotheight;
+	
+	RESOURCE alternate_colormap; // JMS: Special color maps for Sol system planets
 };
 
 struct star_desc
@@ -153,31 +209,6 @@ struct node_info
 			// For energy: undefined
 };
 
-struct planet_orbit
-{
-	FRAME TopoZoomFrame;
-			// 4x scaled topo image for planet-side
-	SBYTE  *lpTopoData;
-			// normal topo data; expressed in elevation levels
-			// data is signed for planets other than gas giants
-			// transformed to light variance map for 3d planet
-	FRAME SphereFrame;
-			// rotating 3d planet frames (current and next)
-	FRAME ObjectFrame;
-			// any extra planetary object (shield, atmo, rings)
-			// automatically drawn if present
-	FRAME TintFrame;
-			// tinted topo images for current scan type (dynamic)
-	Color TintColor;
-			// the color of the last used tint
-	Color *TopoColors;
-			// RGBA version of topo image; for 3d planet
-	Color *ScratchArray;
-			// temp RGBA data for whatever transforms (nuked often)
-	FRAME WorkFrame;
-			// any extra frame workspace (for dynamic objects)
-};
-
 // See doc/devel/generate for information on how this structure is
 // filled.
 struct solarsys_state
@@ -286,16 +317,17 @@ extern void DrawStarBackGround (void);
 extern void XFormIPLoc (POINT *pIn, POINT *pOut, BOOLEAN ToDisplay);
 extern void DrawOval (RECT *pRect, BYTE num_off_pixels);
 extern void DrawFilledOval (RECT *pRect);
+extern void ComputeSpeed(PLANET_DESC *planet, BOOLEAN GeneratingMoons, UWORD rand_val);
 extern void FillOrbits (SOLARSYS_STATE *system, BYTE NumPlanets,
 		PLANET_DESC *pBaseDesc, BOOLEAN TypesDefined);
 extern void InitLander (BYTE LanderFlags);
 
-extern void InitSphereRotation (int direction, BOOLEAN shielded);
+extern void InitSphereRotation (int direction, BOOLEAN shielded, COUNT width, COUNT height);
 extern void UninitSphereRotation (void);
-extern void PrepareNextRotationFrame (void);
+extern void PrepareNextRotationFrame (PLANET_DESC *pPlanetDesc, SIZE frameCounter, BOOLEAN inOrbit);
 extern void DrawPlanetSphere (int x, int y);
 extern void DrawDefaultPlanetSphere (void);
-extern void RenderPlanetSphere (FRAME Frame, int offset, BOOLEAN doThrob);
+extern void RenderPlanetSphere (PLANET_ORBIT *Orbit, FRAME Frame, int offset, BOOLEAN shielded, BOOLEAN doThrob, COUNT width, COUNT height, COUNT radius);
 extern void SetShieldThrobEffect (FRAME FromFrame, int offset, FRAME ToFrame);
 
 extern void ZoomInPlanetSphere (void);
@@ -303,7 +335,7 @@ extern void RotatePlanetSphere (BOOLEAN
 
 extern void DrawScannedObjects (BOOLEAN Reversed);
 extern void GeneratePlanetSurface (PLANET_DESC *pPlanetDesc,
-		FRAME SurfDefFrame);
+		FRAME SurfDefFrame, COUNT width, COUNT height, BOOLEAN inOrbit);
 extern void DeltaTopography (COUNT num_iterations, SBYTE *DepthArray,
 		RECT *pRect, SIZE depth_delta);
 
diff -ruNp src.orig/uqm/planets/plangen.c src/uqm/planets/plangen.c
--- src.orig/uqm/planets/plangen.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/plangen.c	2017-12-30 00:14:53 -0800
@@ -16,6 +16,11 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+// BW 2011: fixed using pixmaps to define planet surfaces so it actually works
+// on planets you can land on. The second frame of planetmask.ani has to be a
+// (Black & White) indexed pic with 128 colors top. Lesser indices (black)
+// will correspond to lower altitudes.
+
 #include "planets.h"
 #include "scan.h"
 #include "../nameref.h"
@@ -41,7 +46,7 @@
 #define SHIELD_REFLECT_COMP 100
 
 #define NUM_BATCH_POINTS 64
-#define RADIUS 37
+#define RADIUS RES_CASE(37,74,163) // JMS_GFX
 //2*RADIUS
 #define TWORADIUS (RADIUS << 1)
 //RADIUS^2
@@ -72,15 +77,22 @@
 #define M_DEG2RAD (M_TWOPI / 360.0)
 #endif
 
-DWORD light_diff[DIAMETER][DIAMETER];
-
-typedef struct 
-{
-	POINT p[4];
-	DWORD m[4];
-} MAP3D_POINT;
-
-MAP3D_POINT map_rotate[DIAMETER][DIAMETER];
+// BW: dynamically allocated in the orbit structure
+// JMS_GFX: Changed initialization to constant numbers since DIAMETER is now variably defined
+// The value 330 is the value that's reached at the biggest resolution, 4x.
+// DWORD light_diff[330][330]; //DWORD light_diff[DIAMETER][DIAMETER];
+
+// BW: Moved to planets.h
+// typedef struct 
+// {
+// 	POINT p[4];
+// 	DWORD m[4];
+// } MAP3D_POINT;
+
+// BW: dynamically allocated in the orbit structure
+// JMS_GFX: Changed initialization to constant numbers since DIAMETER is now variably defined
+// The value 330 is the value that's reached at the biggest resolution, 4x.
+// MAP3D_POINT map_rotate[330][330];//MAP3D_POINT map_rotate[DIAMETER][DIAMETER];
 
 typedef struct
 {
@@ -88,109 +100,77 @@ typedef struct
 } POINT3;
 
 static void
-RenderTopography (FRAME DstFrame, SBYTE *pTopoData, int w, int h)
+RenderTopography (FRAME DstFrame, SBYTE *pTopoData, int w, int h, BOOLEAN SurfDef)
 {
-	FRAME OldFrame;
-
-	OldFrame = SetContextFGFrame (DstFrame);
-
-	if (pSolarSysState->XlatRef == 0)
-	{
+	if (pSolarSysState->XlatRef == 0) {
 		// There is currently nothing we can do w/o an xlat table
 		// This is still called for Earth for 4x scaled topo, but we
 		// do not need it because we cannot land on Earth.
-	}
-	else
-	{
-		COUNT i;
+		log_add(log_Warning, "No xlat table -- could not generate surface.\n");
+	} else {
 		BYTE AlgoType;
 		SIZE base, d;
 		const XLAT_DESC *xlatDesc;
 		POINT pt;
 		const PlanetFrame *PlanDataPtr;
-		PRIMITIVE BatchArray[NUM_BATCH_POINTS];
-		PRIMITIVE *pBatch;
 		SBYTE *pSrc;
 		const BYTE *xlat_tab;
 		BYTE *cbase;
-		POINT oldOrigin;
-		RECT ClipRect;
-
-		oldOrigin = SetContextOrigin (MAKE_POINT (0, 0));
-		GetContextClipRect (&ClipRect);
-		SetContextClipRect (NULL);
+		Color *pix;
+		Color *map;
+		BYTE ColorShift; // JMS
 
-		pBatch = &BatchArray[0];
-		for (i = 0; i < NUM_BATCH_POINTS; ++i, ++pBatch)
-		{
-			SetPrimNextLink (pBatch, i + 1);
-			SetPrimType (pBatch, POINT_PRIM);
-		}
-		SetPrimNextLink (&pBatch[-1], END_OF_LIST);
+		map = HMalloc (sizeof (Color) * w * h);
+		pix = map;
 
-		PlanDataPtr = &PlanData[
-				pSolarSysState->pOrbitalDesc->data_index & ~PLANET_SHIELDED
-				];
+		PlanDataPtr = &PlanData[pSolarSysState->pOrbitalDesc->data_index & ~PLANET_SHIELDED];
 		AlgoType = PLANALGO (PlanDataPtr->Type);
-		base = PlanDataPtr->base_elevation;
+		if (SurfDef) {
+			// Planets given by a pixmap have elevations between -128 and +128
+			base = 256;
+		} else {
+			base = PlanDataPtr->base_elevation;
+		}
 		xlatDesc = (const XLAT_DESC *) pSolarSysState->XlatPtr;
 		xlat_tab = (const BYTE *) xlatDesc->xlat_tab;
 		cbase = GetColorMapAddress (pSolarSysState->OrbitalCMap);
 
-		i = NUM_BATCH_POINTS;
-		pBatch = &BatchArray[i];
+		// JMS: This is for using 8-bits per color channel .ct files for e.g. Mars.
+		if (SurfDef)
+			ColorShift = 3;
+		else
+			ColorShift = 1;
+
 		pSrc = pTopoData;
-		for (pt.y = 0; pt.y < h; ++pt.y)
-		{
-			for (pt.x = 0; pt.x < w; ++pt.x, ++pSrc)
-			{
+		for (pt.y = 0; pt.y < h; ++pt.y) {
+			for (pt.x = 0; pt.x < w; ++pt.x, ++pSrc, ++pix) {
 				BYTE *ctab;
 
 				d = *pSrc;
-				if (AlgoType == GAS_GIANT_ALGO)
-				{	// make elevation value non-negative
+				if (AlgoType == GAS_GIANT_ALGO) {	
+					// make elevation value non-negative
 					d &= 255;
-				}
-				else
-				{
+				} else {
 					d += base;
-					if (d < 0)
+					if (d < 0){
 						d = 0;
-					else if (d > 255)
+					} else if (d > 255) {
 						d = 255;
+					}
 				}
 
-				--pBatch;
-				pBatch->Object.Point.x = pt.x;
-				pBatch->Object.Point.y = pt.y;
-
 				d = xlat_tab[d] - cbase[0];
 				ctab = (cbase + 2) + d * 3;
 
 				// fixed planet surfaces being too dark
 				// ctab shifts were previously >> 3 .. -Mika
-				SetPrimColor (pBatch, BUILD_COLOR (MAKE_RGB15 (ctab[0] >> 1,
-								ctab[1] >> 1, ctab[2] >> 1), d));
-				
-				if (--i == 0)
-				{	// flush the batch and start the next one
-					DrawBatch (BatchArray, 0, 0);
-					i = NUM_BATCH_POINTS;
-					pBatch = &BatchArray[i];
-				}
+				*pix = BUILD_COLOR (MAKE_RGB15 (ctab[0] >> ColorShift, 
+					ctab[1] >> ColorShift, ctab[2] >> ColorShift), d);		
 			}
 		}
-
-		if (i < NUM_BATCH_POINTS)
-		{
-			DrawBatch (BatchArray, i, 0);
-		}
-
-		SetContextClipRect (&ClipRect);
-		SetContextOrigin (oldOrigin);
+		WriteFramePixelColors (DstFrame, map, w, h);
+		HFree(map);
 	}
-
-	SetContextFGFrame (OldFrame);
 }
 
 static inline void
@@ -225,13 +205,16 @@ P3norm (POINT3 *res, POINT3 *vec)
 // GenerateSphereMask builds a shadow map for the rotating planet
 //  loc indicates the planet's position relative to the sun
 static void
-GenerateSphereMask (POINT loc)
+GenerateSphereMask (POINT loc, COUNT radius)
 {
 	POINT pt;
 	POINT3 light;
 	double lrad;
 	const DWORD step = 1 << DIFFUSE_BITS;
 	int y, x;
+	COUNT tworadius = radius << 1;
+	COUNT radius_thres = (radius + 1) * (radius + 1);
+	COUNT radius_2 = radius * radius;
 
 #define AMBIENT_LIGHT 0.1
 #define LIGHT_Z       1.2
@@ -244,11 +227,11 @@ GenerateSphereMask (POINT loc)
 	light.z = LIGHT_Z * lrad;
 	P3norm (&light, &light);
 	
-	for (pt.y = 0, y = -RADIUS; pt.y <= TWORADIUS; ++pt.y, y++)
+	for (pt.y = 0, y = -radius; pt.y <= tworadius; ++pt.y, y++)
 	{
 		DWORD y_2 = y * y;
 
-		for (pt.x = 0, x = -RADIUS; pt.x <= TWORADIUS; ++pt.x, x++)
+		for (pt.x = 0, x = -radius; pt.x <= tworadius; ++pt.x, x++)
 		{
 			DWORD x_2 = x * x;
 			DWORD rad_2 = x_2 + y_2;
@@ -256,13 +239,13 @@ GenerateSphereMask (POINT loc)
 			POINT3 norm;
 			double diff;
 			
-			if (rad_2 < RADIUS_THRES) 
+			if (rad_2 < radius_thres) 
 			{
 				// norm is the sphere's surface normal.
 				norm.x = (double)x;
 				norm.y = (double)y;
-				norm.z = (sqrt (RADIUS_2 - x_2) * sqrt (RADIUS_2 - y_2)) /
-						RADIUS;
+				norm.z = (sqrt (radius_2 - x_2) * sqrt (radius_2 - y_2)) /
+						radius;
 				P3norm (&norm, &norm);
 				// diffuse component is norm dot light
 				diff = P3dot (&norm, &light);
@@ -305,9 +288,9 @@ GenerateSphereMask (POINT loc)
 				if (diff < AMBIENT_LIGHT)
 					diff = AMBIENT_LIGHT;
 				// Now we antialias the edge of the spere to look nice
-				if (rad_2 > RADIUS_2) 
+				if (rad_2 > radius_2) 
 				{
-					diff *= 1 - (sqrt(rad_2) - RADIUS);
+					diff *= 1 - (sqrt(rad_2) - radius);
 					if (diff < 0) 
 						diff = 0;
 				}
@@ -316,7 +299,7 @@ GenerateSphereMask (POINT loc)
 				diff_int = (DWORD)(diff * step);
 			}
 
-			light_diff[pt.y][pt.x] = diff_int;
+			pSolarSysState->Orbit.light_diff[pt.y][pt.x] = diff_int;
 		}
 	}
 }
@@ -326,21 +309,22 @@ GenerateSphereMask (POINT loc)
 //  the concept is to compute the weight based on the
 //  distance from the integer location points to the ideal point
 static void
-create_aa_points (MAP3D_POINT *ppt, double x, double y)
+create_aa_points (MAP3D_POINT *ppt, double x, double y, COUNT height)
 {
 	double deltax, deltay, inv_deltax, inv_deltay;
 	COORD nextx, nexty;
 	COUNT i;
 	double d1, d2, d3, d4, m[4];
+	COUNT spherespanx = height;
 
 	if (x < 0)
 		x = 0;
-	else if (x >= SPHERE_SPAN_X)
-		x = SPHERE_SPAN_X - 1;
+	else if (x >= spherespanx)
+		x = spherespanx - 1;
 	if (y < 0)
 		y = 0;
-	else if (y >= MAP_HEIGHT)
-		y = MAP_HEIGHT - 1;
+	else if (y >= height)
+		y = height - 1;
 
 	// get  the integer value of this point
 	ppt->p[0].x = (COORD)x;
@@ -437,30 +421,32 @@ get_avg_channel (Color p[4], DWORD mult[
 // CreateSphereTiltMap creates 'map_rotate' to map the topo data
 //  for a tilted planet.  It also does the sphere->plane mapping
 static void
-CreateSphereTiltMap (int angle)
+CreateSphereTiltMap (int angle, COUNT height, COUNT radius)
 {
 	int x, y;
-	const double multx = ((double)SPHERE_SPAN_X / M_PI);
-	const double multy = ((double)MAP_HEIGHT / M_PI);
-	const double xadj = ((double)SPHERE_SPAN_X / 2.0);
+	COUNT spherespanx = height;
+	COUNT radius_thres = (radius + 1) * (radius + 1);
+	const double multx = ((double)spherespanx / M_PI);
+	const double multy = ((double)height / M_PI);
+	const double xadj = ((double)spherespanx / 2.0);
 
-	for (y = -RADIUS; y <= RADIUS; y++)
+	for (y = -radius; y <= radius; y++)
 	{
 		int y_2 = y * y;
 
-		for (x = -RADIUS; x <= RADIUS; x++)
+		for (x = -radius; x <= radius; x++)
 		{
 			double dx, dy, newx, newy;
 			double da, rad, rad_2;
 			double xa, ya;
-			MAP3D_POINT *ppt = &map_rotate[y + RADIUS][x + RADIUS];
+			MAP3D_POINT *ppt = &pSolarSysState->Orbit.map_rotate[y + radius][x + radius];
 			
 			rad_2 = x * x + y_2;
 
-			if (rad_2 >= RADIUS_THRES)
+			if (rad_2 >= radius_thres)
 			{	// pixel won't be present
-				ppt->p[0].x = x + RADIUS;
-				ppt->p[0].y = y + RADIUS;
+				ppt->p[0].x = x + radius;
+				ppt->p[0].y = y + radius;
 				ppt->m[0] = 0;
 
 				continue;
@@ -468,8 +454,8 @@ CreateSphereTiltMap (int angle)
 			
 			rad = sqrt (rad_2);
 			// antialiasing goes beyond the actual radius
-			if (rad >= RADIUS)
-				rad = (double)RADIUS - 0.1;
+			if (rad >= radius)
+				rad = (double)radius - 0.1;
 			
 			da = atan2 ((double)y, (double)x);
 			// compute the planet-tilt
@@ -478,8 +464,8 @@ CreateSphereTiltMap (int angle)
 			dy = rad * sin (da);
 
 			// Map the sphere onto a plane
-			xa = acos (-dx / RADIUS);
-			ya = acos (-dy / RADIUS);
+			xa = acos (-dx / radius);
+			ya = acos (-dy / radius);
 			newx = multx * xa;
 			newy = multy * ya;
 			// Adjust for vertical curvature
@@ -488,7 +474,7 @@ CreateSphereTiltMap (int angle)
 			else
 				newx = xadj + ((newx - xadj) / sin (ya));
 
-			create_aa_points (ppt, newx, newy);
+			create_aa_points (ppt, newx, newy, height);
 		}
 	}
 }
@@ -501,34 +487,36 @@ CreateSphereTiltMap (int angle)
 // this routine, but a filter can be applied if desired too.
 
 // HALO rim size
-#define SHIELD_HALO          7
+#define SHIELD_HALO          (6 << RESOLUTION_FACTOR) // JMS_GFX
 #define SHIELD_RADIUS        (RADIUS + SHIELD_HALO)
-#define SHIELD_DIAM          ((SHIELD_RADIUS << 1) + 1)
-#define SHIELD_RADIUS_2      (SHIELD_RADIUS * SHIELD_RADIUS)
-#define SHIELD_RADIUS_THRES  ((SHIELD_RADIUS + 1) * (SHIELD_RADIUS + 1))
 #define SHIELD_HALO_GLOW     (SHIELD_GLOW_COMP + SHIELD_REFLECT_COMP)
 #define SHIELD_HALO_GLOW_MIN (SHIELD_HALO_GLOW >> 2)
 
 static FRAME
-CreateShieldMask (void)
+CreateShieldMask (COUNT Radius)
 {
-	Color clear;
-	Color *pix;
+	Color clear, *pix;
 	int x, y;
 	FRAME ShieldFrame;
+
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
+	
+	COUNT ShieldRadius = SHIELD_RADIUS * Radius / RADIUS;
+	COUNT ShieldDiam = (ShieldRadius << 1) + 1;
+	COUNT RadiusSquared = Radius * Radius;
+	COUNT ShieldRadiusThreshold = (ShieldRadius + 1) * (ShieldRadius + 1);
 
 	ShieldFrame = CaptureDrawable (
 			CreateDrawable (WANT_PIXMAP | WANT_ALPHA,
-				SHIELD_DIAM, SHIELD_DIAM, 1));
+				ShieldDiam, ShieldDiam, 1));
 
 	pix = Orbit->ScratchArray;
 	//  This is 100% transparent.
 	clear = BUILD_COLOR_RGBA (0, 0, 0, 0);
 
-	for (y = -SHIELD_RADIUS; y <= SHIELD_RADIUS; y++)
+	for (y = -ShieldRadius; y <= ShieldRadius; y++)
 	{
-		for (x = -SHIELD_RADIUS; x <= SHIELD_RADIUS; ++x, ++pix)
+		for (x = -ShieldRadius; x <= ShieldRadius; ++x, ++pix)
 		{
 			int rad_2 = x * x + y * y;
 			// This is a non-transparent red for the halo
@@ -536,13 +524,13 @@ CreateShieldMask (void)
 			int alpha = 255;
 			double rad;
 			
-			if (rad_2 >= SHIELD_RADIUS_THRES)
+			if (rad_2 >= ShieldRadiusThreshold)
 			{	// outside all bounds
 				*pix = clear;
 				continue;
 			}
 			// Inside the halo
-			if (rad_2 <= RADIUS_2)
+			if (rad_2 <= RadiusSquared)
 			{	// planet's pixels, ours transparent
 				*pix = clear;
 				continue;
@@ -551,16 +539,16 @@ CreateShieldMask (void)
 			// The halo itself
 			rad = sqrt (rad_2);
 
-			if (rad <= RADIUS + 0.8)
+			if (rad <= Radius + 0.8)
 			{	// pixels common between the shield and planet
 				// do antialiasing using alpha
-				alpha = (int) (red * (rad - RADIUS));
+				alpha = (int) (red * (rad - Radius));
 				red = 255;
 			}
 			else
 			{	// shield pixels
-				red -= (int) ((red - SHIELD_HALO_GLOW_MIN) * (rad - RADIUS)
-						/ SHIELD_HALO);
+				red -= (int) ((red - SHIELD_HALO_GLOW_MIN) * (rad - Radius) / (SHIELD_HALO * Radius / RADIUS));
+				
 				if (red < 0)
 					red = 0;
 			}
@@ -570,9 +558,9 @@ CreateShieldMask (void)
 	}
 	
 	WriteFramePixelColors (ShieldFrame, Orbit->ScratchArray,
-			SHIELD_DIAM, SHIELD_DIAM);
-	SetFrameHot (ShieldFrame, MAKE_HOT_SPOT (SHIELD_RADIUS + 1,
-				SHIELD_RADIUS + 1));
+			ShieldDiam, ShieldDiam);
+	SetFrameHot (ShieldFrame, MAKE_HOT_SPOT (ShieldRadius + 1,
+				ShieldRadius + 1));
 	
 	return ShieldFrame;
 }
@@ -611,10 +599,11 @@ SetShieldThrobEffect (FRAME ShieldFrame,
 	Color *pix;
 	int level;
 
+	width = GetFrameWidth (ShieldFrame);
+	height = GetFrameHeight (ShieldFrame);	
+
 	level = shield_level (offset);
 
-	width = GetFrameWidth (ShieldFrame);
-	height = GetFrameHeight (ShieldFrame);
 	ReadFramePixelColors (ShieldFrame, Orbit->ScratchArray, width, height);
 	
 	for (i = 0, pix = Orbit->ScratchArray; i < width * height; ++i, ++pix)
@@ -685,24 +674,25 @@ calc_map_light (UBYTE val, DWORD dif, in
 }
 
 static inline Color
-get_map_pixel (Color *pixels, int x, int y)
+get_map_pixel (Color *pixels, int x, int y, COUNT width, COUNT spherespanx)
 {
-	return pixels[y * (MAP_WIDTH + SPHERE_SPAN_X) + x];
+	/*if (y * (width + spherespanx) + x > 463000)
+		log_add(log_Warning,"x:%u, y:%u, width:%u, spherespanx:%u, slot:%u. Max:%u", x, y, width, spherespanx, y * (width + spherespanx) + x, (MAP_HEIGHT+1) * (MAP_WIDTH + spherespanx));*/
+	return pixels[y * (width + spherespanx) + x];
 }
 
 static inline int
-get_map_elev (SBYTE *elevs, int x, int y, int offset)
+get_map_elev (SBYTE *elevs, int x, int y, int offset, COUNT width)
 {
-	return elevs[y * MAP_WIDTH + (offset + x) % MAP_WIDTH];
+	return elevs[y * width + (offset + x) % width];
 }
 
 // RenderPlanetSphere builds a frame for the rotating planet view
 // offset is effectively the angle of rotation around the planet's axis
 // We use the SDL routines to directly write to the SDL_Surface to improve performance
 void
-RenderPlanetSphere (FRAME MaskFrame, int offset, BOOLEAN doThrob)
+RenderPlanetSphere (PLANET_ORBIT *Orbit, FRAME MaskFrame, int offset, BOOLEAN shielded, BOOLEAN doThrob, COUNT width, COUNT height, COUNT radius)
 {
-	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
 	POINT pt;
 	Color *pix;
 	Color clear;
@@ -711,6 +701,10 @@ RenderPlanetSphere (FRAME MaskFrame, int
 	SBYTE *elevs;
 	int shLevel;
 
+	COUNT spherespanx = height;
+	COUNT tworadius = radius << 1;
+	COUNT diameter = tworadius + 1;
+	
 #if PROFILE_ROTATION
 	static clock_t t = 0;
 	static int frames_done = 1;
@@ -726,14 +720,14 @@ RenderPlanetSphere (FRAME MaskFrame, int
 	pixels = Orbit->TopoColors + offset;
 	elevs = Orbit->lpTopoData;
 	
-	for (pt.y = 0, y = -RADIUS; pt.y <= TWORADIUS; ++pt.y, ++y)
+	for (pt.y = 0, y = -radius; pt.y <= tworadius; ++pt.y, ++y)
 	{
-		for (pt.x = 0, x = -RADIUS; pt.x <= TWORADIUS; ++pt.x, ++x, ++pix)
+		for (pt.x = 0, x = -radius; pt.x <= tworadius; ++pt.x, ++x, ++pix)
 		{
 			Color c;
-			DWORD diffus = light_diff[pt.y][pt.x];
+			DWORD diffus = Orbit->light_diff[pt.y][pt.x];
 			int i;
-			MAP3D_POINT *ppt = &map_rotate[pt.y][pt.x];
+			MAP3D_POINT *ppt = &Orbit->map_rotate[pt.y][pt.x];
 			int lvf; // light variance factor
 	
 			if (diffus == 0)
@@ -745,8 +739,8 @@ RenderPlanetSphere (FRAME MaskFrame, int
 			// get pixel from topo map and factor from light variance map
 			if (ppt->m[0] == 0) 
 			{	// exact pixel from the topo map
-				c = get_map_pixel (pixels, ppt->p[0].x, ppt->p[0].y);
-				lvf = get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y, offset);
+				c = get_map_pixel (pixels, ppt->p[0].x, ppt->p[0].y, width, spherespanx);
+				lvf = get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y, offset, width);
 			}
 			else
 			{	// fractional pixel -- blend from 4
@@ -755,7 +749,7 @@ RenderPlanetSphere (FRAME MaskFrame, int
 
 				// compute 'ideal' pixel
 				for (i = 0; i < 4; i++)
-					p[i] = get_map_pixel (pixels, ppt->p[i].x, ppt->p[i].y);
+					p[i] = get_map_pixel (pixels, ppt->p[i].x, ppt->p[i].y, width, spherespanx);
 				
 				c.r = get_avg_channel (p, ppt->m, 0);
 				c.g = get_avg_channel (p, ppt->m, 1);
@@ -764,13 +758,13 @@ RenderPlanetSphere (FRAME MaskFrame, int
 				// compute 'ideal' light variance
 				for (i = 0, lvsum = 0; i < 4; i++)
 					lvsum += get_map_elev (elevs, ppt->p[0].x, ppt->p[0].y,
-							offset) * ppt->m[i];
+							       offset, width) * ppt->m[i];
 				lvf = lvsum >> AA_WEIGHT_BITS;
 			}
 		
 			// Apply the lighting model.  This also bounds the sphere
 			// to make it circular.
-			if (pSolarSysState->pOrbitalDesc->data_index & PLANET_SHIELDED)
+			if (shielded)
 			{
 				int r;
 				
@@ -808,12 +802,12 @@ RenderPlanetSphere (FRAME MaskFrame, int
 		}
 	}
 	
-	WriteFramePixelColors (MaskFrame, Orbit->ScratchArray, DIAMETER, DIAMETER);
-	SetFrameHot (MaskFrame, MAKE_HOT_SPOT (RADIUS + 1, RADIUS + 1));
+	WriteFramePixelColors (MaskFrame, Orbit->ScratchArray, diameter, diameter);
+	SetFrameHot (MaskFrame, MAKE_HOT_SPOT (radius + 1, radius + 1));
 
 #if PROFILE_ROTATION
 	t += clock() - t1;
-	if (frames_done == MAP_WIDTH)
+	if (frames_done == width)
 	{
 		log_add (log_Debug, "Rotation frames/sec: %d/%ld(msec)=%f",
 				frames_done,
@@ -831,18 +825,18 @@ RenderPlanetSphere (FRAME MaskFrame, int
 #define RANGE_SHIFT 6
 
 static void
-DitherMap (SBYTE *DepthArray)
+DitherMap (SBYTE *DepthArray, COUNT width, COUNT height)
 {
 #define DITHER_VARIANCE  (1 << (RANGE_SHIFT - 3))
-	COUNT i;
+	DWORD i;  // JMS_GFX: changed from COUNT to avoid overflow at higher resolutions.
 	SBYTE *elev;
 	DWORD rand_val = 0;
 
-	for (i = 0, elev = DepthArray; i < MAP_WIDTH * MAP_HEIGHT; ++i, ++elev)
+	for (i = 0, elev = DepthArray; i < (DWORD)(width * height); ++i, ++elev)
 	{
 		// Use up the random value byte by byte
 		if ((i & 3) == 0)
-			rand_val = RandomContext_Random (SysGenRNG);
+			rand_val = TFB_Random ();
 		else
 			rand_val >>= 8;
 
@@ -853,14 +847,14 @@ DitherMap (SBYTE *DepthArray)
 
 static void
 MakeCrater (RECT *pRect, SBYTE *DepthArray, SIZE rim_delta, SIZE
-		crater_delta, BOOLEAN SetDepth)
+		crater_delta, BOOLEAN SetDepth, COUNT width)
 {
 	COORD x, y, lf_x, rt_x;
 	SIZE A, B;
-	long Asquared, TwoAsquared,
-				Bsquared, TwoBsquared;
-	long d, dx, dy;
-	COUNT TopIndex, BotIndex, rim_pixels;
+	SDWORD Asquared, TwoAsquared, Bsquared, TwoBsquared;	// JMS_GFX: Was 'long' - type changed to conform to UQM's own types
+	SDWORD d, dx, dy;									// JMS_GFX: Was 'long' - type changed to conform to UQM's own types
+	DWORD TopIndex, BotIndex, rim_pixels; // JMS_GFX: Was COUNT - type changed because of overflow at 4x
+ 
 
 	A = pRect->extent.width >> 1;
 	B = pRect->extent.height >> 1;
@@ -879,8 +873,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 
 	A += pRect->corner.x;
 	B += pRect->corner.y;
-	TopIndex = (B - y) * MAP_WIDTH;
-	BotIndex = (B + y) * MAP_WIDTH;
+	TopIndex = (B - y) * width;
+	BotIndex = (B + y) * width;
 	rim_pixels = 1;
 	while (dx < dy)
 	{
@@ -932,8 +926,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 			}
 		
 			--y;
-			TopIndex += MAP_WIDTH;
-			BotIndex -= MAP_WIDTH;
+			TopIndex += width;
+			BotIndex -= width;
 			dy -= TwoAsquared;
 			d -= dy;
 		}
@@ -1001,8 +995,8 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 
 		rim_pixels = 1;
 		--y;
-		TopIndex += MAP_WIDTH;
-		BotIndex -= MAP_WIDTH;
+		TopIndex += width;
+		BotIndex -= width;
 		dy -= TwoAsquared;
 		d += Asquared - dy;
 	}
@@ -1044,9 +1038,9 @@ MakeCrater (RECT *pRect, SBYTE *DepthArr
 #define NUM_BAND_COLORS 4
 
 static void
-MakeStorms (COUNT storm_count, SBYTE *DepthArray)
+MakeStorms (COUNT storm_count, SBYTE *DepthArray, COUNT width, COUNT height)
 {
-#define MAX_STORMS 8
+#define MAX_STORMS 12 // JMS_GFX: was 8
 	COUNT i;
 	RECT storm_r[MAX_STORMS];
 	RECT *pstorm_r;
@@ -1069,25 +1063,18 @@ MakeStorms (COUNT storm_count, SBYTE *De
 			rand_val = RandomContext_Random (SysGenRNG);
 			loword = LOWORD (rand_val);
 			hiword = HIWORD (rand_val);
-			switch (HIBYTE (hiword) & 31)
-			{
+			switch (HIBYTE (hiword) & 31) {
 				case 0:
-					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 2))
-							+ (MAP_HEIGHT >> 2);
+					pstorm_r->extent.height = (LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 2)) + (ORIGINAL_MAP_HEIGHT >> 2);
 					break;
 				case 1:
 				case 2:
 				case 3:
 				case 4:
-					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 3))
-							+ (MAP_HEIGHT >> 3);
+					pstorm_r->extent.height = (LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 3)) + (ORIGINAL_MAP_HEIGHT >> 3);
 					break;
 				default:
-					pstorm_r->extent.height =
-							(LOBYTE (hiword) % (MAP_HEIGHT >> 4))
-							+ 4;
+					pstorm_r->extent.height = (LOBYTE (hiword) % (ORIGINAL_MAP_HEIGHT >> 4)) + 4;
 					break;
 			}
 
@@ -1098,13 +1085,15 @@ MakeStorms (COUNT storm_count, SBYTE *De
 			loword = LOWORD (rand_val);
 			hiword = HIWORD (rand_val);
 
-			pstorm_r->extent.width = pstorm_r->extent.height
-					+ (LOBYTE (loword) % pstorm_r->extent.height);
+			pstorm_r->extent.width = pstorm_r->extent.height + (LOBYTE (loword) % pstorm_r->extent.height);
 
-			pstorm_r->corner.x = HIBYTE (loword)
-					% (MAP_WIDTH - pstorm_r->extent.width);
-			pstorm_r->corner.y = LOBYTE (loword)
-					% (MAP_HEIGHT - pstorm_r->extent.height);
+			pstorm_r->corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - pstorm_r->extent.width);
+			pstorm_r->corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - pstorm_r->extent.height);
+
+			pstorm_r->corner.x = pstorm_r->corner.x * width / ORIGINAL_MAP_WIDTH;
+			pstorm_r->extent.width = pstorm_r->extent.width * width / ORIGINAL_MAP_WIDTH;
+			pstorm_r->corner.y = pstorm_r->corner.y * height / ORIGINAL_MAP_HEIGHT;
+			pstorm_r->extent.height = pstorm_r->extent.height * height / ORIGINAL_MAP_HEIGHT;
 
 			for (j = i + 1; j < storm_count; ++j)
 			{
@@ -1124,7 +1113,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 
 		} while (intersect);
 
-		MakeCrater (pstorm_r, DepthArray, 6, 6, FALSE);
+		MakeCrater (pstorm_r, DepthArray, 6, 6, FALSE, width);
 		++pstorm_r->corner.x;
 		++pstorm_r->corner.y;
 		pstorm_r->extent.width -= 2;
@@ -1132,8 +1121,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 
 		band_delta = HIBYTE (loword) & ((3 << RANGE_SHIFT) + 20);
 
-		MakeCrater (pstorm_r, DepthArray,
-				band_delta, band_delta, TRUE);
+		MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 		++pstorm_r->corner.x;
 		++pstorm_r->corner.y;
 		pstorm_r->extent.width -= 2;
@@ -1142,8 +1130,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		band_delta += 2;
 		if (pstorm_r->extent.width > 2 && pstorm_r->extent.height > 2)
 		{
-			MakeCrater (pstorm_r, DepthArray,
-					band_delta, band_delta, TRUE);
+			MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 			++pstorm_r->corner.x;
 			++pstorm_r->corner.y;
 			pstorm_r->extent.width -= 2;
@@ -1153,8 +1140,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		band_delta += 2;
 		if (pstorm_r->extent.width > 2 && pstorm_r->extent.height > 2)
 		{
-			MakeCrater (pstorm_r, DepthArray,
-					band_delta, band_delta, TRUE);
+			MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 			++pstorm_r->corner.x;
 			++pstorm_r->corner.y;
 			pstorm_r->extent.width -= 2;
@@ -1162,8 +1148,7 @@ MakeStorms (COUNT storm_count, SBYTE *De
 		}
 
 		band_delta += 4;
-		MakeCrater (pstorm_r, DepthArray,
-				band_delta, band_delta, TRUE);
+		MakeCrater (pstorm_r, DepthArray, band_delta, band_delta, TRUE, width);
 	}
 }
 
@@ -1178,14 +1163,14 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 	UWORD loword, hiword;
 	DWORD rand_val;
 
-	band_height = pRect->extent.height / num_bands;
-	band_bump = pRect->extent.height % num_bands;
+	// band_height = pRect->extent.height / num_bands;
+	band_height = ORIGINAL_MAP_HEIGHT / num_bands;
+	// band_bump = pRect->extent.height % num_bands;
+	band_bump = ORIGINAL_MAP_HEIGHT % num_bands;
 	band_error = num_bands >> 1;
 	lpDst = DepthArray;
 
-	band_delta = ((LOWORD (RandomContext_Random (SysGenRNG))
-			& (NUM_BAND_COLORS - 1)) << RANGE_SHIFT)
-			+ (1 << (RANGE_SHIFT - 1));
+	band_delta = ((LOWORD (RandomContext_Random (SysGenRNG)) & (NUM_BAND_COLORS - 1)) << RANGE_SHIFT) + (1 << (RANGE_SHIFT - 1));
 	last_y = next_y = 0;
 	for (i = num_bands; i > 0; --i)
 	{
@@ -1207,23 +1192,22 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 		{
 			RECT r;
 
-			cur_y = next_y
-					+ ((band_height - 2) >> 1)
-					- ((LOBYTE (hiword) % (band_height - 2)) + 1);
+			cur_y = next_y + ((band_height - 2) >> 1) - ((LOBYTE (hiword) % (band_height - 2)) + 1);
+			cur_y = cur_y * pRect->extent.height / ORIGINAL_MAP_HEIGHT;
 			r.corner.x = r.corner.y = 0;
 			r.extent.width = pRect->extent.width;
-			r.extent.height = 5;
+			r.extent.height = 5 * pRect->extent.height / ORIGINAL_MAP_HEIGHT;
 			DeltaTopography (50,
-					&DepthArray[(cur_y - 2) * r.extent.width],
+					&DepthArray[(cur_y - (r.extent.height >>1)) * r.extent.width],
 					&r, depth_delta);
 		}
 
-		for (j = cur_y - last_y; j > 0; --j)
-		{
+		for (j = cur_y - last_y; j > 0; --j) {
 			COUNT k;
 
-			for (k = pRect->extent.width; k > 0; --k)
+			for (k = pRect->extent.width; k > 0; --k){
 				*lpDst++ += band_delta;
+			}
 		}
 
 		last_y = cur_y;
@@ -1232,21 +1216,21 @@ MakeGasGiant (COUNT num_bands, SBYTE *De
 				& (((1 << RANGE_SHIFT) * NUM_BAND_COLORS) - 1);
 	}
 
-	MakeStorms (4 + (RandomContext_Random (SysGenRNG) & 3) + 1, DepthArray);
+	MakeStorms (4 + (TFB_Random () & 7) + 1, DepthArray, pRect->extent.width, pRect->extent.height);
 
-	DitherMap (DepthArray);
+	DitherMap (DepthArray, pRect->extent.width, pRect->extent.height);
 }
 
 static void
-ValidateMap (SBYTE *DepthArray)
+ValidateMap (SBYTE *DepthArray, COUNT width, COUNT height)
 {
 	BYTE state;
 	BYTE pixel_count[2], lb[2];
 	SBYTE last_byte;
-	COUNT i;
+	DWORD i;
 	SBYTE *lpDst;
 
-	i = MAP_WIDTH - 1;
+	i = width - 1;
 	lpDst = DepthArray;
 	last_byte = *lpDst++;
 	state = pixel_count[0] = pixel_count[1] = 0;
@@ -1268,7 +1252,7 @@ ValidateMap (SBYTE *DepthArray)
 		last_byte = *lpDst++;
 	} while (--i);
 
-	i = MAP_WIDTH * MAP_HEIGHT;
+	i = width * height;
 	lpDst = DepthArray;
 	if (pixel_count[0] > pixel_count[1])
 		last_byte = lb[0];
@@ -1291,24 +1275,38 @@ ValidateMap (SBYTE *DepthArray)
 }
 
 static void
-planet_orbit_init (void)
+PlanetOrbitInit (COUNT width, COUNT height, BOOLEAN inOrbit)
 {
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
+	COUNT ShieldRadius = (height >> 1) * SHIELD_RADIUS / RADIUS;
+	COUNT ShieldDiam = (ShieldRadius << 1) + 1;
+	COUNT Diameter = height + 1;	
+	COUNT SphereSpanX = height;
+	COUNT i;
+
 
 	Orbit->SphereFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP | WANT_ALPHA, DIAMETER, DIAMETER, 2));
-	Orbit->TintFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP, MAP_WIDTH, MAP_HEIGHT, 1));
+			WANT_PIXMAP | WANT_ALPHA, Diameter, Diameter, 2));
 	Orbit->ObjectFrame = 0;
 	Orbit->WorkFrame = 0;
-	Orbit->lpTopoData = HCalloc (MAP_WIDTH * MAP_HEIGHT);
-	Orbit->TopoZoomFrame = CaptureDrawable (CreateDrawable (
-			WANT_PIXMAP, MAP_WIDTH << 2, MAP_HEIGHT << 2, 1));
-	Orbit->TopoColors = HMalloc (sizeof (Orbit->TopoColors[0])
-			* (MAP_HEIGHT * (MAP_WIDTH + SPHERE_SPAN_X)));
+	Orbit->lpTopoData = HCalloc (width * height);
+	Orbit->TopoColors = HMalloc (sizeof (Orbit->TopoColors[0]) 
+		* (height * (width + SphereSpanX)));
 	// always allocate the scratch array to largest needed size
-	Orbit->ScratchArray = HMalloc (sizeof (Orbit->ScratchArray[0])
-			* (SHIELD_DIAM) * (SHIELD_DIAM));
+	Orbit->ScratchArray = HMalloc (sizeof (Orbit->ScratchArray[0]) * (ShieldDiam) * (ShieldDiam));
+	Orbit->light_diff = HMalloc (sizeof (DWORD *) * Diameter);
+	Orbit->map_rotate = HMalloc (sizeof (MAP3D_POINT *) * Diameter);
+	for (i=0 ; i < Diameter ; i++) {
+		Orbit->light_diff[i] = HMalloc (sizeof (DWORD)* Diameter);
+		Orbit->map_rotate[i] = HMalloc (sizeof (MAP3D_POINT) * Diameter);
+	}
+
+	if (inOrbit){
+		Orbit->TintFrame = CaptureDrawable (CreateDrawable (
+				WANT_PIXMAP, width, height, 1));
+		Orbit->TopoZoomFrame = CaptureDrawable (CreateDrawable (
+				WANT_PIXMAP, width << 2, height << 2, 1));
+	}
 }
 
 static unsigned
@@ -1542,7 +1540,7 @@ TopoScale4x (SBYTE *pDstTopo, SBYTE *pSr
 // Lots of pure Voodoo here ;)
 //  the goal is a 3D illusion, not mathematically correct lighting
 
-#define LMAP_AVG_BLOCK    ((MAP_HEIGHT + 4) / 5)
+#define LMAP_AVG_BLOCK     ((75 + 4) / 5) // BW: hacky but this shouldn't really depend on the size of the original map
 #define LMAP_MAX_DIST     ((LMAP_AVG_BLOCK + 1) >> 1)
 #define LMAP_WEIGHT_THRES (LMAP_MAX_DIST * 2 / 3)
 
@@ -1555,7 +1553,7 @@ typedef struct
 } elev_block_t;
 
 static inline void
-get_vblock_avg (elev_block_t *pblk, SBYTE *pTopo, int x, int y)
+get_vblock_avg (elev_block_t *pblk, SBYTE *pTopo, int x, int y, COUNT width, COUNT height)
 {
 	SBYTE *elev = pTopo;
 	int y0, y1, i;
@@ -1563,17 +1561,17 @@ get_vblock_avg (elev_block_t *pblk, SBYT
 	int avg = 0, total_weight = 0;
 
 	// surface wraps around along x
-	x = (x + MAP_WIDTH) % MAP_WIDTH;
+	x = (x + width) % width;
 	
 	y0 = y - LMAP_MAX_DIST;
 	y1 = y + LMAP_MAX_DIST;
 	if (y0 < 0)
 		y0 = 0;
-	if (y1 > MAP_HEIGHT)
-		y1 = MAP_HEIGHT;
+	if (y1 > height)
+		y1 = height;
 
-	elev = pTopo + y0 * MAP_WIDTH + x;
-	for (i = y0; i < y1; ++i, elev += MAP_WIDTH)
+	elev = pTopo + y0 * height + x;
+	for (i = y0; i < y1; ++i, elev += height)
 	{
 		int delta = abs (i - y);
 		int weight = 255; // full weight
@@ -1589,7 +1587,7 @@ get_vblock_avg (elev_block_t *pblk, SBYT
 			max = v;
 		if (v < min)
 			min = v;
-		avg += v * weight;
+		avg += pblk->avg * weight;
 		total_weight += weight;
 	}
 	avg /= total_weight;
@@ -1605,13 +1603,15 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 {
 #define LMAP_BLOCKS       (2 * LMAP_MAX_DIST + 1)
 	int x, y;
-	elev_block_t vblocks[LMAP_BLOCKS];
-			// we use a running block average to reduce the amount of work
-			// where a block is a vertical line of map points
+
 	SBYTE *elev;
 	int min, max, med;
 	int sfact, spread;
 
+	elev_block_t vblocks[LMAP_BLOCKS];
+	// we use a running block average to reduce the amount of work
+	// where a block is a vertical line of map points
+
 	// normalize the topo data
 	min = 127;
 	max = -128;
@@ -1663,7 +1663,7 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 			// blocks wrap around on both sides
 			pblk = vblocks + ((i + LMAP_BLOCKS) % LMAP_BLOCKS);
 
-			get_vblock_avg (pblk, pTopo, i, y);
+			get_vblock_avg (pblk, pTopo, i, y, w, h);
 		}
 
 		for (x = 0; x < w; ++x, ++elev)
@@ -1675,7 +1675,7 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 
 			// prepare next block as we move along x
 			pblk = vblocks + ((x + LMAP_MAX_DIST) % LMAP_BLOCKS);
-			get_vblock_avg (pblk, pTopo, x + LMAP_MAX_DIST, y);
+			get_vblock_avg (pblk, pTopo, x + LMAP_MAX_DIST, y, w, h);
 
 			// compute the min, max and weighted avg of blocks
 			for (i = x - LMAP_MAX_DIST; i <= x + LMAP_MAX_DIST; ++i)
@@ -1718,25 +1718,32 @@ GenerateLightMap (SBYTE *pTopo, int w, i
 	}
 }
 
-// Sets the SysGenRNG to the required state first.
 void
-GeneratePlanetSurface (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame)
-{
+GeneratePlanetSurface (PLANET_DESC *pPlanetDesc, FRAME SurfDefFrame, COUNT Width, COUNT Height, BOOLEAN inOrbit) {
 	RECT r;
 	const PlanetFrame *PlanDataPtr;
 	PLANET_INFO *PlanetInfo = &pSolarSysState->SysInfo.PlanetInfo;
-	COUNT i, y;
+	DWORD i, y; 
 	POINT loc;
-	CONTEXT OldContext;
-	CONTEXT TopoContext;
+	COUNT SphereSpanX, Radius;
+	CONTEXT OldContext, TopoContext;
 	PLANET_ORBIT *Orbit = &pSolarSysState->Orbit;
+	BOOLEAN SurfDef = FALSE;
 	BOOLEAN shielded = (pPlanetDesc->data_index & PLANET_SHIELDED) != 0;
 
+	/*if(!inOrbit){
+		Width = Width << RESOLUTION_FACTOR;
+		Height = Height << RESOLUTION_FACTOR;
+	}*/
+	
+	SphereSpanX = (inOrbit ? SPHERE_SPAN_X : Height);
+	Radius = (inOrbit ? RADIUS : ((SphereSpanX >> 1) - RESOLUTION_FACTOR)) ;
+
 	RandomContext_SeedRandom (SysGenRNG, pPlanetDesc->rand_seed);
 
 	TopoContext = CreateContext ("Plangen.TopoContext");
 	OldContext = SetContext (TopoContext);
-	planet_orbit_init ();
+	PlanetOrbitInit (Width, Height, inOrbit);
 
 	PlanDataPtr = &PlanData[pPlanetDesc->data_index & ~PLANET_SHIELDED];
 
@@ -1744,15 +1751,17 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	{	// This is a defined planet; pixmap for the topography and
 		// elevation data is supplied in Surface Definition frame
 		BOOLEAN DeleteDef = FALSE;
+		BOOLEAN DeleteElev = FALSE;
 		FRAME ElevFrame;
 
 		// surface pixmap
+		SurfDef = TRUE;
 		SurfDefFrame = SetAbsFrameIndex (SurfDefFrame, 0);
-		if (GetFrameWidth (SurfDefFrame) != MAP_WIDTH
-				|| GetFrameHeight (SurfDefFrame) != MAP_HEIGHT)
+		if (GetFrameWidth (SurfDefFrame) != Width
+				|| GetFrameHeight (SurfDefFrame) != Height)
 		{
 			pSolarSysState->TopoFrame = CaptureDrawable (RescaleFrame (
-					SurfDefFrame, MAP_WIDTH, MAP_HEIGHT));
+					SurfDefFrame, Width, Height, FALSE));
 			// will not need the passed FRAME anymore
 			DeleteDef = TRUE;
 		}
@@ -1765,40 +1774,66 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 			SBYTE* elev;
 
 			ElevFrame = SetAbsFrameIndex (SurfDefFrame, 1);
-			if (GetFrameWidth (ElevFrame) != MAP_WIDTH
-					|| GetFrameHeight (ElevFrame) != MAP_HEIGHT)
+			if (GetFrameWidth (ElevFrame) != Width
+					|| GetFrameHeight (ElevFrame) != Height)
 			{
 				ElevFrame = CaptureDrawable (RescaleFrame (ElevFrame,
-						MAP_WIDTH, MAP_HEIGHT));
+						Width, Height, TRUE));
+				DeleteElev = TRUE;
 			}
 
 			// grab the elevation data in 1 byte per pixel format
 			ReadFramePixelIndexes (ElevFrame, (BYTE *)Orbit->lpTopoData,
-					MAP_WIDTH, MAP_HEIGHT);
+					Width, Height, inOrbit);
 			// the supplied data is in unsigned format, must convert
-			for (i = 0, elev = Orbit->lpTopoData;
-					i < MAP_WIDTH * MAP_HEIGHT;
-					++i, ++elev)
-			{
+			for (i = 0, elev = Orbit->lpTopoData; i < Width * Height; ++i, ++elev) {
 				*elev = *(BYTE *)elev - 128;
 			}
 		}
 		else
 		{	// no elevation data -- planet flat as a pancake
-			memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
+			memset (Orbit->lpTopoData, 0, Width * Height);
+		}
+
+		// JMS: Planets with special colormaps
+		if (pPlanetDesc->alternate_colormap) {
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (pPlanetDesc->alternate_colormap));
+			pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (SPECIAL_CMAP_XLAT_TAB));
+		} else { // JMS: Normal planets
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
+				LoadColorMap (PlanDataPtr->CMapInstance));
+			pSolarSysState->XlatRef = CaptureStringTable (
+				LoadStringTable (PlanDataPtr->XlatTabInstance));
+
+			if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD) {
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 2);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 2);
+			} else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD) {
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 1);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 1);
+			}
 		}
+		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
 
 		if (DeleteDef)
 			DestroyDrawable (ReleaseDrawable (SurfDefFrame));
+		if (DeleteElev)
+			DestroyDrawable (ReleaseDrawable (ElevFrame));
 	}
 	else
 	{	// Generate planet surface elevation data and look
 
 		r.corner.x = r.corner.y = 0;
-		r.extent.width = MAP_WIDTH;
-		r.extent.height = MAP_HEIGHT;
+		r.extent.width = Width;
+		r.extent.height = Height;
 		{
-			memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
+			memset (Orbit->lpTopoData, 0, Width * Height);
 			switch (PLANALGO (PlanDataPtr->Type))
 			{
 				case GAS_GIANT_ALGO:
@@ -1821,82 +1856,112 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 						switch (HIBYTE (loword) & 31)
 						{
 							case 0:
-								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 2))
-										+ (MAP_HEIGHT >> 2);
+								crater_r.extent.width = (LOBYTE (loword) 
+									% (ORIGINAL_MAP_HEIGHT >> 2)) 
+									+ (ORIGINAL_MAP_HEIGHT >> 2);
 								break;
 							case 1:
 							case 2:
 							case 3:
 							case 4:
-								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 3))
-										+ (MAP_HEIGHT >> 3);
+								crater_r.extent.width = (LOBYTE (loword) 
+									% (ORIGINAL_MAP_HEIGHT >> 3)) 
+									+ (ORIGINAL_MAP_HEIGHT >> 3);
 								break;
 							default:
-								crater_r.extent.width =
-										(LOBYTE (loword) % (MAP_HEIGHT >> 4))
-										+ 4;
+								crater_r.extent.width = (LOBYTE (loword) 
+									% (ORIGINAL_MAP_HEIGHT >> 4)) + 4;
 								break;
 						}
-					
+
 						loword = LOWORD (RandomContext_Random (SysGenRNG));
+
 						crater_r.extent.height = crater_r.extent.width;
-						crater_r.corner.x = HIBYTE (loword)
-								% (MAP_WIDTH - crater_r.extent.width);
-						crater_r.corner.y = LOBYTE (loword)
-								% (MAP_HEIGHT - crater_r.extent.height);
+						crater_r.corner.x = HIBYTE (loword) % (ORIGINAL_MAP_WIDTH - crater_r.extent.width);
+						// crater_r.corner.x = loword % (MAP_WIDTH - crater_r.extent.width); // JMS_GFX: changed the previous line to this. BYTE was too small for 4x resolution
+						crater_r.corner.y = LOBYTE (loword) % (ORIGINAL_MAP_HEIGHT - crater_r.extent.height);
+						// crater_r.corner.y = hiword % (MAP_HEIGHT - crater_r.extent.height); // JMS_GFX: The same
+
+						// BW: ... then scale them up
+						crater_r.extent.width = crater_r.extent.width * Height / ORIGINAL_MAP_HEIGHT;
+						crater_r.extent.height = crater_r.extent.width;
+						crater_r.corner.x = crater_r.corner.x * Width / ORIGINAL_MAP_WIDTH;					
+						crater_r.corner.y = crater_r.corner.y * Height / ORIGINAL_MAP_HEIGHT;
+
 						MakeCrater (&crater_r, Orbit->lpTopoData,
 								PlanDataPtr->fault_depth << 2,
 								-(PlanDataPtr->fault_depth << 2),
-								FALSE);
+								FALSE, Width);
 					}
 
 					if (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO)
-						DitherMap (Orbit->lpTopoData);
-					ValidateMap (Orbit->lpTopoData);
+						DitherMap (Orbit->lpTopoData, Width, Height);
+					ValidateMap (Orbit->lpTopoData, Width, Height);
 					break;
 			}
 		}
 		pSolarSysState->TopoFrame = CaptureDrawable (
-				CreateDrawable (WANT_PIXMAP, (SIZE)MAP_WIDTH,
-				(SIZE)MAP_HEIGHT, 1));
-		pSolarSysState->OrbitalCMap = CaptureColorMap (
+				CreateDrawable (WANT_PIXMAP, (SIZE)Width,
+				(SIZE)Height, 1));
+		if (inOrbit){
+			// JMS: Planets with special colormaps
+			if (pPlanetDesc->alternate_colormap) {
+				pSolarSysState->OrbitalCMap = CaptureColorMap (
+					LoadColorMap (pPlanetDesc->alternate_colormap));
+				pSolarSysState->XlatRef = CaptureStringTable (
+					LoadStringTable (SPECIAL_CMAP_XLAT_TAB));
+			} else { // JMS: Normal planets
+				pSolarSysState->OrbitalCMap = CaptureColorMap (
+					LoadColorMap (PlanDataPtr->CMapInstance));
+				pSolarSysState->XlatRef = CaptureStringTable (
+					LoadStringTable (PlanDataPtr->XlatTabInstance));
+			}
+			if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD) {
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 2);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 2);
+			} else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD) {
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 1);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 1);
+			}
+		} else {
+			pSolarSysState->OrbitalCMap = CaptureColorMap (
 				LoadColorMap (PlanDataPtr->CMapInstance));
-		pSolarSysState->XlatRef = CaptureStringTable (
+			pSolarSysState->XlatRef = CaptureStringTable (
 				LoadStringTable (PlanDataPtr->XlatTabInstance));
-
-		if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
-		{
-			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
-					pSolarSysState->OrbitalCMap, 2);
-			pSolarSysState->XlatRef = SetAbsStringTableIndex (
-					pSolarSysState->XlatRef, 2);
-		}
-		else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
-		{
-			pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
-					pSolarSysState->OrbitalCMap, 1);
-			pSolarSysState->XlatRef = SetAbsStringTableIndex (
-					pSolarSysState->XlatRef, 1);
+			if (PlanetInfo->SurfaceTemperature > HOT_THRESHOLD)
+			{
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 2);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 2);
+			}
+			else if (PlanetInfo->SurfaceTemperature > COLD_THRESHOLD)
+			{
+				pSolarSysState->OrbitalCMap = SetAbsColorMapIndex (
+						pSolarSysState->OrbitalCMap, 1);
+				pSolarSysState->XlatRef = SetAbsStringTableIndex (
+						pSolarSysState->XlatRef, 1);
+			}
 		}
 		pSolarSysState->XlatPtr = GetStringAddress (pSolarSysState->XlatRef);
-		RenderTopography (pSolarSysState->TopoFrame,
-				Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
-
+		RenderTopography (pSolarSysState->TopoFrame, Orbit->lpTopoData, Width, Height, FALSE);
 	}
 
-	if (!shielded && PlanetInfo->AtmoDensity != GAS_GIANT_ATMOSPHERE)
+	if (!shielded && PlanetInfo->AtmoDensity != GAS_GIANT_ATMOSPHERE && inOrbit)
 	{	// produce 4x scaled topo image for Planetside
 		// for the planets that we can land on
-		SBYTE *pScaledTopo = HMalloc (MAP_WIDTH * 4 * MAP_HEIGHT * 4);
+		SBYTE *pScaledTopo = HMalloc (Width * 4 * Height * 4);
 		if (pScaledTopo)
 		{
 			TopoScale4x (pScaledTopo, Orbit->lpTopoData,
 					PlanDataPtr->num_faults, PlanDataPtr->fault_depth
 					* (PLANALGO (PlanDataPtr->Type) == CRATERED_ALGO ? 2 : 1  ));
 			RenderTopography (Orbit->TopoZoomFrame, pScaledTopo,
-					MAP_WIDTH * 4, MAP_HEIGHT * 4);
+					Width * 4, Height * 4, SurfDef);
 
 			HFree (pScaledTopo);
 		}
@@ -1908,21 +1973,21 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	// It may be more efficient to build it from lpTopoData instead of the
 	// FRAMPTR though.
 	ReadFramePixelColors (pSolarSysState->TopoFrame, Orbit->TopoColors,
-			MAP_WIDTH + SPHERE_SPAN_X, MAP_HEIGHT);
-	// Extend the width from MAP_WIDTH to MAP_WIDTH+SPHERE_SPAN_X
-	for (y = 0; y < MAP_HEIGHT * (MAP_WIDTH + SPHERE_SPAN_X);
-			y += MAP_WIDTH + SPHERE_SPAN_X)
-		memcpy (Orbit->TopoColors + y + MAP_WIDTH, Orbit->TopoColors + y,
-				SPHERE_SPAN_X * sizeof (Orbit->TopoColors[0]));
+			Width + SphereSpanX, Height);
+	// Extend the Width from MAP_WIDTH to MAP_WIDTH+SPHERE_SPAN_X
+	for (y = 0; y < (DWORD)(Height * (Width + SphereSpanX));
+			y += Width + SphereSpanX)
+		memcpy (Orbit->TopoColors + y + Width, Orbit->TopoColors + y,
+				SphereSpanX * sizeof (Orbit->TopoColors[0]));
 
 	if (PLANALGO (PlanDataPtr->Type) != GAS_GIANT_ALGO)
 	{	// convert topo data to a light map, based on relative
 		// map point elevations
-		GenerateLightMap (Orbit->lpTopoData, MAP_WIDTH, MAP_HEIGHT);
+		GenerateLightMap (Orbit->lpTopoData, Width, Height);
 	}
 	else
 	{	// gas giants are pretty much flat
-		memset (Orbit->lpTopoData, 0, MAP_WIDTH * MAP_HEIGHT);
+		memset (Orbit->lpTopoData, 0, Width * Height);
 	}
 			
 	if (pSolarSysState->pOrbitalDesc->pPrevDesc ==
@@ -1936,19 +2001,26 @@ GeneratePlanetSurface (PLANET_DESC *pPla
 	}
 	
 	// Rotating planet sphere initialization
-	GenerateSphereMask (loc);
-	CreateSphereTiltMap (PlanetInfo->AxialTilt);
+	GenerateSphereMask (loc, Radius);
+	CreateSphereTiltMap (PlanetInfo->AxialTilt, Height, Radius);
 	if (shielded)
-		Orbit->ObjectFrame = CreateShieldMask ();
-	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded);
+		Orbit->ObjectFrame = CreateShieldMask (Radius);
+	InitSphereRotation (1 - 2 * (PlanetInfo->AxialTilt & 1), shielded, Width, Height);
 
-	if (shielded)
-	{	// This overwrites pSolarSysState->TopoFrame, so everything that
+	if (!inOrbit){
+		pPlanetDesc->rotDirection = 1 - 2 * (PlanetInfo->AxialTilt & 1);
+		pPlanetDesc->rotwidth = Width;
+		pPlanetDesc->rotheight = Height;
+		pPlanetDesc->rotFrameIndex = 0;
+		pPlanetDesc->rotPointIndex = 0; 
+		pPlanetDesc->rot_speed = ((double)(pPlanetDesc->rotwidth * pPlanetDesc->rotDirection * 240)) / PlanetInfo->RotationPeriod;
+	}
+
+	if (shielded) {	// This overwrites pSolarSysState->TopoFrame, so everything that
 		// needs it has to come before
 		ApplyShieldTint ();
 	}
 
 	SetContext (OldContext);
 	DestroyContext (TopoContext);
-}
-
+}
\ No newline at end of file
diff -ruNp src.orig/uqm/planets/pstarmap.c src/uqm/planets/pstarmap.c
--- src.orig/uqm/planets/pstarmap.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/pstarmap.c	2017-12-30 00:14:53 -0800
@@ -41,15 +41,25 @@
 #include "libs/graphics/gfx_common.h"
 #include "libs/mathlib.h"
 #include "libs/memlib.h"
-
+#include "../util.h"
+		// For get_fuel_to_sol()
 #include <stdlib.h>
 
+typedef enum {
+	NORMAL_STARMAP		  = 0,
+	PREWAR_STARMAP		  = 1,
+	CONSTELLATION_STARMAP = 2,
+	NUM_STARMAPS
+} CURRENT_STARMAP_SHOWN;
+
 
 static POINT cursorLoc;
 static POINT mapOrigin;
 static int zoomLevel;
 static FRAME StarMapFrame;
 
+static BOOLEAN show_prewar_situation; // JMS
+static CURRENT_STARMAP_SHOWN which_starmap; // JMS
 
 static inline long
 signedDivWithError (long val, long divisor)
@@ -276,16 +286,182 @@ GetSphereRect (FLEET_INFO *FleetPtr, REC
 	}
 }
 
+
+// JMS: For showing the SC1-era situation in starmap
+static void
+GetPrewarSphereRect (COUNT index, FLEET_INFO *FleetPtr, RECT *pRect, RECT *pRepairRect)
+{
+	long diameter;
+	
+	static const COUNT prewar_strengths[] =
+	{
+		RACE_PREWAR_STRENGTHS
+	};
+	static const POINT prewar_locations[] =
+	{
+		RACE_PREWAR_LOCATIONS
+	};
+	static const BOOLEAN prewar_name_unknown[] =
+	{
+		RACE_PREWAR_NAME_UNKNOWN
+	};
+
+	diameter = (long)(prewar_strengths[index] * 2);
+	pRect->extent.width = UNIVERSE_TO_DISPX (diameter) - UNIVERSE_TO_DISPX (0);
+	if (pRect->extent.width < 0)
+		pRect->extent.width = -pRect->extent.width;
+	else if (pRect->extent.width == 0)
+		pRect->extent.width = 1;
+	pRect->extent.height = UNIVERSE_TO_DISPY (diameter)
+			- UNIVERSE_TO_DISPY (0);
+	if (pRect->extent.height < 0)
+		pRect->extent.height = -pRect->extent.height;
+	else if (pRect->extent.height == 0)
+		pRect->extent.height = 1;
+
+	pRect->corner.x = UNIVERSE_TO_DISPX (prewar_locations[index].x);
+	pRect->corner.y = UNIVERSE_TO_DISPY (prewar_locations[index].y);
+	pRect->corner.x -= pRect->extent.width >> 1;
+	pRect->corner.y -= pRect->extent.height >> 1;
+
+	{
+		TEXT t;
+		STRING locString;
+
+		SetContextFont (TinyFont);
+
+		t.baseline.x = pRect->corner.x + (pRect->extent.width >> 1);
+		t.baseline.y = pRect->corner.y + (pRect->extent.height >> 1) - 1;
+		t.align = ALIGN_CENTER;
+		
+		if (prewar_name_unknown[index])
+		{
+			t.CharCount = 7;
+			t.pStr = GAME_STRING (STAR_STRING_BASE + 132);
+		}
+		else
+		{
+			locString = SetAbsStringTableIndex (FleetPtr->race_strings, 1);
+			t.CharCount = GetStringLength (locString);
+			t.pStr = (UNICODE *)GetStringAddress (locString);
+		}
+		
+		if (prewar_strengths[index])
+			TextRect (&t, pRepairRect, NULL);
+		
+		if (pRepairRect->corner.x <= 0)
+			pRepairRect->corner.x = 1;
+		else if (pRepairRect->corner.x + pRepairRect->extent.width >=
+				SIS_SCREEN_WIDTH)
+			pRepairRect->corner.x =
+					SIS_SCREEN_WIDTH - pRepairRect->extent.width - 1;
+		if (pRepairRect->corner.y <= 0)
+			pRepairRect->corner.y = 1;
+		else if (pRepairRect->corner.y + pRepairRect->extent.height >=
+				SIS_SCREEN_HEIGHT)
+			pRepairRect->corner.y =
+					SIS_SCREEN_HEIGHT - pRepairRect->extent.height - 1;
+
+		BoxUnion (pRepairRect, pRect, pRepairRect);
+		pRepairRect->extent.width++;
+		pRepairRect->extent.height++;
+	}
+}
+
+static void
+DrawFuelCircles ()
+{
+	RECT r;
+	long diameter;
+	long diameter_no_return;
+	POINT corner;
+	Color OldColor;
+	DWORD OnBoardFuel = !optInfiniteFuel ? GLOBAL_SIS (FuelOnBoard) : 0;
+
+	diameter = OnBoardFuel << 1;
+
+	/* Terribly ugly hack to keep this from being assigned
+	 * a negative value, and also to make sure the inner circle
+	 * is not drawn if we don't have enough fuel to get to Sol at
+	 * all.
+	 */
+	if (((OnBoardFuel) - (long)get_fuel_to_sol() < 0) ||
+		(get_fuel_to_sol () > OnBoardFuel))
+	{
+		diameter_no_return = 0;
+	} else
+	{
+		diameter_no_return = OnBoardFuel - get_fuel_to_sol();
+	}
+
+	if (LOBYTE (GLOBAL (CurrentActivity)) != IN_HYPERSPACE)
+		corner = CurStarDescPtr->star_pt;
+	else
+	{
+		corner.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+		corner.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+	}
+
+	/* Draw outer circle*/
+	r.extent.width = UNIVERSE_TO_DISPX (diameter)
+	                 - UNIVERSE_TO_DISPX (0);
+
+	if (r.extent.width < 0)
+		r.extent.width = -r.extent.width;
+
+	r.extent.height = UNIVERSE_TO_DISPY (diameter)
+	                  - UNIVERSE_TO_DISPY (0);
+
+	if (r.extent.height < 0)
+		r.extent.height = -r.extent.height;
+
+	r.corner.x = UNIVERSE_TO_DISPX (corner.x)
+	             - (r.extent.width >> 1);
+	r.corner.y = UNIVERSE_TO_DISPY (corner.y)
+	             - (r.extent.height >> 1);
+
+	OldColor = SetContextForeGroundColor (
+	                   BUILD_COLOR (MAKE_RGB15 (0x03, 0x03, 0x03), 0x22));
+	DrawFilledOval (&r);
+	SetContextForeGroundColor (OldColor);
+
+	/* Draw a second fuel circle showing the 'point of no return', past which there will
+	 * not be enough fuel to return to Sol.
+	 */
+
+	r.extent.width = UNIVERSE_TO_DISPX (diameter_no_return)
+	                 - UNIVERSE_TO_DISPX (0);
+
+	if (r.extent.width < 0)
+		r.extent.width = -r.extent.width;
+
+	r.extent.height = UNIVERSE_TO_DISPY (diameter_no_return)
+	                  - UNIVERSE_TO_DISPY (0);
+
+	if (r.extent.height < 0)
+		r.extent.height = -r.extent.height;
+
+	r.corner.x = UNIVERSE_TO_DISPX (corner.x)
+	             - (r.extent.width >> 1);
+	r.corner.y = UNIVERSE_TO_DISPY (corner.y)
+	             - (r.extent.height >> 1);
+
+	OldColor = SetContextForeGroundColor (
+	                   BUILD_COLOR (MAKE_RGB15 (0x04, 0x04, 0x05), 0x22));
+	DrawFilledOval (&r);
+	SetContextForeGroundColor (OldColor);
+}
+
 static void
 DrawStarMap (COUNT race_update, RECT *pClipRect)
 {
 #define GRID_DELTA 500
 	SIZE i;
 	COUNT which_space;
-	long diameter;
+	// long diameter;
 	RECT r, old_r;
 	POINT oldOrigin = {0, 0};
-	STAMP s;
+	STAMP s, nebula;
 	FRAME star_frame;
 	STAR_DESC *SDPtr;
 	BOOLEAN draw_cursor;
@@ -340,42 +516,8 @@ DrawStarMap (COUNT race_update, RECT *pC
 	ClearDrawable ();
 
 	// Draw the fuel range circle
-	if (race_update == 0
-			&& which_space < 2
-			&& (diameter = (long)GLOBAL_SIS (FuelOnBoard) << 1))
-	{
-		Color OldColor;
-
-		if (!inHQSpace ())
-			r.corner = CurStarDescPtr->star_pt;
-		else
-		{
-			r.corner.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
-			r.corner.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
-		}
-
-		// Cap the diameter to a sane range
-		if (diameter > MAX_X_UNIVERSE * 4)
-			diameter = MAX_X_UNIVERSE * 4;
-
-		r.extent.width = UNIVERSE_TO_DISPX (diameter)
-				- UNIVERSE_TO_DISPX (0);
-		if (r.extent.width < 0)
-			r.extent.width = -r.extent.width;
-		r.extent.height = UNIVERSE_TO_DISPY (diameter)
-				- UNIVERSE_TO_DISPY (0);
-		if (r.extent.height < 0)
-			r.extent.height = -r.extent.height;
-
-		r.corner.x = UNIVERSE_TO_DISPX (r.corner.x)
-				- (r.extent.width >> 1);
-		r.corner.y = UNIVERSE_TO_DISPY (r.corner.y)
-				- (r.extent.height >> 1);
-
-		OldColor = SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x03, 0x03, 0x03), 0x22));
-		DrawFilledOval (&r);
-		SetContextForeGroundColor (OldColor);
+	if (race_update == 0 && which_space < 2) {
+		DrawFuelCircles ();
 	}
 
 	for (i = MAX_Y_UNIVERSE + 1; i >= 0; i -= GRID_DELTA)
@@ -399,7 +541,7 @@ DrawStarMap (COUNT race_update, RECT *pC
 	}
 
 	star_frame = SetRelFrameIndex (StarMapFrame, 2);
-	if (which_space <= 1)
+	if (which_space <= 1 && which_starmap != CONSTELLATION_STARMAP)
 	{
 		COUNT index;
 		HFLEETINFO hStarShip, hNextShip;
@@ -408,6 +550,19 @@ DrawStarMap (COUNT race_update, RECT *pC
 			RACE_COLORS
 		};
 
+		// JMS: For drawing SC1-era starmap.
+		static const BOOLEAN prewar_name_unknown[] =
+		{
+			RACE_PREWAR_NAME_UNKNOWN
+		};
+		static const COUNT prewar_strengths[] =
+		{
+			RACE_PREWAR_STRENGTHS
+		};
+		const char name_androsynth[] = "Androsynth";
+		const char name_chenjesu[] = "Chenjesu";
+		const char name_mmrnmhrm[] = "Mmrnmhrm";
+
 		for (index = 0,
 				hStarShip = GetHeadLink (&GLOBAL (avail_race_q));
 				hStarShip != 0; ++index, hStarShip = hNextShip)
@@ -417,11 +572,16 @@ DrawStarMap (COUNT race_update, RECT *pC
 			FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 			hNextShip = _GetSuccLink (FleetPtr);
 
-			if (FleetPtr->known_strength)
+			if (FleetPtr->known_strength || 
+				(show_prewar_situation && prewar_strengths[index]))
 			{
 				RECT repair_r;
 
-				GetSphereRect (FleetPtr, &r, &repair_r);
+				if (show_prewar_situation)
+					GetPrewarSphereRect (index, FleetPtr, &r, &repair_r);
+				else
+					GetSphereRect (FleetPtr, &r, &repair_r);
+
 				if (r.corner.x < SIS_SCREEN_WIDTH
 						&& r.corner.y < SIS_SCREEN_HEIGHT
 						&& r.corner.x + r.extent.width > 0
@@ -448,11 +608,39 @@ DrawStarMap (COUNT race_update, RECT *pC
 					t.baseline.x = r.corner.x + (r.extent.width >> 1);
 					t.baseline.y = r.corner.y + (r.extent.height >> 1) - 1;
 					t.align = ALIGN_CENTER;
-					locString = SetAbsStringTableIndex (
-							FleetPtr->race_strings, 1);
-					t.CharCount = GetStringLength (locString);
-					t.pStr = (UNICODE *)GetStringAddress (locString);
-					TextRect (&t, &r, NULL);
+					// JMS: For drawing SC1-era starmap.
+					if (show_prewar_situation && prewar_name_unknown[index])
+					{
+						t.CharCount = 7;
+						t.pStr = GAME_STRING (STAR_STRING_BASE + 132);
+					}
+					// JMS: A kludgy way to fix Mrns, Chenjesus and Andros' names.
+					else if (show_prewar_situation && 
+						(index == 1 || index == 16 || index == 20))
+					{
+						if (index == 1)
+						{
+							t.CharCount = 8;
+							t.pStr = (UNICODE *)name_mmrnmhrm;
+						}
+						else if (index == 16)
+						{
+							t.CharCount = 8;
+							t.pStr = (UNICODE *)name_chenjesu;
+						}
+						else if (index == 20)
+						{
+							t.CharCount = 10;
+							t.pStr = (UNICODE *)name_androsynth;
+						}
+					}
+					else
+					{
+						locString = SetAbsStringTableIndex (
+								FleetPtr->race_strings, 1);
+						t.CharCount = GetStringLength (locString);
+						t.pStr = (UNICODE *)GetStringAddress (locString);
+					}
 
 					if (r.corner.x <= 0)
 						t.baseline.x -= r.corner.x - 1;
@@ -475,7 +663,9 @@ DrawStarMap (COUNT race_update, RECT *pC
 							0xff : c.b + CC5TO8 (0x03);
 
 					SetContextForeGroundColor (c);
-					font_DrawText (&t);
+					if ((!show_prewar_situation) ||
+						(show_prewar_situation && prewar_strengths[index]))
+						font_DrawText (&t);
 				}
 			}
 
@@ -507,7 +697,29 @@ DrawStarMap (COUNT race_update, RECT *pC
 
 		++SDPtr;
 	} while (SDPtr->star_pt.x <= MAX_X_UNIVERSE
-			&& SDPtr->star_pt.y <= MAX_Y_UNIVERSE);
+			&& SDPtr->star_pt.y <= MAX_Y_UNIVERSE);	
+	
+	// JMS: Draw a sexy nebula on the map's background (Only in Hyperspace, not in Quasispace).
+	if (which_space <= 1)
+	{
+		nebula.origin.x = nebula.origin.y = 0;
+		nebula.frame = SetAbsFrameIndex (NebulaeFrame, 16);
+		DrawStamp(&nebula);
+	}
+
+	// JMS: This draws the constellation lines on the constellation starmap.
+	if (which_space <= 1 && which_starmap == CONSTELLATION_STARMAP)
+	{
+		s.frame = SetAbsFrameIndex (ConstellationsFrame, 0);
+		DrawStamp (&s);
+		
+		// JMS: If we have a separate frame containing the constellation names, display it.
+		if (GetFrameCount(ConstellationsFrame) > 1)
+		{
+			s.frame = IncFrameIndex (s.frame);
+			DrawStamp (&s);
+		}
+	}
 
 	if (GET_GAME_STATE (ARILOU_SPACE))
 	{
@@ -581,7 +793,7 @@ EraseCursor (COORD curs_x, COORD curs_y)
 		r.extent.height = SIS_SCREEN_HEIGHT - r.corner.y;
 
 #ifndef OLD
-	RepairBackRect (&r);
+	RepairBackRect (&r, FALSE);
 #else /* NEW */
 	r.extent.height += r.corner.y & 1;
 	r.corner.y &= ~1;
@@ -592,7 +804,7 @@ EraseCursor (COORD curs_x, COORD curs_y)
 static void
 ZoomStarMap (SIZE dir)
 {
-#define MAX_ZOOM_SHIFT 4
+#define MAX_ZOOM_SHIFT (BYTE)(4 - RESOLUTION_FACTOR)
 	if (dir > 0)
 	{
 		if (zoomLevel < MAX_ZOOM_SHIFT)
@@ -671,6 +883,10 @@ UpdateCursorLocation (int sx, int sy, co
 			cursorLoc.y = MAX_Y_UNIVERSE;
 
 		s.origin.y = UNIVERSE_TO_DISPY (cursorLoc.y);
+		if (s.origin.y < 0) {
+			s.origin.y = 0;
+			cursorLoc.y = DISP_TO_UNIVERSEY (0);
+		}
 	}
 
 	if (s.origin.x < 0 || s.origin.y < 0
@@ -692,6 +908,9 @@ UpdateCursorLocation (int sx, int sy, co
 }
 
 #define CURSOR_INFO_BUFSIZE 256
+// JMS: How close to a star the cursor has to be to 'snap' into it.
+// Don't make this larger than 1 for lo-res(1x). Otherwise the cursor gets stuck on stars.
+#define CURSOR_SNAP_AREA (RES_CASE(0,1,2)) // MB: Fixed cursor snap area so that trying to autopilot to sol no longer selects sirius all the damn time unless you zoom in.
 
 static void
 UpdateCursorInfo (UNICODE *prevbuf)
@@ -701,23 +920,55 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	STAR_DESC *SDPtr;
 	STAR_DESC *BestSDPtr;
 
+	// JMS: Display star map title.
+	if (which_starmap == CONSTELLATION_STARMAP)
+	{	
+		// "- Known constellations -"
+		utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 4));
+	}
+	else if (which_starmap == PREWAR_STARMAP)
+	{	
+		// "- Old map from 2135 -"
+		utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 3));
+	}
+	else
+	{	
+		// "(Star Search: F6 | Toggle Maps: F7)"
+		utf8StringCopy (buf, sizeof (buf), GAME_STRING (FEEDBACK_STRING_BASE + 2));
+	}
+
 	pt.x = UNIVERSE_TO_DISPX (cursorLoc.x);
 	pt.y = UNIVERSE_TO_DISPY (cursorLoc.y);
 
 	SDPtr = BestSDPtr = 0;
 	while ((SDPtr = FindStar (SDPtr, &cursorLoc, 75, 75)))
 	{
-		if (UNIVERSE_TO_DISPX (SDPtr->star_pt.x) == pt.x
-				&& UNIVERSE_TO_DISPY (SDPtr->star_pt.y) == pt.y
-				&& (BestSDPtr == 0
-				|| STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
+		if ((UNIVERSE_TO_DISPX (SDPtr->star_pt.x) >= pt.x - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPX (SDPtr->star_pt.x) <= pt.x + CURSOR_SNAP_AREA)
+			&& (UNIVERSE_TO_DISPY (SDPtr->star_pt.y) >= pt.y - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPY (SDPtr->star_pt.y) <= pt.y + CURSOR_SNAP_AREA)
+			&& (BestSDPtr == 0 || STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
 			BestSDPtr = SDPtr;
 	}
 
 	if (BestSDPtr)
 	{
-		cursorLoc = BestSDPtr->star_pt;
-		GetClusterName (BestSDPtr, buf);
+		// JMS: For masking the names of QS portals not yet entered.
+		BYTE QuasiPortalsKnown[] =
+		{
+			QS_PORTALS_KNOWN
+		};
+		
+		// A star is near the cursor:
+		// Snap cursor onto star only in 1x res. In hi-res modes,
+		// snapping is done when the star is selected as auto-pilot target.
+		if (RESOLUTION_FACTOR == 0)
+			cursorLoc = BestSDPtr->star_pt;
+		
+		if (GET_GAME_STATE(ARILOU_SPACE_SIDE) >= 2
+			&& !(QuasiPortalsKnown[BestSDPtr->Postfix - 133]))
+			utf8StringCopy (buf, sizeof (buf),
+				GAME_STRING (STAR_STRING_BASE + 132));
+		else
+			GetClusterName (BestSDPtr, buf);
 	}
 	else
 	{	// No star found. Reset the coordinates to the cursor's location
@@ -761,14 +1012,40 @@ UpdateCursorInfo (UNICODE *prevbuf)
 	if (strcmp (buf, prevbuf) != 0)
 	{
 		strcpy (prevbuf, buf);
-		DrawSISMessage (buf);
+		// Cursor is on top of a star. Display its name.
+		if (BestSDPtr)
+			DrawSISMessage (buf);
+		// Cursor is elsewhere.
+		else
+		{
+			// In HS, display default star search button name.
+			if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+			{
+				CONTEXT OldContext;
+				OldContext = SetContext (OffScreenContext);
+				
+				if (show_prewar_situation)
+					SetContextForeGroundColor 
+						(BUILD_COLOR (MAKE_RGB15 (0x18, 0x00, 0x00), 0x00));
+				else
+					SetContextForeGroundColor 
+						(BUILD_COLOR (MAKE_RGB15 (0x0E, 0xA7, 0xD9), 0x00));
+						
+				DrawSISMessageEx (buf, -1, -1, DSME_MYCOLOR);
+				SetContext (OldContext);
+			}
+			// In QS, don't display star search button - the search is unusable.
+			else
+			{
+				strcpy (buf, "QuasiSpace");
+				DrawSISMessage (buf);
+			}
+		}
 	}
 }
 
-static void
-UpdateFuelRequirement (void)
-{
-	UNICODE buf[80];
+static int
+FuelRequired (void){
 	COUNT fuel_required;
 	DWORD f;
 	POINT pt;
@@ -789,6 +1066,15 @@ UpdateFuelRequirement (void)
 	else
 		fuel_required = square_root (f) + (FUEL_TANK_SCALE / 20);
 
+	return fuel_required;
+}
+
+static void
+UpdateFuelRequirement (void)
+{
+	UNICODE buf[80];
+	COUNT fuel_required = FuelRequired();
+
 	sprintf (buf, "%s %u.%u",
 			GAME_STRING (NAVIGATION_STRING_BASE + 4),
 			fuel_required / FUEL_TANK_SCALE,
@@ -1210,11 +1496,14 @@ DoStarSearch (MENU_STATE *pMS)
 static BOOLEAN
 DoMoveCursor (MENU_STATE *pMS)
 {
-#define MIN_ACCEL_DELAY (ONE_SECOND / 60)
-#define MAX_ACCEL_DELAY (ONE_SECOND / 8)
-#define STEP_ACCEL_DELAY (ONE_SECOND / 120)
+// MB: correcting previously-unusable acceleration values
+#define MIN_ACCEL_DELAY (ONE_SECOND / 50)
+#define MAX_ACCEL_DELAY (ONE_SECOND / 13)
+#define STEP_ACCEL_DELAY (ONE_SECOND / 180)
 	static UNICODE last_buf[CURSOR_INFO_BUFSIZE];
 	DWORD TimeIn = GetTimeCounter ();
+	static COUNT moveRepeats;
+	BOOLEAN isMove = FALSE;
 
 	if (!pMS->Initialized)
 	{
@@ -1244,30 +1533,60 @@ DoMoveCursor (MENU_STATE *pMS)
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SELECT])
 	{
-		GLOBAL (autopilot) = cursorLoc;
-#ifdef DEBUG
-		if (instantMove)
-		{
-			PlayMenuSound (MENU_SOUND_INVOKED);
-
-			if (inHQSpace ())
+		// JMS: The hi-res modes now have a user-friendly starmap cursor.
+		// The cursor finds a star even if the cursor is several pixels away from it (CURSOR_SNAP_AREA)
+		// The cursor centers on the star only when selected as an auto-pilot target.
+		if (RESOLUTION_FACTOR > 0)
+		{
+			STAR_DESC *SDPtr;
+			STAR_DESC *BestSDPtr;
+			POINT pt;
+			
+			pt.x = UNIVERSE_TO_DISPX (cursorLoc.x);
+			pt.y = UNIVERSE_TO_DISPY (cursorLoc.y);
+			SDPtr = BestSDPtr = 0;
+			
+			while ((SDPtr = FindStar (SDPtr, &cursorLoc, 75, 75)))
 			{
-				// Move to the new location immediately.
-				doInstantMove ();
+				if ((UNIVERSE_TO_DISPX (SDPtr->star_pt.x) >= pt.x - CURSOR_SNAP_AREA && UNIVERSE_TO_DISPX (SDPtr->star_pt.x) <= pt.x + CURSOR_SNAP_AREA)
+					&& (UNIVERSE_TO_DISPY (SDPtr->star_pt.y) >= pt.y -CURSOR_SNAP_AREA && UNIVERSE_TO_DISPY (SDPtr->star_pt.y) <= pt.y + CURSOR_SNAP_AREA)
+					&& (BestSDPtr == 0 || STAR_TYPE (SDPtr->Type) >= STAR_TYPE (BestSDPtr->Type)))
+					BestSDPtr = SDPtr;
 			}
-			else if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY)
-			{
-				// We're in a solar system; exit it.
-				GLOBAL (CurrentActivity) |= END_INTERPLANETARY;
 			
-				// Set a hook to move to the new location:
-				debugHook = doInstantMove;
+			if (BestSDPtr)
+			{
+				cursorLoc = BestSDPtr->star_pt;
+				UpdateCursorLocation (0, 0, &BestSDPtr->star_pt);
 			}
+		}
 
-			return FALSE;
+		// printf("Fuel Available: %d | Fuel Requirement: %d\n", GLOBAL_SIS (FuelOnBoard), FuelRequired());
+
+		if (optBubbleWarp) {
+			if (GLOBAL_SIS (FuelOnBoard) >= FuelRequired() || optInfiniteFuel){
+				GLOBAL (autopilot) = cursorLoc;
+				PlayMenuSound (MENU_SOUND_BUBBLEWARP);
+				if (inHQSpace ()) {
+					// Move to the new location immediately.
+					doInstantMove ();
+				} else if (LOBYTE (GLOBAL (CurrentActivity)) == IN_INTERPLANETARY) {
+					// We're in a solar system; exit it.
+					GLOBAL (CurrentActivity) |= END_INTERPLANETARY;			
+					// Set a hook to move to the new location:
+					debugHook = doInstantMove;
+				}
+				if(!optInfiniteFuel)
+					DeltaSISGauges (0, -FuelRequired(), 0);
+				
+				return FALSE;
+			} else { 
+				PlayMenuSound (MENU_SOUND_FAILURE);
+			}
+		} else {
+			GLOBAL (autopilot) = cursorLoc;
+			DrawStarMap (0, NULL);
 		}
-#endif
-		DrawStarMap (0, NULL);
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SEARCH])
 	{
@@ -1293,6 +1612,22 @@ DoMoveCursor (MENU_STATE *pMS)
 			PlayMenuSound (MENU_SOUND_FAILURE);
 		}
 	}
+	else if (PulsedInputState.menu[KEY_MENU_TOGGLEMAP] 
+		&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+	{
+		++which_starmap;
+		which_starmap %= NUM_STARMAPS;
+		
+		if (which_starmap == PREWAR_STARMAP) 
+			show_prewar_situation = TRUE;
+		else
+			show_prewar_situation = FALSE;
+	
+		DrawStarMap (0, NULL);
+		last_buf[0] = '\0';
+		UpdateCursorInfo (last_buf);
+		SleepThread (ONE_SECOND / 8);
+	}
 	else
 	{
 		SBYTE sx, sy;
@@ -1312,16 +1647,31 @@ DoMoveCursor (MENU_STATE *pMS)
 		if (PulsedInputState.menu[KEY_MENU_UP])      sy =   -1;
 		if (PulsedInputState.menu[KEY_MENU_DOWN])    sy =    1;
 
+		if (moveRepeats > 20)
+		{
+			sx *= 1 << RESOLUTION_FACTOR;
+			sy *= 1 << RESOLUTION_FACTOR;
+		}
+		// BW: we need to go through this because 4x only checks for
+		// input every ONE_SECOND/40 or so, thus reducing
+		// MIN_ACCEL_STEP is of no use. In practice it's similar.
+
 		if (sx != 0 || sy != 0)
 		{
 			UpdateCursorLocation (sx, sy, NULL);
 			UpdateCursorInfo (last_buf);
 			UpdateFuelRequirement ();
+			isMove = TRUE;
 		}
 
 		SleepThreadUntil (TimeIn + MIN_ACCEL_DELAY);
 	}
 
+	if (isMove)
+		++moveRepeats;
+	else
+		moveRepeats = 0;
+
 	flashCurrentLocation (NULL);
 
 	return !(GLOBAL (CurrentActivity) & CHECK_ABORT);
@@ -1574,6 +1924,10 @@ StarMap (void)
 
 	memset (&MenuState, 0, sizeof (MenuState));
 
+	// JMS: For showing SC1-era starmap / starmap with constellations.
+	show_prewar_situation = FALSE; 
+	which_starmap = NORMAL_STARMAP;
+
 	zoomLevel = 0;
 	mapOrigin.x = MAX_X_UNIVERSE >> 1;
 	mapOrigin.y = MAX_Y_UNIVERSE >> 1;
@@ -1597,6 +1951,15 @@ StarMap (void)
 	transition_pending = TRUE;
 	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
 		UpdateMap ();
+	else
+	{	// This zooms the Quasi map in by 2 if within the local Quasi star cluster.
+		if ((universe.x <= ARILOU_HOME_X && universe.y <= ARILOU_HOME_Y) 
+			&& (universe.x >= 4480 && universe.y >= 4580))
+			zoomLevel = 2;
+	}
+	
+	if(optSubmenu)
+		DrawSubmenu (2);
 
 	DrawStarMap (0, (RECT*)-1);
 	transition_pending = FALSE;
@@ -1621,6 +1984,9 @@ StarMap (void)
 	DrawSISMessage (NULL);
 	DrawStatusMessage (NULL);
 
+	if (optSubmenu)
+		DrawSubmenu (0);
+
 	if (GLOBAL (autopilot.x) == universe.x
 			&& GLOBAL (autopilot.y) == universe.y)
 		GLOBAL (autopilot.x) = GLOBAL (autopilot.y) = ~0;
diff -ruNp src.orig/uqm/planets/report.c src/uqm/planets/report.c
--- src.orig/uqm/planets/report.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/report.c	2017-12-30 00:14:53 -0800
@@ -33,8 +33,8 @@
 #include <string.h>
 
 
-#define NUM_CELL_COLS MAP_WIDTH / 6
-#define NUM_CELL_ROWS MAP_HEIGHT / 6
+#define NUM_CELL_COLS (MAP_WIDTH / (6 << RESOLUTION_FACTOR) + RES_CASE(0,3,7) - (optWhichFonts == OPT_PC ? 0 : RES_CASE(0,0,1))) // JMS_GFX 
+#define NUM_CELL_ROWS (MAP_HEIGHT / (6 << RESOLUTION_FACTOR) + RES_CASE(0,1,2)) // JMS_GFX
 #define MAX_CELL_COLS 40
 
 extern FRAME SpaceJunkFrame;
@@ -43,10 +43,20 @@ static void
 ClearReportArea (void)
 {
 	COUNT x, y;
+	BYTE emptycols, emptyrows;  // JMS_GFX
 	RECT r;
 	STAMP s;
 	COORD startx;
 
+	// JMS_GFX
+	if (RESOLUTION_FACTOR > 0) {
+		emptycols = NUM_CELL_COLS + 1;
+		emptyrows = NUM_CELL_ROWS + 1;
+	} else {
+		emptycols = NUM_CELL_COLS;
+		emptyrows = NUM_CELL_ROWS;
+	}
+
 	if (optWhichFonts == OPT_PC)
 		s.frame = SetAbsFrameIndex (SpaceJunkFrame, 21);
 	else
@@ -60,12 +70,12 @@ ClearReportArea (void)
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x00, 0x07, 0x00), 0x57));
 	
-	startx = 1 + (r.extent.width >> 1) - 1;
-	s.origin.y = 1;
-	for (y = 0; y < NUM_CELL_ROWS; ++y)
+	startx = 1 + (r.extent.width >> 1) - 1 - (4 * RESOLUTION_FACTOR) + RES_CASE(0,0,8);  // JMS_GFX
+	s.origin.y = 1 + RES_CASE(0,0,9);
+	for (y = 0; y < emptyrows; ++y)
 	{
 		s.origin.x = startx;
-		for (x = 0; x < NUM_CELL_COLS; ++x)
+		for (x = 0; x < emptycols; ++x)
 		{
 			if (optWhichFonts == OPT_PC)
 				DrawStamp (&s);
@@ -132,8 +142,9 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 			t.pStr = end_page_buf;
 			StrLen += end_page_len;
 		}
-		t.baseline.x = 1 + (r.extent.width >> 1)
-				+ (col_cells * (r.extent.width + 1)) - 1;
+		t.baseline.x = 1 + (r.extent.width >> 1) 
+			+ (col_cells * (r.extent.width + 1)) 
+			- 1 - 3 * RESOLUTION_FACTOR; // JMS_GFX
 		do
 		{
 			COUNT word_chars;
@@ -167,12 +178,20 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 						PlaySound (ReadOutSounds, NotPositional (), NULL,
 								GAME_SOUND_PRIORITY);
 
-						if (c == ',')
-							TimeOut += ONE_SECOND / 4;
-						if (c == '.' || c == '!' || c == '?')
-							TimeOut += ONE_SECOND / 2;
+						if (last_c && last_c != ' ' && last_c != ',' &&
+								last_c != '.' && last_c != '!' && last_c != '?')
+						{
+							if (c == ',')
+								TimeOut += ONE_SECOND / 4;
+							if (c == '.' || c == '!' || c == '?')
+								TimeOut += ONE_SECOND / 2;
+							else
+								TimeOut += ONE_SECOND / 20;
+						}
 						else
 							TimeOut += ONE_SECOND / 20;
+						last_c = c;
+
 						if (word_chars == 0)
 							TimeOut += ONE_SECOND / 20;
 
@@ -207,7 +226,7 @@ MakeReport (SOUND ReadOutSounds, UNICODE
 
 InitPageCell:
 			ButtonState = 1;
-			t.baseline.y = r.extent.height + 1;
+			t.baseline.y = r.extent.height + (1 << RESOLUTION_FACTOR) + 3 * RESOLUTION_FACTOR; // JMS_GFX
 			row_cells = 0;
 			if (StrLen)
 			{
diff -ruNp src.orig/uqm/planets/roster.c src/uqm/planets/roster.c
--- src.orig/uqm/planets/roster.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/roster.c	2017-12-30 00:14:53 -0800
@@ -21,16 +21,22 @@
 #include "../controls.h"
 #include "../races.h"
 #include "../units.h"
+#include "../util.h" // JMS: For SaveContextFrame()
 #include "../sis.h"
 #include "../shipcont.h"
 #include "../setup.h"
 #include "../sounds.h"
 #include "port.h"
 #include "libs/gfxlib.h"
+#include "libs/log.h"
 #include "libs/tasklib.h"
 
 #include <stdlib.h>
 
+// JMS_GFX: These exist to prevent the leftover red borders of the rostered ships in hi-res.
+static RECT  savedShipFrame_r;
+static STAMP savedShipFrame;
+
 // Ship icon positions in status display around the flagship
 static const POINT ship_pos[MAX_BUILT_SHIPS] =
 {
@@ -58,20 +64,34 @@ typedef struct
 static SHIP_FRAGMENT* LockSupportShip (ROSTER_STATE *, HSHIPFRAG *phFrag);
 
 static void
-drawSupportShip (ROSTER_STATE *rosterState, bool filled)
+drawSupportShip (ROSTER_STATE *rosterState, bool filled, bool saveFrame)
 {
 	STAMP s;
 
 	if (!rosterState->curShipFrame)
 		return;
 
-	s.origin = rosterState->curShipPt;
+	s.origin.x = RES_STAT_SCALE(rosterState->curShipPt.x)
+		+ (rosterState->curShipPt.x >= ship_pos[1].x ? RES_CASE(0,3,5) : RES_CASE(0,-2,-2)); // JMS_GFX
+	s.origin.y = RES_STAT_SCALE(rosterState->curShipPt.y) + RES_CASE(0,5,0);
 	s.frame = rosterState->curShipFrame;
 	
-	if (filled)
-		DrawFilledStamp (&s);
-	else
-		DrawStamp (&s);
+	// JMS: 
+	if (saveFrame) {
+		savedShipFrame_r.corner.x = s.origin.x;
+		savedShipFrame_r.corner.y = s.origin.y;
+		savedShipFrame_r.extent.width  = 16 << RESOLUTION_FACTOR;
+		savedShipFrame_r.extent.height = 16 << RESOLUTION_FACTOR; 
+	
+		savedShipFrame = SaveContextFrame (&savedShipFrame_r);
+		
+		log_add (log_Debug,"Saved x:%u, y:%u", savedShipFrame_r.corner.x ,savedShipFrame_r.corner.y);
+	} else {
+		if (filled)
+			DrawFilledStamp (&s);
+		else
+			DrawStamp (&s);
+	}
 }
 
 static void
@@ -85,16 +105,18 @@ getSupportShipIcon (ROSTER_STATE *roster
 	if (!ShipFragPtr)
 		return;
 
-	rosterState->curShipFrame = ShipFragPtr->icons;
+	rosterState->curShipFrame = SetAbsFrameIndex (ShipFragPtr->icons, 2);
 	UnlockShipFrag (&GLOBAL (built_ship_q), hShipFrag);
 }
 
 static void
-flashSupportShip (ROSTER_STATE *rosterState)
+flashSupportShip (ROSTER_STATE *rosterState, bool saveFrame)
 {
 	static Color c = BUILD_COLOR (MAKE_RGB15_INIT (0x1F, 0x00, 0x00), 0x24);
 	static TimeCount NextTime = 0;
 
+	drawSupportShip (rosterState, TRUE, saveFrame);
+
 	if (GetTimeCounter () >= NextTime)
 	{
 		NextTime = GetTimeCounter () + (ONE_SECOND / 15);
@@ -121,7 +143,7 @@ flashSupportShip (ROSTER_STATE *rosterSt
 		}
 		SetContextForeGroundColor (c);
 
-		drawSupportShip (rosterState, TRUE);
+		drawSupportShip (rosterState, TRUE, FALSE);
 	}
 }
 
@@ -220,7 +242,7 @@ drawModifiedSupportShip (ROSTER_STATE *r
 {
 	SetContext (StatusContext);
 	SetContextForeGroundColor (ROSTER_MODIFY_SHIP_COLOR);
-	drawSupportShip (rosterState, TRUE);
+	drawSupportShip (rosterState, TRUE, FALSE);
 }
 
 static void
@@ -235,7 +257,7 @@ static BOOLEAN
 DoModifyRoster (MENU_STATE *pMS)
 {
 	ROSTER_STATE *rosterState = pMS->privData;
-	BOOLEAN select, cancel, up, down, horiz;
+	BOOLEAN select, cancel, up, down, pgup, pgdn, horiz;
 
 	if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 		return FALSE;
@@ -247,6 +269,8 @@ DoModifyRoster (MENU_STATE *pMS)
 	// Left or right produces the same effect because there are 2 columns
 	horiz = PulsedInputState.menu[KEY_MENU_LEFT] ||
 			PulsedInputState.menu[KEY_MENU_RIGHT];
+	pgup = PulsedInputState.menu[KEY_MENU_PAGE_UP];
+	pgdn = PulsedInputState.menu[KEY_MENU_PAGE_DOWN];
 
 	if (cancel && !rosterState->modifyingCrew)
 	{
@@ -258,14 +282,15 @@ DoModifyRoster (MENU_STATE *pMS)
 		if (!rosterState->modifyingCrew)
 		{
 			SetFlashRect (NULL);
-			SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
+			SetMenuSounds (MENU_SOUND_ARROWS | MENU_SOUND_PAGEUP |
+				MENU_SOUND_PAGEDOWN, MENU_SOUND_SELECT);
 		}
 		else
 		{
 			drawModifiedSupportShip (rosterState);
 			flashSupportShipCrew ();
-			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
-					MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
+			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN | MENU_SOUND_PAGEUP |
+				MENU_SOUND_PAGEDOWN, MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
 		}
 	}
 	else if (rosterState->modifyingCrew)
@@ -273,17 +298,17 @@ DoModifyRoster (MENU_STATE *pMS)
 		SIZE delta = 0;
 		BOOLEAN failed = FALSE;
 
-		if (up)
+		if (up || pgup)
 		{
 			if (GLOBAL_SIS (CrewEnlisted))
-				delta = 1;
+				delta = pgup ? 10 : 1;
 			else
 				failed = TRUE;
 		}
-		else if (down)
+		else if (down || pgdn)
 		{
 			if (GLOBAL_SIS (CrewEnlisted) < GetCrewPodCapacity ())
-				delta = -1;
+				delta = pgdn ? -10 : -1;
 			else
 				failed = TRUE;
 		}
@@ -351,14 +376,26 @@ DoModifyRoster (MENU_STATE *pMS)
 
 		if (NewState != pMS->CurState)
 		{
-			// Draw the previous escort in unselected state
-			drawSupportShip (rosterState, FALSE);
+			// Draw the previous escort in unselected state.
+			// JMS_GFX: In 4x and 2x modes we draw the rectangle of screen
+			// we captured earlier.
+			if (RESOLUTION_FACTOR > 0)
+				DrawStamp (&savedShipFrame);
+			else // In 1x mode we just draw the icon.
+				drawSupportShip (rosterState, FALSE, FALSE);
 			// Select the new one
 			selectSupportShip (rosterState, NewState);
 			pMS->CurState = NewState;
-		}
 
-		flashSupportShip (rosterState);
+			// JMS_GFX: In 2x and 4x modes we now have to capture the
+			// location of this new rectangle.
+			if (RESOLUTION_FACTOR > 0)
+				flashSupportShip (rosterState, TRUE);
+			else
+				flashSupportShip (rosterState, FALSE);
+		} 
+		else
+			flashSupportShip (rosterState, FALSE);
 
 		UnbatchGraphics ();
 	}
@@ -413,14 +450,26 @@ RosterMenu (void)
 	SetContext (StatusContext);
 	selectSupportShip (&RosterState, MenuState.CurState);
 
+	// JMS_GFX: Remember the location of the first ship to be able to erase
+	// the red junk from around it after rostering.
+	if (RESOLUTION_FACTOR > 0)
+		drawSupportShip (&RosterState, TRUE, TRUE);
+
 	SetMenuSounds (MENU_SOUND_ARROWS, MENU_SOUND_SELECT);
 
 	MenuState.InputFunc = DoModifyRoster;
 	DoInput (&MenuState, TRUE);
 
 	SetContext (StatusContext);
-	// unselect the last ship
-	drawSupportShip (&RosterState, FALSE);
+	
+	// Draw the last escort in unselected state.
+	// JMS_GFX: In 4x and 2x modes we draw the rectangle of screen
+	// we captured earlier.
+	if (RESOLUTION_FACTOR > 0)
+		DrawStamp (&savedShipFrame);
+	else // In 1x mode we just draw the icon.
+		drawSupportShip (&RosterState, FALSE, FALSE);
+
 	DrawStatusMessage (NULL);
 
 	return TRUE;
diff -ruNp src.orig/uqm/planets/scan.c src/uqm/planets/scan.c
--- src.orig/uqm/planets/scan.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/scan.c	2017-12-30 00:14:53 -0800
@@ -30,7 +30,7 @@
 #include "../nameref.h"
 #include "../resinst.h"
 #include "../settings.h"
-#include "../util.h"
+#include "../util.h" // for get_fuel_to_sol()
 #include "../process.h"
 #include "../setup.h"
 #include "../sounds.h"
@@ -43,6 +43,8 @@
 #include "libs/inplib.h"
 #include "libs/mathlib.h"
 
+#define HAZARD_COLORS
+
 extern FRAME SpaceJunkFrame;
 
 // define SPIN_ON_SCAN to allow the planet to spin 
@@ -68,7 +70,7 @@ enum ScanMenuItems
 
 
 void
-RepairBackRect (RECT *pRect)
+RepairBackRect (RECT *pRect, BOOLEAN Fullscreen)
 {
 	RECT new_r, old_r;
 
@@ -79,7 +81,11 @@ RepairBackRect (RECT *pRect)
 
 	new_r.extent.height += new_r.corner.y & 1;
 	new_r.corner.y &= ~1;
-	DrawFromExtraScreen (&new_r);
+	
+	if (Fullscreen)
+		DrawFromExtraScreen_Fs (&new_r);
+	else
+		DrawFromExtraScreen (&new_r);
 }
 
 static void
@@ -149,19 +155,27 @@ GetPlanetTitle (UNICODE *buf, COUNT bufs
 static void
 PrintCoarseScanPC (void)
 {
-#define SCAN_LEADING_PC 14
+#define SCAN_LEADING_PC (14 << RESOLUTION_FACTOR) // JMS_GFX
 	SDWORD val;
 	TEXT t;
 	RECT r;
 	UNICODE buf[200];
 
+	/* We need this for the new color-changing hazard readouts.
+	 * We initialize it to SCAN_PC_TITLE_COLOR because we'll need
+	 * to reset the ContextForeGroundColor to this value whenever
+	 * we may have changed it - and having it always be set to a
+	 * sane value removes the need to only reset it conditionally.
+	 */
+	Color OldColor = (SCAN_PC_TITLE_COLOR);
+
 	GetPlanetTitle (buf, sizeof (buf));
 
 	SetContext (PlanetContext);
 
 	t.align = ALIGN_CENTER;
 	t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-	t.baseline.y = 13;
+	t.baseline.y = (13 << RESOLUTION_FACTOR) + 4*RESOLUTION_FACTOR; // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
@@ -171,9 +185,9 @@ PrintCoarseScanPC (void)
 
 	SetContextFont (TinyFont);
 
-#define LEFT_SIDE_BASELINE_X_PC 5
-#define RIGHT_SIDE_BASELINE_X_PC (SIS_SCREEN_WIDTH - 75)
-#define SCAN_BASELINE_Y_PC 40
+#define LEFT_SIDE_BASELINE_X_PC (5 << RESOLUTION_FACTOR) // JMS_GFX
+#define RIGHT_SIDE_BASELINE_X_PC (SIS_SCREEN_WIDTH - (75 << RESOLUTION_FACTOR)) // JMS_GFX
+#define SCAN_BASELINE_Y_PC (40 << RESOLUTION_FACTOR) // JMS_GFX
 
 	t.baseline.y = SCAN_BASELINE_Y_PC;
 	t.align = ALIGN_LEFT;
@@ -213,9 +227,22 @@ PrintCoarseScanPC (void)
 			LEFT_SIDE_BASELINE_X_PC); // "Temp: "
 	sprintf (buf, "%d" STR_DEGREE_SIGN " c",
 			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature);
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) >= (100) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) <= (400))
+	{ /* Between 100 and 400 temperature the planet is still explorable,
+	   * draw the readout in yellow */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature > 400)
+	{ /* Above 400 the planet is quite dangerous, draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING_PC;
 
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 7),
@@ -229,8 +256,22 @@ PrintCoarseScanPC (void)
 				pSolarSysState->SysInfo.PlanetInfo.Weather + 1);
 		t.pStr = buf;
 	}
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Weather + 1) <= (4))
+	{ /* Weather values of 3 or 4 will unavoidably kill a few
+	   * crew, draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (5))
+	{ /* Weather values >= 5 will unavoidably kill many crew,
+	   * draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING_PC;
 
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 10),
@@ -245,9 +286,22 @@ PrintCoarseScanPC (void)
 				pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1);
 		t.pStr = buf;
 	}
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) <= (5))
+	{ /* Between class 3 and 5 tectonics the planet is still explorable,
+	   * draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) > (5))
+	{ /* Above class 5 tectonics the planet is quite dangerous, draw the
+	   * readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
-
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y = SCAN_BASELINE_Y_PC;
 
 	PrintScanTitlePC (&t, &r, GAME_STRING (ORBITSCAN_STRING_BASE + 11),
@@ -312,19 +366,27 @@ PrintCoarseScanPC (void)
 static void
 PrintCoarseScan3DO (void)
 {
-#define SCAN_LEADING 19
+#define SCAN_LEADING (19 << RESOLUTION_FACTOR) // JMS_GFX
 	SDWORD val;
 	TEXT t;
 	STAMP s;
 	UNICODE buf[200];
 
+	/* We need this for the new color-changing hazard readouts.
+	 * We initialize it to SCAN_PC_TITLE_COLOR because we'll need
+	 * to reset the ContextForeGroundColor to this value whenever
+	 * we may have changed it - and having it always be set to a
+	 * sane value removes the need to only reset it conditionally.
+	 */
+	Color OldColor = (SCAN_PC_TITLE_COLOR);
+
 	GetPlanetTitle (buf, sizeof (buf));
 
 	SetContext (PlanetContext);
 
 	t.align = ALIGN_CENTER;
 	t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-	t.baseline.y = 13;
+	t.baseline.y = (13 << RESOLUTION_FACTOR); // JMS_GFX
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
@@ -333,13 +395,13 @@ PrintCoarseScan3DO (void)
 	font_DrawText (&t);
 
 	s.origin.x = s.origin.y = 0;
-	s.origin.x = 16 - SAFE_X;
+	s.origin.x = ((16 - SAFE_X) << RESOLUTION_FACTOR); // JMS_GFX
 	s.frame = SetAbsFrameIndex (SpaceJunkFrame, 20);
 	DrawStamp (&s);
 
-#define LEFT_SIDE_BASELINE_X (27 + (16 - SAFE_X))
+#define LEFT_SIDE_BASELINE_X ((27 + (16 - SAFE_X)) << RESOLUTION_FACTOR) // JMS_GFX
 #define RIGHT_SIDE_BASELINE_X (SIS_SCREEN_WIDTH - LEFT_SIDE_BASELINE_X)
-#define SCAN_BASELINE_Y 25
+#define SCAN_BASELINE_Y (25 << RESOLUTION_FACTOR) // JMS_GFX
 
 	t.baseline.x = LEFT_SIDE_BASELINE_X;
 	t.baseline.y = SCAN_BASELINE_Y;
@@ -348,7 +410,8 @@ PrintCoarseScan3DO (void)
 	t.pStr = buf;
 	val = ((pSolarSysState->SysInfo.PlanetInfo.PlanetToSunDist * 100L
 			+ (EARTH_RADIUS >> 1)) / EARTH_RADIUS);
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 1)); // " a.u."
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
@@ -360,34 +423,77 @@ PrintCoarseScan3DO (void)
 	{
 		val = (pSolarSysState->SysInfo.PlanetInfo.AtmoDensity * 100
 				+ (EARTH_ATMOSPHERE >> 1)) / EARTH_ATMOSPHERE;
-		MakeScanValue (buf, val, STR_EARTH_SIGN);
+		MakeScanValue (buf, val,
+				GAME_STRING (ORBITSCAN_STRING_BASE + 5)); // " atm"
 	}
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
 
 	t.pStr = buf;
-	sprintf (buf, "%d" STR_DEGREE_SIGN,
+	sprintf (buf, "%d" STR_DEGREE_SIGN " c",
 			pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature);
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) >= (100) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature) <= (400))
+	{ /* Between 100 and 400 temperature the planet is still explorable,
+	   * draw the readout in yellow */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if (pSolarSysState->SysInfo.PlanetInfo.SurfaceTemperature > 400)
+	{ /* Above 400 the planet is quite dangerous, draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING;
 
 	t.pStr = buf;
-	sprintf (buf, "<%u>", pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == 0
+	sprintf (buf, "%s %u", GAME_STRING (ORBITSCAN_STRING_BASE + 9), // Class
+			pSolarSysState->SysInfo.PlanetInfo.AtmoDensity == 0
 			? 0 : (pSolarSysState->SysInfo.PlanetInfo.Weather + 1));
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Weather + 1) <= (4))
+	{ /* Weather values of 3 or 4 will unavoidably kill a few
+	   * crew, draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Weather + 1) >= (5))
+	{ /* Weather values < 5 will unavoidably kill many crew,
+	   * draw the readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 	t.baseline.y += SCAN_LEADING;
 
 	t.pStr = buf;
-	sprintf (buf, "<%u>",
+	sprintf (buf, "%s %u", GAME_STRING (ORBITSCAN_STRING_BASE + 9), // Class
 			PLANSIZE (
 			pSolarSysState->SysInfo.PlanetInfo.PlanDataPtr->Type
 			) == GAS_GIANT
 			? 0 : (pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1));
+#ifdef HAZARD_COLORS
+	if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) >= (3) &&
+	    (pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) <= (5))
+	{ /* Between class 3 and 5 tectonics the planet is still explorable,
+	   * draw the readout in yellow. */
+		OldColor = SetContextForeGroundColor (DULL_YELLOW_COLOR);
+	}
+	else if ((pSolarSysState->SysInfo.PlanetInfo.Tectonics + 1) > (5))
+	{ /* Above class 5 tectonics the planet is quite dangerous, draw the
+	   * readout in red. */
+		OldColor = SetContextForeGroundColor (BRIGHT_RED_COLOR);
+	}
+#endif
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
+	SetContextForeGroundColor (OldColor);
 
 	t.baseline.x = RIGHT_SIDE_BASELINE_X;
 	t.baseline.y = SCAN_BASELINE_Y;
@@ -400,14 +506,16 @@ PrintCoarseScan3DO (void)
 			+ ((100L * 100L) >> 1)) / (100L * 100L);
 	if (val == 0)
 		val = 1;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 12)); // " e.s."
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
 
 	t.pStr = buf;
 	val = pSolarSysState->SysInfo.PlanetInfo.PlanetRadius;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 15)); // " g."
 
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
@@ -417,7 +525,8 @@ PrintCoarseScan3DO (void)
 	val = pSolarSysState->SysInfo.PlanetInfo.SurfaceGravity;
 	if (val == 0)
 		val = 1;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 17)); // " days"
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 	t.baseline.y += SCAN_LEADING;
@@ -434,7 +543,8 @@ PrintCoarseScan3DO (void)
 	t.pStr = buf;
 	val = (SDWORD)pSolarSysState->SysInfo.PlanetInfo.RotationPeriod
 			* 10 / 24;
-	MakeScanValue (buf, val, STR_EARTH_SIGN);
+	MakeScanValue (buf, val,
+			GAME_STRING (ORBITSCAN_STRING_BASE + 17)); // " days"
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 }
@@ -619,7 +729,9 @@ DispatchLander (void)
 	// Deactivate planet rotation callback
 	oldCallback = SetInputCallback (NULL);
 
-	DeltaSISGauges (0, -landingFuel, 0);
+	if (!optInfiniteFuel)
+		DeltaSISGauges (0, -landingFuel, 0);
+
 	SetContext (ScanContext);
 	drawPlanetCursor (FALSE);
 
@@ -663,6 +775,8 @@ DoPickPlanetSide (MENU_STATE *pMS)
 	DWORD TimeIn = GetTimeCounter ();
 	BOOLEAN select, cancel;
 
+	POINT	new_pt;
+
 	select = PulsedInputState.menu[KEY_MENU_SELECT];
 	cancel = PulsedInputState.menu[KEY_MENU_CANCEL];
 	
@@ -684,9 +798,9 @@ DoPickPlanetSide (MENU_STATE *pMS)
 	}
 	else
 	{
-		SIZE dx = 0;
-		SIZE dy = 0;
-		POINT new_pt;
+		COUNT	i, j = 0; // JMS_GFX
+		SIZE	dx = 0;
+		SIZE	dy = 0;
 
 		new_pt = planetLoc;
 
@@ -699,49 +813,86 @@ DoPickPlanetSide (MENU_STATE *pMS)
 		if (CurrentInputState.menu[KEY_MENU_DOWN])
 			dy = 1;
 
-		BatchGraphics ();
+		// BatchGraphics ();
 
 		dx = dx << MAG_SHIFT;
-		if (dx)
-		{
-			new_pt.x += dx;
-			if (new_pt.x < 0)
-				new_pt.x += (MAP_WIDTH << MAG_SHIFT);
-			else if (new_pt.x >= (MAP_WIDTH << MAG_SHIFT))
-				new_pt.x -= (MAP_WIDTH << MAG_SHIFT);
-		}
 		dy = dy << MAG_SHIFT;
-		if (dy)
-		{
-			new_pt.y += dy;
-			if (new_pt.y < 0 || new_pt.y >= (MAP_HEIGHT << MAG_SHIFT))
-				new_pt.y = planetLoc.y;
-		}
 
-		if (!pointsEqual (new_pt, planetLoc))
+		// JMS_GFX: 1 for 320x240, 3 for 640x480, 7 for 1280x960
+		// XXX: This was good for debugging build, but too fast on opitmized release build.
+		//j = (1 << (RESOLUTION_FACTOR + 1)) - 1;
+		
+		// JMS_GFX: 1 for 320x240, 2 for 640x480, 4 for 1280x960
+		j = 1 << RESOLUTION_FACTOR;
+		
+		// JMS_GFX: This makes the scan cursor faster in hi-res modes.
+		// (Originally there was no loop, just the contents.)
+		for (i = 0; i < j; i++)
 		{
-			setPlanetLoc (new_pt, TRUE);
+			BatchGraphics ();
+			
+			if (dx)
+			{
+				new_pt.x += dx;
+				if (new_pt.x < 0)
+					new_pt.x += (MAP_WIDTH << MAG_SHIFT);
+				else if (new_pt.x >= (MAP_WIDTH << MAG_SHIFT))
+					new_pt.x -= (MAP_WIDTH << MAG_SHIFT);
+			}
+			
+			if (dy)
+			{
+				new_pt.y += dy;
+				if (new_pt.y < 0 || new_pt.y >= (MAP_HEIGHT << MAG_SHIFT))
+					new_pt.y = planetLoc.y;
+			}
+			
+			if (!pointsEqual (new_pt, planetLoc))
+				setPlanetLoc (new_pt, TRUE);
+			
+			flashPlanetLocation ();
+			
+			// JMS_GFX: Just upping the denominator wouldn't do no good since
+			// something else limits entering this function to about once per 1/40 secs...
+			// Since I couldn't find that mysterious element, I had to do speed things up
+			// with a loop and this thing here.
+			// XXX: Actually, with the optimized release build the best solution now seems is to keep all at 1/40th, but keep the loop...
+			if (RESOLUTION_FACTOR == 0)
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			else if (RESOLUTION_FACTOR == 1)
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			else
+				SleepThreadUntil (TimeIn + ONE_SECOND / 40);
+			
+			UnbatchGraphics ();
 		}
-
-		flashPlanetLocation ();
-
-		UnbatchGraphics ();
-
-		SleepThreadUntil (TimeIn + ONE_SECOND / 40);
 	}
-
 	return TRUE;
 }
 
 static void
 drawLandingFuelUsage (COUNT fuel)
 {
+	/* We need this so we can save the StatusMessageMode
+	 * and fix it when we're done.
+	 */
+	StatMsgMode old_status_message_mode;
 	UNICODE buf[100];
 
+	if (((SDWORD) (GLOBAL_SIS (FuelOnBoard)) - fuel) <= (SDWORD)(get_fuel_to_sol ()))
+	{ /* We will not have enough fuel to get to Sol if we dispatch the lander */
+		old_status_message_mode = SetStatusMessageMode (SMM_ALERT);
+	} else if (((SDWORD) (GLOBAL_SIS (FuelOnBoard)) - fuel) <= (SDWORD)(get_fuel_to_sol () + (5 * FUEL_TANK_SCALE)))
+	{ /* We will have enough fuel to get to Sol if we dispatch the lander, but will have less than 5 to spare */
+		old_status_message_mode = SetStatusMessageMode (SMM_WARNING);
+	}
+
 	sprintf (buf, "%s%1.1f",
 			GAME_STRING (NAVIGATION_STRING_BASE + 5),
 			(float) fuel / FUEL_TANK_SCALE);
 	DrawStatusMessage (buf);
+
+	SetStatusMessageMode (old_status_message_mode);
 }
 
 static void
@@ -921,9 +1072,9 @@ callPickupForScanType (SOLARSYS_STATE *s
 static void
 ScanPlanet (COUNT scanType)
 {
-#define SCAN_DURATION   (ONE_SECOND * 7 / 4)
+#define SCAN_DURATION   RES_CASE(ONE_SECOND * 7 / 4, ONE_SECOND * 7 / 4, ONE_SECOND * 12 / 4)
 // NUM_FLASH_COLORS for flashing blips; 1 for the final frame
-#define SCAN_LINES      (MAP_HEIGHT + NUM_FLASH_COLORS + 1)
+#define SCAN_LINES      (MAP_HEIGHT + NUM_FLASH_COLORS - 8)
 #define SCAN_LINE_WAIT  (SCAN_DURATION / SCAN_LINES)
 
 	COUNT startScan, endScan;
@@ -962,7 +1113,7 @@ ScanPlanet (COUNT scanType)
 		TimeCount TimeOut;
 
 		t.baseline.x = SIS_SCREEN_WIDTH >> 1;
-		t.baseline.y = SIS_SCREEN_HEIGHT - MAP_HEIGHT - 7;
+		t.baseline.y = SIS_SCREEN_HEIGHT - MAP_HEIGHT - (7 << RESOLUTION_FACTOR); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.CharCount = (COUNT)~0;
 
@@ -970,12 +1121,12 @@ ScanPlanet (COUNT scanType)
 
 		SetContext (PlanetContext);
 		r.corner.x = 0;
-		r.corner.y = t.baseline.y - 10;
+		r.corner.y = t.baseline.y - (10 << RESOLUTION_FACTOR); // JMS_GFX
 		r.extent.width = SIS_SCREEN_WIDTH;
-		r.extent.height = t.baseline.y - r.corner.y + 1;
+		r.extent.height = t.baseline.y - r.corner.y + (1 << RESOLUTION_FACTOR); // JMS_GFX
 		// XXX: I do not know why we are repairing it here, as there
 		//   should not be anything drawn over the stars at the moment
-		RepairBackRect (&r);
+		RepairBackRect (&r, FALSE);
 
 		SetContextFont (MicroFont);
 		SetContextForeGroundColor (textColors[scan]);
@@ -992,7 +1143,7 @@ ScanPlanet (COUNT scanType)
 
 		// Draw the scan slowly line by line
 		TimeOut = GetTimeCounter ();
-		for (i = 0; i < SCAN_LINES; i++)
+		for (i = 0; i < (SWORD)SCAN_LINES; i++)
 		{
 			TimeOut += SCAN_LINE_WAIT;
 			if (WaitForAnyButtonUntil (TRUE, TimeOut, FALSE))
@@ -1007,7 +1158,7 @@ ScanPlanet (COUNT scanType)
 #endif
 		}
 
-		if (i < SCAN_LINES)
+		if (i < (SWORD)SCAN_LINES)
 		{	// Aborted by a keypress; draw in finished state
 			BatchGraphics ();
 			DrawPlanet (SCAN_LINES - 1, tintColor);
@@ -1017,7 +1168,7 @@ ScanPlanet (COUNT scanType)
 	}
 
 	SetContext (PlanetContext);
-	RepairBackRect (&r);
+	RepairBackRect (&r, FALSE);
 
 	SetContext (ScanContext);
 	if (scanType == AUTO_SCAN)
@@ -1214,6 +1365,7 @@ generateBioNode (SOLARSYS_STATE *system,
 		BYTE *life_init_tab, COUNT creatureType)
 {
 	COUNT i;
+	DWORD j;
 
 	// NOTE: TFB_Random() calls here are NOT part of the deterministic planet
 	//   generation PRNG flow.
@@ -1221,10 +1373,15 @@ generateBioNode (SOLARSYS_STATE *system,
 	{
 		// Place moving creatures at a random location.
 		i = TFB_Random ();
-		NodeElementPtr->current.location.x =
-				(LOBYTE (i) % (MAP_WIDTH - (8 << 1))) + 8;
-		NodeElementPtr->current.location.y =
-				(HIBYTE (i) % (MAP_HEIGHT - (8 << 1))) + 8;
+		j = (DWORD)TFB_Random ();
+		
+		if (RESOLUTION_FACTOR == 0) {
+			NodeElementPtr->current.location.x = (LOBYTE (i) % (MAP_WIDTH - (8 << 1))) + 8;
+			NodeElementPtr->current.location.y = (HIBYTE (i) % (MAP_HEIGHT - (8 << 1))) + 8;
+		} else {
+			NodeElementPtr->current.location.x = (LOWORD (j) % (MAP_WIDTH - (8 << 1))) + 8;	// JMS_GFX: Replaced previous line with this line (BYTE was too small for 640x480 maps.)
+			NodeElementPtr->current.location.y = (HIWORD (j) % (MAP_HEIGHT - (8 << 1))) + 8;  // JMS_GFX: Replaced previous line with this line (BYTE was too small for 1280x960 maps.)
+		}
 	}
 
 	if (system->PlanetSideFrame[0] == 0)
@@ -1307,7 +1464,11 @@ GeneratePlanetSide (void)
 			if (scan == MINERAL_SCAN)
 			{
 				NodeElementPtr->turn_wait = info.type;
-				NodeElementPtr->mass_points = HIBYTE (info.density);
+
+				// JMS: Partially scavenged energy blips won't return anymore to original size after leaving planet.
+				NodeElementPtr->mass_points = HIBYTE (info.density)
+				- pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[scan][num_nodes];
+
 				NodeElementPtr->current.image.frame = SetAbsFrameIndex (
 						MiscDataFrame, (NUM_SCANDOT_TRANSITIONS * 2)
 						+ ElementCategory (info.type) * 5);
diff -ruNp src.orig/uqm/planets/scan.h src/uqm/planets/scan.h
--- src.orig/uqm/planets/scan.h	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/scan.h	2017-12-30 00:14:53 -0800
@@ -48,7 +48,7 @@ struct scan_block
 
 extern void ScanSystem (void);
 
-extern void RepairBackRect (RECT *pRect);
+extern void RepairBackRect (RECT *pRect, BOOLEAN Fullscreen);
 extern void GeneratePlanetSide (void);
 extern COUNT callGenerateForScanType (const SOLARSYS_STATE *,
 		const PLANET_DESC *world, COUNT node, BYTE scanType, NODE_INFO *);
diff -ruNp src.orig/uqm/planets/solarsys.c src/uqm/planets/solarsys.c
--- src.orig/uqm/planets/solarsys.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/solarsys.c	2017-12-30 00:14:53 -0800
@@ -47,18 +47,31 @@
 #include "libs/mathlib.h"
 #include "libs/log.h"
 #include "libs/misc.h"
+#include "scan.h"
 
+#include <math.h>
+#include <time.h>
 
-//#define DEBUG_SOLARSYS
-//#define SMOOTH_SYSTEM_ZOOM  1
+// #define DEBUG_SOLARSYS
+#define SMOOTH_SYSTEM_ZOOM  1
 
 #define IP_FRAME_RATE  (ONE_SECOND / 30)
 
+// BW: those do not depend on the resolution because numbers too small
+// cause crashes in the generation and rendering
+#define GENERATE_PLANET_DIAMETER (29 << 2)
+#define GENERATE_MOON_DIAMETER (7 << 2)
+#define GENERATE_PLANET_PERIMETER (GENERATE_PLANET_DIAMETER * ORIGINAL_MAP_WIDTH / ORIGINAL_MAP_HEIGHT)
+#define GENERATE_MOON_PERIMETER (GENERATE_MOON_DIAMETER * ORIGINAL_MAP_WIDTH / ORIGINAL_MAP_HEIGHT)
+
+static void AnimateSun (SIZE radius); // JMS
 static BOOLEAN DoIpFlight (SOLARSYS_STATE *pSS);
 static void DrawSystem (SIZE radius, BOOLEAN IsInnerSystem);
 static FRAME CreateStarBackGround (void);
 static void DrawInnerSystem (void);
 static void DrawOuterSystem (void);
+static void SetPlanetColorMap (PLANET_DESC *planet); // JMS, BW
+static void ValidateInnerOrbits (void);
 static void ValidateOrbits (void);
 
 // SolarSysMenu() items
@@ -222,11 +235,6 @@ GenerateMoons (SOLARSYS_STATE *system, P
 
 	RandomContext_SeedRandom (SysGenRNG, planet->rand_seed);
 
-	(*system->genFuncs->generateName) (system, planet);
-	(*system->genFuncs->generateMoons) (system, planet);
-
-	facing = NORMALIZE_FACING (ANGLE_TO_FACING (
-			ARCTAN (planet->location.x, planet->location.y)));
 	for (i = 0, pMoonDesc = &system->MoonDesc[0];
 			i < MAX_MOONS; ++i, ++pMoonDesc)
 	{
@@ -236,6 +244,112 @@ GenerateMoons (SOLARSYS_STATE *system, P
 		
 		pMoonDesc->temp_color = planet->temp_color;
 	}
+
+	(*system->genFuncs->generateName) (system, planet);
+	(*system->genFuncs->generateMoons) (system, planet);
+
+	facing = NORMALIZE_FACING (ANGLE_TO_FACING (
+			ARCTAN (planet->location.x, planet->location.y)));
+}
+
+static void
+GenerateTexturedMoons (SOLARSYS_STATE *system, PLANET_DESC *planet)
+{
+	COUNT i;
+	FRAME SurfFrame;
+	PLANET_DESC *pMoonDesc;
+
+	PLANET_DESC *previousOrbitalDesc;
+	previousOrbitalDesc = pSolarSysState->pOrbitalDesc;
+
+	for (i = 0, pMoonDesc = &system->MoonDesc[0];
+			i < planet->NumPlanets; ++i, ++pMoonDesc)
+	{
+		SurfFrame = NULL;
+	
+		// BW : precompute the generated texture to display it in IP
+		if (!(pMoonDesc->data_index & WORLD_TYPE_SPECIAL))
+		{
+			DoPlanetaryAnalysis (&pSolarSysState->SysInfo, pMoonDesc);
+			
+			if (CurStarDescPtr->Index == SOL_DEFINED)
+				pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 0;
+
+			pSolarSysState->pOrbitalDesc = pMoonDesc;
+
+			if (CurStarDescPtr->Index == SOL_DEFINED)
+			{	// png defined moons in Sol
+			
+				COUNT curr_planet_index = planetIndex (pSolarSysState, planet);
+		
+				if (curr_planet_index == 2) {
+					// EARTH
+					switch (i) {
+						case 1: /* LUNA */
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_LUNA_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 0;
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 240 * 29;
+							break;
+					}
+				} else if (curr_planet_index == 4) {
+					// JUPITER
+					switch (i) {
+						case 0: /* IO */
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_IO_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 390;
+							break;
+						case 1: /* EUROPA */
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_EUROPA_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 840;
+							break;
+						case 2: /* GANYMEDE */
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_GANYMEDE_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 1728;
+							break;
+						case 3: /* CALLISTO */
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_CALLISTO_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 4008;
+							break;
+					}
+				} else if (curr_planet_index == 5) {
+					// SATURN
+					switch (i) {
+						case 0: /* TITAN */
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_TITAN_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 3816;
+							break;
+					}
+				} else if (curr_planet_index == 7) {
+					// NEPTUNE
+					switch (i) {
+						case 0: /* TRITON */
+							if (solTexturesPresent)
+								SurfFrame = CaptureDrawable (LoadGraphic (IP_TRITON_MASK_ANIM));
+							pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 4300;
+							break;
+					}
+				}
+			}
+
+			GeneratePlanetSurface (pMoonDesc, SurfFrame, GENERATE_MOON_PERIMETER, GENERATE_MOON_DIAMETER, FALSE);
+			pMoonDesc->orbit = pSolarSysState->Orbit;
+			PrepareNextRotationFrame (pMoonDesc, 0, FALSE);
+
+			DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+			pSolarSysState->XlatRef = 0;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+			pSolarSysState->TopoFrame = 0;
+			DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+			pSolarSysState->OrbitalCMap = 0;
+		}
+	}
+	pSolarSysState->pOrbitalDesc = previousOrbitalDesc;
 }
 
 void
@@ -263,17 +377,31 @@ FreeIPData (void)
 void
 LoadIPData (void)
 {
+	if (RESOLUTION_FACTOR == 0) {
+		SunFrame = CaptureDrawable (LoadGraphic (SUN_MASK_PMAP_ANIM));
+	} else {
+		if (STAR_COLOR(CurStarDescPtr->Type) == BLUE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNBLUE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == GREEN_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNGREEN_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == ORANGE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNORANGE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == RED_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNRED_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type)== WHITE_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNWHITE_MASK_PMAP_ANIM));
+		else if (STAR_COLOR(CurStarDescPtr->Type) == YELLOW_BODY)
+			SunFrame = CaptureDrawable (LoadGraphic (SUNYELLOW_MASK_PMAP_ANIM));
+	}
+
 	if (SpaceJunkFrame == 0)
 	{
-		SpaceJunkFrame = CaptureDrawable (
-				LoadGraphic (IPBKGND_MASK_PMAP_ANIM));
+		SpaceJunkFrame = CaptureDrawable (LoadGraphic (IPBKGND_MASK_PMAP_ANIM));
 		SISIPFrame = CaptureDrawable (LoadGraphic (SISIP_MASK_PMAP_ANIM));
 
 		OrbitalCMap = CaptureColorMap (LoadColorMap (ORBPLAN_COLOR_MAP));
-		OrbitalFrame = CaptureDrawable (
-				LoadGraphic (ORBPLAN_MASK_PMAP_ANIM));
+		OrbitalFrame = CaptureDrawable (LoadGraphic (ORBPLAN_MASK_PMAP_ANIM));
 		SunCMap = CaptureColorMap (LoadColorMap (IPSUN_COLOR_MAP));
-		SunFrame = CaptureDrawable (LoadGraphic (SUN_MASK_PMAP_ANIM));
 
 		SpaceMusic = LoadMusic (IP_MUSIC);
 	}
@@ -363,6 +491,100 @@ GetRandomSeedForStar (const STAR_DESC *s
 	return MAKE_DWORD (star->star_pt.x, star->star_pt.y);
 }
 
+void GenerateTexturedPlanets (void)
+{
+	COUNT i;
+	FRAME SurfFrame;
+	PLANET_DESC *pCurDesc;
+	PLANET_DESC *previousOrbitalDesc;
+	previousOrbitalDesc = pSolarSysState->pOrbitalDesc;
+	
+	for (i = 0, pCurDesc = pSolarSysState->PlanetDesc;
+			i < pSolarSysState->SunDesc[0].NumPlanets; ++i, ++pCurDesc)
+	{
+		SurfFrame = NULL;
+
+		DoPlanetaryAnalysis (&pSolarSysState->SysInfo, pCurDesc);
+		
+		// BW : precompute the generated texture to display it in IP
+		pSolarSysState->pOrbitalDesc = pCurDesc;
+		if (CurStarDescPtr->Index == SOL_DEFINED){
+			switch (i) {
+				case 0: /* MERCURY */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_MERCURY_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 59 * 240;
+					break;
+				case 1: /* VENUS */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_VENUS_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 177;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 243 * 240;
+					break;
+				case 2: // EARTH
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_EARTH_MASK_ANIM));
+					else
+						SurfFrame = CaptureDrawable (LoadGraphic (EARTH_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 23;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 240;
+					break;
+				case 3: // MARS
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_MARS_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 24;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 246;
+					break;
+				case 4: /* JUPITER */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_JUPITER_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 3;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 98;
+					break;
+				case 5: /* SATURN */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_SATURN_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 27;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 102;
+					break;
+				case 6: /* URANUS */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_URANUS_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 98;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 172;
+					break;
+				case 7: /* NEPTUNE */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_NEPTUNE_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 30;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 182;
+					break;
+				case 8: /* PLUTO */
+					if (solTexturesPresent)
+						SurfFrame = CaptureDrawable (LoadGraphic (IP_PLUTO_MASK_ANIM));
+					pSolarSysState->SysInfo.PlanetInfo.AxialTilt = 119;
+					pSolarSysState->SysInfo.PlanetInfo.RotationPeriod = 1533;
+					break;
+			}
+		}
+		
+		GeneratePlanetSurface (pCurDesc, SurfFrame, GENERATE_PLANET_PERIMETER, GENERATE_PLANET_DIAMETER, FALSE);
+		pCurDesc->orbit = pSolarSysState->Orbit;
+		PrepareNextRotationFrame (pCurDesc, 0, FALSE);
+		
+		// Clean up some parasitic use of pSolarSysState
+		DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+		pSolarSysState->XlatRef = 0;
+		DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+		pSolarSysState->TopoFrame = 0;
+		DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+		pSolarSysState->OrbitalCMap = 0;
+		// End clean up
+	}
+	pSolarSysState->pOrbitalDesc = previousOrbitalDesc;
+}
+
 // Returns an orbital PLANET_DESC when player is in orbit
 static PLANET_DESC *
 LoadSolarSys (void)
@@ -371,7 +593,9 @@ LoadSolarSys (void)
 	PLANET_DESC *orbital = NULL;
 	PLANET_DESC *pCurDesc;
 #define NUM_TEMP_RANGES 5
-	static const Color temp_color_array[NUM_TEMP_RANGES] =
+	// JMS_GFX: Let's make the dark blue planet orbit dots a little
+	// more visible in 640x480 and 1280x960.
+	static const Color temp_color_array_1x[NUM_TEMP_RANGES] =
 	{
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x0E), 0x54),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),
@@ -379,10 +603,22 @@ LoadSolarSys (void)
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x08, 0x00), 0x75),
 	};
+	static const Color temp_color_array_2x4x[NUM_TEMP_RANGES] =
+	{
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x12), 0x54),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0B, 0x00), 0x6D),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x08, 0x00), 0x75),
+	};
 
 	RandomContext_SeedRandom (SysGenRNG, GetRandomSeedForStar (CurStarDescPtr));
 
-	SunFrame = SetAbsFrameIndex (SunFrame, STAR_TYPE (CurStarDescPtr->Type));
+	// JMS: Animating IP sun in hi-res...
+	if (RESOLUTION_FACTOR == 0)
+		SunFrame = SetAbsFrameIndex (SunFrame, STAR_TYPE (CurStarDescPtr->Type));
+	else
+		SunFrame = SetAbsFrameIndex (SunFrame, (STAR_TYPE (CurStarDescPtr->Type)) * 32);
 
 	pCurDesc = &pSolarSysState->SunDesc[0];
 	pCurDesc->pPrevDesc = 0;
@@ -419,7 +655,12 @@ LoadSolarSys (void)
 			index = (SysInfo.PlanetInfo.SurfaceTemperature + 250) / 100;
 			if (index >= NUM_TEMP_RANGES)
 				index = NUM_TEMP_RANGES - 1;
-			pCurDesc->temp_color = temp_color_array[index];
+			// JMS_GFX: Let's make the dark blue planet orbit dots a little
+			// more visible in 640x480 and 1280x960.
+			if (RESOLUTION_FACTOR == 0)
+				pCurDesc->temp_color = temp_color_array_1x[index];
+			else
+				pCurDesc->temp_color = temp_color_array_2x4x[index];
 		}
 	}
 
@@ -497,16 +738,117 @@ saveNonOrbitalLocation (void)
 static void
 FreeSolarSys (void)
 {
-	if (pSolarSysState->InIpFlight)
-	{
+	COUNT i, j;
+	PLANET_DESC *pCurDesc;
+
+	if (pSolarSysState->InIpFlight) {
 		pSolarSysState->InIpFlight = FALSE;
-		
+			
 		if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
 			saveNonOrbitalLocation ();
 	}
-
+	
 	DestroyDrawable (ReleaseDrawable (SolarSysFrame));
 	SolarSysFrame = NULL;
+	
+	if (TEXTURED_PLANETS)
+	{
+		// BW: clean up data generated for textured IP planets
+		for (i = 0, pCurDesc = pSolarSysState->PlanetDesc;
+			 i < pSolarSysState->SunDesc[0].NumPlanets; ++i, ++pCurDesc)
+		{
+			PLANET_ORBIT *Orbit = &pCurDesc->orbit;
+			HFree (Orbit->lpTopoData);
+			Orbit->lpTopoData = 0;
+			DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+			Orbit->SphereFrame = NULL;
+		
+			DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+			Orbit->ObjectFrame = 0;
+			DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+			Orbit->WorkFrame = 0;
+		
+			// JMS: Not sure if these do any good...
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TintFrame));
+			pSolarSysState->Orbit.TintFrame = 0;
+			pSolarSysState->Orbit.TintColor = BLACK_COLOR;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->Orbit.TopoZoomFrame));
+			pSolarSysState->Orbit.TopoZoomFrame = 0;
+			DestroyStringTable (ReleaseStringTable (pSolarSysState->XlatRef));
+			pSolarSysState->XlatRef = 0;
+			DestroyDrawable (ReleaseDrawable (pSolarSysState->TopoFrame));
+			pSolarSysState->TopoFrame = 0;
+			DestroyColorMap (ReleaseColorMap (pSolarSysState->OrbitalCMap));
+			pSolarSysState->OrbitalCMap = 0;
+			// JMS ends.
+		
+			HFree (Orbit->TopoColors);
+			Orbit->TopoColors = NULL;
+			HFree (Orbit->ScratchArray);
+			Orbit->ScratchArray = NULL;
+			if (Orbit->map_rotate && Orbit->light_diff)
+			{
+				for (j=0 ; j < GENERATE_PLANET_DIAMETER+1 ; j++)
+				{
+					HFree (Orbit->map_rotate[j]);
+					HFree (Orbit->light_diff[j]);
+				}
+			}
+ 
+			HFree (Orbit->map_rotate);
+			Orbit->map_rotate = NULL;
+			HFree (Orbit->light_diff);
+			Orbit->light_diff = NULL;
+		}	
+
+		// BW: if we were in Inner System, clean up data for textured IP moons
+		if (playerInInnerSystem())
+		{
+			COUNT numMoons;
+			if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
+				numMoons = pSolarSysState->pOrbitalDesc->pPrevDesc->NumPlanets;
+			else
+				numMoons = pSolarSysState->pOrbitalDesc->NumPlanets;
+		
+			for (i = 0, pCurDesc = pSolarSysState->MoonDesc;
+				 i < numMoons; ++i, ++pCurDesc)
+			{
+				if (!(pCurDesc->data_index & WORLD_TYPE_SPECIAL))
+				{
+					PLANET_ORBIT *Orbit = &pCurDesc->orbit;
+			
+					HFree (Orbit->lpTopoData);
+					Orbit->lpTopoData = 0;
+					DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+					Orbit->SphereFrame = NULL;
+			
+					DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+					Orbit->ObjectFrame = 0;
+					DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+					Orbit->WorkFrame = 0;
+			
+					HFree (Orbit->TopoColors);
+					Orbit->TopoColors = NULL;
+					HFree (Orbit->ScratchArray);
+					Orbit->ScratchArray = NULL;
+					if (Orbit->map_rotate && Orbit->light_diff)
+					{
+						for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++)
+						{
+							HFree (Orbit->map_rotate[j]);
+							HFree (Orbit->light_diff[j]);
+						}
+					}
+				
+					HFree (Orbit->map_rotate);
+					Orbit->map_rotate = NULL;
+					HFree (Orbit->light_diff);
+					Orbit->light_diff = NULL;
+				}
+			}
+		}
+	// End clean up
+	}
 
 	StopMusic ();
 
@@ -669,6 +1011,18 @@ ValidateOrbit (PLANET_DESC *planet, int
 {
 	COUNT index;
 
+	if (ORBITING_PLANETS) {
+		// BW: recompute planet position to account for orbiting
+		// COUNT newAngle;
+		// newAngle = NORMALIZE_ANGLE(planet->angle + (COUNT)(daysElapsed() * planet->orb_speed));
+		// planet->location.x = COSINE (newAngle, planet->radius);
+		// planet->location.y = SINE (newAngle, planet->radius);
+		double newAngle;
+		newAngle = (planet->angle + daysElapsed() * planet->orb_speed) * M_PI / 32 - M_PI/2 ;
+		planet->location.x = (COORD)(cos(newAngle) * planet->radius);
+		planet->location.y = (COORD)(sin(newAngle) * planet->radius);
+	}
+
 	if (sizeNumer <= DISPLAY_FACTOR)
 	{	// All planets in outer view, and moons in inner
 		RECT r;
@@ -702,7 +1056,9 @@ ValidateOrbit (PLANET_DESC *planet, int
 		}
 		else if (worldIsMoon (pSolarSysState, planet))
 		{
-			Size += 2;
+			Size = 2; // += 2;
+			// BW:	Force moons to size 2 to avoid issues with
+			//		Triton (the one and only large rocky moon)
 		}
 		else if (denom <= (MAX_ZOOM_RADIUS >> 2))
 		{
@@ -720,6 +1076,23 @@ ValidateOrbit (PLANET_DESC *planet, int
 			angle = ARCTAN (planet->pPrevDesc->location.x,
 					planet->pPrevDesc->location.y);
 		}
+		if (TEXTURED_PLANETS) {
+			// Those match the sizes of the png planets
+			switch (Size) {
+			case 0: planet->size = 3;
+				break;
+			case 1: planet->size = 4;
+				break;
+			case 2: planet->size = 7;
+				break;
+			case 3: planet->size = 11;
+				break;
+			case 4: planet->size = 15;
+				break;
+			case 5: planet->size = 29;
+				break;
+			}
+		}
 		planet->image.frame =	SetAbsFrameIndex (OrbitalFrame,
 				(Size << FACING_SHIFT) + NORMALIZE_FACING (
 				ANGLE_TO_FACING (angle)));
@@ -915,6 +1288,8 @@ enterInnerSystem (PLANET_DESC *planet)
 	ZeroVelocityComponents (&GLOBAL (velocity));
 
 	GenerateMoons (pSolarSysState, planet);
+	if (TEXTURED_PLANETS)
+		GenerateTexturedMoons (pSolarSysState, planet);
 	pSolarSysState->pBaseDesc = pSolarSysState->MoonDesc;
 	pSolarSysState->pOrbitalDesc = planet;
 }
@@ -923,17 +1298,62 @@ static void
 leaveInnerSystem (PLANET_DESC *planet)
 {
 	COUNT outerPlanetWait;
+	COUNT i, j;
+	PLANET_DESC *pMoonDesc;
 
 	pSolarSysState->pBaseDesc = pSolarSysState->PlanetDesc;
 	pSolarSysState->pOrbitalDesc = NULL;
 
 	outerPlanetWait = MAKE_WORD (planet - pSolarSysState->PlanetDesc + 1, 0);
+	// BW: planet may have moved while we were into Inner System
+	ValidateOrbit (planet, DISPLAY_FACTOR, DISPLAY_FACTOR / 4,
+		       pSolarSysState->SunDesc[0].radius);
+	pSolarSysState->SunDesc[0].location =
+			planetOuterLocation (planetIndex (pSolarSysState, planet));
 	GLOBAL (ip_location) = pSolarSysState->SunDesc[0].location;
 	XFormIPLoc (&GLOBAL (ip_location), &GLOBAL (ShipStamp.origin), TRUE);
 	ZeroVelocityComponents (&GLOBAL (velocity));
 
 	// Now the ship is in outer system (as per game logic)
 
+	if (TEXTURED_PLANETS) {
+		// BW: clean up data generated for textured IP moons
+		for (i = 0, pMoonDesc = pSolarSysState->MoonDesc;
+			 i < planet->NumPlanets; ++i, ++pMoonDesc)
+		{
+			if (!(pMoonDesc->data_index & WORLD_TYPE_SPECIAL)) {
+				PLANET_ORBIT *Orbit = &pMoonDesc->orbit;
+
+				HFree (Orbit->lpTopoData);
+				Orbit->lpTopoData = 0;
+				DestroyDrawable (ReleaseDrawable (Orbit->SphereFrame));
+				Orbit->SphereFrame = NULL;
+		
+				DestroyDrawable (ReleaseDrawable (Orbit->ObjectFrame));
+				Orbit->ObjectFrame = 0;
+				DestroyDrawable (ReleaseDrawable (Orbit->WorkFrame));
+				Orbit->WorkFrame = 0;
+
+				HFree (Orbit->TopoColors);
+				Orbit->TopoColors = NULL;
+				HFree (Orbit->ScratchArray);
+				Orbit->ScratchArray = NULL;
+				if (Orbit->map_rotate && Orbit->light_diff) {
+					for (j=0 ; j < GENERATE_MOON_DIAMETER+1 ; j++) {
+						HFree (Orbit->map_rotate[j]);
+						HFree (Orbit->light_diff[j]);
+					}
+				}
+
+				HFree (Orbit->map_rotate);
+				Orbit->map_rotate = NULL;
+				HFree (Orbit->light_diff);
+				Orbit->light_diff = NULL;
+			}
+		}
+		// End clean up
+	}
+
 	pSolarSysState->WaitIntersect = outerPlanetWait;
 	// See if we also intersect with another planet, and if we do,
 	// disable collisions comletely until we stop intersecting
@@ -955,6 +1375,7 @@ static BOOLEAN
 CheckShipLocation (SIZE *newRadius)
 {
 	SIZE radius;
+	BYTE ec = GET_GAME_STATE (ESCAPE_COUNTER); // JMS_GFX
 
 	radius = pSolarSysState->SunDesc[0].radius;
 	*newRadius = pSolarSysState->SunDesc[0].radius;
@@ -992,7 +1413,8 @@ CheckShipLocation (SIZE *newRadius)
 		return TRUE;
 	}
 
-	if (GLOBAL (autopilot.x) == ~0 && GLOBAL (autopilot.y) == ~0)
+	if (GLOBAL (autopilot.x) == ~0 && GLOBAL (autopilot.y) == ~0
+		&& (ec < 60 || RESOLUTION_FACTOR == 0))
 	{	// Not on autopilot -- may collide with a planet
 		PLANET_DESC *planet = CheckIntersect ();
 		if (planet)
@@ -1037,7 +1459,7 @@ TransitionSystemIn (void)
 static void
 ScaleSystem (SIZE new_radius)
 {
-#ifdef SMOOTH_SYSTEM_ZOOM
+#ifdef SMOOTH_SYSTEM_ZOOM // Enabled this for shits 'n gigs.
 	// XXX: This appears to have been an attempt to zoom the system view
 	//   in a different way. This code zooms gradually instead of
 	//   doing a crossfade from one zoom level to the other.
@@ -1046,7 +1468,7 @@ ScaleSystem (SIZE new_radius)
 	//   controls are not handled in the loop, and the flagship
 	//   can collide with a group while zooming, and that is not handled
 	//   100% correctly.
-#define NUM_STEPS 10
+#define NUM_STEPS 1
 	COUNT i;
 	SIZE old_radius;
 	SIZE d, step;
@@ -1108,38 +1530,284 @@ RestoreSystemView (void)
 	DrawStamp (&s);
 }
 
+// JMS: This animates the truespace suns!
+#define SUN_ANIMFRAMES_NUM 32
+static void
+AnimateSun (SIZE radius)
+{
+	PLANET_DESC *pSunDesc = &pSolarSysState->SunDesc[0];
+	PLANET_DESC *pNearestPlanetDesc = &pSolarSysState->PlanetDesc[0];
+	static COUNT sunAnimIndex = 0;
+	COUNT zoomLevelIndex = 0;
+	
+	// Advance to the next frame.
+	sunAnimIndex++;
+	
+	// Go back to start of the anim after advancing past the last frame.
+	if (sunAnimIndex % SUN_ANIMFRAMES_NUM == 0)
+		sunAnimIndex = 0;
+	
+	// Zoom according to how close we are to the sun.
+	if (radius <= (MAX_ZOOM_RADIUS >> 1))
+	{
+		zoomLevelIndex += SUN_ANIMFRAMES_NUM;
+		if (radius <= (MAX_ZOOM_RADIUS >> 2))
+			zoomLevelIndex += SUN_ANIMFRAMES_NUM;
+	}
+	
+	// Tell the imageset which frame it should use.
+	pSunDesc->image.frame = SetRelFrameIndex (SunFrame, zoomLevelIndex + sunAnimIndex);
+	
+	// Draw the image.
+	DrawStamp (&pSunDesc->image);
+	
+	// BW: temporary workaround, drawing order will have to be redone anyway
+	if (!TEXTURED_PLANETS)
+	{
+		// Re-draw the image of the nearest planet, so the sun won't obscure it.
+		SetPlanetColorMap (pNearestPlanetDesc);
+		DrawStamp (&pNearestPlanetDesc->image);
+	}
+}
+
+static void
+CalcSunSize (PLANET_DESC *pSunDesc, SIZE radius)
+{
+	SIZE index = 0;
+
+	if (radius <= (MAX_ZOOM_RADIUS >> 1))
+	{
+		++index;
+		if (radius <= (MAX_ZOOM_RADIUS >> 2))
+			++index;
+	}
+
+	pSunDesc->image.origin.x = SIS_SCREEN_WIDTH >> 1;
+	pSunDesc->image.origin.y = SIS_SCREEN_HEIGHT >> 1;
+	// JMS: Animating IP sun in hi-res modes...
+	if (RESOLUTION_FACTOR == 0)
+		pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index);
+	else
+		pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index * SUN_ANIMFRAMES_NUM);
+}
+
+static void
+SetPlanetColorMap (PLANET_DESC *planet)
+{
+	COUNT index = planet->data_index & ~WORLD_TYPE_SPECIAL;
+	assert (index < NUMBER_OF_PLANET_TYPES);
+	SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (OrbitalCMap,
+			PLANCOLOR (PlanData[index].Type))));
+}
+
+static void
+DrawTexturedBody (PLANET_DESC* planet, STAMP s)
+{
+	int oldScale;
+	int oldMode;
+	
+	BatchGraphics ();
+	oldMode = SetGraphicScaleMode (TFB_SCALE_BILINEAR);
+	if (worldIsMoon(pSolarSysState, planet))
+		oldScale = SetGraphicScale (GSCALE_IDENTITY * (optScalePlanets ? RES_SCALE(planet->size) : planet->size) / GENERATE_MOON_DIAMETER);
+	else
+		oldScale = SetGraphicScale (GSCALE_IDENTITY * (optScalePlanets ? RES_SCALE(planet->size) : planet->size) / GENERATE_PLANET_DIAMETER);
+	s.frame = planet->orbit.SphereFrame;
+	DrawStamp (&s);
+	if (planet->orbit.ObjectFrame)
+	{
+		s.frame = planet->orbit.ObjectFrame;
+		DrawStamp (&s);
+	}
+	SetGraphicScale (oldScale);
+	SetGraphicScaleMode (oldMode);
+	
+	UnbatchGraphics ();
+}
+
+static void
+DrawInnerPlanets (PLANET_DESC *planet)
+{
+	STAMP s;
+	COUNT i;
+	PLANET_DESC *moon;
+
+	s.origin.x = SIS_SCREEN_WIDTH >> 1;
+	s.origin.y = SIS_SCREEN_HEIGHT >> 1;
+
+	if (TEXTURED_PLANETS) {
+		// Draw the planet image
+		DrawTexturedBody (planet, s);
+		
+		// Draw the moon images
+		for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
+		     i; --i, ++moon)
+		{
+			if (moon->data_index & WORLD_TYPE_SPECIAL)
+				DrawStamp (&moon->image);
+			else
+				DrawTexturedBody(moon, moon->image);
+		}
+	} else {
+		// Draw the planet image
+		SetPlanetColorMap (planet);
+		s.frame = planet->image.frame;
+
+		i = planet->data_index & ~WORLD_TYPE_SPECIAL;
+		if (i < NUMBER_OF_PLANET_TYPES
+			&& (planet->data_index & PLANET_SHIELDED))
+		{	// Shielded world looks "shielded" in inner view
+			s.frame = SetAbsFrameIndex (SpaceJunkFrame, 17);
+		}
+		DrawStamp (&s);
+
+		// Draw the moon images
+		for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
+			i; --i, ++moon)
+		{
+			if (!(moon->data_index & WORLD_TYPE_SPECIAL))
+				SetPlanetColorMap (moon);
+			DrawStamp (&moon->image);
+		}
+	}
+}
+
+static void
+DrawOuterPlanets (SIZE radius)
+{
+	SIZE index;
+	PLANET_DESC *pCurDesc;
+	
+	CalcSunSize (&pSolarSysState->SunDesc[0], radius);
+	
+	index = pSolarSysState->FirstPlanetIndex;
+	for (;;)
+	{
+		pCurDesc = &pSolarSysState->PlanetDesc[index];
+		if (TEXTURED_PLANETS)
+		{
+			if (pCurDesc == &pSolarSysState->SunDesc[0])
+			{	// It's a sun
+				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
+					SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
+				DrawStamp (&pCurDesc->image);
+			}
+			else
+			{	// It's a planet
+				DrawTexturedBody(pCurDesc, pCurDesc->image);
+			}
+		}
+		else
+		{
+			if (pCurDesc == &pSolarSysState->SunDesc[0])
+			{	// It's a sun
+				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
+					SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
+			}
+			else
+			{	// It's a planet
+				SetPlanetColorMap (pCurDesc);
+			}
+			DrawStamp (&pCurDesc->image);
+		}
+		
+		if (index == pSolarSysState->LastPlanetIndex)
+			break;
+		index = pCurDesc->NextIndex;
+	}
+}
+
+void RotatePlanets (BOOLEAN IsInnerSystem, SIZE frameCounter)
+{
+	PLANET_DESC *planet;
+	PLANET_DESC *moon;
+	COUNT i;
+
+	// Do not try to rotate planets that haven't been generated yet.
+	if (!pSolarSysState->PlanetDesc->orbit.lpTopoData)
+		return;
+	
+	if (IsInnerSystem) {
+		planet = pSolarSysState->pOrbitalDesc;
+		PrepareNextRotationFrame (planet, frameCounter, FALSE);
+		for (i = 0; i < planet->NumPlanets; ++i) {
+			moon = &pSolarSysState->MoonDesc[i];
+			if (!(moon->data_index & WORLD_TYPE_SPECIAL))
+				PrepareNextRotationFrame (moon, frameCounter, FALSE);
+		}
+	} else {
+		for (i = pSolarSysState->SunDesc[0].NumPlanets,
+			     planet = &pSolarSysState->PlanetDesc[0]; i; --i, ++planet)
+			PrepareNextRotationFrame (planet, frameCounter, FALSE);
+	}
+}
+
 // Normally called by DoIpFlight() to process a frame
 static void
 IP_frame (void)
 {
 	BOOLEAN locChange;
 	SIZE newRadius;
+	static SIZE frameCounter;
 
 	SetContext (SpaceContext);
 
 	GameClockTick ();
+	++frameCounter;
 	ProcessShipControls ();
 	
 	locChange = CheckShipLocation (&newRadius);
-	if (locChange)
-	{
-		if (playerInInnerSystem ())
-		{	// Entering inner system
+	if (locChange) {
+		if (playerInInnerSystem ()) {	// Entering inner system
 			DrawSystemTransition (TRUE);
-		}
-		else if (pSolarSysState->SunDesc[0].radius == newRadius)
-		{	// Leaving inner system to outer
+		} else if (pSolarSysState->SunDesc[0].radius == newRadius) {	
+			// Leaving inner system to outer
 			DrawSystemTransition (FALSE);
-		}
-		else
-		{	// Zooming outer system
+		} else {	// Zooming outer system
 			ScaleSystem (newRadius);
 		}
-	}
-	else
-	{	// Just flying around, minding own business..
+	} else if (!pSolarSysState->InOrbit) {
+		// Just flying around, minding own business..
 		BatchGraphics ();
 		RestoreSystemView ();
+
+		if (ORBITING_PLANETS) {
+			// BW: recompute planet position to account for orbiting
+			if (playerInInnerSystem ()) {
+				// Draw the inner system view
+				ValidateInnerOrbits ();
+			} else {
+				// Draw the outer system view
+				ValidateOrbits ();
+			}
+		}
+		
+		if (ROTATING_PLANETS) {
+		// BW: rotate planets
+		// every frame in Inner (not much CPU required)
+		// depending on planet size and speed in Outer
+			if (playerInInnerSystem ()) {
+				RotatePlanets (TRUE, frameCounter);
+			} else {
+				RotatePlanets (FALSE, frameCounter);
+			}
+		}
+
+		if (ORBITING_PLANETS || ROTATING_PLANETS) { 
+			// Planets have probably moved or changed
+			if (playerInInnerSystem ()) {	
+				// Draw the inner system view
+				DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
+			} else {
+				// Draw the outer system view
+				DrawOuterPlanets (pSolarSysState->SunDesc[0].radius);
+			}
+		}
+
+		// JMS: Animating IP sun in hi-res modes...
+		if (!playerInInnerSystem () && RESOLUTION_FACTOR != 0)
+			AnimateSun (newRadius);
+
 		RedrawQueue (FALSE);
 		DrawAutoPilotMessage (FALSE);
 		UnbatchGraphics ();
@@ -1207,7 +1875,10 @@ DrawInnerSystem (void)
 {
 	ValidateInnerOrbits ();
 	DrawSystem (pSolarSysState->pOrbitalDesc->radius, TRUE);
+	if (ORBITING_PLANETS || ROTATING_PLANETS)
+		DrawInnerPlanets(pSolarSysState->pOrbitalDesc);
 	DrawSISTitle (GLOBAL_SIS (PlanetName));
+	IP_frame(); // MB: To fix planet texture and sun corona 'pop-in'
 }
 
 static void
@@ -1215,7 +1886,10 @@ DrawOuterSystem (void)
 {
 	ValidateOrbits ();
 	DrawSystem (pSolarSysState->SunDesc[0].radius, FALSE);
+	if (ORBITING_PLANETS || ROTATING_PLANETS)
+		DrawOuterPlanets(pSolarSysState->SunDesc[0].radius);
 	DrawHyperCoords (CurStarDescPtr->star_pt);
+	IP_frame(); // MB: To fix planet texture and sun corona 'pop-in'
 }
 
 static void
@@ -1255,24 +1929,32 @@ ResetSolarSys (void)
 static void
 EnterPlanetOrbit (void)
 {
-	if (pSolarSysState->InIpFlight)
-	{	// This means we hit a planet in IP flight; not a Load into orbit
+	//	if (pSolarSysState->InIpFlight)
+	//	{	// This means we hit a planet in IP flight; not a Load into orbit
+	// BW: It seems that even a Load generates a solar system...
 		FreeSolarSys ();
 
 		if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc))
-		{	// Moon -- use its origin
+		{	
+			int moon;
+			// Moon -- use its origin
 			// XXX: The conversion functions do not error-correct, so the
 			//   point we set here will change once flag_ship_preprocess()
 			//   in ipdisp.c starts over again.
-			GLOBAL (ShipStamp.origin) =
-					pSolarSysState->pOrbitalDesc->image.origin;
-		}
-		else
-		{	// Planet -- its origin is for the outer view, so use mid-screen
+			GLOBAL (ShipStamp.origin) = pSolarSysState->pOrbitalDesc->image.origin;
+			// JMS_GFX: Draw the moon letter when orbiting a moon in 1280x960
+			// and 640x480 modes. Do not draw it in 320x240 since there's no room!
+			if (RESOLUTION_FACTOR > 0 && !(GetNamedPlanetaryBody()) && pSolarSysState->pOrbitalDesc->data_index != HIERARCHY_STARBASE)
+			{
+				moon = moonIndex (pSolarSysState, pSolarSysState->pOrbitalDesc);
+				snprintf ((GLOBAL_SIS (PlanetName)) + strlen(GLOBAL_SIS (PlanetName)), 3, "-%c%c", 'A' + moon, '\0');
+				DrawSISTitle (GLOBAL_SIS (PlanetName));
+			}
+		} else {	
+			// Planet -- its origin is for the outer view, so use mid-screen
 			GLOBAL (ShipStamp.origin.x) = SIS_SCREEN_WIDTH >> 1;
 			GLOBAL (ShipStamp.origin.y) = SIS_SCREEN_HEIGHT >> 1;
 		}
-	}
 
 	GetPlanetInfo ();
 	(*pSolarSysState->genFuncs->generateOrbital) (pSolarSysState,
@@ -1281,7 +1963,9 @@ EnterPlanetOrbit (void)
 	if ((GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD |
 			START_ENCOUNTER)) || GLOBAL_SIS (CrewEnlisted) == (COUNT)~0
 			|| GET_GAME_STATE (CHMMR_BOMB_STATE) == 2)
-		return;
+		{
+			return;
+		}
 
 	// Implement a to-do in generate.h for a better test
 	if (pSolarSysState->TopoFrame)
@@ -1306,6 +1990,13 @@ EnterPlanetOrbit (void)
 		ValidateOrbits ();
 		ValidateInnerOrbits ();
 		ResetSolarSys ();
+		if (TEXTURED_PLANETS) {
+			if (worldIsMoon (pSolarSysState, pSolarSysState->pOrbitalDesc)) {
+				GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc->pPrevDesc);
+			} else {
+				GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc);
+			}
+		}
 
 		RepairSISBorder ();
 		TransitionSystemIn ();
@@ -1380,6 +2071,10 @@ InitSolarSys (void)
 
 		ResetSolarSys ();
 
+		// JMS: This is to prevent flashing the 3do "navigate"
+		// unnecessarily whilst starting a new game.
+		SetFlashRect (NULL);
+
 		if (LastActivity == (CHECK_LOAD | CHECK_RESTART))
 		{	// Starting a new game, NOT from load!
 			// We have to fade the screen in from intro or menu
@@ -1397,8 +2092,12 @@ InitSolarSys (void)
 		}
 		else
 		{	// Entered a new system, or loaded into inner or outer
-			if (InnerSystem)
-				DrawInnerSystem ();
+			if (InnerSystem) {
+				if (TEXTURED_PLANETS) {
+					GenerateTexturedMoons(pSolarSysState, pSolarSysState->pOrbitalDesc);
+				}
+ 				DrawInnerSystem ();
+			}
 			else
 				DrawOuterSystem ();
 			RedrawQueue (FALSE);
@@ -1407,6 +2106,7 @@ InitSolarSys (void)
 
 			LastActivity &= ~CHECK_LOAD;
 		}
+		IP_frame(); // MB: To fix planet texture and sun corona 'pop-in'
 	}
 }
 
@@ -1461,8 +2161,8 @@ UninitSolarSys (void)
 {
 	FreeSolarSys ();
 
-//FreeLanderData ();
-//FreeIPData ();
+	// FreeLanderData (); // JMS: This is not needed since the landerframes won't reload if they're already loaded once.
+	FreeIPData (); // JMS This IS necessary.
 
 	DestroyDrawable (ReleaseDrawable (StarsFrame));
 	StarsFrame = NULL;
@@ -1490,63 +2190,6 @@ UninitSolarSys (void)
 }
 
 static void
-CalcSunSize (PLANET_DESC *pSunDesc, SIZE radius)
-{
-	SIZE index = 0;
-
-	if (radius <= (MAX_ZOOM_RADIUS >> 1))
-	{
-		++index;
-		if (radius <= (MAX_ZOOM_RADIUS >> 2))
-			++index;
-	}
-
-	pSunDesc->image.origin.x = SIS_SCREEN_WIDTH >> 1;
-	pSunDesc->image.origin.y = SIS_SCREEN_HEIGHT >> 1;
-	pSunDesc->image.frame = SetRelFrameIndex (SunFrame, index);
-}
-
-static void
-SetPlanetColorMap (PLANET_DESC *planet)
-{
-	COUNT index = planet->data_index & ~WORLD_TYPE_SPECIAL;
-	assert (index < NUMBER_OF_PLANET_TYPES);
-	SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (OrbitalCMap,
-			PLANCOLOR (PlanData[index].Type))));
-}
-
-static void
-DrawInnerPlanets (PLANET_DESC *planet)
-{
-	STAMP s;
-	COUNT i;
-	PLANET_DESC *moon;
-
-	// Draw the planet image
-	SetPlanetColorMap (planet);
-	s.origin.x = SIS_SCREEN_WIDTH >> 1;
-	s.origin.y = SIS_SCREEN_HEIGHT >> 1;
-	s.frame = planet->image.frame;
-
-	i = planet->data_index & ~WORLD_TYPE_SPECIAL;
-	if (i < NUMBER_OF_PLANET_TYPES
-			&& (planet->data_index & PLANET_SHIELDED))
-	{	// Shielded world looks "shielded" in inner view
-		s.frame = SetAbsFrameIndex (SpaceJunkFrame, 17);
-	}
-	DrawStamp (&s);
-
-	// Draw the moon images
-	for (i = planet->NumPlanets, moon = pSolarSysState->MoonDesc;
-			i; --i, ++moon)
-	{
-		if (!(moon->data_index & WORLD_TYPE_SPECIAL))
-			SetPlanetColorMap (moon);
-		DrawStamp (&moon->image);
-	}
-}
-
-static void
 DrawSystem (SIZE radius, BOOLEAN IsInnerSystem)
 {
 	BYTE i;
@@ -1555,6 +2198,12 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 	CONTEXT oldContext;
 	STAMP s;
 
+	if (TEXTURED_PLANETS) {
+		// BW: This to test if we have already rendered 
+		if (!pSolarSysState->PlanetDesc->orbit.lpTopoData)
+			GenerateTexturedPlanets();
+	}
+
 	if (!SolarSysFrame)
 	{	// Create the saved view graphic
 		RECT clipRect;
@@ -1588,34 +2237,13 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 					radius);
 	}
 
-	if (IsInnerSystem)
-	{	// Draw the inner system view
-		DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
-	}
-	else
-	{	// Draw the outer system view
-		SIZE index;
-
-		CalcSunSize (&pSolarSysState->SunDesc[0], radius);
-
-		index = pSolarSysState->FirstPlanetIndex;
-		for (;;)
-		{
-			pCurDesc = &pSolarSysState->PlanetDesc[index];
-			if (pCurDesc == &pSolarSysState->SunDesc[0])
-			{	// It's a sun
-				SetColorMap (GetColorMapAddress (SetAbsColorMapIndex (
-						SunCMap, STAR_COLOR (CurStarDescPtr->Type))));
-			}
-			else
-			{	// It's a planet
-				SetPlanetColorMap (pCurDesc);
-			}
-			DrawStamp (&pCurDesc->image);
-
-			if (index == pSolarSysState->LastPlanetIndex)
-				break;
-			index = pCurDesc->NextIndex;
+	if (!ORBITING_PLANETS && !ROTATING_PLANETS) {
+		if (IsInnerSystem) {	
+			// Draw the inner system view
+			DrawInnerPlanets (pSolarSysState->pOrbitalDesc);
+		} else {	
+			// Draw the outer system view
+			DrawOuterPlanets (radius);
 		}
 	}
 
@@ -1626,6 +2254,7 @@ DrawSystem (SIZE radius, BOOLEAN IsInner
 	s.origin.y = 0;
 	s.frame = SolarSysFrame;
 	DrawStamp (&s);
+	IP_frame();  // MB: To fix planet texture and sun corona 'pop-in'
 }
 
 void
@@ -1644,10 +2273,13 @@ CreateStarBackGround (void)
 {
 	COUNT i, j;
 	DWORD rand_val;
-	STAMP s;
+	STAMP s, nebula; // JMS (added that nebula there)
 	CONTEXT oldContext;
 	RECT clipRect;
 	FRAME frame;
+	BYTE numNebulae = 44;
+	COUNT NebulaePercentX = CurStarDescPtr->star_pt.x % numNebulae;
+	COUNT NebulaePercentY = CurStarDescPtr->star_pt.y % (numNebulae + 6);
 
 	// Use SpaceContext to find out the dimensions of the background
 	oldContext = SetContext (SpaceContext);
@@ -1683,7 +2315,7 @@ CreateStarBackGround (void)
 #define NUM_BRT_PIECES 8
 	for (i = 0; i < NUM_BRT_PIECES; ++i)
 	{
-#define NUM_BRT_DRAWN 30
+#define NUM_BRT_DRAWN (optNebulae && NebulaePercentY < numNebulae ? RES_CASE(30, 90, 270) : RES_CASE(30, 120, 480))
 		for (j = 0; j < NUM_BRT_DRAWN; ++j)
 		{
 			rand_val = RandomContext_Random (SysGenRNG);
@@ -1694,6 +2326,16 @@ CreateStarBackGround (void)
 		}
 		s.frame = IncFrameIndex (s.frame);
 	}
+	
+	if (optNebulae && NebulaePercentY < numNebulae){ // MB: Make some solar systems not have nebulae
+		nebula.origin.x = nebula.origin.y = 0;
+		nebula.frame = SetAbsFrameIndex (NebulaeFrame, NebulaePercentX);
+		DrawStamp(&nebula);
+#ifdef DEBUG
+		// Prints out the frame number of the current system's nebula
+		printf("Nebula Frame: %d\n", NebulaePercentX);
+#endif	
+	}
 
 	SetContext (oldContext);
 
@@ -1825,8 +2467,10 @@ void
 GetPlanetOrMoonName (UNICODE *buf, COUNT bufsize)
 {
 	UNICODE *named;
-	int moon;
-	int i;
+	UNICODE *tempbuf;
+	int		moon;
+	int		i;
+	BOOLEAN name_has_suffix = FALSE;
 
 	named = GetNamedPlanetaryBody ();
 	if (named)
@@ -1846,11 +2490,20 @@ GetPlanetOrMoonName (UNICODE *buf, COUNT
 
 	// Orbiting an unnamed moon
 	i = strlen (buf);
+	tempbuf = buf;
 	buf += i;
 	bufsize -= i;
 	moon = moonIndex (pSolarSysState, pSolarSysState->pOrbitalDesc);
-	if (bufsize >= 3)
-	{
+	
+	log_add (log_Debug,"last %02d, i %d", tempbuf[i-1], i);	
+	// JMS: Prevent printing something like 'planet II-A-A' in summary screen.
+	if (i > 0) {
+		if(tempbuf[i-1] == 'A' || tempbuf[i-1] == 'B' 
+			|| tempbuf[i-1] == 'C' || tempbuf[i-1] == 'D')
+			name_has_suffix = TRUE;
+	}
+	
+	if (bufsize >= 3 && !name_has_suffix) {
 		snprintf (buf, bufsize, "-%c", 'A' + moon);
 		buf[bufsize - 1] = '\0';
 	}
diff -ruNp src.orig/uqm/planets/surface.c src/uqm/planets/surface.c
--- src.orig/uqm/planets/surface.c	2017-12-30 00:14:41 -0800
+++ src/uqm/planets/surface.c	2017-12-30 00:14:53 -0800
@@ -47,18 +47,36 @@ CalcMineralDeposits (const SYSTEM_INFO *
 		while (num_possible--)
 		{
 #define MEDIUM_DEPOSIT_THRESHOLD 150
-#define LARGE_DEPOSIT_THRESHOLD 225
+#define LARGE_DEPOSIT_THRESHOLD 220
 			COUNT deposit_quality_fine;
 			COUNT deposit_quality_gross;
 
+			// JMS: For making the mineral blip smaller in case it is partially scavenged.
+			SDWORD temp_deposit_quality;
+
 			deposit_quality_fine = (LOWORD (RandomContext_Random (SysGenRNG)) % 100)
 					+ (
 					DEPOSIT_QUALITY (eptr->Density)
 					+ SysInfoPtr->StarSize
 					) * 50;
-			if (deposit_quality_fine < MEDIUM_DEPOSIT_THRESHOLD)
+
+			// JMS: This makes the mineral blip smaller in case it is partially scavenged.
+			if (which_deposit < 32)
+				temp_deposit_quality = deposit_quality_fine - ((SysInfoPtr->PlanetInfo.PartiallyScavengedList[MINERAL_SCAN][which_deposit]) * 10);
+			// JMS: In case which_deposit >= 32 (most likely 65535), it means that this
+			// function is being called only to count the number of deposit nodes on the
+			// surface. In that case we don't need to use the PartiallyScavengedList
+			// since the amount of minerals in that node is not stored yet.
+			// (AND we cannot use the list since accessing element 65535 would crash the game ;)
+			else
+				temp_deposit_quality = deposit_quality_fine;
+			
+			if (temp_deposit_quality < 0)
+				temp_deposit_quality = 0;
+			
+			if (temp_deposit_quality < MEDIUM_DEPOSIT_THRESHOLD)
 				deposit_quality_gross = 0;
-			else if (deposit_quality_fine < LARGE_DEPOSIT_THRESHOLD)
+			else if (temp_deposit_quality < LARGE_DEPOSIT_THRESHOLD)
 				deposit_quality_gross = 1;
 			else
 				deposit_quality_gross = 2;
@@ -212,10 +230,32 @@ void
 GenerateRandomLocation (POINT *loc)
 {
 	UWORD rand_val;
+	UWORD x, y; // JMS_GFX: Helpers.
 
 	rand_val = RandomContext_Random (SysGenRNG);
-	loc->x = 8 + LOBYTE (rand_val) % (MAP_WIDTH - (8 << 1));
-	loc->y = 8 + HIBYTE (rand_val) % (MAP_HEIGHT - (8 << 1));
+	// loc->x = 8 + LOBYTE (rand_val) % (MAP_WIDTH - (8 << 1));
+	// loc->y = 8 + HIBYTE (rand_val) % (MAP_HEIGHT - (8 << 1));
+
+	x = (LOBYTE (rand_val) % (ORIGINAL_MAP_WIDTH - (8 << 1)));
+	y = (HIBYTE (rand_val) % (ORIGINAL_MAP_HEIGHT - (8 << 1)));
+	
+	// JMS_GFX
+	x <<= RESOLUTION_FACTOR;
+	y <<= RESOLUTION_FACTOR;
+	loc->x = x;
+	loc->y = y;
+	
+	loc->x += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	loc->y += 8 << RESOLUTION_FACTOR; // JMS_GFX
+	
+	// JMS_GFX: Compensate for 1280x960's different aspect ratio
+	if (RESOLUTION_FACTOR == 2)
+	{
+		DWORD xx = (DWORD)loc->x;
+		xx *= 111;
+		xx /= 100;
+		loc->x = (COUNT)xx;
+	}
 }
 
 // Returns:
diff -ruNp src.orig/uqm/process.c src/uqm/process.c
--- src.orig/uqm/process.c	2017-12-30 00:14:41 -0800
+++ src/uqm/process.c	2017-12-30 00:14:53 -0800
@@ -39,9 +39,9 @@
 
 COUNT DisplayFreeList;
 PRIMITIVE DisplayArray[MAX_DISPLAY_PRIMS];
-extern POINT SpaceOrg;
+extern DPOINT SpaceOrg;
 
-SIZE zoom_out = 1 << ZOOM_SHIFT;
+COUNT zoom_out = 1 << ZOOM_SHIFT;
 static SIZE opt_max_zoom_out;
 
 #if 0
@@ -204,7 +204,7 @@ PostProcess (ELEMENT *ElementPtr)
 }
 
 static COUNT
-CalcReduction (SIZE dx, SIZE dy)
+CalcReduction (SDWORD dx, SDWORD dy)
 {
 	COUNT next_reduction;
 
@@ -214,7 +214,7 @@ CalcReduction (SIZE dx, SIZE dy)
 
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{
-		SIZE sdx, sdy;
+		SDWORD sdx, sdy;
 
 		if (LOBYTE (GLOBAL (CurrentActivity)) > IN_ENCOUNTER)
 			return (0);
@@ -232,8 +232,8 @@ CalcReduction (SIZE dx, SIZE dy)
 		if (next_reduction < zoom_out
 				&& zoom_out <= MAX_VIS_REDUCTION)
 		{
-#define HYSTERESIS_X DISPLAY_TO_WORLD(24)
-#define HYSTERESIS_Y DISPLAY_TO_WORLD(20)
+#define HYSTERESIS_X DISPLAY_TO_WORLD(24 << RESOLUTION_FACTOR) // JMS_GFX
+#define HYSTERESIS_Y DISPLAY_TO_WORLD(20 << RESOLUTION_FACTOR) // JMS_GFX
 		if (((sdx + HYSTERESIS_X)
 				<< (MAX_VIS_REDUCTION - next_reduction)) > TRANSITION_WIDTH
 				|| ((sdy + HYSTERESIS_Y)
@@ -281,23 +281,23 @@ CalcReduction (SIZE dx, SIZE dy)
 }
 
 static VIEW_STATE
-CalcView (POINT *pNewScrollPt, SIZE next_reduction,
-		SIZE *pdx, SIZE *pdy, COUNT ships_alive)
+CalcView (DPOINT *pNewScrollPt, SIZE next_reduction,
+		SDWORD *pdx, SDWORD *pdy, COUNT ships_alive)
 {
-	SIZE dx, dy;
+	SDWORD dx, dy;
 	VIEW_STATE view_state;
 
 #ifdef KDEBUG
 	log_add (log_Debug, "CalcView:");
 #endif
-	dx = ((COORD)(LOG_SPACE_WIDTH >> 1) - pNewScrollPt->x);
-	dy = ((COORD)(LOG_SPACE_HEIGHT >> 1) - pNewScrollPt->y);
+	dx = ((SDWORD)(LOG_SPACE_WIDTH >> 1) - pNewScrollPt->x);
+	dy = ((SDWORD)(LOG_SPACE_HEIGHT >> 1) - pNewScrollPt->y);
 	dx = WRAP_DELTA_X (dx);
 	dy = WRAP_DELTA_Y (dy);
 	if (ships_alive == 1)
 	{
-#define ORG_JUMP_X ((SIZE)DISPLAY_ALIGN(LOG_SPACE_WIDTH / 75))
-#define ORG_JUMP_Y ((SIZE)DISPLAY_ALIGN(LOG_SPACE_HEIGHT / 75))
+#define ORG_JUMP_X ((SDWORD)DISPLAY_ALIGN(LOG_SPACE_WIDTH / 75))
+#define ORG_JUMP_Y ((SDWORD)DISPLAY_ALIGN(LOG_SPACE_HEIGHT / 75))
 		if (dx > ORG_JUMP_X)
 			dx = ORG_JUMP_X;
 		else if (dx < -ORG_JUMP_X)
@@ -318,12 +318,8 @@ CalcView (POINT *pNewScrollPt, SIZE next
 	{
 		if (optMeleeScale == TFB_SCALE_STEP)
 		{
-			SpaceOrg.x = (COORD)(LOG_SPACE_WIDTH >> 1)
-					- (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1)
-					- next_reduction));
-			SpaceOrg.y = (COORD)(LOG_SPACE_HEIGHT >> 1)
-					- (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1)
-					- next_reduction));
+			SpaceOrg.x = (SDWORD)(LOG_SPACE_WIDTH >> 1) - (LOG_SPACE_WIDTH >> ((MAX_REDUCTION + 1) - next_reduction));
+			SpaceOrg.y = (SDWORD)(LOG_SPACE_HEIGHT >> 1) - (LOG_SPACE_HEIGHT >> ((MAX_REDUCTION + 1) - next_reduction));
 		}
 		else
 		{
@@ -336,10 +332,9 @@ CalcView (POINT *pNewScrollPt, SIZE next
 				
 			// Always align the origin on a whole pixel to reduce the
 			// amount of object positioning jitter
-			SpaceOrg.x = DISPLAY_ALIGN((int)(LOG_SPACE_WIDTH >> 1) -
-					(LOG_SPACE_WIDTH * next_reduction / (MAX_ZOOM_OUT << 2)));
-			SpaceOrg.y = DISPLAY_ALIGN((int)(LOG_SPACE_HEIGHT >> 1) -
-					(LOG_SPACE_HEIGHT * next_reduction / (MAX_ZOOM_OUT << 2)));
+			SpaceOrg.x = DISPLAY_ALIGN((int)(LOG_SPACE_WIDTH >> 1) - (LOG_SPACE_WIDTH * next_reduction / (MAX_ZOOM_OUT << 2)));
+			SpaceOrg.y = DISPLAY_ALIGN((int)(LOG_SPACE_HEIGHT >> 1) - (LOG_SPACE_HEIGHT * next_reduction / (MAX_ZOOM_OUT << 2)));
+ 		
 		}
 		zoom_out = next_reduction;
 		view_state = VIEW_CHANGE;
@@ -627,11 +622,11 @@ ProcessCollisions (HELEMENT hSuccElement
 }
 
 static VIEW_STATE
-PreProcessQueue (SIZE *pscroll_x, SIZE *pscroll_y)
+PreProcessQueue (SDWORD *pscroll_x, SDWORD *pscroll_y)
 {
 	SIZE min_reduction, max_reduction;
 	COUNT sides_active;
-	POINT Origin;
+	DPOINT Origin;
 	HELEMENT hElement;
 	COUNT ships_alive;
 
@@ -646,8 +641,8 @@ PreProcessQueue (SIZE *pscroll_x, SIZE *
 	else
 		min_reduction = max_reduction = MAX_ZOOM_OUT + (1 << ZOOM_SHIFT);
 
-	Origin.x = (COORD)(LOG_SPACE_WIDTH >> 1);
-	Origin.y = (COORD)(LOG_SPACE_HEIGHT >> 1);
+	Origin.x = (SDWORD)(LOG_SPACE_WIDTH >> 1);
+	Origin.y = (SDWORD)(LOG_SPACE_HEIGHT >> 1);
 
 	hElement = GetHeadElement ();
 	ships_alive = 0;
@@ -669,7 +664,7 @@ PreProcessQueue (SIZE *pscroll_x, SIZE *
 
 		if (ElementPtr->state_flags & PLAYER_SHIP)
 		{
-			SIZE dx, dy;
+			SDWORD dx, dy;
 
 			ships_alive++;
 			if (max_reduction > opt_max_zoom_out
@@ -783,7 +778,7 @@ InsertPrim (PRIM_LINKS *pLinks, COUNT pr
 PRIM_LINKS DisplayLinks;
 
 static inline COORD
-CalcDisplayCoord (COORD c, COORD orgc, SIZE reduction)
+CalcDisplayCoord (SDWORD c, SDWORD orgc, SIZE reduction)
 {
 	if (optMeleeScale == TFB_SCALE_STEP)
 	{	/* old fixed-step zoom style */
@@ -796,10 +791,9 @@ CalcDisplayCoord (COORD c, COORD orgc, S
 }
 
 static void
-PostProcessQueue (VIEW_STATE view_state, SIZE scroll_x,
-		SIZE scroll_y)
+PostProcessQueue (VIEW_STATE view_state, SDWORD scroll_x, SDWORD scroll_y)
 {
-	POINT delta;
+	DPOINT delta;
 	SIZE reduction;
 	HELEMENT hElement;
 
@@ -889,35 +883,28 @@ PostProcessQueue (VIEW_STATE view_state,
 
 				if (ObjType == LINE_PRIM)
 				{
-					SIZE dx, dy;
-
-					dx = ElementPtr->next.location.x
-							- ElementPtr->current.location.x;
-					dy = ElementPtr->next.location.y
-							- ElementPtr->current.location.y;
-
-					next.x = WRAP_X (ElementPtr->current.location.x + delta.x);
-					next.y = WRAP_Y (ElementPtr->current.location.y + delta.y);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					SDWORD dx, dy;
+					
+					dx = (SDWORD)ElementPtr->next.location.x - (SDWORD)ElementPtr->current.location.x;
+					dy = (SDWORD)ElementPtr->next.location.y - (SDWORD)ElementPtr->current.location.y;
+					
+					next.x = WRAP_X ((SDWORD)ElementPtr->current.location.x + (SDWORD)delta.x);
+					next.y = WRAP_Y ((SDWORD)ElementPtr->current.location.y + (SDWORD)delta.y);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.first.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
 
 					next.x += dx;
 					next.y += dy;
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Line.second.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
 				}
 				else
 				{
-					next.x = WRAP_X (ElementPtr->next.location.x + delta.x);
-					next.y = WRAP_Y (ElementPtr->next.location.y + delta.y);
-					DisplayArray[ElementPtr->PrimIndex].Object.Point.x =
-							CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
-					DisplayArray[ElementPtr->PrimIndex].Object.Point.y =
-							CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
+					next.x = WRAP_X ((SDWORD)ElementPtr->next.location.x + (SDWORD)delta.x);
+					next.y = WRAP_Y ((SDWORD)ElementPtr->next.location.y + (SDWORD)delta.y);
+					
+					DisplayArray[ElementPtr->PrimIndex].Object.Point.x = CalcDisplayCoord (next.x, SpaceOrg.x, reduction);
+					DisplayArray[ElementPtr->PrimIndex].Object.Point.y = CalcDisplayCoord (next.y, SpaceOrg.y, reduction);
 
 					if (ObjType == STAMP_PRIM || ObjType == STAMPFILL_PRIM)
 					{
@@ -1012,7 +999,7 @@ UWORD nth_frame = 0;
 void
 RedrawQueue (BOOLEAN clear)
 {
-	SIZE scroll_x, scroll_y;
+	SDWORD scroll_x, scroll_y;
 	VIEW_STATE view_state;
 
 	SetContext (StatusContext);
diff -ruNp src.orig/uqm/races.h src/uqm/races.h
--- src.orig/uqm/races.h	2017-12-30 00:14:41 -0800
+++ src/uqm/races.h	2017-12-30 00:14:53 -0800
@@ -56,6 +56,8 @@ extern "C" {
 #define DONT_CHASE        (1 << 12)
 #define PLAYER_CAPTAIN    (1 << 13)
 		/* The protagonist himself is on board. He gets a different color. */
+#define LIGHT_POINT_DEFENSE (1 << 14)
+#define HEAVY_POINT_DEFENSE (1 << 15)
 
 typedef UWORD STATUS_FLAGS;
 
@@ -389,6 +391,7 @@ enum
 	DEAD_GUY = 0,  // Race is extinct
 	GOOD_GUY,      // Race is allied with the player
 	BAD_GUY,       // Race is not allied with the player
+	CAN_BUILD,	   // Ships can be built regardless
 };
 
 static inline FLEET_INFO *
@@ -542,29 +545,29 @@ typedef enum
 
 #define LOG_TO_HYPER(s) (WORLD_TO_VELOCITY (s) >> 1)
 #define RACE_HYPER_SPEED \
-		LOG_TO_HYPER (40),  /* ARILOU_SHIP */ \
-		LOG_TO_HYPER (27),  /* CHMMR_SHIP */ \
-		LOG_TO_HYPER (24),  /* HUMAN_SHIP */ \
-		LOG_TO_HYPER (40),  /* ORZ_SHIP */ \
-		LOG_TO_HYPER (40),  /* PKUNK_SHIP */ \
-		LOG_TO_HYPER (35),  /* SHOFIXTI_SHIP */ \
-		LOG_TO_HYPER (48),  /* SPATHI_SHIP */ \
-		LOG_TO_HYPER (40),  /* SUPOX_SHIP */ \
-		LOG_TO_HYPER (50),  /* THRADDASH_SHIP */ \
-		LOG_TO_HYPER (30),  /* UTWIG_SHIP */ \
-		LOG_TO_HYPER (21),  /* VUX_SHIP */ \
-		LOG_TO_HYPER (30),  /* YEHAT_SHIP */ \
-		LOG_TO_HYPER (40),  /* MELNORME_SHIP */ \
-		LOG_TO_HYPER (20),  /* DRUUGE_SHIP */ \
-		LOG_TO_HYPER (25),  /* ILWRATH_SHIP */ \
-		LOG_TO_HYPER (27),  /* MYCON_SHIP */ \
-		LOG_TO_HYPER (60),  /* SLYLANDRO_SHIP */ \
-		LOG_TO_HYPER (18),  /* UMGAH_SHIP */ \
-		LOG_TO_HYPER (30),  /* URQUAN_SHIP */ \
-		LOG_TO_HYPER (40),  /* ZOQFOTPIK_SHIP */ \
-		LOG_TO_HYPER (36),  /* SYREEN_SHIP */ \
-		LOG_TO_HYPER (30),  /* BLACK_URQUAN_SHIP */ \
-		LOG_TO_HYPER (30),  /* YEHAT_REBEL_SHIP */
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ARILOU_SHIP */ \
+		LOG_TO_HYPER (27 << RESOLUTION_FACTOR),  /* CHMMR_SHIP */ \
+		LOG_TO_HYPER (24 << RESOLUTION_FACTOR),  /* HUMAN_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ORZ_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* PKUNK_SHIP */ \
+		LOG_TO_HYPER (35 << RESOLUTION_FACTOR),  /* SHOFIXTI_SHIP */ \
+		LOG_TO_HYPER (48 << RESOLUTION_FACTOR),  /* SPATHI_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* SUPOX_SHIP */ \
+		LOG_TO_HYPER (50 << RESOLUTION_FACTOR),  /* THRADDASH_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* UTWIG_SHIP */ \
+		LOG_TO_HYPER (21 << RESOLUTION_FACTOR),  /* VUX_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* YEHAT_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* MELNORME_SHIP */ \
+		LOG_TO_HYPER (20 << RESOLUTION_FACTOR),  /* DRUUGE_SHIP */ \
+		LOG_TO_HYPER (25 << RESOLUTION_FACTOR),  /* ILWRATH_SHIP */ \
+		LOG_TO_HYPER (27 << RESOLUTION_FACTOR),  /* MYCON_SHIP */ \
+		LOG_TO_HYPER (60 << RESOLUTION_FACTOR),  /* SLYLANDRO_SHIP */ \
+		LOG_TO_HYPER (18 << RESOLUTION_FACTOR),  /* UMGAH_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* URQUAN_SHIP */ \
+		LOG_TO_HYPER (40 << RESOLUTION_FACTOR),  /* ZOQFOTPIK_SHIP */ \
+		LOG_TO_HYPER (36 << RESOLUTION_FACTOR),  /* SYREEN_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* BLACK_URQUAN_SHIP */ \
+		LOG_TO_HYPER (30 << RESOLUTION_FACTOR),  /* YEHAT_REBEL_SHIP */
 
 #define RACE_HYPERSPACE_PERCENT \
 		20,  /* ARILOU_SHIP */ \
@@ -593,7 +596,7 @@ typedef enum
 		 0,  /* URQUAN_DRONE_SHIP */
 
 #define RACE_INTERPLANETARY_PERCENT \
-		 0,  /* ARILOU_SHIP */ \
+		 5,  /* ARILOU_SHIP */ \
 		 0,  /* CHMMR_SHIP */ \
 		 0,  /* HUMAN_SHIP */ \
 		20,  /* ORZ_SHIP */ \
@@ -647,30 +650,108 @@ typedef enum
 		MAKE_BYTE (1, 5),  /* YEHAT_REBEL_SHIP */
 
 #define RACE_COLORS \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x10), 0x53),  /* ARILOU_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* CHMMR_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x12), 0x53),  /* ARILOU_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0D, 0x0D, 0x0D), 0x00),  /* CHMMR_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x01, 0x1f), 0x4D),  /* HUMAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x00, 0x0E), 0x36),  /* ORZ_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* PKUNK_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* SHOFIXTI_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0C, 0x05, 0x00), 0x76),  /* SPATHI_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0C, 0x05, 0x00), 0x76),  /* SUPOX_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* THRADDASH_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* UTWIG_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x10), 0x53),  /* VUX_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x00, 0x11), 0x3D),  /* YEHAT_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x09, 0x11), 0x62),  /* PKUNK_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x06, 0x00), 0x77),  /* SHOFIXTI_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x07, 0x00), 0x76),  /* SPATHI_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x07, 0x00), 0x76),  /* SUPOX_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x09, 0x11), 0x62),  /* THRADDASH_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x09, 0x11), 0x62),  /* UTWIG_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x12), 0x53),  /* VUX_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x0B, 0x00, 0x12), 0x3D),  /* YEHAT_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x06, 0x08), 0x62),  /* MELNORME_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),  /* DRUUGE_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x00, 0x0E), 0x36),  /* ILWRATH_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0E, 0x00, 0x0E), 0x36),  /* MYCON_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x0C, 0x05, 0x00), 0x76),  /* SLYLANDRO_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x08, 0x08, 0x0D), 0x76),  /* SLYLANDRO_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0A, 0x00, 0x11), 0x3D),  /* UMGAH_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x08, 0x00), 0x6E),  /* URQUAN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x10, 0x00), 0x6E),  /* URQUAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x0F, 0x00, 0x00), 0x2D),  /* ZOQFOTPIK_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x00), 0x00),  /* SYREEN_SHIP */ \
-		BUILD_COLOR (MAKE_RGB15_INIT (0x06, 0x06, 0x06), 0x20),  /* BLACK_URQUAN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x0B, 0x00), 0x00),  /* SYREEN_SHIP */ \
+		BUILD_COLOR (MAKE_RGB15_INIT (0x08, 0x08, 0x08), 0x20),  /* BLACK_URQUAN_SHIP */ \
 		BUILD_COLOR (MAKE_RGB15_INIT (0x14, 0x07, 0x1F), 0x39),  /* YEHAT_REBEL_SHIP */
 
+// JMS: For showing the SC1-era situation in starmap
+#define RACE_PREWAR_STRENGTHS \
+		0,    /* ARILOU_SHIP */ \
+		500,  /* CHMMR_SHIP masquerading as Mmrnmhrm */ \
+		400,  /* HUMAN_SHIP */ \
+		0,    /* ORZ_SHIP */ \
+		642,  /* PKUNK_SHIP, should be marked 'Unknown' */ \
+		400,  /* SHOFIXTI_SHIP */ \
+		1003, /* SPATHI_SHIP */ \
+		0,	  /* SUPOX_SHIP */ \
+		835,  /* THRADDASH_SHIP, should be marked 'Unknown' */ \
+		0,    /* UTWIG_SHIP masquerading as Chenjesu */ \
+		700,  /* VUX_SHIP */ \
+		1100, /* YEHAT_SHIP */ \
+		0,	  /* MELNORME_SHIP */ \
+		800,  /* DRUUGE_SHIP, should be marked 'Unknown' */ \
+		500,  /* ILWRATH_SHIP */ \
+		650,  /* MYCON_SHIP */ \
+		750,  /* SLYLANDRO_SHIP masquerading as Chenjesu */ \
+		633,  /* UMGAH_SHIP */ \
+		0,    /* URQUAN_SHIP */ \
+		0,	  /* ZOQFOTPIK_SHIP */ \
+		450,  /* SYREEN_SHIP masquareding as Androsynth */ \
+		0,	  /* BLACK_URQUAN_SHIP */ \
+		0,	  /* YEHAT_REBEL_SHIP */
+		
+// JMS: For showing the SC1-era situation in starmap
+#define RACE_PREWAR_LOCATIONS \
+		{0,0},		 /* ARILOU_SHIP */ \
+		{742,2968},	 /* CHMMR_SHIP masquerading as Mmrnmhrm */ \
+		{1752,1450}, /* HUMAN_SHIP */ \
+		{0,0 },		 /* ORZ_SHIP */ \
+		{502,401},   /* PKUNK_SHIP, should be marked 'Unknown' */ \
+		{2908,269},	 /* SHOFIXTI_SHIP */ \
+		{2549,3600}, /* SPATHI_SHIP */ \
+		{0,0},		 /* SUPOX_SHIP */ \
+		{2535,8358}, /* THRADDASH_SHIP, should be marked 'Unknown' */ \
+		{0,0},		 /* UTWIG_SHIP masquerading as Chenjesu */ \
+		{4333,1687}, /* VUX_SHIP */ \
+		{4923,294},  /* YEHAT_SHIP */ \
+		{0,0},		 /* MELNORME_SHIP */ \
+		{9469,2806}, /* DRUUGE_SHIP, should be marked 'Unknown' */ \
+		{229,3666},  /* ILWRATH_SHIP */ \
+		{6392,2200}, /* MYCON_SHIP */ \
+		{0742,2268}, /* SLYLANDRO_SHIP masquerading as Chenjesu */ \
+		{1978,5968}, /* UMGAH_SHIP */ \
+		{0,0},		 /* URQUAN_SHIP */ \
+		{0,0},		 /* ZOQFOTPIK_SHIP */ \
+		{3587,2566}, /* SYREEN_SHIP masquerading as Androsynth */ \
+		{0,0},		 /* BLACK_URQUAN_SHIP */ \
+		{0,0},		 /* YEHAT_REBEL_SHIP */
+		
+// JMS: For showing the SC1-era situation in starmap
+#define RACE_PREWAR_NAME_UNKNOWN \
+		FALSE,  /* ARILOU_SHIP */ \
+		FALSE,  /* CHMMR_SHIP masquerading as Mmrnmhrm */ \
+		FALSE,  /* HUMAN_SHIP */ \
+		FALSE,  /* ORZ_SHIP */ \
+		TRUE,   /* PKUNK_SHIP, should be marked 'Unknown' */ \
+		FALSE,  /* SHOFIXTI_SHIP */ \
+		FALSE,  /* SPATHI_SHIP */ \
+		FALSE,	/* SUPOX_SHIP */ \
+		TRUE,   /* THRADDASH_SHIP, should be marked 'Unknown' */ \
+		FALSE,  /* UTWIG_SHIP */ \
+		FALSE,  /* VUX_SHIP */ \
+		FALSE,  /* YEHAT_SHIP */ \
+		FALSE,	/* MELNORME_SHIP */ \
+		TRUE,   /* DRUUGE_SHIP, should be marked 'Unknown' */ \
+		FALSE,  /* ILWRATH_SHIP */ \
+		FALSE,  /* MYCON_SHIP */ \
+		FALSE,	/* SLYLANDRO_SHIP masquerading as Chenjesu */ \
+		FALSE,  /* UMGAH_SHIP */ \
+		FALSE,  /* URQUAN_SHIP */ \
+		FALSE,	/* ZOQFOTPIK_SHIP */ \
+		FALSE,  /* SYREEN_SHIP masquareding as Androsynth */ \
+		FALSE,	/* BLACK_URQUAN_SHIP */ \
+		FALSE,	/* YEHAT_REBEL_SHIP */
+
 #if defined(__cplusplus)
 }
 #endif
diff -ruNp src.orig/uqm/restart.c src/uqm/restart.c
--- src.orig/uqm/restart.c	2017-12-30 00:14:41 -0800
+++ src/uqm/restart.c	2017-12-30 00:14:53 -0800
@@ -40,7 +40,10 @@
 #include "uqmversion.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
-
+#include "libs/graphics/sdl/pure.h"
+#include "libs/log.h"
+#include "options.h"
+#include "cons_res.h"
 
 enum
 {
@@ -57,9 +60,47 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 {
 	RECT r;
 	STAMP s;
-	TEXT t;
+	TEXT t; 
+	char *Credit;
 	UNICODE buf[64];
 
+	// Re-load all of the restart menu fonts so the text shows in correct size after changing the resolution.
+	if (resFactorWasChanged) {	
+		DestroyFont (TinyFont);
+		DestroyFont (PlyrFont);
+		DestroyFont (StarConFont);
+	}
+	
+
+	// DC: Load the different menus and fonts depending on the resolution factor	
+	switch (resolutionFactor){
+		case 1:
+			if (resFactorWasChanged) {
+				TinyFont = LoadFont (TINY_FALLBACK_TO2X_FONT);
+				PlyrFont = LoadFont (PLYR_FALLBACK_TO2X_FONT);
+				StarConFont = LoadFont (SCON_FALLBACK_TO2X_FONT);
+			}
+			pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM2x));
+			break;
+		case 2:
+			if (resFactorWasChanged) {
+				TinyFont = LoadFont (TINY_FALLBACK_TO4X_FONT);
+				PlyrFont = LoadFont (PLYR_FALLBACK_TO4X_FONT);
+				StarConFont = LoadFont (SCON_FALLBACK_TO4X_FONT);
+			}
+			pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM4x));
+			break;
+		case 0:
+		default:
+			if (resFactorWasChanged) {
+				TinyFont = LoadFont (TINY_FALLBACK_TO1X_FONT);
+				PlyrFont = LoadFont (PLYR_FALLBACK_TO1X_FONT);
+				StarConFont = LoadFont (SCON_FALLBACK_TO1X_FONT);
+			}
+			pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
+			break;
+	}
+
 	s.frame = pMS->CurFrame;
 	GetFrameRect (s.frame, &r);
 	s.origin.x = (SCREEN_WIDTH - r.extent.width) >> 1;
@@ -74,26 +115,43 @@ DrawRestartMenuGraphic (MENU_STATE *pMS)
 	// Put the version number in the bottom right corner.
 	SetContextFont (TinyFont);
 	t.pStr = buf;
-	t.baseline.x = SCREEN_WIDTH - 3;
-	t.baseline.y = SCREEN_HEIGHT - 2;
+	t.baseline.x = SCREEN_WIDTH - RES_SCALE(2);
+	t.baseline.y = SCREEN_HEIGHT - RES_SCALE(2);
 	t.align = ALIGN_RIGHT;
 	t.CharCount = (COUNT)~0;
-	sprintf (buf, "v%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
-			UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
+	sprintf (buf, "v%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION, UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
 	SetContextForeGroundColor (WHITE_COLOR);
 	font_DrawText (&t);
-
+	// Put the main menu music credit in the bottom left corner.
+	memset(&buf[0], 0, sizeof(buf));
+	t.baseline.x = RES_SCALE(2);
+	t.baseline.y = SCREEN_HEIGHT - RES_SCALE(2);
+	t.align = ALIGN_LEFT;
+	switch (Rando){
+		case 1:
+			Credit = "Main Menu Music by Rush AX";
+			break;
+		case 2:
+			Credit = "Main Menu Music by Mark Vera";
+			break;
+		case 0:
+		default:
+			Credit = "Main Menu Music by Saibuster";
+			break;
+	}
+	sprintf (buf, "%s", Credit);
+	font_DrawText (&t);
 	UnbatchGraphics ();
 }
 
+// JMS_GFX: The cleanup boolean can be used to avoid drawing a wrong-sized "Setup" flash overlay.
 static void
-DrawRestartMenu (MENU_STATE *pMS, BYTE NewState, FRAME f)
+DrawRestartMenu (MENU_STATE *pMS, BYTE NewState, FRAME f, BOOLEAN cleanup)
 {
 	POINT origin;
 	origin.x = 0;
 	origin.y = 0;
-	Flash_setOverlay(pMS->flashContext,
-			&origin, SetAbsFrameIndex (f, NewState + 1));
+	Flash_setOverlay (pMS->flashContext, &origin, SetAbsFrameIndex (f, NewState + 1), cleanup);
 }
 
 static BOOLEAN
@@ -111,29 +169,41 @@ DoRestart (MENU_STATE *pMS)
 
 	if (!pMS->Initialized)
 	{
-		if (pMS->hMusic)
+		if (pMS->hMusic && !comingFromInit)
 		{
 			StopMusic ();
 			DestroyMusic (pMS->hMusic);
 			pMS->hMusic = 0;
 		}
-		pMS->hMusic = LoadMusic (MAINMENU_MUSIC);
-		InactTimeOut = (pMS->hMusic ? 120 : 20) * ONE_SECOND;
+		
+		pMS->hMusic = loadMainMenuMusic (Rando);
+		InactTimeOut = (optMainMenuMusic ? 90 : 20) * ONE_SECOND;
+
 		pMS->flashContext = Flash_createOverlay (ScreenContext,
 				NULL, NULL);
 		Flash_setMergeFactors (pMS->flashContext, -3, 3, 16);
-		Flash_setSpeed (pMS->flashContext, (6 * ONE_SECOND) / 16, 0,
-				(6 * ONE_SECOND) / 16, 0);
+		Flash_setSpeed (pMS->flashContext, (6 * ONE_SECOND) / 14, 0,
+				(6 * ONE_SECOND) / 14, 0);
 		Flash_setFrameTime (pMS->flashContext, ONE_SECOND / 16);
 		Flash_setState(pMS->flashContext, FlashState_fadeIn,
 				(3 * ONE_SECOND) / 16);
-		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
+
+		if(optSuperMelee)
+			goto MELEE; // A really shitty way to start Super Melee without using the menu.
+
+		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 		Flash_start (pMS->flashContext);
-		PlayMusic (pMS->hMusic, TRUE, 1);
 		LastInputTime = GetTimeCounter ();
 		pMS->Initialized = TRUE;
 
 		SleepThreadUntil (FadeScreen (FadeAllToColor, ONE_SECOND / 2));
+		if (!comingFromInit){
+			FadeMusic(0,0);
+			PlayMusic (pMS->hMusic, TRUE, 1);
+		
+			if (optMainMenuMusic)
+				FadeMusic (NORMAL_VOLUME+70, ONE_SECOND * 3);
+		}
 	}
 	else if (GLOBAL (CurrentActivity) & CHECK_ABORT)
 	{
@@ -141,32 +211,150 @@ DoRestart (MENU_STATE *pMS)
 	}
 	else if (PulsedInputState.menu[KEY_MENU_SELECT])
 	{
+		//BYTE fade_buf[1];
+		COUNT oldresfactor;
+		BOOLEAN packsInstalled;
+		
+		if (resolutionFactor == 0)
+			packsInstalled = TRUE;
+		else if (resolutionFactor == 1 && hires2xPackPresent)
+			packsInstalled = TRUE;
+		else if (resolutionFactor == 2 && hires4xPackPresent)
+			packsInstalled = TRUE;
+		else
+			packsInstalled = FALSE;
+
 		switch (pMS->CurState)
 		{
 			case LOAD_SAVED_GAME:
-				LastActivity = CHECK_LOAD;
-				GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				if (resFactorWasChanged) {
+					SetFlashRect (NULL);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					//fade_buf[0] = FadeAllToBlack;
+					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				} else if (!packsInstalled) {
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + RESOLUTION_FACTOR));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				} else {
+					LastActivity = CHECK_LOAD;
+					GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				}
 				break;
 			case START_NEW_GAME:
-				LastActivity = CHECK_LOAD | CHECK_RESTART;
-				GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				if (resFactorWasChanged) {
+					SetFlashRect (NULL);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					//fade_buf[0] = FadeAllToBlack;
+					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				} else if (!packsInstalled) {
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + RESOLUTION_FACTOR));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				}
+				else
+				{
+					LastActivity = CHECK_LOAD | CHECK_RESTART;
+					GLOBAL (CurrentActivity) = IN_INTERPLANETARY;
+				}	
 				break;
 			case PLAY_SUPER_MELEE:
-				GLOBAL (CurrentActivity) = SUPER_MELEE;
+				MELEE:
+				if(optSuperMelee)
+					optSuperMelee = FALSE;
+				if (resFactorWasChanged) {
+					SetFlashRect (NULL);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35));
+					// Got to restart -message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					//fade_buf[0] = FadeAllToBlack;
+					//SleepThreadUntil (XFormColorMap ((COLORMAPPTR)fade_buf, ONE_SECOND / 2));
+					SleepThreadUntil (FadeScreen(FadeAllToBlack, ONE_SECOND / 2));
+					GLOBAL (CurrentActivity) = CHECK_ABORT;
+				} else if (!packsInstalled) {
+					Flash_pause(pMS->flashContext);
+					DoPopupWindow (GAME_STRING (MAINMENU_STRING_BASE + 35 + RESOLUTION_FACTOR));
+					// Could not find graphics pack - message
+					SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);	
+					SetTransitionSource (NULL);
+					BatchGraphics ();
+					DrawRestartMenuGraphic (pMS);
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
+					ScreenTransition (3, NULL);
+					UnbatchGraphics ();
+					Flash_continue(pMS->flashContext);
+					SleepThreadUntil (TimeIn + ONE_SECOND / 30);
+					return TRUE;
+				} else
+					GLOBAL (CurrentActivity) = SUPER_MELEE;
 				break;
 			case SETUP_GAME:
+				oldresfactor = resolutionFactor;
 				Flash_pause(pMS->flashContext);
 				Flash_setState(pMS->flashContext, FlashState_fadeIn,
 						(3 * ONE_SECOND) / 16);
 				SetupMenu ();
 				SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
 						MENU_SOUND_SELECT);
+
+				InactTimeOut = (optMainMenuMusic ? 90 : 20) * ONE_SECOND;
+
 				LastInputTime = GetTimeCounter ();
 				SetTransitionSource (NULL);
 				BatchGraphics ();
 				DrawRestartMenuGraphic (pMS);
 				ScreenTransition (3, NULL);
-				DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
+				// JMS_GFX: This prevents drawing an annoying wrong-sized "Setup" frame when changing resolution. 
+				if (oldresfactor < resolutionFactor)
+					DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, TRUE);
+				
+				DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 				Flash_continue(pMS->flashContext);
 				UnbatchGraphics ();
 				return TRUE;
@@ -203,7 +391,7 @@ DoRestart (MENU_STATE *pMS)
 		if (NewState != pMS->CurState)
 		{
 			BatchGraphics ();
-			DrawRestartMenu (pMS, NewState, pMS->CurFrame);
+			DrawRestartMenu (pMS, NewState, pMS->CurFrame, FALSE);
 			UnbatchGraphics ();
 			pMS->CurState = NewState;
 		}
@@ -224,7 +412,7 @@ DoRestart (MENU_STATE *pMS)
 		SetTransitionSource (NULL);
 		BatchGraphics ();
 		DrawRestartMenuGraphic (pMS);
-		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame);
+		DrawRestartMenu (pMS, pMS->CurState, pMS->CurFrame, FALSE);
 		ScreenTransition (3, NULL);
 		UnbatchGraphics ();
 		Flash_continue(pMS->flashContext);
@@ -233,9 +421,13 @@ DoRestart (MENU_STATE *pMS)
 	}
 	else
 	{	// No input received, check if timed out
-		if (GetTimeCounter () - LastInputTime > InactTimeOut)
+		// JMS: After changing resolution mode, prevent displaying credits
+		// (until the next time the game is restarted). This is to prevent
+		// showing the credits with the wrong resolution mode's font&background.
+		if (GetTimeCounter () - LastInputTime > InactTimeOut
+			&& !resFactorWasChanged)
 		{
-			SleepThreadUntil (FadeMusic (0, ONE_SECOND));
+			SleepThreadUntil (FadeMusic (0, ONE_SECOND/2));
 			StopMusic ();
 			FadeMusic (NORMAL_VOLUME, 0);
 
@@ -243,7 +435,7 @@ DoRestart (MENU_STATE *pMS)
 			return FALSE;
 		}
 	}
-
+	comingFromInit = FALSE;
 	SleepThreadUntil (TimeIn + ONE_SECOND / 30);
 
 	return TRUE;
@@ -300,19 +492,23 @@ RestartMenu (MENU_STATE *pMS)
 	if (TimeOut == ONE_SECOND / 8)
 		SleepThread (ONE_SECOND * 3);
 
-	pMS->CurFrame = CaptureDrawable (LoadGraphic (RESTART_PMAP_ANIM));
-
 	DrawRestartMenuGraphic (pMS);
 	GLOBAL (CurrentActivity) &= ~CHECK_ABORT;
 	SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN, MENU_SOUND_SELECT);
 	SetDefaultMenuRepeatDelay ();
 	DoInput (pMS, TRUE);
 	
+	if (optMainMenuMusic)
+		SleepThreadUntil (FadeMusic (0, ONE_SECOND));
+
 	StopMusic ();
 	if (pMS->hMusic)
 	{
 		DestroyMusic (pMS->hMusic);
 		pMS->hMusic = 0;
+
+		if (optMainMenuMusic)
+			FadeMusic (NORMAL_VOLUME, 0);
 	}
 
 	Flash_terminate (pMS->flashContext);
@@ -381,6 +577,9 @@ StartGame (void)
 			{	// timed out
 				GLOBAL (CurrentActivity) = 0;
 				SplashScreen (0);
+				if(optWhichIntro == OPT_3DO && optFMV){
+					Drumall ();
+				}
 				Credits (FALSE);
 			}
 
@@ -390,7 +589,10 @@ StartGame (void)
 
 		if (LastActivity & CHECK_RESTART)
 		{	// starting a new game
-			Introduction ();
+			FadeMusic (NORMAL_VOLUME, 0);
+			if(!optSkipIntro){
+				Introduction ();
+			}
 		}
 	
 	} while (GLOBAL (CurrentActivity) & CHECK_ABORT);
diff -ruNp src.orig/uqm/save.c src/uqm/save.c
--- src.orig/uqm/save.c	2017-12-30 00:14:41 -0800
+++ src/uqm/save.c	2017-12-30 00:14:53 -0800
@@ -168,8 +168,8 @@ const GameStateBitMap gameStateBitMap[]
 	{ "MOONBASE_DESTROYED", 1 },
 	{ "WILL_DESTROY_BASE", 1 },
 
-	{ "ARTIFACT_2_ON_SHIP", 1 },
-	{ "ARTIFACT_3_ON_SHIP", 1 },
+	{ "WIMBLIS_TRIDENT_ON_SHIP", 1 },
+	{ "GLOWING_ROD_ON_SHIP", 1 },
 
 	{ "KOHR_AH_KILLED_ALL", 1 },
 
@@ -698,6 +698,25 @@ const GameStateBitMap gameStateBitMap[]
 	{ "COLONY_GRPOFFS", 32 },
 	{ "SAMATRA_GRPOFFS", 32 },
 	
+	{ "AUTOPILOT_OK", 1 },
+	
+	{ "KNOW_QS_PORTAL_0", 1 },
+	{ "KNOW_QS_PORTAL_1", 1 },
+	{ "KNOW_QS_PORTAL_2", 1 },
+	{ "KNOW_QS_PORTAL_3", 1 },
+	{ "KNOW_QS_PORTAL_4", 1 },
+	{ "KNOW_QS_PORTAL_5", 1 },
+	{ "KNOW_QS_PORTAL_6", 1 },
+	{ "KNOW_QS_PORTAL_7", 1 },
+	{ "KNOW_QS_PORTAL_8", 1 },
+	{ "KNOW_QS_PORTAL_9", 1 },
+	{ "KNOW_QS_PORTAL_10", 1 },
+	{ "KNOW_QS_PORTAL_11", 1 },
+	{ "KNOW_QS_PORTAL_12", 1 },
+	{ "KNOW_QS_PORTAL_13", 1 },
+	{ "KNOW_QS_PORTAL_14", 1 },
+	{ "KNOW_QS_PORTAL_15", 1 },
+	
 	{ NULL, 0 },
 };
 
@@ -924,8 +943,8 @@ SaveEncounters (uio_Stream *fh)
 		}
 
 		// Save the stuff after the BRIEF_SHIP_INFO array
-		write_32  (fh, EncounterPtr->log_x);
-		write_32  (fh, EncounterPtr->log_y);
+		write_32  (fh, ((EncounterPtr->log_x) >> RESOLUTION_FACTOR));
+		write_32  (fh, ((EncounterPtr->log_y) >> RESOLUTION_FACTOR));
 
 		UnlockEncounter (hEncounter);
 		hEncounter = hNextEncounter;
@@ -979,6 +998,13 @@ SaveClockState (const CLOCK_STATE *Clock
 static BOOLEAN
 SaveGameState (const GAME_STATE *GSPtr, uio_Stream *fh)
 {
+	BYTE res_scale; // JMS
+
+	if (LOBYTE (GSPtr->CurrentActivity) != IN_INTERPLANETARY)
+		res_scale = RESOLUTION_FACTOR; 
+	else
+		res_scale = 0;
+
 	write_32  (fh, GLOBAL_STATE_TAG);
 	write_32  (fh, 75);
 	write_8   (fh, GSPtr->glob_flags);
@@ -995,22 +1021,22 @@ SaveGameState (const GAME_STATE *GSPtr,
 	write_16  (fh, GSPtr->ip_location.x);
 	write_16  (fh, GSPtr->ip_location.y);
 	/* STAMP ShipStamp */
-	write_16  (fh, GSPtr->ShipStamp.origin.x);
-	write_16  (fh, GSPtr->ShipStamp.origin.y);
+	write_16  (fh, (GSPtr->ShipStamp.origin.x >> RESOLUTION_FACTOR));
+	write_16  (fh, (GSPtr->ShipStamp.origin.y >> RESOLUTION_FACTOR));
 	write_16  (fh, GSPtr->ShipFacing);
 	write_8   (fh, GSPtr->ip_planet);
 	write_8   (fh, GSPtr->in_orbit);
 
 	/* VELOCITY_DESC velocity */
-	write_16  (fh, GSPtr->velocity.TravelAngle);
-	write_16  (fh, GSPtr->velocity.vector.width);
-	write_16  (fh, GSPtr->velocity.vector.height);
-	write_16  (fh, GSPtr->velocity.fract.width);
-	write_16  (fh, GSPtr->velocity.fract.height);
-	write_16  (fh, GSPtr->velocity.error.width);
-	write_16  (fh, GSPtr->velocity.error.height);
-	write_16  (fh, GSPtr->velocity.incr.width);
-	write_16  (fh, GSPtr->velocity.incr.height);
+	write_16  (fh, GSPtr->velocity.TravelAngle >> res_scale);
+	write_16  (fh, GSPtr->velocity.vector.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.vector.height >> res_scale);
+	write_16  (fh, GSPtr->velocity.fract.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.fract.height >> res_scale);
+	write_16  (fh, GSPtr->velocity.error.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.error.height >> res_scale);
+	write_16  (fh, GSPtr->velocity.incr.width >> res_scale);
+	write_16  (fh, GSPtr->velocity.incr.height >> res_scale);
 
 	/* The Game state bits. Vanilla UQM uses 155 bytes here at
 	 * present. Only the first 99 bytes are significant, though;
@@ -1035,8 +1061,8 @@ SaveGameState (const GAME_STATE *GSPtr,
 static void
 SaveSisState (const SIS_STATE *SSPtr, void *fp)
 {
-	write_32  (fp, SSPtr->log_x);
-	write_32  (fp, SSPtr->log_y);
+	write_32  (fp, ((SSPtr->log_x) >> RESOLUTION_FACTOR));
+	write_32  (fp, ((SSPtr->log_y) >> RESOLUTION_FACTOR));
 	write_32  (fp, SSPtr->ResUnits);
 	write_32  (fp, SSPtr->FuelOnBoard);
 	write_16  (fp, SSPtr->CrewEnlisted);
@@ -1073,6 +1099,7 @@ SaveSummary (const SUMMARY_DESC *SummPtr
 	write_8  (fp, SummPtr->NumDevices);
 	write_a8 (fp, SummPtr->ShipList, MAX_BUILT_SHIPS);
 	write_a8 (fp, SummPtr->DeviceList, MAX_EXCLUSIVE_DEVICES);
+	write_8  (fp, SummPtr->res_factor);
 	write_a8 (fp, SummPtr->SaveName, strlen(SummPtr->SaveName));
 }
 
@@ -1152,6 +1179,7 @@ PrepareSummary (SUMMARY_DESC *SummPtr, c
 	SummPtr->year_index = GLOBAL (GameClock.year_index);
 	SummPtr->SaveName[SAVE_NAME_SIZE-1] = 0;
 	strncpy (SummPtr->SaveName, name, SAVE_NAME_SIZE-1);
+	SummPtr->res_factor = RESOLUTION_FACTOR;
 }
 
 static void
@@ -1190,10 +1218,10 @@ SaveProblemMessage (STAMP *MsgStamp)
 			- r.corner.x;
 	t.baseline.y = ((SIS_SCREEN_HEIGHT >> 1) - (r.extent.height >> 1))
 			- r.corner.y;
-	r.corner.x += t.baseline.x - 4;
-	r.corner.y += t.baseline.y - 4;
-	r.extent.width += 8;
-	r.extent.height += 8;
+	r.corner.x += t.baseline.x - (4 << RESOLUTION_FACTOR);
+	r.corner.y += t.baseline.y - (4 << RESOLUTION_FACTOR);
+	r.extent.width += (8 << RESOLUTION_FACTOR);
+	r.extent.height += (8 << RESOLUTION_FACTOR);
 
 	*MsgStamp = SaveContextFrame (&r);
 
diff -ruNp src.orig/uqm/save.h src/uqm/save.h
--- src.orig/uqm/save.h	2017-12-30 00:14:41 -0800
+++ src/uqm/save.h	2017-12-30 00:14:53 -0800
@@ -61,6 +61,7 @@ typedef struct
 	BYTE ShipList[MAX_BUILT_SHIPS];
 	BYTE DeviceList[MAX_EXCLUSIVE_DEVICES];
 	UNICODE SaveName[SAVE_NAME_SIZE];
+	BYTE res_factor;	// JMS: Stores resolution factor to enable saving/loading from different res modes.
 } SUMMARY_DESC;
 
 extern ACTIVITY NextActivity;
diff -ruNp src.orig/uqm/setup.c src/uqm/setup.c
--- src.orig/uqm/setup.c	2017-12-30 00:14:41 -0800
+++ src/uqm/setup.c	2017-12-30 00:14:53 -0800
@@ -59,14 +59,28 @@ FRAME Screen;
 FONT StarConFont;
 FONT MicroFont;
 FONT TinyFont;
+FONT PlyrFont;
 QUEUE race_q[NUM_PLAYERS];
 FRAME ActivityFrame;
 FRAME StatusFrame;
+FRAME SubmenuFrame;
+FRAME ConstellationsFrame; // JMS
+FRAME hyperspacesuns; // BW
+FRAME NebulaeFrame; // JMS
 FRAME FlagStatFrame;
 FRAME MiscDataFrame;
 FRAME FontGradFrame;
 STRING GameStrings;
 QUEUE disp_q;
+// Serosis
+BOOLEAN solTexturesPresent;
+BOOLEAN seroNebulaePresent;
+BOOLEAN seroMenuPresent;
+// JMS_GFX
+BOOLEAN hires2xPackPresent;
+BOOLEAN hires4xPackPresent;
+BOOLEAN comingFromInit;
+BYTE Rando;
 
 uio_Repository *repository;
 uio_DirHandle *rootDir;
@@ -115,15 +129,55 @@ LoadKernel (int argc, char *argv[])
 		return FALSE; // Must have at least one index in content dir
 
 	/* Load addons demanded by the current configuration. */
+
+	switch (resolutionFactor) {
+		case 1:
+			if(loadAddon ("hires2x")){
+				hires2xPackPresent = TRUE;
+				log_add (log_Debug, "loading addon hires2x");
+				if(loadAddon("sol-textures-2x")){
+					solTexturesPresent = TRUE;
+					printf("Loading Sol Textures \n");
+					log_add (log_Debug, "loading sol-textures-2x");
+				}
+				loadAddon("alt-kohr-2x");
+			}
+			break;
+		case 2:
+			if(loadAddon ("hires4x")){
+				hires4xPackPresent = TRUE;
+				log_add (log_Debug, "loading addon hires4x");
+				if(loadAddon("sol-textures-4x")){
+					solTexturesPresent = TRUE;
+					printf("Loading Sol Textures \n");
+					log_add (log_Debug, "loading sol-textures-4x");
+				}
+				loadAddon("alt-kohr-4x");
+			}
+			break;
+		case 0:
+		default:
+			if(loadAddon("sol-textures-1x")){
+				solTexturesPresent = TRUE;
+				printf("Loading Sol Textures \n");
+				log_add (log_Debug, "loading sol-textures-1x");
+			}
+			break;
+	}
+
 	if (opt3doMusic)
 	{
 		loadAddon ("3domusic");
 	}
 
 	usingSpeech = optSpeech;
-	if (optSpeech && !loadAddon ("3dovoice"))
-	{
+	if (optSpeech && !loadAddon ("3dovoice")) {
 		usingSpeech = FALSE;
+	} else {
+		loadAddon("rmx-shofixti");
+		loadAddon("rmx-utwig");
+		// Autoload support for Soul Reaver's dialog fixes
+		loadAddon("MelnormeVoiceFix");
 	}
 
 	if (optRemixMusic)
@@ -202,6 +256,10 @@ InitKernel (void)
 	if (TinyFont == NULL)
 		return FALSE;
 
+	PlyrFont = LoadFont (PLAYER_FONT);
+	if (PlyrFont == NULL)
+		return FALSE;
+
 	ActivityFrame = CaptureDrawable (LoadGraphic (ACTIVITY_ANIM));
 	if (ActivityFrame == NULL)
 		return FALSE;
@@ -209,6 +267,27 @@ InitKernel (void)
 	StatusFrame = CaptureDrawable (LoadGraphic (STATUS_MASK_PMAP_ANIM));
 	if (StatusFrame == NULL)
 		return FALSE;
+	
+	// JMS: Animated hyperspace suns.
+	if (hires4xPackPresent || hires2xPackPresent) { 
+		hyperspacesuns = CaptureDrawable (LoadGraphic (HYPERSUNS_MASK_PMAP_ANIM));
+		if (hyperspacesuns == NULL)
+			return FALSE;
+	}
+
+	NebulaeFrame = CaptureDrawable (LoadGraphic (NEBULAE_PMAP_ANIM));
+	if (NebulaeFrame == NULL || !NebulaeFrame)
+		return FALSE;
+		
+	// JMS: Constellation lines for the constellation starmap.
+	ConstellationsFrame = CaptureDrawable (LoadGraphic (CONSTELLATIONS_MASK_PMAP_ANIM));
+	if (ConstellationsFrame == NULL)
+		return FALSE;
+		
+	// JMS: This is a table of mineral values that will be shown on the status bar.
+	SubmenuFrame = CaptureDrawable (LoadGraphic (SUBMENU_MASK_PMAP_ANIM));
+	if (SubmenuFrame == NULL)
+		return FALSE;
 
 	GameStrings = CaptureStringTable (LoadStringTable (STARCON_GAME_STRINGS));
 	if (GameStrings == 0)
diff -ruNp src.orig/uqm/setup.h src/uqm/setup.h
--- src.orig/uqm/setup.h	2017-12-30 00:14:41 -0800
+++ src/uqm/setup.h	2017-12-30 00:14:53 -0800
@@ -33,6 +33,10 @@ extern RESOURCE_INDEX hResIndex;
 extern FRAME Screen;
 extern FRAME ActivityFrame;
 extern FRAME StatusFrame;
+extern FRAME SubmenuFrame; // JMS
+extern FRAME ConstellationsFrame; // JMS
+extern FRAME NebulaeFrame;	// JMS
+extern FRAME hyperspacesuns;	// BW
 extern FRAME FlagStatFrame;
 extern FRAME MiscDataFrame;
 extern FRAME FontGradFrame;
@@ -50,6 +54,7 @@ extern SIZE screen_width, screen_height;
 extern FONT StarConFont;
 extern FONT MicroFont;
 extern FONT TinyFont;
+extern FONT PlyrFont;
 
 extern CondVar RenderingCond;
 
@@ -57,6 +62,14 @@ extern QUEUE race_q[];
 		/* Array of lists of ships involved in a battle, one queue per side;
 		 * queue element is STARSHIP */
 
+// Serosis
+extern BOOLEAN solTexturesPresent;
+extern BOOLEAN seroNebulaePresent;
+extern BOOLEAN hires2xPackPresent; // JMS
+extern BOOLEAN hires4xPackPresent; // JMS
+extern BOOLEAN comingFromInit;
+extern BYTE Rando;
+
 extern ACTIVITY LastActivity;
 
 extern BYTE PlayerControl[];
diff -ruNp src.orig/uqm/setupmenu.c src/uqm/setupmenu.c
--- src.orig/uqm/setupmenu.c	2017-12-30 00:14:41 -0800
+++ src/uqm/setupmenu.c	2017-12-30 00:14:53 -0800
@@ -38,6 +38,8 @@
 #include "resinst.h"
 #include "nameref.h"
 #include <math.h>
+#include "gamestr.h"
+#include "libs/graphics/bbox.h"
 
 
 static STRING SetupTab;
@@ -59,7 +61,7 @@ static int quit_sub_menu (WIDGET *self,
 static int do_graphics (WIDGET *self, int event);
 static int do_audio (WIDGET *self, int event);
 static int do_engine (WIDGET *self, int event);
-static int do_resources (WIDGET *self, int event);
+static int do_cheats (WIDGET *self, int event);
 static int do_keyconfig (WIDGET *self, int event);
 static int do_advanced (WIDGET *self, int event);
 static int do_editkeys (WIDGET *self, int event);
@@ -69,13 +71,13 @@ static void rebind_control (WIDGET_CONTR
 static void clear_control (WIDGET_CONTROLENTRY *widget);
 
 #ifdef HAVE_OPENGL
-#define RES_OPTS 4
+#define RES_OPTS 3
 #else
-#define RES_OPTS 2
+#define RES_OPTS 3
 #endif
 
 #define MENU_COUNT          8
-#define CHOICE_COUNT       24
+#define CHOICE_COUNT       46
 #define SLIDER_COUNT        4
 #define BUTTON_COUNT       10
 #define LABEL_COUNT         4
@@ -95,76 +97,108 @@ static WIDGET_CONTROLENTRY controlentrie
 
 typedef int (*HANDLER)(WIDGET *, int);
 
+// Each number corresponds to a choice widget in order starting from choices[0]
+// The value determines how many columns the choice has.
 static int choice_widths[CHOICE_COUNT] = {
-	3, 2, 3, 3, 2, 2, 2, 2, 2, 2, 
-	2, 2, 3, 2, 2, 3, 3, 2,	3, 3, 
-	3, 2, 2, 2 };
+	3, 2, 3, 2, 2, 2, 2, 2, 2, 2, 
+	2, 2, 2, 2, 2, 3, 3, 2,	3, 3, 
+	3, 2, 2, 2, 
+	2, 2, 3, 2, 2, 2, 2, 2, 2, 2,
+	2, 2, 2, 2, 3, 2, 2, 2, 2, 3,
+	2, 2 };
 
 static HANDLER button_handlers[BUTTON_COUNT] = {
 	quit_main_menu, quit_sub_menu, do_graphics, do_engine,
-	do_audio, do_resources, do_keyconfig, do_advanced, do_editkeys, 
+	do_audio, do_cheats, do_keyconfig, do_advanced, do_editkeys, 
 	do_keyconfig };
 
 /* These refer to uninitialized widgets, but that's OK; we'll fill
  * them in before we touch them */
 static WIDGET *main_widgets[] = {
-	(WIDGET *)(&buttons[2]),
-	(WIDGET *)(&buttons[3]),
-	(WIDGET *)(&buttons[4]),
-	(WIDGET *)(&buttons[5]),
-	(WIDGET *)(&buttons[6]),
-	(WIDGET *)(&buttons[7]),
-	(WIDGET *)(&buttons[0]),
+	(WIDGET *)(&buttons[2]),	// Graphics
+	(WIDGET *)(&buttons[3]),	// PC/3DO Compat Options
+	(WIDGET *)(&buttons[4]),	// Sound
+	(WIDGET *)(&buttons[5]),	// Cheats
+	(WIDGET *)(&buttons[6]),	// Controls
+	(WIDGET *)(&buttons[7]),	// Advanced
+	(WIDGET *)(&buttons[0]),	// Quit Setup Menu
 	NULL };
 
 static WIDGET *graphics_widgets[] = {
-	(WIDGET *)(&choices[0]),
-	(WIDGET *)(&choices[23]),
-	(WIDGET *)(&choices[10]),
-	(WIDGET *)(&sliders[3]),
-	(WIDGET *)(&choices[2]),
-	(WIDGET *)(&choices[3]),
+	(WIDGET *)(&choices[0]),	// Resolution
+	(WIDGET *)(&choices[43]),	// Scale GFX
+#ifdef HAVE_OPENGL
+	(WIDGET *)(&choices[1]),	// Use Framebuffer
+#endif
+	(WIDGET *)(&choices[23]),	// Aspect Ratio
+	(WIDGET *)(&choices[10]),	// Display
+	(WIDGET *)(&sliders[3]),	// Gamma Correction
+	(WIDGET *)(&choices[2]),	// Scaler
+	(WIDGET *)(&choices[3]),	// Scanlines	
+	(WIDGET *)(&choices[12]),	// Show FPS
 	(WIDGET *)(&buttons[1]),
 	NULL };
 
-static WIDGET *audio_widgets[] = {
-	(WIDGET *)(&sliders[0]),
-	(WIDGET *)(&sliders[1]),
-	(WIDGET *)(&sliders[2]),
-	(WIDGET *)(&choices[14]),
-	(WIDGET *)(&choices[9]),
-	(WIDGET *)(&choices[21]),
-	(WIDGET *)(&choices[22]),
+static WIDGET *engine_widgets[] = {
+	(WIDGET *)(&choices[4]),	// Menu Style
+	(WIDGET *)(&choices[5]),	// Font Style
+	(WIDGET *)(&choices[6]),	// Scan Style
+	(WIDGET *)(&choices[7]),	// Scroll Style
+	(WIDGET *)(&choices[8]),	// Subtitles
+	(WIDGET *)(&choices[13]),	// Melee Zoom
+	(WIDGET *)(&choices[11]),	// Cutscenes
+	(WIDGET *)(&choices[33]),	// Extra Cutscenes
+	(WIDGET *)(&choices[17]),	// Slave Shields
+	(WIDGET *)(&choices[32]),	// Skip Intro
 	(WIDGET *)(&buttons[1]),
 	NULL };
 
-static WIDGET *engine_widgets[] = {
-	(WIDGET *)(&choices[4]),
-	(WIDGET *)(&choices[5]),
-	(WIDGET *)(&choices[6]),
-	(WIDGET *)(&choices[7]),
-	(WIDGET *)(&choices[8]),
-	(WIDGET *)(&choices[13]),
-	(WIDGET *)(&choices[11]),
-	(WIDGET *)(&choices[17]),
+static WIDGET *audio_widgets[] = {
+	(WIDGET *)(&sliders[0]),	// Music Volume
+	(WIDGET *)(&sliders[1]),	// SFX Volume
+	(WIDGET *)(&sliders[2]),	// Speech Volume
+	(WIDGET *)(&choices[14]),	// Positional Audio	
+	(WIDGET *)(&choices[15]),	// Sound Driver
+	(WIDGET *)(&choices[16]),	// Sound Quality
+	(WIDGET *)(&choices[9]),	// 3DO Remixes
+	(WIDGET *)(&choices[21]),	// Precursor's Remixes
+	(WIDGET *)(&choices[22]),	// Speech
+	(WIDGET *)(&choices[34]),	// JMS: Main Menu Music
 	(WIDGET *)(&buttons[1]),
 	NULL };
 
-static WIDGET *advanced_widgets[] = {
-#ifdef HAVE_OPENGL
-	(WIDGET *)(&choices[1]),
-#endif
-	(WIDGET *)(&choices[12]),
-	(WIDGET *)(&choices[15]),
-	(WIDGET *)(&choices[16]),
-	(WIDGET *)(&buttons[1]),
+static WIDGET *cheat_widgets[] = {
+	(WIDGET *)(&choices[24]), // JMS: cheatMode on/off
+	// Serosis
+	(WIDGET *)(&choices[25]),	// God Mode
+	(WIDGET *)(&choices[26]),	// Time Dilation
+	(WIDGET *)(&choices[27]),	// Bubble Warp
+	(WIDGET *)(&choices[28]),	// Unlock Ships
+	(WIDGET *)(&choices[29]),	// Head Start
+	(WIDGET *)(&choices[30]),	// Unlock Upgrades
+	(WIDGET *)(&choices[31]),	// Infinite RU
+	(WIDGET *)(&choices[39]),	// Infinite Fuel
+	(WIDGET *)(&choices[44]),	// Add Devices
+	(WIDGET *)(&buttons[1]),	// Exit to Menu
 	NULL };
 	
 static WIDGET *keyconfig_widgets[] = {
-	(WIDGET *)(&choices[18]),
-	(WIDGET *)(&choices[19]),
+	(WIDGET *)(&choices[18]),	// Bottom Player
+	(WIDGET *)(&choices[19]),	// Top Player
 	(WIDGET *)(&labels[1]),
-	(WIDGET *)(&buttons[8]),
+	(WIDGET *)(&buttons[8]),	// Edit Controls
+	(WIDGET *)(&buttons[1]),
+	NULL };
+
+static WIDGET *advanced_widgets[] = {
+	(WIDGET *)(&choices[35]),	// JMS: IP nebulae on/off
+	(WIDGET *)(&choices[36]),	// JMS: orbitingPlanets on/off
+	(WIDGET *)(&choices[37]),	// JMS: texturedPlanets on/off
+	(WIDGET *)(&choices[45]),	// Serosis: Scaled Planets
+	(WIDGET *)(&choices[38]),	// Nic: Switch date formats
+	(WIDGET *)(&choices[40]),	// Serosis: Thraddash Story switch
+	(WIDGET *)(&choices[41]),	// Serosis: Partial Pickup switch
+	(WIDGET *)(&choices[42]),	// Serosis: Submenu switch
 	(WIDGET *)(&buttons[1]),
 	NULL };
 
@@ -182,11 +216,6 @@ static WIDGET *editkeys_widgets[] = {
 	(WIDGET *)(&buttons[9]),
 	NULL };
 
-static WIDGET *incomplete_widgets[] = {
-	(WIDGET *)(&labels[0]),
-	(WIDGET *)(&buttons[1]),
-	NULL };
-
 static const struct
 {
 	WIDGET **widgets;
@@ -196,12 +225,12 @@ menu_defs[] =
 {
 	{main_widgets, 0},
 	{graphics_widgets, 1},
-	{audio_widgets, 1},
-	{engine_widgets, 2},
-	{incomplete_widgets, 3},
-	{keyconfig_widgets, 1},
-	{advanced_widgets, 2},
-	{editkeys_widgets, 1},
+	{audio_widgets, 2},
+	{engine_widgets, 3},
+	{cheat_widgets, 4},
+	{keyconfig_widgets, 5},
+	{advanced_widgets, 6},
+	{editkeys_widgets, 7},
 	{NULL, 0}
 };
 
@@ -282,7 +311,7 @@ do_engine (WIDGET *self, int event)
 }
 
 static int
-do_resources (WIDGET *self, int event)
+do_cheats (WIDGET *self, int event)
 {
 	if (event == WIDGET_EVENT_SELECT)
 	{
@@ -384,15 +413,15 @@ SetDefaults (void)
 	GLOBALOPTS opts;
 	
 	GetGlobalOptions (&opts);
-	if (opts.res == OPTVAL_CUSTOM)
+	/*if (opts.screenResolution == OPTVAL_CUSTOM)
 	{
 		choices[0].numopts = RES_OPTS + 1;
 	}
 	else
-	{
+	{*/
 		choices[0].numopts = RES_OPTS;
-	}
-	choices[0].selected = opts.res;
+	//}
+	choices[0].selected = opts.screenResolution;
 	choices[1].selected = opts.driver;
 	choices[2].selected = opts.scaler;
 	choices[3].selected = opts.scanlines;
@@ -417,6 +446,33 @@ SetDefaults (void)
 	choices[22].selected = opts.speech;
 	choices[23].selected = opts.keepaspect;
 
+ 	choices[24].selected = opts.cheatMode; // JMS	
+	// Serosis
+	choices[25].selected = opts.godMode;
+	choices[26].selected = opts.tdType;
+	choices[27].selected = opts.bubbleWarp;
+	choices[28].selected = opts.unlockShips;
+	choices[29].selected = opts.headStart;
+	choices[30].selected = opts.unlockUpgrades;
+	choices[31].selected = opts.infiniteRU;
+	choices[32].selected = opts.skipIntro;
+	choices[33].selected = opts.FMV;
+	// JMS
+	choices[34].selected = opts.mainMenuMusic;
+	choices[35].selected = opts.nebulae;
+	choices[36].selected = opts.orbitingPlanets;
+	choices[37].selected = opts.texturedPlanets;
+	// Nic
+	choices[38].selected = opts.dateType;
+	 // Serosis
+	choices[39].selected = opts.infiniteFuel;
+	choices[40].selected = opts.thraddStory;
+	choices[41].selected = opts.partialPickup;
+	choices[42].selected = opts.submenu;
+	choices[43].selected = opts.loresBlowup; // JMS
+	choices[44].selected = opts.addDevices;
+	choices[45].selected = opts.scalePlanets;
+
 	sliders[0].value = opts.musicvol;
 	sliders[1].value = opts.sfxvol;
 	sliders[2].value = opts.speechvol;
@@ -427,7 +483,7 @@ static void
 PropagateResults (void)
 {
 	GLOBALOPTS opts;
-	opts.res = choices[0].selected;
+	opts.screenResolution = choices[0].selected;
 	opts.driver = choices[1].selected;
 	opts.scaler = choices[2].selected;
 	opts.scanlines = choices[3].selected;
@@ -451,6 +507,33 @@ PropagateResults (void)
 	opts.speech = choices[22].selected;
 	opts.keepaspect = choices[23].selected;
 
+ 	opts.cheatMode = choices[24].selected; // JMS
+	// Serosis
+	opts.godMode = choices[25].selected;
+	opts.tdType = choices[26].selected;
+	opts.bubbleWarp = choices[27].selected;
+	opts.unlockShips = choices[28].selected;
+	opts.headStart = choices[29].selected;
+	opts.unlockUpgrades = choices[30].selected;
+	opts.infiniteRU = choices[31].selected;
+	opts.skipIntro = choices[32].selected;
+	opts.FMV = choices[33].selected;
+	 // JMS
+	opts.mainMenuMusic = choices[34].selected;
+	opts.nebulae = choices[35].selected;
+	opts.orbitingPlanets = choices[36].selected;
+	opts.texturedPlanets = choices[37].selected;
+	// Nic
+	opts.dateType = choices[38].selected;
+	// Serosis
+	opts.infiniteFuel = choices[39].selected;
+	opts.thraddStory = choices[40].selected;
+	opts.partialPickup = choices[41].selected;
+	opts.submenu = choices[42].selected;
+	opts.loresBlowup = choices[43].selected; // JMS
+	opts.addDevices = choices[44].selected;
+	opts.scalePlanets = choices[45].selected;
+
 	opts.musicvol = sliders[0].value;
 	opts.sfxvol = sliders[1].value;
 	opts.speechvol = sliders[2].value;
@@ -469,7 +552,7 @@ DoSetupMenu (SETUP_MENU_STATE *pInputSta
 		SetDefaultMenuRepeatDelay ();
 		pInputState->NextTime = GetTimeCounter ();
 		SetDefaults ();
-		Widget_SetFont (StarConFont);
+		Widget_SetFont (PlyrFont); // Was StarConFont: Switched for better readability
 		Widget_SetWindowColors (SHADOWBOX_BACKGROUND_COLOR,
 				SHADOWBOX_DARK_COLOR, SHADOWBOX_MEDIUM_COLOR);
 
@@ -789,9 +872,15 @@ init_widgets (void)
 		bank = StringBank_Create ();
 	}
 	
-	if (setup_frame == NULL)
+	if (setup_frame == NULL || resFactorWasChanged)
 	{
-		setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM));
+		// JMS: Load the different menus depending on the resolution factor.
+		if (resolutionFactor < 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM));
+		if (resolutionFactor == 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM2X));
+		if (resolutionFactor > 1)
+			setup_frame = CaptureDrawable (LoadGraphic (MENUBKG_PMAP_ANIM4X));
 	}
 
 	count = GetStringTableCount (SetupTab);
@@ -837,7 +926,7 @@ init_widgets (void)
 	/* Options */
 	if (SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 2)), '\n', 100, buffer, bank) != CHOICE_COUNT)
 	{
-		log_add (log_Fatal, "PANIC: Incorrect number of Choice Options");
+		log_add (log_Fatal, "PANIC: Incorrect number of Choice Options: %d. Should be %d", CHOICE_COUNT, SplitString (GetStringAddress (SetAbsStringTableIndex (SetupTab, 2)), '\n', 100, buffer, bank));
 		exit (EXIT_FAILURE);
 	}
 
@@ -1304,68 +1393,6 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	/* Work out resolution.  On the way, try to guess a good default
 	 * for config.alwaysgl, then overwrite it if it was set previously. */
 	opts->driver = OPTVAL_PURE_IF_POSSIBLE;
-	switch (ScreenWidthActual)
-	{
-	case 320:
-		if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
-		{
-			opts->res = OPTVAL_320_240;
-		}
-		else
-		{
-			if (ScreenHeightActual != 240)
-			{
-				opts->res = OPTVAL_CUSTOM;
-			}
-			else
-			{
-				opts->res = OPTVAL_320_240;
-				opts->driver = OPTVAL_ALWAYS_GL;
-			}
-		}
-		break;
-	case 640:
-		if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
-		{
-			opts->res = OPTVAL_640_480;
-		}
-		else
-		{
-			if (ScreenHeightActual != 480)
-			{
-				opts->res = OPTVAL_CUSTOM;
-			}
-			else
-			{
-				opts->res = OPTVAL_640_480;
-				opts->driver = OPTVAL_ALWAYS_GL;
-			}
-		}
-		break;
-	case 800:
-		if (ScreenHeightActual != 600)
-		{
-			opts->res = OPTVAL_CUSTOM;
-		}
-		else
-		{
-			opts->res = OPTVAL_800_600;
-		}
-		break;
-	case 1024:
-		if (ScreenHeightActual != 768)
-		{
-			opts->res = OPTVAL_CUSTOM;
-		}
-		else
-		{
-			opts->res = OPTVAL_1024_768;
-		}		
-		break;
-	default:
-		opts->res = OPTVAL_CUSTOM;
-		break;
-	}
 
 	if (res_IsBoolean ("config.alwaysgl"))
 	{
@@ -1395,6 +1422,89 @@ GetGlobalOptions (GLOBALOPTS *opts)
 	opts->musicvol = (((int)(musicVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->sfxvol = (((int)(sfxVolumeScale * 100.0f) + 2) / 5) * 5;
 	opts->speechvol = (((int)(speechVolumeScale * 100.0f) + 2) / 5) * 5;
+
+ 	opts->cheatMode = optCheatMode ? OPTVAL_ENABLED : OPTVAL_DISABLED; // JMS
+	// Serosis
+	opts->godMode = optGodMode ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->tdType = res_GetInteger ("cheat.timeDilation");
+	opts->bubbleWarp = optBubbleWarp ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->unlockShips = optUnlockShips ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->headStart = optHeadStart ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->unlockUpgrades = optUnlockUpgrades ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->infiniteRU = optInfiniteRU ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->skipIntro = optSkipIntro ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->FMV = optFMV ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	// JMS
+	opts->mainMenuMusic = optMainMenuMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->nebulae = optNebulae ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->orbitingPlanets = optOrbitingPlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->texturedPlanets = optTexturedPlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	// Nic
+	opts->dateType = res_GetInteger ("config.dateFormat");
+	// Serosis
+	opts->infiniteFuel = optInfiniteFuel ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->thraddStory = optThraddStory ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->partialPickup = optPartialPickup ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->submenu = optSubmenu ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->addDevices = optAddDevices ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->scalePlanets = optScalePlanets ? OPTVAL_ENABLED : OPTVAL_DISABLED;
+	opts->loresBlowup = res_GetInteger ("config.loresBlowupScale");
+
+	// JMS_GFX: 1280x960
+	if (resolutionFactor == 2)
+	{
+		opts->screenResolution = OPTVAL_REAL_1280_960;
+		opts->loresBlowup = NO_BLOWUP;	
+	}
+	// JMS_GFX: 640x480
+	else if (resolutionFactor == 1)
+	{
+		opts->screenResolution = OPTVAL_REAL_640_480;
+		opts->loresBlowup = NO_BLOWUP;
+	}
+	// JMS_GFX: 320x240
+	else
+	{
+		switch (ScreenWidthActual)
+		{
+			case 320:
+				if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
+				{
+					opts->screenResolution = OPTVAL_320_240;
+				}
+				else
+				{
+					opts->screenResolution = OPTVAL_320_240;
+					opts->driver = OPTVAL_ALWAYS_GL;
+				}
+				break;
+			case 640:
+				if (GraphicsDriver == TFB_GFXDRIVER_SDL_PURE)
+				{
+					opts->screenResolution = OPTVAL_320_240;
+					opts->loresBlowup = OPTVAL_320_TO_640;
+				}
+				else
+				{
+					opts->screenResolution = OPTVAL_320_240;
+					opts->loresBlowup = OPTVAL_320_TO_640;
+					opts->driver = OPTVAL_ALWAYS_GL;
+				}
+				break;
+			case 960:
+				opts->screenResolution = OPTVAL_320_240;
+				opts->loresBlowup = OPTVAL_320_TO_960;
+				break;
+			case 1280:
+				opts->screenResolution = OPTVAL_320_240;
+				opts->loresBlowup = OPTVAL_320_TO_1280;	
+				break;
+			default:
+				opts->screenResolution = OPTVAL_320_240;
+				opts->loresBlowup = NO_BLOWUP;
+				break;
+		}
+	}
 }
 
 void
@@ -1404,75 +1514,260 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	int NewWidth = ScreenWidthActual;
 	int NewHeight = ScreenHeightActual;
 	int NewDriver = GraphicsDriver;
+	
+	unsigned int oldResFactor = resolutionFactor; // JMS_GFX
 
 	NewGfxFlags &= ~TFB_GFXFLAGS_SCALE_ANY;
-
-	switch (opts->res) {
-	case OPTVAL_320_240:
-		NewWidth = 320;
-		NewHeight = 240;
+	
+	// JMS_GFX
+	switch (opts->screenResolution) {
+		case OPTVAL_320_240:
+			NewWidth = 320;
+			NewHeight = 240;
 #ifdef HAVE_OPENGL	       
-		NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
+			NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
 #else
-		NewDriver = TFB_GFXDRIVER_SDL_PURE;
+			NewDriver = TFB_GFXDRIVER_SDL_PURE;
 #endif
-		break;
-	case OPTVAL_640_480:
-		NewWidth = 640;
-		NewHeight = 480;
+			resolutionFactor = 0;
+			break;
+		case OPTVAL_REAL_640_480:
+			NewWidth = 640;	
+			NewHeight = 480;
 #ifdef HAVE_OPENGL	       
-		NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
+			NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
 #else
-		NewDriver = TFB_GFXDRIVER_SDL_PURE;
+			NewDriver = TFB_GFXDRIVER_SDL_PURE;
 #endif
-		break;
-	case OPTVAL_800_600:
-		NewWidth = 800;
-		NewHeight = 600;
-		NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
-		break;
-	case OPTVAL_1024_768:
-		NewWidth = 1024;
-		NewHeight = 768;
-		NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
-		break;
-	default:
-		/* Don't mess with the custom value */
-		break;
+			resolutionFactor = 1;
+			break;
+		case OPTVAL_REAL_1280_960:
+			NewWidth = 1280;
+			NewHeight = 960;
+#ifdef HAVE_OPENGL	       
+			NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
+#else
+			NewDriver = TFB_GFXDRIVER_SDL_PURE;
+#endif
+			resolutionFactor = 2;
+			break;
+		default:
+			/* Don't mess with the custom value */
+			resolutionFactor = 0; // JMS_GFX
+			break;
+	}
+
+	if (NewWidth == 320 && NewHeight == 240) // MB: Moved code to here to make it work with 320x240 resolutions before opts->loresBlowup switch after
+	{
+		switch (opts->scaler)
+		{
+			case OPTVAL_BILINEAR_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
+				res_PutString ("config.scaler", "bilinear");
+				break;
+			case OPTVAL_BIADAPT_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPT;
+				res_PutString ("config.scaler", "biadapt");
+				break;
+			case OPTVAL_BIADV_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPTADV;
+				res_PutString ("config.scaler", "biadv");
+				break;
+			case OPTVAL_TRISCAN_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_TRISCAN;
+				res_PutString ("config.scaler", "triscan");
+				break;
+			case OPTVAL_HQXX_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_HQXX;
+				res_PutString ("config.scaler", "hq");
+				break;
+			default:
+				/* OPTVAL_NO_SCALE has no equivalent in gfxflags. */
+				res_PutString ("config.scaler", "no");
+				break;
+		}
+	}
+	else
+	{
+		// JMS: For now, only bilinear works in 1280x960 and 640x480.
+		switch (opts->scaler)
+		{
+			case OPTVAL_BILINEAR_SCALE:
+			case OPTVAL_BIADAPT_SCALE:
+			case OPTVAL_BIADV_SCALE:
+			case OPTVAL_TRISCAN_SCALE:
+			case OPTVAL_HQXX_SCALE:
+				NewGfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
+				res_PutString ("config.scaler", "bilinear");
+				break;
+			default:
+				/* OPTVAL_NO_SCALE has no equivalent in gfxflags. */
+				res_PutString ("config.scaler", "no");
+				break;
+		}
+	}
+
+	if (NewWidth == 320 && NewHeight == 240)
+	{	
+		switch (opts->loresBlowup) {
+			case NO_BLOWUP:
+				// JMS: Default value: Don't do anything.
+				break;
+			case OPTVAL_320_TO_640:
+				NewWidth = 640;
+				NewHeight = 480;
+#ifdef HAVE_OPENGL	       
+				NewDriver = (opts->driver == OPTVAL_ALWAYS_GL ? TFB_GFXDRIVER_SDL_OPENGL : TFB_GFXDRIVER_SDL_PURE);
+#else
+				NewDriver = TFB_GFXDRIVER_SDL_PURE;
+#endif
+				resolutionFactor = 0;
+				break;
+			case OPTVAL_320_TO_960:
+				NewWidth = 960;
+				NewHeight = 720;
+				NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
+				resolutionFactor = 0;
+				break;
+			case OPTVAL_320_TO_1280:
+				NewWidth = 1280;
+				NewHeight = 960;
+				NewDriver = TFB_GFXDRIVER_SDL_OPENGL;
+				resolutionFactor = 0;
+				break;
+			default:
+				break;
+		}
 	}
+	else
+		opts->loresBlowup = NO_BLOWUP;
+	
+ 	if (oldResFactor != resolutionFactor || (opts->music3do != (opt3doMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED)) || (opts->musicremix != (optRemixMusic ? OPTVAL_ENABLED : OPTVAL_DISABLED))) // MB: To force the game to restart when changing music options (otherwise music will not be changed) or resfactor 
+ 		resFactorWasChanged = TRUE;
 
 	res_PutInteger ("config.reswidth", NewWidth);
 	res_PutInteger ("config.resheight", NewHeight);
 	res_PutBoolean ("config.alwaysgl", opts->driver == OPTVAL_ALWAYS_GL);
-	res_PutBoolean ("config.usegl", NewDriver == TFB_GFXDRIVER_SDL_OPENGL);
+	res_PutBoolean ("config.usegl", NewDriver == TFB_GFXDRIVER_SDL_OPENGL);	
+	
+	// JMS_GFX
+	res_PutInteger ("config.resolutionfactor", resolutionFactor);
+	res_PutInteger ("config.loresBlowupScale", opts->loresBlowup);
+
+	// JMS: Cheat Mode: Kohr-Ah move at zero speed when trying to cleanse the galaxy
+	res_PutBoolean ("cheat.kohrStahp", opts->cheatMode == OPTVAL_ENABLED);
+	optCheatMode = opts->cheatMode == OPTVAL_ENABLED;
+
+	// Serosis: God Mode: Health and Energy does not deplete in battle.
+	res_PutBoolean ("cheat.godMode", opts->godMode == OPTVAL_ENABLED);
+	optGodMode = opts->godMode == OPTVAL_ENABLED;
 
-	switch (opts->scaler) {
-	case OPTVAL_BILINEAR_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_BILINEAR;
-		res_PutString ("config.scaler", "bilinear");
+	// Serosis: Time Dilation: Increases and divides time in IP and HS by a factor of 12
+	switch (opts->tdType){
+		case OPTVAL_SLOW:
+			timeDilationScale=1;
 		break;
-	case OPTVAL_BIADAPT_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPT;
-		res_PutString ("config.scaler", "biadapt");
+		case OPTVAL_FAST:
+			timeDilationScale=2;
 		break;
-	case OPTVAL_BIADV_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_BIADAPTADV;
-		res_PutString ("config.scaler", "biadv");
+		case OPTVAL_NORMAL:
+		default:
+			timeDilationScale=0;
 		break;
-	case OPTVAL_TRISCAN_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_TRISCAN;
-		res_PutString ("config.scaler", "triscan");
+	}
+	res_PutInteger ("cheat.timeDilation", opts->tdType);
+
+	// Serosis: Bubble Warp: Warp instantly to your destination
+	res_PutBoolean ("cheat.bubbleWarp", opts->bubbleWarp == OPTVAL_ENABLED);
+	optBubbleWarp = opts->bubbleWarp == OPTVAL_ENABLED;
+
+	// Serosis: Unlocks ships that you can not unlock under normal conditions
+	res_PutBoolean ("cheat.unlockShips", opts->unlockShips == OPTVAL_ENABLED);
+	optUnlockShips = opts->unlockShips == OPTVAL_ENABLED;
+
+	// Serosis: Gives you 1000 Radioactives and a better outfitted ship on a a new game
+	res_PutBoolean ("cheat.headStart", opts->headStart == OPTVAL_ENABLED);
+	optHeadStart = opts->headStart == OPTVAL_ENABLED;
+
+	// Serosis: Unlocks all upgrades
+	res_PutBoolean ("cheat.unlockUpgrades", opts->unlockUpgrades == OPTVAL_ENABLED);
+	optUnlockUpgrades = opts->unlockUpgrades == OPTVAL_ENABLED;
+
+	// Serosis: Virtually Infinite RU
+	res_PutBoolean ("cheat.infiniteRU", opts->infiniteRU == OPTVAL_ENABLED);
+	optInfiniteRU = opts->infiniteRU == OPTVAL_ENABLED;
+
+	// Serosis: Skip the intro
+	res_PutBoolean ("config.skipIntro", opts->skipIntro == OPTVAL_ENABLED);
+	optSkipIntro = opts->skipIntro == OPTVAL_ENABLED;
+
+	// Serosis: Adds the Crystal Dynamics Logo and Commercial to the loaded 3DO videos
+	res_PutBoolean ("config.FMV", opts->FMV == OPTVAL_ENABLED);
+	optFMV = opts->FMV == OPTVAL_ENABLED;
+	
+	// JMS: Main menu music
+	res_PutBoolean ("config.mainMenuMusic", opts->mainMenuMusic == OPTVAL_ENABLED);
+	optMainMenuMusic = opts->mainMenuMusic == OPTVAL_ENABLED;
+	if(!optMainMenuMusic)
+		FadeMusic (0,ONE_SECOND);
+	else
+		FadeMusic (NORMAL_VOLUME+70, ONE_SECOND);
+	
+	// JMS: Is a beautiful nebula background shown as the background of solarsystems.
+	res_PutBoolean ("config.nebulae", opts->nebulae == OPTVAL_ENABLED);
+	optNebulae = opts->nebulae == OPTVAL_ENABLED;
+	
+	// JMS: Rotating planets in IP.
+	res_PutBoolean ("config.orbitingPlanets", opts->orbitingPlanets == OPTVAL_ENABLED);
+	optOrbitingPlanets = opts->orbitingPlanets == OPTVAL_ENABLED;
+	
+	// JMS: Textured or plain(==vanilla UQM style) planets in IP.
+	res_PutBoolean ("config.texturedPlanets", opts->texturedPlanets == OPTVAL_ENABLED);
+	optTexturedPlanets = opts->texturedPlanets == OPTVAL_ENABLED;	
+
+	// Nic: Date Format: Switch the displayed date format
+	switch (opts->dateType){
+		case OPTVAL_MMDDYYYY:
+			optDateFormat=1;
 		break;
-	case OPTVAL_HQXX_SCALE:
-		NewGfxFlags |= TFB_GFXFLAGS_SCALE_HQXX;
-		res_PutString ("config.scaler", "hq");
+		case OPTVAL_DDMMMYYYY:
+			optDateFormat=2;
 		break;
-	default:
-		/* OPTVAL_NO_SCALE has no equivalent in gfxflags. */
-		res_PutString ("config.scaler", "no");
+		case OPTVAL_DDMMYYYY:
+			optDateFormat=3;
+		break;
+		case OPTVAL_MMMDDYYYY:
+		default:
+			optDateFormat=0;
 		break;
 	}
-	if (opts->scanlines) {
+	res_PutInteger ("config.dateFormat", opts->dateType);	
+	
+	// Serosis: Infinite Fuel
+	res_PutBoolean ("cheat.infiniteFuel", opts->infiniteFuel == OPTVAL_ENABLED);
+	optInfiniteFuel = opts->infiniteFuel == OPTVAL_ENABLED;
+	
+	// Serosis: Optionalized the alt Thraddash story
+	res_PutBoolean ("config.thraddStory", opts->thraddStory == OPTVAL_ENABLED);
+	optThraddStory = opts->thraddStory == OPTVAL_ENABLED;
+	
+	// Serosis: Partial mineral pickup when enabled.
+	res_PutBoolean ("config.partialPickup", opts->partialPickup == OPTVAL_ENABLED);
+	optPartialPickup = opts->partialPickup == OPTVAL_ENABLED;
+	
+	// Serosis: Show submenu
+	res_PutBoolean ("config.submenu", opts->submenu == OPTVAL_ENABLED);
+	optSubmenu = opts->submenu == OPTVAL_ENABLED;
+	
+	// Serosis: get all devices
+	res_PutBoolean ("cheat.addDevices", opts->addDevices == OPTVAL_ENABLED);
+	optAddDevices = opts->addDevices == OPTVAL_ENABLED;
+	
+	// Serosis: Scale Planets in HD
+	res_PutBoolean ("config.scalePlanets", opts->scalePlanets == OPTVAL_ENABLED);
+	optScalePlanets = opts->scalePlanets == OPTVAL_ENABLED;
+
+	if (opts->scanlines && RESOLUTION_FACTOR == 0) {
 		NewGfxFlags |= TFB_GFXFLAGS_SCANLINES;
 	} else {
 		NewGfxFlags &= ~TFB_GFXFLAGS_SCANLINES;
@@ -1484,15 +1779,38 @@ SetGlobalOptions (GLOBALOPTS *opts)
 
 	res_PutBoolean ("config.scanlines", opts->scanlines);
 	res_PutBoolean ("config.fullscreen", opts->fullscreen);
-
-
+	
 	if ((NewWidth != ScreenWidthActual) ||
 	    (NewHeight != ScreenHeightActual) ||
 	    (NewDriver != GraphicsDriver) ||
+		(resFactorWasChanged) || // JMS_GFX
 	    (NewGfxFlags != GfxFlags)) 
 	{
 		FlushGraphics ();
 		UninitVideoPlayer ();
+		
+		// JMS_GFX
+		if (resFactorWasChanged)
+		{
+			// Tell the game the new screen's size.
+			ScreenWidth  = 320 << resolutionFactor;
+			ScreenHeight = 240 << resolutionFactor;
+			
+			log_add (log_Debug, "ScreenWidth:%d, ScreenHeight:%d, Wactual:%d, Hactual:%d",
+				ScreenWidth, ScreenHeight, ScreenWidthActual, ScreenHeightActual);
+			
+			// These solve the context problem that plagued the setupmenu when changing to higher resolution.
+			TFB_BBox_Reset ();
+			TFB_BBox_Init (ScreenWidth, ScreenHeight);
+			
+			// Change how big area of the screen is update-able.
+			DestroyDrawable (ReleaseDrawable (Screen));
+			Screen = CaptureDrawable (CreateDisplay (WANT_MASK | WANT_PIXMAP, &screen_width, &screen_height));
+			SetContext (ScreenContext);
+			SetContextFGFrame ((FRAME)NULL);
+			SetContextFGFrame (Screen);
+		}
+		
 		TFB_DrawScreen_ReinitVideo (NewDriver, NewGfxFlags, NewWidth, NewHeight);
 		FlushGraphics ();
 		InitVideoPlayer (TRUE);
@@ -1541,32 +1859,32 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	res_PutInteger ("config.player2control", opts->player2);
 
 	switch (opts->adriver) {
-	case OPTVAL_SILENCE:
-		res_PutString ("config.audiodriver", "none");
-		break;
-	case OPTVAL_MIXSDL:
-		res_PutString ("config.audiodriver", "mixsdl");
-		break;
-	case OPTVAL_OPENAL:
-		res_PutString ("config.audiodriver", "openal");
-	default:
-		/* Shouldn't happen; leave config untouched */
-		break;
+		case OPTVAL_SILENCE:
+			res_PutString ("config.audiodriver", "none");
+			break;
+		case OPTVAL_MIXSDL:
+			res_PutString ("config.audiodriver", "mixsdl");
+			break;
+		case OPTVAL_OPENAL:
+			res_PutString ("config.audiodriver", "openal");
+		default:
+			/* Shouldn't happen; leave config untouched */
+			break;
 	}
 
 	switch (opts->aquality) {
-	case OPTVAL_LOW:
-		res_PutString ("config.audioquality", "low");
-		break;
-	case OPTVAL_MEDIUM:
-		res_PutString ("config.audioquality", "medium");
-		break;
-	case OPTVAL_HIGH:
-		res_PutString ("config.audioquality", "high");
-		break;
-	default:
-		/* Shouldn't happen; leave config untouched */
-		break;
+		case OPTVAL_LOW:
+			res_PutString ("config.audioquality", "low");
+			break;
+		case OPTVAL_MEDIUM:
+			res_PutString ("config.audioquality", "medium");
+			break;
+		case OPTVAL_HIGH:
+			res_PutString ("config.audioquality", "high");
+			break;
+		default:
+			/* Shouldn't happen; leave config untouched */
+			break;
 	}
 
 	res_PutInteger ("config.musicvol", opts->musicvol);
@@ -1587,5 +1905,8 @@ SetGlobalOptions (GLOBALOPTS *opts)
 	res_PutString ("keys.6.name", input_templates[5].name);
 
 	SaveResourceIndex (configDir, "uqm.cfg", "config.", TRUE);
+
 	SaveKeyConfiguration (configDir, "flight.cfg");
+	
+	SaveResourceIndex (configDir, "cheats.cfg", "cheat.", TRUE);
 }
diff -ruNp src.orig/uqm/setupmenu.h src/uqm/setupmenu.h
--- src.orig/uqm/setupmenu.h	2017-12-30 00:14:41 -0800
+++ src/uqm/setupmenu.h	2017-12-30 00:14:53 -0800
@@ -46,13 +46,18 @@ typedef enum {
 
 typedef enum {
 	OPTVAL_320_240,
-	OPTVAL_640_480,
-	OPTVAL_800_600,
-	OPTVAL_1024_768,
-	OPTVAL_CUSTOM
+	OPTVAL_REAL_640_480, // JMS_GFX
+	OPTVAL_REAL_1280_960, // JMS_GFX
 } OPT_RESTYPE;
 
 typedef enum {
+	NO_BLOWUP,
+	OPTVAL_320_TO_640,
+	OPTVAL_320_TO_960,
+	OPTVAL_320_TO_1280,
+} OPT_LORESBLOWUPTYPE;
+
+typedef enum {
 	OPTVAL_PURE_IF_POSSIBLE,
 	OPTVAL_ALWAYS_GL
 } OPT_DRIVERTYPE;
@@ -68,19 +73,36 @@ typedef enum {
 	OPTVAL_MEDIUM,
 	OPTVAL_HIGH
 } OPT_AQUALITYTYPE;
+ 
+typedef enum {
+	OPTVAL_NORMAL,
+	OPTVAL_SLOW,
+	OPTVAL_FAST
+} OPT_TDTYPE;
+ 
+typedef enum {
+	OPTVAL_MMMDDYYYY,
+	OPTVAL_MMDDYYYY,
+	OPTVAL_DDMMMYYYY,
+	OPTVAL_DDMMYYYY
+} OPT_DATETYPE;
 
 /* At the moment, CONTROL_TEMPLATE is directly in this structure.  If
  * CONTROL_TEMPLATE and the options available diverge, this will need
  * to change */
 typedef struct globalopts_struct {
 	OPT_SCALETYPE scaler;
-	OPT_RESTYPE res;
+	OPT_RESTYPE screenResolution;
+	OPT_LORESBLOWUPTYPE loresBlowup;
 	OPT_DRIVERTYPE driver;
 	OPT_ADRIVERTYPE adriver;
 	OPT_AQUALITYTYPE aquality;
-	OPT_ENABLABLE fullscreen, subtitles, scanlines, fps, stereo;
-	OPT_ENABLABLE music3do, musicremix, speech;
-	OPT_ENABLABLE keepaspect;
+	OPT_TDTYPE tdType; // Serosis
+	OPT_DATETYPE dateType; //
+	OPT_ENABLABLE fullscreen, subtitles, scanlines, fps, stereo, music3do, musicremix, speech, keepaspect,
+		cheatMode, godMode, bubbleWarp, unlockShips, headStart, unlockUpgrades, infiniteRU, skipIntro, FMV, // Serosis: except for cheatMode = JMS
+		mainMenuMusic, nebulae, orbitingPlanets, texturedPlanets, // JMS
+		infiniteFuel, thraddStory, partialPickup, submenu, addDevices, scalePlanets; // Serosis
 	OPT_CONSOLETYPE menu, text, cscan, scroll, intro, meleezoom, shield;
 	CONTROL_TEMPLATE player1, player2;
 	int speechvol, musicvol, sfxvol;
diff -ruNp src.orig/uqm/ship.c src/uqm/ship.c
--- src.orig/uqm/ship.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ship.c	2017-12-30 00:14:53 -0800
@@ -55,7 +55,7 @@ animation_preprocess (ELEMENT *ElementPt
 STATUS_FLAGS
 inertial_thrust (ELEMENT *ElementPtr)
 {
-#define MAX_ALLOWED_SPEED     WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (18))
+#define MAX_ALLOWED_SPEED     WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (18 << RESOLUTION_FACTOR)) // JMS_GFX
 #define MAX_ALLOWED_SPEED_SQR ((DWORD)MAX_ALLOWED_SPEED * MAX_ALLOWED_SPEED)
 
 	COUNT CurrentAngle, TravelAngle;
@@ -186,7 +186,7 @@ ship_preprocess (ELEMENT *ElementPtr)
 		{
 			CONTEXT OldContext;
 
-			InitShipStatus (&RDPtr->ship_info, StarShipPtr, NULL);
+			InitShipStatus (&RDPtr->ship_info, StarShipPtr, NULL, FALSE);
 			OldContext = SetContext (StatusContext);
 			DrawCaptainsWindow (StarShipPtr);
 			SetContext (OldContext);
@@ -271,7 +271,7 @@ ship_preprocess (ELEMENT *ElementPtr)
 		if (!OBJECT_CLOAKED (ElementPtr)
 				&& LOBYTE (GLOBAL (CurrentActivity)) <= IN_ENCOUNTER)
 		{
-			spawn_ion_trail (ElementPtr);
+			spawn_ion_trail (ElementPtr, 0, 0);
 		}
 	}
 
diff -ruNp src.orig/uqm/shipcont.h src/uqm/shipcont.h
--- src.orig/uqm/shipcont.h	2017-12-30 00:14:41 -0800
+++ src/uqm/shipcont.h	2017-12-30 00:14:53 -0800
@@ -25,7 +25,7 @@
 extern "C" {
 #endif
 
-#define FIELD_WIDTH (STATUS_WIDTH - 5)
+#define FIELD_WIDTH (STATUS_WIDTH - RES_CASE(5,5,7)) // JMS_GFX
 
 extern void CargoMenu (void);
 extern BOOLEAN RosterMenu (void);
diff -ruNp src.orig/uqm/ships/androsyn/androsyn.c src/uqm/ships/androsyn/androsyn.c
--- src.orig/uqm/ships/androsyn/androsyn.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/androsyn/androsyn.c	2017-12-30 00:14:53 -0800
@@ -19,6 +19,7 @@
 #include "../ship.h"
 #include "androsyn.h"
 #include "resinst.h"
+#include "../../units.h"
 
 #include "libs/mathlib.h"
 
@@ -29,6 +30,10 @@
 #define ENERGY_WAIT 8
 #define MAX_THRUST 24
 #define THRUST_INCREMENT 3
+#define MAX_THRUST_2X 48
+#define THRUST_INCREMENT_2X 6
+#define MAX_THRUST_4X 96
+#define THRUST_INCREMENT_4X 12
 #define TURN_WAIT 4
 #define THRUST_WAIT 0
 #define SHIP_MASS 6
@@ -36,9 +41,9 @@
 // Bubbles
 #define WEAPON_ENERGY_COST 3
 #define WEAPON_WAIT 0
-#define ANDROSYNTH_OFFSET 14
-#define MISSILE_OFFSET 3
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8)
+#define ANDROSYNTH_OFFSET (14 << RESOLUTION_FACTOR)
+#define MISSILE_OFFSET (3 << RESOLUTION_FACTOR)
+#define MISSILE_SPEED DISPLAY_TO_WORLD (8 << RESOLUTION_FACTOR)
 #define MISSILE_LIFE 200
 #define MISSILE_HITS 3
 #define MISSILE_DAMAGE 2
@@ -48,13 +53,13 @@
 #define SPECIAL_ENERGY_COST 2
 #define BLAZER_DEGENERATION (-1)
 #define SPECIAL_WAIT 0
-#define BLAZER_OFFSET 10
-#define BLAZER_THRUST 60
+#define BLAZER_OFFSET (10 << RESOLUTION_FACTOR)
+#define BLAZER_THRUST (60 << RESOLUTION_FACTOR)
 #define BLAZER_TURN_WAIT 1
 #define BLAZER_DAMAGE 3
 #define BLAZER_MASS 1
 
-static RACE_DESC androsynth_desc =
+static RACE_DESC androsynth_desc1x =
 {
 	{ /* SHIP_INFO */
 		"guardian",
@@ -127,6 +132,150 @@ static RACE_DESC androsynth_desc =
 	0, /* CodeRef */
 };
 
+static RACE_DESC androsynth_desc2x =
+{
+	{ /* SHIP_INFO */
+		"guardian",
+		FIRES_FORE | SEEKING_WEAPON,
+		15, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ANDROSYNTH_RACE_STRINGS,
+		ANDROSYNTH_ICON_MASK_PMAP_ANIM,
+		ANDROSYNTH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_2X,
+		THRUST_INCREMENT_2X,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ANDROSYNTH_BIG_MASK_PMAP_ANIM,
+			ANDROSYNTH_MED_MASK_PMAP_ANIM,
+			ANDROSYNTH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUBBLE_BIG_MASK_PMAP_ANIM,
+			BUBBLE_MED_MASK_PMAP_ANIM,
+			BUBBLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BLAZER_BIG_MASK_PMAP_ANIM,
+			BLAZER_MED_MASK_PMAP_ANIM,
+			BLAZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ANDROSYNTH_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ANDROSYNTH_VICTORY_SONG,
+		ANDROSYNTH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_2XRES >> 2,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC androsynth_desc4x =
+{
+	{ /* SHIP_INFO */
+		"guardian",
+		FIRES_FORE | SEEKING_WEAPON,
+		15, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ANDROSYNTH_RACE_STRINGS,
+		ANDROSYNTH_ICON_MASK_PMAP_ANIM,
+		ANDROSYNTH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_4X,
+		THRUST_INCREMENT_4X,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ANDROSYNTH_BIG_MASK_PMAP_ANIM,
+			ANDROSYNTH_MED_MASK_PMAP_ANIM,
+			ANDROSYNTH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUBBLE_BIG_MASK_PMAP_ANIM,
+			BUBBLE_MED_MASK_PMAP_ANIM,
+			BUBBLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BLAZER_BIG_MASK_PMAP_ANIM,
+			BLAZER_MED_MASK_PMAP_ANIM,
+			BLAZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ANDROSYNTH_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ANDROSYNTH_VICTORY_SONG,
+		ANDROSYNTH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_4XRES >> 2,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
 
 // Private per-instance ship data
 typedef struct
@@ -301,10 +450,10 @@ androsynth_intelligence (ELEMENT *ShipPt
 			if (lpEvalDesc->which_turn <= 16
 					&& (StarShipPtr->special_counter > 0
 					|| StarShipPtr->RaceDescPtr->ship_info.energy_level < MAX_ENERGY / 3
-					|| ((WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) <= CLOSE_RANGE_WEAPON
+					|| ((WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) <= (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)
 					&& lpEvalDesc->ObjectPtr->crew_level > BLAZER_DAMAGE)
 					|| (lpEvalDesc->ObjectPtr->crew_level > (BLAZER_DAMAGE * 3)
-					&& MANEUVERABILITY (&pEnemyStarShip->RaceDescPtr->cyborg_control) > SLOW_SHIP))))
+					&& MANEUVERABILITY (&pEnemyStarShip->RaceDescPtr->cyborg_control) > RESOLUTION_COMPENSATED(SLOW_SHIP)))))
 				lpEvalDesc->MoveState = ENTICE;
 		}
 
@@ -320,11 +469,11 @@ androsynth_intelligence (ELEMENT *ShipPt
 					&& (WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) >=
 					WEAPON_RANGE (&StarShipPtr->RaceDescPtr->cyborg_control) << 1
 					|| (lpEvalDesc->which_turn < 16
-					&& (WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) > CLOSE_RANGE_WEAPON
+					&& (WEAPON_RANGE (&pEnemyStarShip->RaceDescPtr->cyborg_control) > (CLOSE_RANGE_WEAPON << RESOLUTION_FACTOR)
 					|| lpEvalDesc->ObjectPtr->crew_level <= BLAZER_DAMAGE)
 					&& (lpEvalDesc->ObjectPtr->crew_level <= (BLAZER_DAMAGE * 3)
 					|| MANEUVERABILITY (&pEnemyStarShip->RaceDescPtr->cyborg_control) <=
-					SLOW_SHIP)))))
+					RESOLUTION_COMPENSATED(SLOW_SHIP))))))
 				StarShipPtr->ship_input_state |= SPECIAL;
 		}
 
@@ -338,13 +487,13 @@ androsynth_intelligence (ELEMENT *ShipPt
 					&& lpEvalDesc->which_turn <= 12)
 			{
 				COUNT travel_facing, direction_facing;
-				SIZE delta_x, delta_y,
+				SDWORD delta_x, delta_y,
 							ship_delta_x, ship_delta_y,
 							other_delta_x, other_delta_y;
 
-				GetCurrentVelocityComponents (&ShipPtr->velocity,
+				GetCurrentVelocityComponentsSdword (&ShipPtr->velocity,
 						&ship_delta_x, &ship_delta_y);
-				GetCurrentVelocityComponents (&lpEvalDesc->ObjectPtr->velocity,
+				GetCurrentVelocityComponentsSdword (&lpEvalDesc->ObjectPtr->velocity,
 						&other_delta_x, &other_delta_y);
 				delta_x = ship_delta_x - other_delta_x;
 				delta_y = ship_delta_y - other_delta_y;
@@ -514,14 +663,15 @@ uninit_androsynth (RACE_DESC *pRaceDesc)
 RACE_DESC*
 init_androsynth (void)
 {
+	static RACE_DESC androsynth_desc;
 	RACE_DESC *RaceDescPtr;
+	
+	androsynth_desc = (RESOLUTION_FACTOR == 0 ? androsynth_desc1x : (RESOLUTION_FACTOR == 1 ? androsynth_desc2x : androsynth_desc4x));
 
-	androsynth_desc.uninit_func = uninit_androsynth;
 	androsynth_desc.preprocess_func = androsynth_preprocess;
 	androsynth_desc.postprocess_func = androsynth_postprocess;
 	androsynth_desc.init_weapon_func = initialize_bubble;
 	androsynth_desc.cyborg_control.intelligence_func = androsynth_intelligence;
-
 	RaceDescPtr = &androsynth_desc;
 
 	return (RaceDescPtr);
diff -ruNp src.orig/uqm/ships/arilou/arilou.c src/uqm/ships/arilou/arilou.c
--- src.orig/uqm/ships/arilou/arilou.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/arilou/arilou.c	2017-12-30 00:14:53 -0800
@@ -19,8 +19,10 @@
 #include "../ship.h"
 #include "arilou.h"
 #include "resinst.h"
-
+#include "libs/log.h"
 #include "libs/mathlib.h"
+#include "uqm/globdata.h"
+#include <math.h>
 
 // Core characteristics
 #define MAX_CREW 6
@@ -44,7 +46,19 @@
 #define SPECIAL_WAIT 2
 #define HYPER_LIFE 5
 
-static RACE_DESC arilou_desc =
+// HD Values
+// 2x
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (20) */ 80					// JMS_GFX
+#define THRUST_INCREMENT_2XRES MAX_THRUST_2XRES							// JMS_GFX
+#define ARILOU_OFFSET_2XRES 18											// JMS_GFX
+#define LASER_RANGE_2XRES DISPLAY_TO_WORLD (200 + ARILOU_OFFSET_2XRES)	// JMS_GFX
+// 4x
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (20) */ 160				// JMS_GFX
+#define THRUST_INCREMENT_4XRES MAX_THRUST_4XRES							// JMS_GFX
+#define ARILOU_OFFSET_4XRES 36											// JMS_GFX
+#define LASER_RANGE_4XRES DISPLAY_TO_WORLD (400 + ARILOU_OFFSET_4XRES)	// JMS_GFX
+
+static RACE_DESC arilou_desc1x =
 {
 	{ /* SHIP_INFO */
 		"skiff",
@@ -116,6 +130,152 @@ static RACE_DESC arilou_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC arilou_desc2x =
+{
+	{ /* SHIP_INFO */
+		"skiff",
+		/* FIRES_FORE | */ IMMEDIATE_WEAPON,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ARILOU_RACE_STRINGS,
+		ARILOU_ICON_MASK_PMAP_ANIM,
+		ARILOU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			438, 6372,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ARILOU_BIG_MASK_PMAP_ANIM,
+			ARILOU_MED_MASK_PMAP_ANIM,
+			ARILOU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			WARP_BIG_MASK_PMAP_ANIM,
+			WARP_MED_MASK_PMAP_ANIM,
+			WARP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ARILOU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ARILOU_VICTORY_SONG,
+		ARILOU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LASER_RANGE_2XRES >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC arilou_desc4x =
+{
+	{ /* SHIP_INFO */
+		"skiff",
+		/* FIRES_FORE | */ IMMEDIATE_WEAPON,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ARILOU_RACE_STRINGS,
+		ARILOU_ICON_MASK_PMAP_ANIM,
+		ARILOU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		250 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			438, 6372,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ARILOU_BIG_MASK_PMAP_ANIM,
+			ARILOU_MED_MASK_PMAP_ANIM,
+			ARILOU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			WARP_BIG_MASK_PMAP_ANIM,
+			WARP_MED_MASK_PMAP_ANIM,
+			WARP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ARILOU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ARILOU_VICTORY_SONG,
+		ARILOU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LASER_RANGE_4XRES >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_autoaim_laser (ELEMENT *ShipPtr, HELEMENT LaserArray[])
 {
@@ -123,6 +283,9 @@ initialize_autoaim_laser (ELEMENT *ShipP
 	SIZE delta_facing;
 	STARSHIP *StarShipPtr;
 	LASER_BLOCK LaserBlock;
+	COUNT LaserRange; // JMS_GFX
+
+	LaserRange = RESOLUTION_FACTOR == 0 ? LASER_RANGE : (RESOLUTION_FACTOR == 1 ? LASER_RANGE_2XRES : LASER_RANGE_4XRES );
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	LaserBlock.face = orig_facing = StarShipPtr->ShipFacing;
@@ -132,11 +295,11 @@ initialize_autoaim_laser (ELEMENT *ShipP
 
 	LaserBlock.cx = ShipPtr->next.location.x;
 	LaserBlock.cy = ShipPtr->next.location.y;
-	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
-	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
+	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), LaserRange);
+	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), LaserRange);
 	LaserBlock.sender = ShipPtr->playerNr;
 	LaserBlock.flags = IGNORE_SIMILAR;
-	LaserBlock.pixoffs = ARILOU_OFFSET;
+	LaserBlock.pixoffs = RES_SCALE(ARILOU_OFFSET);
 	LaserBlock.color = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x0A), 0x0E);
 	LaserArray[0] = initialize_laser (&LaserBlock);
 
@@ -274,13 +437,24 @@ arilou_preprocess (ELEMENT *ElementPtr)
 				else
 					ElementPtr->next.image.frame =
 							IncFrameIndex (ElementPtr->next.image.frame);
-			}
-			else
-			{
-				ElementPtr->next.location.x =
-						WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
-				ElementPtr->next.location.y =
-						WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
+			} else { // JMS: Reduce the odds of teleporting into Sa-Matra.
+				if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE) {
+					SDWORD dist = 0;
+					SDWORD dx, dy;
+                    do {
+                        ElementPtr->next.location.x = WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
+                        ElementPtr->next.location.y = WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
+                        
+                        dx = ((SDWORD)ElementPtr->next.location.x - (LOG_SPACE_WIDTH >> 1));
+                        dy = ((SDWORD)ElementPtr->next.location.y - (LOG_SPACE_HEIGHT >> 1));
+                        
+                        dist = sqrt(dx*dx + dy*dy);                        
+                    } 
+					while (dist < (RES_SCALE(2800)));
+                } else {
+                    ElementPtr->next.location.x = WRAP_X (DISPLAY_ALIGN_X (TFB_Random ()));
+					ElementPtr->next.location.y = WRAP_Y (DISPLAY_ALIGN_Y (TFB_Random ()));
+				}
 			}
 		}
 
@@ -291,12 +465,15 @@ arilou_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_arilou (void)
 {
+	
+	static RACE_DESC arilou_desc;
 	RACE_DESC *RaceDescPtr;
+	
+	arilou_desc = (RESOLUTION_FACTOR == 0 ? arilou_desc1x : (RESOLUTION_FACTOR == 1 ? arilou_desc2x : arilou_desc4x));
 
 	arilou_desc.preprocess_func = arilou_preprocess;
 	arilou_desc.init_weapon_func = initialize_autoaim_laser;
 	arilou_desc.cyborg_control.intelligence_func = arilou_intelligence;
-
 	RaceDescPtr = &arilou_desc;
 
 	return (RaceDescPtr);
diff -ruNp src.orig/uqm/ships/blackurq/blackurq.c src/uqm/ships/blackurq/blackurq.c
--- src.orig/uqm/ships/blackurq/blackurq.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/blackurq/blackurq.c	2017-12-30 00:14:53 -0800
@@ -36,16 +36,16 @@
 // Buzzsaw
 #define WEAPON_ENERGY_COST 6
 #define WEAPON_WAIT 6
-#define MISSILE_OFFSET 9
-#define KOHR_AH_OFFSET 28
-#define MISSILE_SPEED 64
+#define MISSILE_OFFSET RES_SCALE(9)
+#define KOHR_AH_OFFSET RES_SCALE(28)
+#define MISSILE_SPEED RES_SCALE(64)
 #define MISSILE_LIFE 64
 		/* actually, it's as long as you hold the button down.*/
 #define MISSILE_HITS 10
 #define MISSILE_DAMAGE 4
 #define SAW_RATE 0
 #define MAX_SAWS 8
-#define ACTIVATE_RANGE 224
+#define ACTIVATE_RANGE RES_SCALE(224)
 		/* Originally SPACE_WIDTH - the distance within which
 		 * stationary sawblades will home */
 #define TRACK_WAIT 4
@@ -56,8 +56,8 @@
 // F.R.I.E.D.
 #define SPECIAL_ENERGY_COST (MAX_ENERGY_SIZE / 2)
 #define SPECIAL_WAIT 9
-#define GAS_OFFSET 2
-#define GAS_SPEED 16
+#define GAS_OFFSET RES_SCALE(2)
+#define GAS_SPEED RES_SCALE(16)
 #define GAS_RATE 2 /* Controls animation of the gas cloud decay - the decay
                     * animation advances one frame every GAS_RATE frames. */
 #define GAS_HITS 100
@@ -65,7 +65,13 @@
 #define GAS_ALT_DAMAGE 50
 #define NUM_GAS_CLOUDS 16
 
-static RACE_DESC black_urquan_desc =
+// HD
+#define MAX_THRUST_2XRES 60			// JMS_GFX
+#define THRUST_INCREMENT_2XRES 12	// JMS_GFX
+#define MAX_THRUST_4XRES 120		// JMS_GFX
+#define THRUST_INCREMENT_4XRES 24	// JMS_GFX
+
+static RACE_DESC black_urquan_desc1x =
 {
 	{ /* SHIP_INFO */
 		"marauder",
@@ -137,6 +143,152 @@ static RACE_DESC black_urquan_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC black_urquan_desc2x =
+{
+	{ /* SHIP_INFO */
+		"marauder",
+		FIRES_FORE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		KOHR_AH_RACE_STRINGS,
+		KOHR_AH_ICON_MASK_PMAP_ANIM,
+		KOHR_AH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			6000, 6250,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			KOHR_AH_BIG_MASK_PMAP_ANIM,
+			KOHR_AH_MED_MASK_PMAP_ANIM,
+			KOHR_AH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUZZSAW_BIG_MASK_PMAP_ANIM,
+			BUZZSAW_MED_MASK_PMAP_ANIM,
+			BUZZSAW_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GAS_BIG_MASK_PMAP_ANIM,
+			GAS_MED_MASK_PMAP_ANIM,
+			GAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			KOHR_AH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		KOHR_AH_VICTORY_SONG,
+		KOHR_AH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC black_urquan_desc4x =
+{
+	{ /* SHIP_INFO */
+		"marauder",
+		FIRES_FORE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		KOHR_AH_RACE_STRINGS,
+		KOHR_AH_ICON_MASK_PMAP_ANIM,
+		KOHR_AH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			6000, 6250,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			KOHR_AH_BIG_MASK_PMAP_ANIM,
+			KOHR_AH_MED_MASK_PMAP_ANIM,
+			KOHR_AH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUZZSAW_BIG_MASK_PMAP_ANIM,
+			BUZZSAW_MED_MASK_PMAP_ANIM,
+			BUZZSAW_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GAS_BIG_MASK_PMAP_ANIM,
+			GAS_MED_MASK_PMAP_ANIM,
+			GAS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			KOHR_AH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		KOHR_AH_VICTORY_SONG,
+		KOHR_AH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 spin_preprocess (ELEMENT *ElementPtr)
 {
@@ -224,7 +376,7 @@ buzztrack_preprocess (ELEMENT *ElementPt
 			{
 				ElementPtr->thrust_wait = TRACK_WAIT;
 				SetVelocityVector (&ElementPtr->velocity,
-						DISPLAY_TO_WORLD (2), facing);
+						DISPLAY_TO_WORLD (RES_SCALE(2)), facing);
 			}
 		}
 	}
@@ -235,9 +387,9 @@ buzztrack_preprocess (ELEMENT *ElementPt
 static void
 decelerate_preprocess (ELEMENT *ElementPtr)
 {
-	SIZE dx, dy;
+	SDWORD dx, dy;
 
-	GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+	GetCurrentVelocityComponentsSdword (&ElementPtr->velocity, &dx, &dy);
 	dx /= 2;
 	dy /= 2;
 	SetVelocityComponents (&ElementPtr->velocity, dx, dy);
@@ -474,7 +626,7 @@ gas_cloud_collision (ELEMENT *ElementPtr
 static void
 spawn_gas_cloud (ELEMENT *ElementPtr)
 {
-	SIZE dx, dy;
+	SDWORD dx, dy;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -485,7 +637,7 @@ spawn_gas_cloud (ELEMENT *ElementPtr)
 	MissileBlock.index = 0;
 	MissileBlock.sender = ElementPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
-	MissileBlock.pixoffs = 20;
+	MissileBlock.pixoffs = RES_SCALE(20);
 	MissileBlock.speed = GAS_SPEED;
 	MissileBlock.hit_points = GAS_HITS;
 	MissileBlock.damage = GAS_DAMAGE;
@@ -494,7 +646,7 @@ spawn_gas_cloud (ELEMENT *ElementPtr)
 	MissileBlock.preprocess_func = gas_cloud_preprocess;
 	MissileBlock.blast_offs = GAS_OFFSET;
 
-	GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+	GetCurrentVelocityComponentsSdword (&ElementPtr->velocity, &dx, &dy);
 	for (MissileBlock.face = 0;
 			MissileBlock.face < ANGLE_TO_FACING (FULL_CIRCLE);
 			MissileBlock.face +=
@@ -555,13 +707,15 @@ black_urquan_preprocess (ELEMENT *Elemen
 RACE_DESC*
 init_black_urquan (void)
 {
+	static RACE_DESC black_urquan_desc;
 	RACE_DESC *RaceDescPtr;
 
+	black_urquan_desc = (RESOLUTION_FACTOR == 0 ? black_urquan_desc1x : (RESOLUTION_FACTOR == 1 ? black_urquan_desc2x : black_urquan_desc4x));
+
 	black_urquan_desc.preprocess_func = black_urquan_preprocess;
 	black_urquan_desc.postprocess_func = black_urquan_postprocess;
 	black_urquan_desc.init_weapon_func = initialize_buzzsaw;
 	black_urquan_desc.cyborg_control.intelligence_func = black_urquan_intelligence;
-
 	RaceDescPtr = &black_urquan_desc;
 
 	return (RaceDescPtr);
diff -ruNp src.orig/uqm/ships/chenjesu/chenjesu.c src/uqm/ships/chenjesu/chenjesu.c
--- src.orig/uqm/ships/chenjesu/chenjesu.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/chenjesu/chenjesu.c	2017-12-30 00:14:53 -0800
@@ -37,9 +37,9 @@
 // Photon Shard
 #define WEAPON_ENERGY_COST 5
 #define WEAPON_WAIT 0
-#define CHENJESU_OFFSET 16
+#define CHENJESU_OFFSET RES_SCALE(16)
 #define MISSILE_OFFSET 0
-#define MISSILE_SPEED DISPLAY_TO_WORLD (16)
+#define MISSILE_SPEED DISPLAY_TO_WORLD (RES_SCALE(16))
 #define MISSILE_LIFE 90
 		/* actually, it's as long as you hold the button down. */
 #define MISSILE_HITS 10
@@ -47,7 +47,7 @@
 #define NUM_SPARKLES 8
 
 // Shrapnel
-#define FRAGMENT_OFFSET 2
+#define FRAGMENT_OFFSET RES_SCALE(2)
 #define NUM_FRAGMENTS 8
 #define FRAGMENT_LIFE 10
 #define FRAGMENT_SPEED MISSILE_SPEED
@@ -59,14 +59,20 @@
 // DOGI
 #define SPECIAL_ENERGY_COST MAX_ENERGY
 #define SPECIAL_WAIT 0
-#define DOGGY_OFFSET 18
-#define DOGGY_SPEED DISPLAY_TO_WORLD (8)
+#define DOGGY_OFFSET RES_SCALE(18) + 5 * RESOLUTION_FACTOR
+#define DOGGY_SPEED DISPLAY_TO_WORLD (RES_SCALE(8))
 #define ENERGY_DRAIN 10
 #define MAX_DOGGIES 4
 #define DOGGY_HITS 3
 #define DOGGY_MASS 4
 
-static RACE_DESC chenjesu_desc =
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (14) */ 54 // JMS_GFX
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 6 // JMS_GFX
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (28) */ 108 // JMS_GFX
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 12 // JMS_GFX
+
+static RACE_DESC chenjesu_desc1x =
 {
 	{ /* SHIP_INFO */
 		"broodhome",
@@ -138,6 +144,152 @@ static RACE_DESC chenjesu_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC chenjesu_desc2x =
+{
+	{ /* SHIP_INFO */
+		"broodhome",
+		FIRES_FORE | SEEKING_SPECIAL | SEEKING_WEAPON,
+		28, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHENJESU_RACE_STRINGS,
+		CHENJESU_ICON_MASK_PMAP_ANIM,
+		CHENJESU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHENJESU_BIG_MASK_PMAP_ANIM,
+			CHENJESU_MED_MASK_PMAP_ANIM,
+			CHENJESU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPARK_BIG_MASK_PMAP_ANIM,
+			SPARK_MED_MASK_PMAP_ANIM,
+			SPARK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DOGGY_BIG_MASK_PMAP_ANIM,
+			DOGGY_MED_MASK_PMAP_ANIM,
+			DOGGY_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHENJESU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHENJESU_VICTORY_SONG,
+		CHENJESU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC chenjesu_desc4x =
+{
+	{ /* SHIP_INFO */
+		"broodhome",
+		FIRES_FORE | SEEKING_SPECIAL | SEEKING_WEAPON,
+		28, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHENJESU_RACE_STRINGS,
+		CHENJESU_ICON_MASK_PMAP_ANIM,
+		CHENJESU_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHENJESU_BIG_MASK_PMAP_ANIM,
+			CHENJESU_MED_MASK_PMAP_ANIM,
+			CHENJESU_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPARK_BIG_MASK_PMAP_ANIM,
+			SPARK_MED_MASK_PMAP_ANIM,
+			SPARK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DOGGY_BIG_MASK_PMAP_ANIM,
+			DOGGY_MED_MASK_PMAP_ANIM,
+			DOGGY_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHENJESU_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHENJESU_VICTORY_SONG,
+		CHENJESU_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 crystal_postprocess (ELEMENT *ElementPtr)
 {
@@ -295,6 +447,26 @@ doggy_preprocess (ELEMENT *ElementPtr)
 			SetVelocityVector (&ElementPtr->velocity,
 					DOGGY_SPEED, facing);
 	}
+
+	// JMS_GFX: Doggy is animated in hi-res modes
+	if (RESOLUTION_FACTOR != 0)
+	{
+		if (ElementPtr->turn_wait > 0)
+			--ElementPtr->turn_wait;
+		else
+		{
+			if (GetFrameIndex (ElementPtr->current.image.frame) == 11)
+				ElementPtr->next.image.frame =
+					SetAbsFrameIndex (ElementPtr->current.image.frame, 0);
+			else
+				ElementPtr->next.image.frame =
+					IncFrameIndex (ElementPtr->current.image.frame);
+					
+			ElementPtr->state_flags |= CHANGING;
+
+			ElementPtr->turn_wait = 1;
+		}
+ 	}
 }
 
 static void
@@ -309,10 +481,13 @@ doggy_death (ELEMENT *ElementPtr)
 
 	ElementPtr->state_flags &= ~DISAPPEARING;
 	ElementPtr->state_flags |= NONSOLID | FINITE_LIFE;
-	ElementPtr->life_span = 6;
-	{
-		ElementPtr->preprocess_func = animate;
+	// JMS_GFX: Doggy's dying animation starts at different frame in hi-res modes.
+	if (RESOLUTION_FACTOR != 0){
+		ElementPtr->current.image.frame = SetRelFrameIndex (
+			ElementPtr->current.image.frame, 12);
 	}
+	ElementPtr->life_span = 6;
+	ElementPtr->preprocess_func = animate;
 	ElementPtr->death_func = NULL;
 	ElementPtr->collision_func = NULL;
 	ZeroVelocityComponents (&ElementPtr->velocity);
@@ -403,6 +578,8 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
 
+	static DWORD old_dist[NUM_SIDES] = {(DWORD)~0, (DWORD)~0};
+
 	GetElementStarShip (ShipPtr, &StarShipPtr);
 	StarShipPtr->ship_input_state &= ~SPECIAL;
 
@@ -415,13 +592,13 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 		if ((lpEvalDesc->which_turn <= 16
 				&& MANEUVERABILITY (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) >= MEDIUM_SHIP)
+				) >= RESOLUTION_COMPENSATED(MEDIUM_SHIP)) // JMS_GFX
 				|| (MANEUVERABILITY (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) <= SLOW_SHIP
+				) <= RESOLUTION_COMPENSATED(SLOW_SHIP) // JMS_GFX
 				&& WEAPON_RANGE (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) >= LONG_RANGE_WEAPON * 3 / 4
+				) >= RES_SCALE(LONG_RANGE_WEAPON) * 3 / 4 // JMS_GFX
 				&& (EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags & SEEKING_WEAPON)))
 			lpEvalDesc->MoveState = PURSUE;
 	}
@@ -456,16 +633,50 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 				if (ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr)
 				{
 					COUNT which_turn;
+					BOOLEAN crystal_would_miss = false;
 
-					if ((which_turn = PlotIntercept (CrystalPtr,
+					if (RESOLUTION_FACTOR == 0 || lpEvalDesc != &ObjectsOfConcern[ENEMY_SHIP_INDEX])
+					{
+						crystal_would_miss = ((which_turn = PlotIntercept (CrystalPtr,
 							ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
-							CrystalPtr->life_span,
-							FRAGMENT_RANGE / 2)) == 0
-							|| (which_turn == 1
-							&& PlotIntercept (CrystalPtr,
+							CrystalPtr->life_span, FRAGMENT_RANGE / 2)) == 0
+						 || (which_turn == 1
+							 && PlotIntercept (CrystalPtr,
+								ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
+								CrystalPtr->life_span, 0) == 0));
+					} else {
+						DWORD curr_dist = 0;
+						SDWORD dx, dy;
+						
+						dx = CrystalPtr->next.location.x - 
+								ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr->next.location.x;
+						dy = CrystalPtr->next.location.y - 
+								ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr->next.location.y;		
+					
+						curr_dist = square_root ((long)dx * dx + (long)dy * dy);
+					
+						/*which_turn = PlotIntercept (CrystalPtr,
 							ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
-							CrystalPtr->life_span, 0) == 0))
+							CrystalPtr->life_span, FRAGMENT_RANGE / 3);*/
+						crystal_would_miss = ((PlotIntercept (CrystalPtr,
+							ObjectsOfConcern[ENEMY_SHIP_INDEX].ObjectPtr,
+							CrystalPtr->life_span, FRAGMENT_RANGE * 8) == 0)
+							|| curr_dist > old_dist[ShipPtr->playerNr]);
+						old_dist[ShipPtr->playerNr] = curr_dist;
+					}
+					if (crystal_would_miss)
+					{
 						StarShipPtr->ship_input_state &= ~WEAPON;
+						old_dist[ShipPtr->playerNr] = (DWORD)~0;
+						
+						// JMS: Let's try to stop Chenjesu's stupid over-rapid firing behavior in hires modes...
+						if (RESOLUTION_FACTOR > 0 
+							&& ObjectsOfConcern[ENEMY_SHIP_INDEX].which_turn > 16
+							&& ((ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr
+								 && ObjectsOfConcern[ENEMY_WEAPON_INDEX].which_turn > 8)
+								|| !(ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr)))
+							StarShipPtr->weapon_counter = 10;
+					}
 					else if (StarShipPtr->weapon_counter == 0)
 					{
 						StarShipPtr->ship_input_state |= WEAPON;
@@ -485,12 +696,53 @@ chenjesu_intelligence (ELEMENT *ShipPtr,
 			if (StarShipPtr->old_status_flags & WEAPON)
 			{
 				StarShipPtr->ship_input_state &= ~WEAPON;
+				old_dist[ShipPtr->playerNr] = (DWORD)~0;
 				if (lpEvalDesc == &ObjectsOfConcern[ENEMY_WEAPON_INDEX])
 					StarShipPtr->weapon_counter = 3;
 			}
 			else if (StarShipPtr->weapon_counter == 0
 					&& ship_weapons (ShipPtr, lpEvalDesc->ObjectPtr, FRAGMENT_RANGE / 2))
-				StarShipPtr->ship_input_state |= WEAPON;
+			{
+				if (RESOLUTION_FACTOR > 0)
+				{
+					COUNT num_weapons;
+					ELEMENT Ship;
+					HELEMENT Weapon[6];
+					HELEMENT *WeaponPtr,w;
+					ELEMENT *EPtr;
+					STARSHIP *StarShipPtr2;
+					
+					Ship = *ShipPtr;
+					GetElementStarShip (&Ship, &StarShipPtr2);
+					num_weapons = (*StarShipPtr->RaceDescPtr->init_weapon_func) (ShipPtr, Weapon);
+					WeaponPtr = &Weapon[0];
+					
+					w = *WeaponPtr;
+					if (w)
+					{
+						LockElement (w, &EPtr);
+						if (EPtr->state_flags & APPEARING)
+						{
+							EPtr->next = EPtr->current;
+							InitIntersectStartPoint (EPtr);
+							InitIntersectEndPoint (EPtr);
+							InitIntersectFrame (EPtr);
+						}
+							
+						if (PlotIntercept (EPtr, lpEvalDesc->ObjectPtr, EPtr->life_span, FRAGMENT_RANGE / 2) < 80)
+						{
+							StarShipPtr->ship_input_state |= WEAPON;
+						}
+							
+						UnlockElement (w);
+						FreeElement (w);
+					}
+				}
+				else
+				{
+					StarShipPtr->ship_input_state |= WEAPON;
+				}
+			}
 		}
 	}
 
@@ -574,14 +826,16 @@ chenjesu_preprocess (ELEMENT *ElementPtr
 
 RACE_DESC*
 init_chenjesu (void)
-{
+{	
+	static RACE_DESC chenjesu_desc;
 	RACE_DESC *RaceDescPtr;
+	
+	chenjesu_desc = (RESOLUTION_FACTOR == 0 ? chenjesu_desc1x : (RESOLUTION_FACTOR == 1 ? chenjesu_desc2x : chenjesu_desc4x));
 
 	chenjesu_desc.preprocess_func = chenjesu_preprocess;
 	chenjesu_desc.postprocess_func = chenjesu_postprocess;
 	chenjesu_desc.init_weapon_func = initialize_crystal;
 	chenjesu_desc.cyborg_control.intelligence_func = chenjesu_intelligence;
-
 	RaceDescPtr = &chenjesu_desc;
 
 	return (RaceDescPtr);
diff -ruNp src.orig/uqm/ships/chmmr/chmmr.c src/uqm/ships/chmmr/chmmr.c
--- src.orig/uqm/ships/chmmr/chmmr.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/chmmr/chmmr.c	2017-12-30 00:14:53 -0800
@@ -19,7 +19,7 @@
 #include "../ship.h"
 #include "chmmr.h"
 #include "resinst.h"
-
+#include "../../setup.h"
 #include "uqm/colors.h"
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
@@ -49,13 +49,19 @@
 
 // Satellites
 #define NUM_SATELLITES 3
-#define SATELLITE_OFFSET DISPLAY_TO_WORLD (64)
+#define SATELLITE_OFFSET DISPLAY_TO_WORLD (64 << RESOLUTION_FACTOR)
 #define SATELLITE_HITPOINTS 10
 #define SATELLITE_MASS 10
-#define DEFENSE_RANGE (UWORD)64
+#define DEFENSE_RANGE (UWORD)(64 << RESOLUTION_FACTOR)
 #define DEFENSE_WAIT 2
 
-static RACE_DESC chmmr_desc =
+// HD
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 14
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 28
+
+static RACE_DESC chmmr_desc1x =
 {
 	{ /* SHIP_INFO */
 		"avatar",
@@ -127,6 +133,152 @@ static RACE_DESC chmmr_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC chmmr_desc2x =
+{
+	{ /* SHIP_INFO */
+		"avatar",
+		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | HEAVY_POINT_DEFENSE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHMMR_RACE_STRINGS,
+		CHMMR_ICON_MASK_PMAP_ANIM,
+		CHMMR_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL//, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHMMR_BIG_MASK_PMAP_ANIM,
+			CHMMR_MED_MASK_PMAP_ANIM,
+			CHMMR_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MUZZLE_BIG_MASK_PMAP_ANIM,
+			MUZZLE_MED_MASK_PMAP_ANIM,
+			MUZZLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATELLITE_BIG_MASK_PMAP_ANIM,
+			SATELLITE_MED_MASK_PMAP_ANIM,
+			SATELLITE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHMMR_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHMMR_VICTORY_SONG,
+		CHMMR_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC chmmr_desc4x =
+{
+	{ /* SHIP_INFO */
+		"avatar",
+		FIRES_FORE | IMMEDIATE_WEAPON | SEEKING_SPECIAL | HEAVY_POINT_DEFENSE,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		CHMMR_RACE_STRINGS,
+		CHMMR_ICON_MASK_PMAP_ANIM,
+		CHMMR_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL//, SHIP_IS_NOT_DAMAGED
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			CHMMR_BIG_MASK_PMAP_ANIM,
+			CHMMR_MED_MASK_PMAP_ANIM,
+			CHMMR_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MUZZLE_BIG_MASK_PMAP_ANIM,
+			MUZZLE_MED_MASK_PMAP_ANIM,
+			MUZZLE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATELLITE_BIG_MASK_PMAP_ANIM,
+			SATELLITE_MED_MASK_PMAP_ANIM,
+			SATELLITE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CHMMR_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		CHMMR_VICTORY_SONG,
+		CHMMR_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 animate (ELEMENT *ElementPtr)
 {
@@ -152,7 +304,7 @@ laser_death (ELEMENT *ElementPtr)
 
 	if (StarShipPtr->hShip)
 	{
-		SIZE dx, dy;
+		SDWORD dx, dy;
 		long dist;
 		HELEMENT hIonSpots;
 		ELEMENT *ShipPtr;
@@ -165,8 +317,8 @@ laser_death (ELEMENT *ElementPtr)
 				- ShipPtr->current.location.y;
 		if (((BYTE)TFB_Random () & 0x07)
 				&& (dist = (long)dx * dx + (long)dy * dy) >=
-				(long)DISPLAY_TO_WORLD (CHMMR_OFFSET + 10)
-				* DISPLAY_TO_WORLD (CHMMR_OFFSET + 10)
+				(long)DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR) // JMS_GFX
+				* DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR) // JMS_GFX
 				&& (hIonSpots = AllocElement ()))
 		{
 			COUNT angle, magnitude;
@@ -177,13 +329,13 @@ laser_death (ELEMENT *ElementPtr)
 			IonSpotsPtr->state_flags = FINITE_LIFE | NONSOLID
 					| IGNORE_SIMILAR | APPEARING;
 			IonSpotsPtr->turn_wait = IonSpotsPtr->next_turn = 0;
-			IonSpotsPtr->life_span = 9;
+			IonSpotsPtr->life_span = RES_CASE(9,9,14);
 
 			angle = ARCTAN (dx, dy);
 			magnitude = ((COUNT)TFB_Random ()
 					% ((square_root (dist) + 1)
-					- DISPLAY_TO_WORLD (CHMMR_OFFSET + 10)))
-					+ DISPLAY_TO_WORLD (CHMMR_OFFSET + 10);
+					- DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR))) // JMS_GFX
+					+ DISPLAY_TO_WORLD ((CHMMR_OFFSET + 10) << RESOLUTION_FACTOR); // JMS_GFX
 			IonSpotsPtr->current.location.x =
 					ShipPtr->current.location.x
 					+ COSINE (angle, magnitude);
@@ -236,8 +388,8 @@ initialize_megawatt_laser (ELEMENT *Ship
 			+ DISPLAY_TO_WORLD (r.corner.x);
 	LaserBlock.cy = DISPLAY_ALIGN (ShipPtr->next.location.y)
 			+ DISPLAY_TO_WORLD (r.corner.y);
-	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
-	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), LASER_RANGE);
+	LaserBlock.ex = COSINE (FACING_TO_ANGLE (LaserBlock.face), (LASER_RANGE << RESOLUTION_FACTOR)); // JMS_GFX
+	LaserBlock.ey = SINE (FACING_TO_ANGLE (LaserBlock.face), (LASER_RANGE << RESOLUTION_FACTOR)); // JMS_GFX
 	LaserBlock.sender = ShipPtr->playerNr;
 	LaserBlock.flags = IGNORE_SIMILAR;
 	LaserBlock.pixoffs = 0;
@@ -289,7 +441,6 @@ static void
 chmmr_postprocess (ELEMENT *ElementPtr)
 {
 	STARSHIP *StarShipPtr;
-
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 
 	if (StarShipPtr->cur_status_flags & WEAPON)
@@ -366,6 +517,22 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 					DISPLAY_TO_WORLD (8 + 9 + 11 + 14),
 					DISPLAY_TO_WORLD (8 + 9 + 11 + 14 + 18),
 				};
+				static const SIZE shadow_offs_2xres[] =
+				{
+					DISPLAY_TO_WORLD (16),
+					DISPLAY_TO_WORLD (16 + 18),
+					DISPLAY_TO_WORLD (16 + 18 + 22),
+					DISPLAY_TO_WORLD (16 + 18 + 22 + 28),
+					DISPLAY_TO_WORLD (16 + 18 + 22 + 28 + 36),
+				};
+				static const SIZE shadow_offs_4xres[] =
+				{
+					DISPLAY_TO_WORLD (32),
+					DISPLAY_TO_WORLD (32 + 36),
+					DISPLAY_TO_WORLD (32 + 36 + 44),
+					DISPLAY_TO_WORLD (32 + 36 + 44 + 56),
+					DISPLAY_TO_WORLD (32 + 36 + 44 + 56 + 72),
+				};
 				static const Color color_tab[] =
 				{
 					BUILD_COLOR (MAKE_RGB15_INIT (0x00, 0x00, 0x10), 0x53),
@@ -379,16 +546,15 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 				// calculate tractor beam effect
 				angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 				dx = (ElementPtr->next.location.x
-						+ COSINE (angle, (LASER_RANGE / 3)
-						+ DISPLAY_TO_WORLD (CHMMR_OFFSET)))
+						+ COSINE (angle, ((LASER_RANGE << RESOLUTION_FACTOR) / 3) // JMS_GFX
+						+ DISPLAY_TO_WORLD (CHMMR_OFFSET << RESOLUTION_FACTOR))) // JMS_GFX
 						- ShipElementPtr->next.location.x;
 				dy = (ElementPtr->next.location.y
-						+ SINE (angle, (LASER_RANGE / 3)
-						+ DISPLAY_TO_WORLD (CHMMR_OFFSET)))
+						+ SINE (angle, ((LASER_RANGE << RESOLUTION_FACTOR) / 3) // JMS_GFX
+						+ DISPLAY_TO_WORLD (CHMMR_OFFSET << RESOLUTION_FACTOR))) // JMS_GFX
 						- ShipElementPtr->next.location.y;
 				angle = ARCTAN (dx, dy);
-				magnitude = WORLD_TO_VELOCITY (12) /
-						ShipElementPtr->mass_points;
+				magnitude = WORLD_TO_VELOCITY (12 << RESOLUTION_FACTOR) / ShipElementPtr->mass_points; // JMS_GFX
 				DeltaVelocityComponents (&ShipElementPtr->velocity,
 						COSINE (angle, magnitude), SINE (angle, magnitude));
 
@@ -418,6 +584,15 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 					if (hShadow)
 					{
 						ELEMENT *ShadowElementPtr;
+						COUNT shadow_magnitude; // JMS_GFX
+
+						// JMS_GFX
+						if (RESOLUTION_FACTOR == 0)
+							shadow_magnitude = shadow_offs[i];
+						else if (RESOLUTION_FACTOR == 1)
+							shadow_magnitude = shadow_offs_2xres[i];
+						else
+							shadow_magnitude = shadow_offs_4xres[i];
 
 						LockElement (hShadow, &ShadowElementPtr);
 						ShadowElementPtr->playerNr = ShipElementPtr->playerNr;
@@ -427,9 +602,9 @@ chmmr_postprocess (ELEMENT *ElementPtr)
 
 						ShadowElementPtr->current = ShipElementPtr->next;
 						ShadowElementPtr->current.location.x +=
-								COSINE (angle, shadow_offs[i]);
+								COSINE (angle, shadow_magnitude);
 						ShadowElementPtr->current.location.y +=
-								SINE (angle, shadow_offs[i]);
+								SINE (angle, shadow_magnitude);
 						ShadowElementPtr->next = ShadowElementPtr->current;
 
 						SetElementStarShip (ShadowElementPtr, EnemyStarShipPtr);
@@ -474,7 +649,7 @@ satellite_preprocess (ELEMENT *ElementPt
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->hShip)
 	{
-		SIZE dx, dy;
+		SDWORD dx, dy;
 		ELEMENT *ShipPtr;
 
 		StarShipPtr->RaceDescPtr->ship_info.ship_flags |= POINT_DEFENSE;
@@ -490,7 +665,7 @@ satellite_preprocess (ELEMENT *ElementPt
 		dx = WRAP_DELTA_X (dx);
 		dy = WRAP_DELTA_Y (dy);
 		if ((long)dx * dx + (long)dy * dy
-				<= DISPLAY_TO_WORLD (20L) * DISPLAY_TO_WORLD (20L))
+				<= DISPLAY_TO_WORLD (20L << RESOLUTION_FACTOR) * DISPLAY_TO_WORLD (20L << RESOLUTION_FACTOR))
 			SetVelocityComponents (&ElementPtr->velocity,
 					WORLD_TO_VELOCITY (dx),
 					WORLD_TO_VELOCITY (dy));
@@ -500,8 +675,8 @@ satellite_preprocess (ELEMENT *ElementPt
 
 			angle = ARCTAN (dx, dy);
 			SetVelocityComponents (&ElementPtr->velocity,
-					COSINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20))),
-					SINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20))));
+					COSINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR))),
+					SINE (angle, WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (20 << RESOLUTION_FACTOR))));
 		}
 
 		UnlockElement (StarShipPtr->hShip);
@@ -521,7 +696,7 @@ spawn_point_defense (ELEMENT *ElementPtr
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	hBestObject = 0;
-	best_dist = DEFENSE_RANGE + 1;
+	best_dist = DEFENSE_RANGE + (1 << RESOLUTION_FACTOR);
 	weakest = 255;
 	LockElement (StarShipPtr->hShip, &ShipPtr);
 	LockElement (ElementPtr->hTarget, &SattPtr);
@@ -535,7 +710,7 @@ spawn_point_defense (ELEMENT *ElementPtr
 				&& CollisionPossible (ObjectPtr, ShipPtr)
 				&& !OBJECT_CLOAKED (ObjectPtr))
 		{
-			SIZE delta_x, delta_y;
+			SDWORD delta_x, delta_y;
 			UWORD dist;
 
 			delta_x = ObjectPtr->next.location.x
@@ -683,12 +858,20 @@ spawn_satellites (ELEMENT *ElementPtr)
 {
 	COUNT i;
 	STARSHIP *StarShipPtr;
+	BYTE NumSatellites = NUM_SATELLITES;
+
+	if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+		(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
+		((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
+	{
+		NumSatellites = NUM_SATELLITES + 2;
+	}
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	if (StarShipPtr->hShip)
 	{
 		LockElement (StarShipPtr->hShip, &ElementPtr);
-		for (i = 0; i < NUM_SATELLITES; ++i)
+		for (i = 0; i < NumSatellites; ++i)
 		{
 			HELEMENT hSatellite;
 
@@ -706,8 +889,8 @@ spawn_satellites (ELEMENT *ElementPtr)
 				SattPtr->hit_points = SATELLITE_HITPOINTS;
 				SattPtr->mass_points = SATELLITE_MASS;
 
-				angle = (i * FULL_CIRCLE + (NUM_SATELLITES >> 1))
-						/ NUM_SATELLITES;
+				angle = (i * FULL_CIRCLE + (NumSatellites >> 1))
+						/ NumSatellites;
 				SattPtr->turn_wait = (BYTE)angle;
 				SattPtr->current.location.x = ElementPtr->next.location.x
 						+ COSINE (angle, SATELLITE_OFFSET);
@@ -777,7 +960,10 @@ chmmr_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_chmmr (void)
 {
+	static RACE_DESC chmmr_desc;
 	RACE_DESC *RaceDescPtr;
+	
+	chmmr_desc = (RESOLUTION_FACTOR == 0 ? chmmr_desc1x : (RESOLUTION_FACTOR == 1 ? chmmr_desc2x : chmmr_desc4x));
 
 	chmmr_desc.preprocess_func = chmmr_preprocess;
 	chmmr_desc.postprocess_func = chmmr_postprocess;
diff -ruNp src.orig/uqm/ships/druuge/druuge.c src/uqm/ships/druuge/druuge.c
--- src.orig/uqm/ships/druuge/druuge.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/druuge/druuge.c	2017-12-30 00:14:53 -0800
@@ -34,21 +34,32 @@
 // Mass Driver
 #define WEAPON_ENERGY_COST 4
 #define WEAPON_WAIT 10
-#define DRUUGE_OFFSET 24
-#define MISSILE_OFFSET 6
+#define DRUUGE_OFFSET RES_SCALE(24)
+#define MISSILE_OFFSET RES_SCALE(6)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 20
 #define MISSILE_RANGE (MISSILE_SPEED * MISSILE_LIFE)
 #define MISSILE_HITS 4
 #define MISSILE_DAMAGE 6
-#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (6))
+#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD RES_SCALE(6))
 #define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
 
 // Furnace
 #define SPECIAL_ENERGY_COST 16
 #define SPECIAL_WAIT 30
 
-static RACE_DESC druuge_desc =
+// HD
+#define MAX_THRUST_2XRES 40
+#define THRUST_INCREMENT_2XRES 4
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+#define MAX_THRUST_4XRES 80
+#define THRUST_INCREMENT_4XRES 8
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_4XRES * MISSILE_LIFE)
+
+static RACE_DESC druuge_desc1x =
 {
 	{ /* SHIP_INFO */
 		"mauler",
@@ -120,6 +131,152 @@ static RACE_DESC druuge_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC druuge_desc2x =
+{
+	{ /* SHIP_INFO */
+		"mauler",
+		FIRES_FORE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		DRUUGE_RACE_STRINGS,
+		DRUUGE_ICON_MASK_PMAP_ANIM,
+		DRUUGE_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9500, 2792,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			DRUUGE_BIG_MASK_PMAP_ANIM,
+			DRUUGE_MED_MASK_PMAP_ANIM,
+			DRUUGE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DRUUGE_CANNON_BIG_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_MED_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			DRUUGE_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		DRUUGE_VICTORY_SONG,
+		DRUUGE_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC druuge_desc4x =
+{
+	{ /* SHIP_INFO */
+		"mauler",
+		FIRES_FORE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		DRUUGE_RACE_STRINGS,
+		DRUUGE_ICON_MASK_PMAP_ANIM,
+		DRUUGE_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1400 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			9500, 2792,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			DRUUGE_BIG_MASK_PMAP_ANIM,
+			DRUUGE_MED_MASK_PMAP_ANIM,
+			DRUUGE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DRUUGE_CANNON_BIG_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_MED_MASK_PMAP_ANIM,
+			DRUUGE_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			DRUUGE_CAPT_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		DRUUGE_VICTORY_SONG,
+		DRUUGE_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 cannon_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -208,7 +365,7 @@ druuge_intelligence (ELEMENT *ShipPtr, E
 	if (StarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED)
 		lpEvalDesc->MoveState = ENTICE;
 	else if (lpEvalDesc->ObjectPtr
-			&& lpEvalDesc->which_turn <= WORLD_TO_TURN (MISSILE_RANGE * 3 / 4))
+			&& lpEvalDesc->which_turn <= WORLD_TO_TURN (RES_SCALE(MISSILE_RANGE) * 3 / 4))
 	{
 		GetElementStarShip (lpEvalDesc->ObjectPtr, &EnemyStarShipPtr);
 		ship_flags = EnemyStarShipPtr->RaceDescPtr->ship_info.ship_flags;
@@ -258,7 +415,7 @@ druuge_postprocess (ELEMENT *ElementPtr)
 			StarShipPtr->RaceDescPtr->characteristics.weapon_wait)
 	{
 		COUNT angle;
-		SIZE cur_delta_x, cur_delta_y;
+		SDWORD cur_delta_x, cur_delta_y;
 
 		StarShipPtr->cur_status_flags &= ~SHIP_AT_MAX_SPEED;
 
@@ -266,7 +423,7 @@ druuge_postprocess (ELEMENT *ElementPtr)
 		DeltaVelocityComponents (&ElementPtr->velocity,
 				COSINE (angle, RECOIL_VELOCITY),
 				SINE (angle, RECOIL_VELOCITY));
-		GetCurrentVelocityComponents (&ElementPtr->velocity,
+		GetCurrentVelocityComponentsSdword (&ElementPtr->velocity,
 				&cur_delta_x, &cur_delta_y);
 		if ((long)cur_delta_x * (long)cur_delta_x
 				+ (long)cur_delta_y * (long)cur_delta_y
@@ -311,8 +468,11 @@ druuge_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_druuge (void)
 {
+	static RACE_DESC druuge_desc;
 	RACE_DESC *RaceDescPtr;
 
+	druuge_desc = (RESOLUTION_FACTOR == 0 ? druuge_desc1x : (RESOLUTION_FACTOR == 1 ? druuge_desc2x : druuge_desc4x));
+
 	druuge_desc.preprocess_func = druuge_preprocess;
 	druuge_desc.postprocess_func = druuge_postprocess;
 	druuge_desc.init_weapon_func = initialize_cannon;
diff -ruNp src.orig/uqm/ships/human/human.c src/uqm/ships/human/human.c
--- src.orig/uqm/ships/human/human.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/human/human.c	2017-12-30 00:14:53 -0800
@@ -37,13 +37,12 @@
 // Nuke
 #define WEAPON_ENERGY_COST 9
 #define WEAPON_WAIT 10
-#define HUMAN_OFFSET 42
-#define NUKE_OFFSET 8
-#define MIN_MISSILE_SPEED DISPLAY_TO_WORLD (10)
-#define MAX_MISSILE_SPEED DISPLAY_TO_WORLD (20)
-#define MISSILE_SPEED (MAX_THRUST >= MIN_MISSILE_SPEED ? \
-		MAX_THRUST : MIN_MISSILE_SPEED)
-#define THRUST_SCALE DISPLAY_TO_WORLD (1)
+#define HUMAN_OFFSET RES_SCALE(42)
+#define NUKE_OFFSET RES_SCALE(8)
+#define MIN_MISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(10)
+#define MAX_MISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(20)
+#define MISSILE_SPEED ((MAX_THRUST << RESOLUTION_FACTOR) >= MIN_MISSILE_SPEED ? (MAX_THRUST << RESOLUTION_FACTOR) : MIN_MISSILE_SPEED)
+#define THRUST_SCALE DISPLAY_TO_WORLD RES_SCALE(1)
 #define MISSILE_LIFE 60
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 4
@@ -52,9 +51,15 @@
 // Point-Defense Laser
 #define SPECIAL_ENERGY_COST 4
 #define SPECIAL_WAIT 9
-#define LASER_RANGE (UWORD)100
+#define LASER_RANGE (UWORD)RES_SCALE(100)
 
-static RACE_DESC human_desc =
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (12) */ 48
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 6
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (24) */ 96
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 12
+
+static RACE_DESC human_desc1x =
 {
 	{ /* SHIP_INFO */
 		"cruiser",
@@ -126,6 +131,152 @@ static RACE_DESC human_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC human_desc2x =
+{
+	{ /* SHIP_INFO */
+		"cruiser",
+		FIRES_FORE | SEEKING_WEAPON | LIGHT_POINT_DEFENSE,
+		11, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		HUMAN_RACE_STRINGS,
+		HUMAN_ICON_MASK_PMAP_ANIM,
+		HUMAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			1752, 1450,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			HUMAN_BIG_MASK_PMAP_ANIM,
+			HUMAN_MED_MASK_PMAP_ANIM,
+			HUMAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATURN_BIG_MASK_PMAP_ANIM,
+			SATURN_MED_MASK_PMAP_ANIM,
+			SATURN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			HUMAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		HUMAN_VICTORY_SONG,
+		HUMAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC human_desc4x =
+{
+	{ /* SHIP_INFO */
+		"cruiser",
+		FIRES_FORE | SEEKING_WEAPON | LIGHT_POINT_DEFENSE,
+		11, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		HUMAN_RACE_STRINGS,
+		HUMAN_ICON_MASK_PMAP_ANIM,
+		HUMAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			1752, 1450,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			HUMAN_BIG_MASK_PMAP_ANIM,
+			HUMAN_MED_MASK_PMAP_ANIM,
+			HUMAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SATURN_BIG_MASK_PMAP_ANIM,
+			SATURN_MED_MASK_PMAP_ANIM,
+			SATURN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			HUMAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		HUMAN_VICTORY_SONG,
+		HUMAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		LONG_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 nuke_preprocess (ELEMENT *ElementPtr)
 {
@@ -148,7 +299,7 @@ nuke_preprocess (ELEMENT *ElementPtr)
 	}
 
 	{
-		SIZE speed;
+		SDWORD speed;
 
 		if ((speed = MISSILE_SPEED +
 				((MISSILE_LIFE - ElementPtr->life_span) *
@@ -283,7 +434,7 @@ initialize_nuke (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = 0;
 	MissileBlock.pixoffs = HUMAN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -348,8 +499,11 @@ human_postprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_human (void)
 {
+	static RACE_DESC human_desc;
 	RACE_DESC *RaceDescPtr;
 
+	human_desc = (RESOLUTION_FACTOR == 0 ? human_desc1x : (RESOLUTION_FACTOR == 1 ? human_desc2x : human_desc4x));
+
 	human_desc.postprocess_func = human_postprocess;
 	human_desc.init_weapon_func = initialize_nuke;
 	human_desc.cyborg_control.intelligence_func = human_intelligence;
diff -ruNp src.orig/uqm/ships/ilwrath/ilwrath.c src/uqm/ships/ilwrath/ilwrath.c
--- src.orig/uqm/ships/ilwrath/ilwrath.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/ilwrath/ilwrath.c	2017-12-30 00:14:53 -0800
@@ -42,8 +42,8 @@
 #define WEAPON_ENERGY_COST 1
 #define WEAPON_WAIT 0
 #define MISSILE_LIFE 8
-#define ILWRATH_OFFSET 29
-#define MISSILE_SPEED MAX_THRUST
+#define ILWRATH_OFFSET RES_SCALE(29)
+#define MISSILE_SPEED RES_SCALE(MAX_THRUST)
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
 #define MISSILE_OFFSET 0
@@ -52,7 +52,13 @@
 #define SPECIAL_ENERGY_COST 3
 #define SPECIAL_WAIT 13
 
-static RACE_DESC ilwrath_desc =
+// HD
+#define MAX_THRUST_2XRES 50
+#define THRUST_INCREMENT_2XRES 10
+#define MAX_THRUST_4XRES 100
+#define THRUST_INCREMENT_4XRES 20
+
+static RACE_DESC ilwrath_desc1x =
 {
 	{ /* SHIP_INFO */
 		"avenger",
@@ -124,6 +130,152 @@ static RACE_DESC ilwrath_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC ilwrath_desc2x =
+{
+	{ /* SHIP_INFO */
+		"avenger",
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ILWRATH_RACE_STRINGS,
+		ILWRATH_ICON_MASK_PMAP_ANIM,
+		ILWRATH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1410 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			48, 1700,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ILWRATH_BIG_MASK_PMAP_ANIM,
+			ILWRATH_MED_MASK_PMAP_ANIM,
+			ILWRATH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIRE_BIG_MASK_PMAP_ANIM,
+			FIRE_MED_MASK_PMAP_ANIM,
+			FIRE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			ILWRATH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ILWRATH_VICTORY_SONG,
+		ILWRATH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC ilwrath_desc4x =
+{
+	{ /* SHIP_INFO */
+		"avenger",
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ILWRATH_RACE_STRINGS,
+		ILWRATH_ICON_MASK_PMAP_ANIM,
+		ILWRATH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1410 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			48, 1700,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ILWRATH_BIG_MASK_PMAP_ANIM,
+			ILWRATH_MED_MASK_PMAP_ANIM,
+			ILWRATH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIRE_BIG_MASK_PMAP_ANIM,
+			FIRE_MED_MASK_PMAP_ANIM,
+			FIRE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			ILWRATH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ILWRATH_VICTORY_SONG,
+		ILWRATH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 flame_preprocess (ELEMENT *ElementPtr)
 {
@@ -213,11 +365,11 @@ initialize_flame (ELEMENT *ShipPtr, HELE
 
 	if (FlameArray[0])
 	{
-		SIZE dx, dy;
+		SDWORD dx, dy;
 		ELEMENT *FlamePtr;
 
 		LockElement (FlameArray[0], &FlamePtr);
-		GetCurrentVelocityComponents (&ShipPtr->velocity, &dx, &dy);
+		GetCurrentVelocityComponentsSdword (&ShipPtr->velocity, &dx, &dy);
 		DeltaVelocityComponents (&FlamePtr->velocity, dx, dy);
 		FlamePtr->current.location.x -= VELOCITY_TO_WORLD (dx);
 		FlamePtr->current.location.y -= VELOCITY_TO_WORLD (dy);
@@ -396,9 +548,12 @@ ilwrath_preprocess (ELEMENT *ElementPtr)
 
 RACE_DESC*
 init_ilwrath (void)
-{
+{	
+	static RACE_DESC ilwrath_desc;
 	RACE_DESC *RaceDescPtr;
 
+	ilwrath_desc = (RESOLUTION_FACTOR == 0 ? ilwrath_desc1x : (RESOLUTION_FACTOR == 1 ? ilwrath_desc2x : ilwrath_desc4x));
+
 	ilwrath_desc.preprocess_func = ilwrath_preprocess;
 	ilwrath_desc.init_weapon_func = initialize_flame;
 	ilwrath_desc.cyborg_control.intelligence_func = ilwrath_intelligence;
diff -ruNp src.orig/uqm/ships/lastbat/lastbat.c src/uqm/ships/lastbat/lastbat.c
--- src.orig/uqm/ships/lastbat/lastbat.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/lastbat/lastbat.c	2017-12-30 00:14:53 -0800
@@ -48,7 +48,7 @@
 #define COMET_DAMAGE 2
 #define COMET_OFFSET 0
 #define COMET_HITS 12
-#define COMET_SPEED DISPLAY_TO_WORLD (12)
+#define COMET_SPEED DISPLAY_TO_WORLD RES_SCALE(12)
 #define COMET_LIFE 2
 #define COMET_TURN_WAIT 3
 #define MAX_COMETS 3
@@ -58,14 +58,14 @@
 
 // Green sentinel
 #define SPECIAL_WAIT ((ONE_SECOND / BATTLE_FRAME_RATE) * 3)
-#define SENTINEL_SPEED DISPLAY_TO_WORLD (8)
+#define SENTINEL_SPEED DISPLAY_TO_WORLD RES_SCALE(8)
 #define SENTINEL_LIFE 2
 #define SENTINEL_OFFSET 0
 #define SENTINEL_HITS 10
 #define SENTINEL_DAMAGE 1
 #define TRACK_WAIT 1
 #define ANIMATION_WAIT 1
-#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (10))
+#define RECOIL_VELOCITY WORLD_TO_VELOCITY (DISPLAY_TO_WORLD RES_SCALE(10))
 #define MAX_RECOIL_VELOCITY (RECOIL_VELOCITY * 4)
 #define MAX_SENTINELS 4
 #define SPECIAL_ENERGY_COST 3
@@ -164,7 +164,7 @@ comet_preprocess (ELEMENT *ElementPtr)
 	{
 		if (frame_index == 25)
 		{
-			SIZE cur_delta_x, cur_delta_y;
+			SDWORD cur_delta_x, cur_delta_y;
 			STARSHIP *StarShipPtr;
 
 			GetElementStarShip (ElementPtr, &StarShipPtr);
@@ -172,7 +172,7 @@ comet_preprocess (ELEMENT *ElementPtr)
 			spawn_comet (ElementPtr);
 			ElementPtr->state_flags |= NONSOLID;
 
-			GetCurrentVelocityComponents (&ElementPtr->velocity,
+			GetCurrentVelocityComponentsSdword (&ElementPtr->velocity,
 					&cur_delta_x, &cur_delta_y);
 			SetVelocityComponents (&ElementPtr->velocity,
 					cur_delta_x / 2, cur_delta_y / 2);
@@ -518,22 +518,22 @@ sentinel_preprocess (ELEMENT *ElementPtr
 			hTarget = ElementPtr->hTarget;
 		else
 		{
-			SIZE delta_x0, delta_y0, delta_x1, delta_y1;
+			SDWORD delta_x0, delta_y0, delta_x1, delta_y1;
 			ELEMENT *ShipPtr;
 			ELEMENT *EnemyShipPtr;
 
 			LockElement (ElementPtr->hTarget, &EnemyShipPtr);
 
 			LockElement (StarShipPtr->hShip, &ShipPtr);
-			delta_x0 = ShipPtr->current.location.x
-					- ElementPtr->current.location.x;
-			delta_y0 = ShipPtr->current.location.y
-					- ElementPtr->current.location.y;
-
-			delta_x1 = ShipPtr->current.location.x
-					- EnemyShipPtr->current.location.x;
-			delta_y1 = ShipPtr->current.location.y
-					- EnemyShipPtr->current.location.y;
+			delta_x0 = (SDWORD)ShipPtr->current.location.x
+					- (SDWORD)ElementPtr->current.location.x;
+			delta_y0 = (SDWORD)ShipPtr->current.location.y
+					- (SDWORD)ElementPtr->current.location.y;
+
+			delta_x1 = (SDWORD)ShipPtr->current.location.x
+					- (SDWORD)EnemyShipPtr->current.location.x;
+			delta_y1 = (SDWORD)ShipPtr->current.location.y
+					- (SDWORD)EnemyShipPtr->current.location.y;
 			UnlockElement (StarShipPtr->hShip);
 
 			if ((long)delta_x0 * delta_x0
@@ -550,17 +550,17 @@ sentinel_preprocess (ELEMENT *ElementPtr
 		if (hTarget)
 		{
 			COUNT num_frames;
-			SIZE delta_x, delta_y;
+			SDWORD delta_x, delta_y;
 			ELEMENT *TargetPtr;
 			VELOCITY_DESC TargetVelocity;
 
 			LockElement (hTarget, &TargetPtr);
 
-			delta_x = TargetPtr->current.location.x
-					- ElementPtr->current.location.x;
+			delta_x = (SDWORD)TargetPtr->current.location.x
+					- (SDWORD)ElementPtr->current.location.x;
 			delta_x = WRAP_DELTA_X (delta_x);
-			delta_y = TargetPtr->current.location.y
-					- ElementPtr->current.location.y;
+			delta_y = (SDWORD)TargetPtr->current.location.y
+					- (SDWORD)ElementPtr->current.location.y;
 			delta_y = WRAP_DELTA_Y (delta_y);
 
 			if ((num_frames = WORLD_TO_TURN (
@@ -570,14 +570,14 @@ sentinel_preprocess (ELEMENT *ElementPtr
 				num_frames = 1;
 
 			TargetVelocity = TargetPtr->velocity;
-			GetNextVelocityComponents (&TargetVelocity,
+			GetNextVelocityComponentsSdword (&TargetVelocity,
 					&delta_x, &delta_y, num_frames);
 
-			delta_x = (TargetPtr->current.location.x + delta_x)
-					- ElementPtr->current.location.x;
+			delta_x = ((SDWORD)TargetPtr->current.location.x + (SDWORD)delta_x)
+					- (SDWORD)ElementPtr->current.location.x;
 			delta_x = WRAP_DELTA_X (delta_x);
-			delta_y = (TargetPtr->current.location.y + delta_y)
-					- ElementPtr->current.location.y;
+			delta_y = ((SDWORD)TargetPtr->current.location.y + (SDWORD)delta_y)
+					- (SDWORD)ElementPtr->current.location.y;
 			delta_y = WRAP_DELTA_Y (delta_y);
 
 			UnlockElement (hTarget);
@@ -641,7 +641,7 @@ sentinel_collision (ELEMENT *ElementPtr0
 				&& ElementPtr1->crew_level
 				&& !GRAVITY_MASS (ElementPtr1->mass_points + 1))
 		{
-			SIZE cur_delta_x, cur_delta_y;
+			SDWORD cur_delta_x, cur_delta_y;
 
 			ElementPtr0->life_span = old_life;
 			ElementPtr0->hit_points = old_hits;
@@ -661,7 +661,7 @@ sentinel_collision (ELEMENT *ElementPtr0
 			DeltaVelocityComponents (&ElementPtr1->velocity,
 					COSINE (angle, RECOIL_VELOCITY),
 					SINE (angle, RECOIL_VELOCITY));
-			GetCurrentVelocityComponents (&ElementPtr1->velocity,
+			GetCurrentVelocityComponentsSdword (&ElementPtr1->velocity,
 					&cur_delta_x, &cur_delta_y);
 			if ((long)cur_delta_x * (long)cur_delta_x
 					+ (long)cur_delta_y * (long)cur_delta_y
@@ -773,7 +773,7 @@ samatra_preprocess (ELEMENT *ElementPtr)
 	}
 	else
 	{
-		POINT offs[] =
+		POINT offs1x[] =
 		{
 			{-127-9,  -53+18},
 			{ -38-9,  -88+18},
@@ -784,6 +784,34 @@ samatra_preprocess (ELEMENT *ElementPtr)
 			{ -87-9,   58+18},
 			{-136-9,   29+18},
 		};
+		
+		POINT offs2x[] =
+		{
+			{-153, -116}, // Top left generator
+			{-208, -49 }, // The one below the top left generator
+			{-198,  72},
+			{-104,  132},
+			{113,   132},
+			{205,   70},
+			{220,  -44 },
+			{165,  -107}, // Top right generator
+		};
+		
+		POINT offs4x[] =
+		{
+			{-305, -234}, // Top left generator
+			{-414, -96 }, // The one below the top left generator
+			{-396,  140},
+			{-208,  262},
+			{215,   262},
+			{410,   140},
+			{441,  -87 },
+			{329,  -214}, // Top right generator
+		};
+		
+		POINT *offs;
+
+		offs = (RESOLUTION_FACTOR == 0 ? offs1x : (RESOLUTION_FACTOR == 1 ? offs2x : offs4x));
 
 		for (StarShipPtr->RaceDescPtr->num_generators = 0;
 				StarShipPtr->RaceDescPtr->num_generators < MAX_GENERATORS;
@@ -808,11 +836,11 @@ samatra_preprocess (ELEMENT *ElementPtr)
 						);
 				GeneratorPtr->current.location.x =
 						((LOG_SPACE_WIDTH >> 1)
-						+ DISPLAY_TO_WORLD (offs[StarShipPtr->RaceDescPtr->num_generators].x))
+						+ DISPLAY_TO_WORLD ((offs[StarShipPtr->RaceDescPtr->num_generators].x)))
 						& ~((SCALED_ONE << MAX_VIS_REDUCTION) - 1);
 				GeneratorPtr->current.location.y =
 						((LOG_SPACE_HEIGHT >> 1)
-						+ DISPLAY_TO_WORLD (offs[StarShipPtr->RaceDescPtr->num_generators].y))
+						+ DISPLAY_TO_WORLD ((offs[StarShipPtr->RaceDescPtr->num_generators].y)))
 						& ~((SCALED_ONE << MAX_VIS_REDUCTION) - 1);
 				GeneratorPtr->current.image.farray =
 						StarShipPtr->RaceDescPtr->ship_data.special;
diff -ruNp src.orig/uqm/ships/melnorme/melnorme.c src/uqm/ships/melnorme/melnorme.c
--- src.orig/uqm/ships/melnorme/melnorme.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/melnorme/melnorme.c	2017-12-30 00:14:53 -0800
@@ -19,7 +19,7 @@
 #include "../ship.h"
 #include "melnorme.h"
 #include "resinst.h"
-
+#include "../../setup.h"
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
@@ -37,7 +37,7 @@
 // Blaster Pulse
 #define WEAPON_ENERGY_COST 5
 #define WEAPON_WAIT 1
-#define MELNORME_OFFSET 24
+#define MELNORME_OFFSET RES_SCALE(24)
 #define LEVEL_COUNTER 72
 #define MAX_PUMP 4
 #define PUMPUP_SPEED DISPLAY_TO_WORLD (45)
@@ -50,13 +50,21 @@
 // Confusion Pulse
 #define SPECIAL_ENERGY_COST 20
 #define SPECIAL_WAIT 20
-#define CMISSILE_SPEED DISPLAY_TO_WORLD (30)
+#define CMISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(30)
 #define CMISSILE_LIFE 20
 #define CMISSILE_HITS 200
 #define CMISSILE_DAMAGE 0
-#define CMISSILE_OFFSET 4
+#define CMISSILE_OFFSET RES_SCALE(4)
+
+// HD
+#define MAX_THRUST_2XRES 72
+#define THRUST_INCREMENT_2XRES 12
+#define PUMPUP_SPEED_2XRES DISPLAY_TO_WORLD (90)
+#define MAX_THRUST_4XRES 144
+#define THRUST_INCREMENT_4XRES 24
+#define PUMPUP_SPEED_4XRES DISPLAY_TO_WORLD (180)
 
-static RACE_DESC melnorme_desc =
+static RACE_DESC melnorme_desc1x =
 {
 	{ /* SHIP_INFO */
 		"trader",
@@ -128,6 +136,152 @@ static RACE_DESC melnorme_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC melnorme_desc2x =
+{
+	{ /* SHIP_INFO */
+		"trader",
+		FIRES_FORE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MELNORME_RACE_STRINGS,
+		MELNORME_ICON_MASK_PMAP_ANIM,
+		MELNORME_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MELNORME_BIG_MASK_PMAP_ANIM,
+			MELNORME_MED_MASK_PMAP_ANIM,
+			MELNORME_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PUMPUP_BIG_MASK_PMAP_ANIM,
+			PUMPUP_MED_MASK_PMAP_ANIM,
+			PUMPUP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CONFUSE_BIG_MASK_PMAP_ANIM,
+			CONFUSE_MED_MASK_PMAP_ANIM,
+			CONFUSE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MELNORME_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MELNORME_VICTORY_SONG,
+		MELNORME_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		PUMPUP_SPEED_2XRES * PUMPUP_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC melnorme_desc4x =
+{
+	{ /* SHIP_INFO */
+		"trader",
+		FIRES_FORE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MELNORME_RACE_STRINGS,
+		MELNORME_ICON_MASK_PMAP_ANIM,
+		MELNORME_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			MAX_X_UNIVERSE >> 1, MAX_Y_UNIVERSE >> 1,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MELNORME_BIG_MASK_PMAP_ANIM,
+			MELNORME_MED_MASK_PMAP_ANIM,
+			MELNORME_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PUMPUP_BIG_MASK_PMAP_ANIM,
+			PUMPUP_MED_MASK_PMAP_ANIM,
+			PUMPUP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			CONFUSE_BIG_MASK_PMAP_ANIM,
+			CONFUSE_MED_MASK_PMAP_ANIM,
+			CONFUSE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MELNORME_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MELNORME_VICTORY_SONG,
+		MELNORME_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		PUMPUP_SPEED_4XRES * PUMPUP_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 pump_up_preprocess (ELEMENT *ElementPtr)
 {
@@ -240,8 +394,8 @@ pump_up_postprocess (ELEMENT *ElementPtr
 
 			angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 			SetVelocityComponents (&EPtr->velocity,
-					COSINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED)),
-					SINE (angle, WORLD_TO_VELOCITY (PUMPUP_SPEED)));
+					COSINE (angle, WORLD_TO_VELOCITY (RES_SCALE(PUMPUP_SPEED))),
+					SINE (angle, WORLD_TO_VELOCITY (RES_SCALE(PUMPUP_SPEED))));
 
 			ProcessSound (SetAbsSoundIndex (
 					StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), EPtr);
@@ -463,7 +617,14 @@ confusion_collision (ELEMENT *ElementPtr
 				ConfusionPtr->hTarget = StarShipPtr->hShip;
 			}
 
-			ConfusionPtr->life_span = 400;
+			if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+				(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr0->playerNr == 0) || 
+				((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr0->playerNr == 1))))
+			{
+				ConfusionPtr->life_span = 0;
+			} else {
+				ConfusionPtr->life_span = 400;
+			}
 			ConfusionPtr->turn_wait =
 					(BYTE)(1 << ((BYTE)TFB_Random () & 1)); /* LEFT or RIGHT */
 
@@ -529,7 +690,7 @@ initialize_test_pump_up (ELEMENT *ShipPt
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = MELNORME_OFFSET;
-	MissileBlock.speed = PUMPUP_SPEED;
+	MissileBlock.speed = RES_SCALE(PUMPUP_SPEED);
 	MissileBlock.hit_points = PUMPUP_DAMAGE;
 	MissileBlock.damage = PUMPUP_DAMAGE;
 	MissileBlock.life = PUMPUP_LIFE;
@@ -646,8 +807,11 @@ melnorme_postprocess (ELEMENT *ElementPt
 RACE_DESC*
 init_melnorme (void)
 {
+	static RACE_DESC melnorme_desc;
 	RACE_DESC *RaceDescPtr;
 
+	melnorme_desc = (RESOLUTION_FACTOR == 0 ? melnorme_desc1x : (RESOLUTION_FACTOR == 1 ? melnorme_desc2x : melnorme_desc4x));
+
 	melnorme_desc.postprocess_func = melnorme_postprocess;
 	melnorme_desc.init_weapon_func = initialize_pump_up;
 	melnorme_desc.cyborg_control.intelligence_func = melnorme_intelligence;
diff -ruNp src.orig/uqm/ships/mmrnmhrm/mmrnmhrm.c src/uqm/ships/mmrnmhrm/mmrnmhrm.c
--- src.orig/uqm/ships/mmrnmhrm/mmrnmhrm.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/mmrnmhrm/mmrnmhrm.c	2017-12-30 00:14:54 -0800
@@ -37,25 +37,25 @@
 #define YWING_ENERGY_REGENERATION 1
 #define YWING_SPECIAL_ENERGY_COST MAX_ENERGY
 #define YWING_ENERGY_WAIT 6
-#define YWING_MAX_THRUST 50
-#define YWING_THRUST_INCREMENT 10
+#define YWING_MAX_THRUST RES_SCALE(50)
+#define YWING_THRUST_INCREMENT RES_SCALE(10)
 #define YWING_THRUST_WAIT 0
 #define YWING_TURN_WAIT 14
 
 // X-Wing Lasers
-#define MMRNMHRM_OFFSET 16
+#define MMRNMHRM_OFFSET RES_SCALE(16)
 #define WEAPON_ENERGY_COST 1
 #define WEAPON_WAIT 0
-#define CENTER_OFFS DISPLAY_TO_WORLD (4)
+#define CENTER_OFFS DISPLAY_TO_WORLD RES_SCALE(4)
 #define WING_OFFS DISPLAY_TO_WORLD (10)
-#define LASER_RANGE DISPLAY_TO_WORLD (125 + MMRNMHRM_OFFSET)
+#define LASER_RANGE DISPLAY_TO_WORLD (RES_SCALE(125) + MMRNMHRM_OFFSET)
 
 // Y-Wing Missiles
 #define YWING_WEAPON_ENERGY_COST 1
 #define YWING_WEAPON_WAIT 20
-#define LAUNCH_OFFS DISPLAY_TO_WORLD (4)
+#define LAUNCH_OFFS DISPLAY_TO_WORLD RES_SCALE(4)
 #define MISSILE_OFFSET 0
-#define MISSILE_SPEED DISPLAY_TO_WORLD (20)
+#define MISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(20)
 #define MISSILE_LIFE 40
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
@@ -66,7 +66,13 @@
 #define SPECIAL_WAIT 0
 #define YWING_SPECIAL_WAIT 0
 
-static RACE_DESC mmrnmhrm_desc =
+// HD
+#define MAX_THRUST_2XRES 40
+#define THRUST_INCREMENT_2XRES 10
+#define MAX_THRUST_4XRES 80
+#define THRUST_INCREMENT_4XRES 20
+
+static RACE_DESC mmrnmhrm_desc1x =
 {
 	{ /* SHIP_INFO */
 		"xform",
@@ -138,6 +144,152 @@ static RACE_DESC mmrnmhrm_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC mmrnmhrm_desc2x =
+{
+	{ /* SHIP_INFO */
+		"xform",
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		19, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MMRNMHRM_RACE_STRINGS,
+		MMRNMHRM_ICON_MASK_PMAP_ANIM,
+		MMRNMHRM_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MMRNMHRM_BIG_MASK_PMAP_ANIM,
+			MMRNMHRM_MED_MASK_PMAP_ANIM,
+			MMRNMHRM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TORP_BIG_MASK_PMAP_ANIM,
+			TORP_MED_MASK_PMAP_ANIM,
+			TORP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YWING_BIG_MASK_PMAP_ANIM,
+			YWING_MED_MASK_PMAP_ANIM,
+			YWING_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MMRNMHRM_VICTORY_SONG,
+		MMRNMHRM_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC mmrnmhrm_desc4x =
+{
+	{ /* SHIP_INFO */
+		"xform",
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		19, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MMRNMHRM_RACE_STRINGS,
+		MMRNMHRM_ICON_MASK_PMAP_ANIM,
+		MMRNMHRM_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MMRNMHRM_BIG_MASK_PMAP_ANIM,
+			MMRNMHRM_MED_MASK_PMAP_ANIM,
+			MMRNMHRM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TORP_BIG_MASK_PMAP_ANIM,
+			TORP_MED_MASK_PMAP_ANIM,
+			TORP_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YWING_BIG_MASK_PMAP_ANIM,
+			YWING_MED_MASK_PMAP_ANIM,
+			YWING_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MMRNMHRM_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MMRNMHRM_VICTORY_SONG,
+		MMRNMHRM_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 // Private per-instance ship data
 typedef CHARACTERISTIC_STUFF MMRNMHRM_DATA;
 
@@ -225,10 +377,10 @@ mmrnmhrm_intelligence (ELEMENT *ShipPtr,
 			&& lpEvalDesc->ObjectPtr
 			&& !(StarShipPtr->ship_input_state & WEAPON))
 	{
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 		COUNT travel_angle, direction_angle;
 
-		GetCurrentVelocityComponents (&lpEvalDesc->ObjectPtr->velocity,
+		GetCurrentVelocityComponentsSdword (&lpEvalDesc->ObjectPtr->velocity,
 				&delta_x, &delta_y);
 		if (delta_x == 0 && delta_y == 0)
 			direction_angle = travel_angle = 0;
@@ -248,7 +400,7 @@ mmrnmhrm_intelligence (ELEMENT *ShipPtr,
 		{
 			if (lpEvalDesc->which_turn > 8)
 			{
-				if (MANEUVERABILITY (&EnemyStarShipPtr->RaceDescPtr->cyborg_control) <= SLOW_SHIP
+				if (MANEUVERABILITY (&EnemyStarShipPtr->RaceDescPtr->cyborg_control) <= RESOLUTION_COMPENSATED(SLOW_SHIP) // JMS_GFX
 						|| NORMALIZE_ANGLE (
 								direction_angle - travel_angle + QUADRANT
 								) > HALF_CIRCLE)
@@ -257,9 +409,9 @@ mmrnmhrm_intelligence (ELEMENT *ShipPtr,
 		}
 		else
 		{
-			SIZE ship_delta_x, ship_delta_y;
+			SDWORD ship_delta_x, ship_delta_y;
 
-			GetCurrentVelocityComponents (&ShipPtr->velocity,
+			GetCurrentVelocityComponentsSdword (&ShipPtr->velocity,
 					&ship_delta_x, &ship_delta_y);
 			delta_x -= ship_delta_x;
 			delta_y -= ship_delta_y;
@@ -304,7 +456,7 @@ initialize_dual_weapons (ELEMENT *ShipPt
 {
 	COORD cx, cy;
 	COUNT facing, angle;
-	SIZE offs_x, offs_y;
+	SDWORD offs_x, offs_y;
 	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ShipPtr, &StarShipPtr);
@@ -426,7 +578,7 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 
 		if (ElementPtr->next.image.farray == StarShipPtr->RaceDescPtr->ship_data.special)
 		{
-			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = LONG_RANGE_WEAPON - 1;
+			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = RES_SCALE(LONG_RANGE_WEAPON - 1);
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags &= ~IMMEDIATE_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags |= SEEKING_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_data.ship_sounds =
@@ -437,7 +589,7 @@ mmrnmhrm_postprocess (ELEMENT *ElementPt
 		}
 		else
 		{
-			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = CLOSE_RANGE_WEAPON;
+			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = RES_SCALE(CLOSE_RANGE_WEAPON);
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags &= ~SEEKING_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_info.ship_flags |= IMMEDIATE_WEAPON;
 			StarShipPtr->RaceDescPtr->ship_data.ship_sounds =
@@ -494,11 +646,15 @@ uninit_mmrnmhrm (RACE_DESC *pRaceDesc)
 RACE_DESC*
 init_mmrnmhrm (void)
 {
+	static RACE_DESC mmrnmhrm_desc;
 	RACE_DESC *RaceDescPtr;
+
 	// The caller of this func will copy the struct
 	static RACE_DESC new_mmrnmhrm_desc;
 	MMRNMHRM_DATA otherwing_desc;
 
+	mmrnmhrm_desc = (RESOLUTION_FACTOR == 0 ? mmrnmhrm_desc1x : (RESOLUTION_FACTOR == 1 ? mmrnmhrm_desc2x : mmrnmhrm_desc4x));
+
 	mmrnmhrm_desc.uninit_func = uninit_mmrnmhrm;
 	mmrnmhrm_desc.preprocess_func = mmrnmhrm_preprocess;
 	mmrnmhrm_desc.postprocess_func = mmrnmhrm_postprocess;
diff -ruNp src.orig/uqm/ships/mycon/mycon.c src/uqm/ships/mycon/mycon.c
--- src.orig/uqm/ships/mycon/mycon.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/mycon/mycon.c	2017-12-30 00:14:54 -0800
@@ -34,13 +34,13 @@
 // Plasmoid
 #define WEAPON_ENERGY_COST 20
 #define WEAPON_WAIT 5
-#define MYCON_OFFSET 24
+#define MYCON_OFFSET RES_SCALE(24)
 #define MISSILE_OFFSET 0
 #define NUM_PLASMAS 11
 #define NUM_GLOBALLS 8
 #define PLASMA_DURATION 13
 #define MISSILE_LIFE (NUM_PLASMAS * PLASMA_DURATION)
-#define MISSILE_SPEED DISPLAY_TO_WORLD (8)
+#define MISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(8)
 #define MISSILE_DAMAGE 10
 #define TRACK_WAIT 1
 
@@ -49,7 +49,16 @@
 #define SPECIAL_WAIT 0
 #define REGENERATION_AMOUNT 4
 
-static RACE_DESC mycon_desc =
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (14) */ 54
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (4) */ 18
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (28) */ 108
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (8) */ 36
+
+#define MAX_THRUST_HIRES /* DISPLAY_TO_WORLD (20) */ 108 // DC_GFX
+#define THRUST_INCREMENT_HIRES MAX_THRUST_HIRES // DC_GFX
+
+static RACE_DESC mycon_desc1x =
 {
 	{ /* SHIP_INFO */
 		"podship",
@@ -121,6 +130,152 @@ static RACE_DESC mycon_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC mycon_desc2x =
+{
+	{ /* SHIP_INFO */
+		"podship",
+		FIRES_FORE | SEEKING_WEAPON,
+		21, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MYCON_RACE_STRINGS,
+		MYCON_ICON_MASK_PMAP_ANIM,
+		MYCON_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1070 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			6392, 2200,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MYCON_BIG_MASK_PMAP_ANIM,
+			MYCON_MED_MASK_PMAP_ANIM,
+			MYCON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PLASMA_BIG_MASK_PMAP_ANIM,
+			PLASMA_MED_MASK_PMAP_ANIM,
+			PLASMA_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			MYCON_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MYCON_VICTORY_SONG,
+		MYCON_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		DISPLAY_TO_WORLD (1600),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC mycon_desc4x =
+{
+	{ /* SHIP_INFO */
+		"podship",
+		FIRES_FORE | SEEKING_WEAPON,
+		21, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		MYCON_RACE_STRINGS,
+		MYCON_ICON_MASK_PMAP_ANIM,
+		MYCON_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1070 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			6392, 2200,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			MYCON_BIG_MASK_PMAP_ANIM,
+			MYCON_MED_MASK_PMAP_ANIM,
+			MYCON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			PLASMA_BIG_MASK_PMAP_ANIM,
+			PLASMA_MED_MASK_PMAP_ANIM,
+			PLASMA_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			MYCON_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		MYCON_VICTORY_SONG,
+		MYCON_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		DISPLAY_TO_WORLD (3200),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 plasma_preprocess (ELEMENT *ElementPtr)
 {
@@ -259,7 +414,7 @@ mycon_intelligence (ELEMENT *ShipPtr, EV
 			|| ShipPtr->crew_level == StarShipPtr->RaceDescPtr->ship_info.max_crew))
 	{
 		COUNT travel_facing, direction_facing;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 
 		travel_facing = NORMALIZE_FACING (
 				ANGLE_TO_FACING (GetVelocityTravelAngle (&ShipPtr->velocity)
@@ -288,7 +443,7 @@ mycon_intelligence (ELEMENT *ShipPtr, EV
 	if (StarShipPtr->special_counter == 0)
 	{
 		StarShipPtr->ship_input_state &= ~SPECIAL;
-		StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = DISPLAY_TO_WORLD (800);
+		StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = DISPLAY_TO_WORLD (RES_SCALE(800));
 		if (ShipPtr->crew_level < StarShipPtr->RaceDescPtr->ship_info.max_crew)
 		{
 			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = MISSILE_SPEED * MISSILE_LIFE;
@@ -364,8 +519,11 @@ mycon_postprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_mycon (void)
 {
+	static RACE_DESC mycon_desc;
 	RACE_DESC *RaceDescPtr;
 
+	mycon_desc = (RESOLUTION_FACTOR == 0 ? mycon_desc1x : (RESOLUTION_FACTOR == 1 ? mycon_desc2x : mycon_desc4x));
+
 	mycon_desc.postprocess_func = mycon_postprocess;
 	mycon_desc.init_weapon_func = initialize_plasma;
 	mycon_desc.cyborg_control.intelligence_func = mycon_intelligence;
diff -ruNp src.orig/uqm/ships/orz/orz.c src/uqm/ships/orz/orz.c
--- src.orig/uqm/ships/orz/orz.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/orz/orz.c	2017-12-30 00:14:54 -0800
@@ -19,7 +19,7 @@
 #include "../ship.h"
 #include "orz.h"
 #include "resinst.h"
-
+#include "../../setup.h"
 #include "uqm/colors.h"
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
@@ -48,8 +48,8 @@
 // Marine
 #define SPECIAL_ENERGY_COST 0
 #define SPECIAL_WAIT 12
-#define MARINE_MAX_THRUST 32
-#define MARINE_THRUST_INCREMENT 8
+#define MARINE_MAX_THRUST RES_SCALE(32)
+#define MARINE_THRUST_INCREMENT RES_SCALE(8)
 #define MARINE_HIT_POINTS 3
 #define MARINE_MASS_POINTS 1
 #define MAX_MARINES 8
@@ -58,10 +58,18 @@
 #define START_ION_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
 
 // Rotating Turret
-#define TURRET_OFFSET 14
+#define TURRET_OFFSET RES_SCALE(14)
 #define TURRET_WAIT 3
 
-static RACE_DESC orz_desc =
+// HD
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 10
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 20
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+static RACE_DESC orz_desc1x =
 {
 	{ /* SHIP_INFO */
 		"nemesis",
@@ -133,6 +141,152 @@ static RACE_DESC orz_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC orz_desc2x =
+{
+	{ /* SHIP_INFO */
+		"nemesis",
+		FIRES_FORE | SEEKING_SPECIAL,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ORZ_RACE_STRINGS,
+		ORZ_ICON_MASK_PMAP_ANIM,
+		ORZ_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			3608, 2637,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ORZ_BIG_MASK_PMAP_ANIM,
+			ORZ_MED_MASK_PMAP_ANIM,
+			ORZ_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HOWITZER_BIG_MASK_PMAP_ANIM,
+			HOWITZER_MED_MASK_PMAP_ANIM,
+			HOWITZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TURRET_BIG_MASK_PMAP_ANIM,
+			TURRET_MED_MASK_PMAP_ANIM,
+			TURRET_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ORZ_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ORZ_VICTORY_SONG,
+		ORZ_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC orz_desc4x =
+{
+	{ /* SHIP_INFO */
+		"nemesis",
+		FIRES_FORE | SEEKING_SPECIAL,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ORZ_RACE_STRINGS,
+		ORZ_ICON_MASK_PMAP_ANIM,
+		ORZ_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			3608, 2637,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ORZ_BIG_MASK_PMAP_ANIM,
+			ORZ_MED_MASK_PMAP_ANIM,
+			ORZ_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HOWITZER_BIG_MASK_PMAP_ANIM,
+			HOWITZER_MED_MASK_PMAP_ANIM,
+			HOWITZER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			TURRET_BIG_MASK_PMAP_ANIM,
+			TURRET_MED_MASK_PMAP_ANIM,
+			TURRET_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ORZ_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ORZ_VICTORY_SONG,
+		ORZ_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 howitzer_collision (ELEMENT *ElementPtr0, POINT *pPt0,
 		ELEMENT *ElementPtr1, POINT *pPt1)
@@ -173,7 +327,7 @@ initialize_turret_missile (ELEMENT *Ship
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = TURRET_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -310,7 +464,7 @@ orz_intelligence (ELEMENT *ShipPtr, EVAL
 				& POINT_DEFENSE)
 				&& (MANEUVERABILITY (
 						&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-						) < SLOW_SHIP
+						) < RESOLUTION_COMPENSATED(SLOW_SHIP)
 				|| lpEvalDesc->which_turn <= 12
 				|| count_marines (StarShipPtr, FALSE) < 2))
 		{
@@ -395,10 +549,15 @@ intruder_preprocess (ELEMENT *ElementPtr
 			{
 				--ElementPtr->thrust_wait;
 
-				s.origin.x = 16 + (ElementPtr->turn_wait & 3) * 9;
-				s.origin.y = 14 + (ElementPtr->turn_wait >> 2) * 11;
-				s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0],
-						GetFrameCount (ElementPtr->next.image.farray[0]) - 2);
+				if (RESOLUTION_FACTOR < 2) {
+					s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+				} else {
+					s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+					s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+				}
+				s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0], GetFrameCount (ElementPtr->next.image.farray[0]) - 2);
+
 				ModifySilhouette (ShipPtr, &s, 0);
 			}
 
@@ -410,8 +569,13 @@ intruder_preprocess (ELEMENT *ElementPtr
 				UnlockElement (hElement);
 				hElement = 0;
 LeftShip:
-				s.origin.x = 16 + (ElementPtr->turn_wait & 3) * 9;
-				s.origin.y = 14 + (ElementPtr->turn_wait >> 2) * 11;
+				if (RESOLUTION_FACTOR < 2) {
+					s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+				} else {
+					s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+					s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+				}
 				s.frame = ElementPtr->next.image.frame;
 				ModifySilhouette (ShipPtr, &s, MODIFY_SWAP);
 			}
@@ -433,14 +597,26 @@ LeftShip:
 				}
 				else if (randval < (0x0100 / 2 + 0x0100 / 16))
 				{
-					if (!DeltaCrew (ShipPtr, -1))
-						ShipPtr->life_span = 0;
+					if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+						(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0) || 
+						((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1))))
+					{
+						// Marines do no damage to player while boarded
+					} else {
+						if (!DeltaCrew (ShipPtr, -1))
+							ShipPtr->life_span = 0;
+					}
 
 					++ElementPtr->thrust_wait;
-					s.origin.x = 16 + (ElementPtr->turn_wait & 3) * 9;
-					s.origin.y = 14 + (ElementPtr->turn_wait >> 2) * 11;
-					s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0],
-							GetFrameCount (ElementPtr->next.image.farray[0]) - 1);
+					if (RESOLUTION_FACTOR < 2) {
+						s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+						s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					} else {
+						s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+						s.origin.y = (14 + (ElementPtr->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+					}
+					s.frame = SetAbsFrameIndex (ElementPtr->next.image.farray[0], GetFrameCount (ElementPtr->next.image.farray[0]) - 1);
+
 					ModifySilhouette (ShipPtr, &s, 0);
 					ProcessSound (SetAbsSoundIndex (
 							StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 3), ElementPtr);
@@ -497,15 +673,15 @@ spawn_marine_ion_trail (ELEMENT *Element
 				// 'cycle_ion_trail', it is given new life a number of
 				// times, by setting life_span to thrust_wait.
 		SetPrimType (&(GLOBAL (DisplayArray))[IonElementPtr->PrimIndex],
-				POINT_PRIM);
+				POINT_PRIM); // Actual marine ion trail
 		SetPrimColor (&(GLOBAL (DisplayArray))[IonElementPtr->PrimIndex],
 				START_ION_COLOR);
 		IonElementPtr->colorCycleIndex = 0;
 		IonElementPtr->current.location = ElementPtr->current.location;
 		IonElementPtr->current.location.x +=
-				(COORD)COSINE (angle, DISPLAY_TO_WORLD (2));
+				(COORD)COSINE (angle, DISPLAY_TO_WORLD RES_SCALE(2));
 		IonElementPtr->current.location.y +=
-				(COORD)SINE (angle, DISPLAY_TO_WORLD (2));
+				(COORD)SINE (angle, DISPLAY_TO_WORLD RES_SCALE(2));
 		IonElementPtr->death_func = ion_preprocess;
 
 		SetElementStarShip (IonElementPtr, StarShipPtr);
@@ -548,7 +724,7 @@ marine_preprocess (ELEMENT *ElementPtr)
 	else
 	{
 		COUNT facing, pfacing = 0;
-		SIZE delta_x, delta_y, delta_facing;
+		SDWORD delta_x, delta_y, delta_facing;
 		HELEMENT hObject, hNextObject, hTarget;
 		ELEMENT *ObjectPtr;
 
@@ -635,7 +811,7 @@ marine_preprocess (ELEMENT *ElementPtr)
 			}
 			else
 			{
-				COUNT num_frames;
+				DWORD num_frames;
 				VELOCITY_DESC ShipVelocity;
 
 				if (elementsOfSamePlayer (ObjectPtr, ElementPtr)
@@ -648,20 +824,21 @@ marine_preprocess (ELEMENT *ElementPtr)
 					ElementPtr->state_flags |= CHANGING;
 				}
 
-				num_frames = WORLD_TO_TURN (
+				num_frames = (WORLD_TO_TURN (
 						square_root ((long)delta_x * delta_x
-						+ (long)delta_y * delta_y));
+						+ (long)delta_y * delta_y))) >> RESOLUTION_FACTOR;
+
 				if (num_frames == 0)
 					num_frames = 1;
 
 				ShipVelocity = ObjectPtr->velocity;
-				GetNextVelocityComponents (&ShipVelocity,
+				GetNextVelocityComponentsSdword (&ShipVelocity,
 						&delta_x, &delta_y, num_frames);
 
-				delta_x = (ObjectPtr->current.location.x + delta_x)
-						- ElementPtr->current.location.x;
-				delta_y = (ObjectPtr->current.location.y + delta_y)
-						- ElementPtr->current.location.y;
+				delta_x = ((SDWORD)ObjectPtr->current.location.x + delta_x)
+						- (SDWORD)ElementPtr->current.location.x;
+				delta_y = ((SDWORD)ObjectPtr->current.location.y + delta_y)
+						- (SDWORD)ElementPtr->current.location.y;
 
 				delta_facing = NORMALIZE_FACING (
 						ANGLE_TO_FACING (ARCTAN (delta_x, delta_y)) - facing);
@@ -733,84 +910,61 @@ marine_preprocess (ELEMENT *ElementPtr)
 }
 
 void
-marine_collision (ELEMENT *ElementPtr0, POINT *pPt0,
-		ELEMENT *ElementPtr1, POINT *pPt1)
-{
-	if (ElementPtr0->life_span
-			&& !(ElementPtr0->state_flags & (NONSOLID | COLLISION))
-			&& !(ElementPtr1->state_flags & FINITE_LIFE))
-	{
-		if (!elementsOfSamePlayer (ElementPtr0, ElementPtr1))
-		{
-			ElementPtr0->turn_wait =
-					MAKE_BYTE (5, HINIBBLE (ElementPtr0->turn_wait));
-			ElementPtr0->thrust_wait &=
-					~((SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED) >> 6);
+marine_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1) {	
+	STAMP s;
+	STARSHIP *StarShipPtr;
+	GetElementStarShip (ElementPtr0, &StarShipPtr);
+	if (ElementPtr0->life_span && !(ElementPtr0->state_flags & (NONSOLID | COLLISION)) && !(ElementPtr1->state_flags & FINITE_LIFE)) {
+		if (!elementsOfSamePlayer (ElementPtr0, ElementPtr1)) {
+			ElementPtr0->turn_wait = MAKE_BYTE (5, HINIBBLE (ElementPtr0->turn_wait));
+			ElementPtr0->thrust_wait &= ~((SHIP_AT_MAX_SPEED | SHIP_BEYOND_MAX_SPEED) >> 6);
 			ElementPtr0->state_flags |= COLLISION;
 		}
-
-		if (GRAVITY_MASS (ElementPtr1->mass_points))
-		{
+		if (GRAVITY_MASS (ElementPtr1->mass_points)) {
 			ElementPtr0->state_flags |= NONSOLID | FINITE_LIFE;
 			ElementPtr0->hit_points = 0;
 			ElementPtr0->life_span = 0;
-		}
-		else if ((ElementPtr1->state_flags & PLAYER_SHIP)
-				&& ((ElementPtr1->state_flags & FINITE_LIFE)
-				|| ElementPtr1->life_span == NORMAL_LIFE))
-		{
+		} else if ((ElementPtr1->state_flags & PLAYER_SHIP) && ((ElementPtr1->state_flags & FINITE_LIFE) || ElementPtr1->life_span == NORMAL_LIFE)) {
 			ElementPtr1->state_flags &= ~COLLISION;
-
-			if (!(ElementPtr0->state_flags & COLLISION))
-			{
+			if (!(ElementPtr0->state_flags & COLLISION)) {
 				DeltaCrew (ElementPtr1, 1);
-
-				ElementPtr0->state_flags |=
-						DISAPPEARING | NONSOLID | FINITE_LIFE;
+				ElementPtr0->state_flags |= DISAPPEARING | NONSOLID | FINITE_LIFE;
 				ElementPtr0->hit_points = 0;
 				ElementPtr0->life_span = 0;
-			}
-			else if ((ElementPtr0->state_flags & IGNORE_SIMILAR)
-					&& ElementPtr1->crew_level
-#ifdef NEVER
-					&& (BYTE)TFB_Random () <= (0x0100 / 3)
-#endif /* NEVER */
-					)
-			{
-				STAMP s;
-				STARSHIP *StarShipPtr;
-
-				GetElementStarShip (ElementPtr0, &StarShipPtr);
-				if (!DeltaCrew (ElementPtr1, -1))
-					ElementPtr1->life_span = 0;
-				else
+			} else if ((ElementPtr0->state_flags & IGNORE_SIMILAR) && ElementPtr1->crew_level) {
+				if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+				(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 1) || 
+				((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 0))))
 				{
-					ElementPtr0->turn_wait = count_marines (StarShipPtr, TRUE);
-					ElementPtr0->thrust_wait = MARINE_WAIT;
-					ElementPtr0->next.image.frame = SetAbsFrameIndex (
-							ElementPtr0->next.image.farray[0],
-							22 + ElementPtr0->turn_wait
-							);
-					ElementPtr0->state_flags |= NONSOLID;
-					ElementPtr0->state_flags &= ~CREW_OBJECT;
-					SetPrimType (&(GLOBAL (DisplayArray))[
-							ElementPtr0->PrimIndex
-							], NO_PRIM);
-					ElementPtr0->preprocess_func = intruder_preprocess;
-
-					s.origin.x = 16 + (ElementPtr0->turn_wait & 3) * 9;
-					s.origin.y = 14 + (ElementPtr0->turn_wait >> 2) * 11;
-					s.frame = ElementPtr0->next.image.frame;
-					ModifySilhouette (ElementPtr1, &s, 0);
+					if (!DeltaCrew (ElementPtr1, 0)){ // Marines won't damage player while boarding
+						ElementPtr1->life_span = 0;
+					}
+				} else {
+					if (!DeltaCrew (ElementPtr1, -1)){
+						ElementPtr1->life_span = 0;
+					}					
 				}
-
-				ProcessSound (SetAbsSoundIndex (
-						StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2),
-						ElementPtr1);
+				ElementPtr0->turn_wait = count_marines (StarShipPtr, TRUE);
+				ElementPtr0->thrust_wait = MARINE_WAIT;
+				ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
+				ElementPtr0->state_flags |= NONSOLID;
+				ElementPtr0->state_flags &= ~CREW_OBJECT;
+				SetPrimType (&(GLOBAL (DisplayArray))[ElementPtr0->PrimIndex], NO_PRIM);
+				ElementPtr0->preprocess_func = intruder_preprocess;
+				if (RESOLUTION_FACTOR < 2) {
+					s.origin.x = (16 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait & 3) * ((9 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+					s.origin.y = (14 << RESOLUTION_FACTOR) + (ElementPtr0->turn_wait >> 2) * ((11 + RESOLUTION_FACTOR * 6) << RESOLUTION_FACTOR);
+				} else {
+					s.origin.x = (16 - (RESOLUTION_FACTOR * 3 / 2) + (ElementPtr0->turn_wait & 3) * (9 + RESOLUTION_FACTOR * 3 / 2)) << RESOLUTION_FACTOR; // JMS_GFX
+					s.origin.y = (14 + (ElementPtr0->turn_wait >> 2) * (11 + RESOLUTION_FACTOR)) << RESOLUTION_FACTOR; // JMS_GFX
+				}
+				s.frame = ElementPtr0->next.image.frame;
+				ModifySilhouette (ElementPtr1, &s, 0);
+				ElementPtr0->next.image.frame = SetAbsFrameIndex (ElementPtr0->next.image.farray[0], 22 + ElementPtr0->turn_wait);
+				ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1);
 			}
-
 			ElementPtr0->state_flags &= ~COLLISION;
-		}
+		}			
 	}
 	(void) pPt0;  /* Satisfying compiler (unused parameter) */
 	(void) pPt1;  /* Satisfying compiler (unused parameter) */
@@ -979,10 +1133,10 @@ turret_postprocess (ELEMENT *ElementPtr)
 				facing = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 				SpaceMarinePtr->current.location.x =
 						ShipPtr->current.location.x
-						- COSINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET));
+						- COSINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET << ((RESOLUTION_FACTOR + 1)/2))); // JMS_GFX
 				SpaceMarinePtr->current.location.y =
 						ShipPtr->current.location.y
-						- SINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET));
+						- SINE (facing, DISPLAY_TO_WORLD (TURRET_OFFSET << ((RESOLUTION_FACTOR + 1)/2))); // JMS_GFX
 				SpaceMarinePtr->current.image.farray =
 						StarShipPtr->RaceDescPtr->ship_data.special;
 				SpaceMarinePtr->current.image.frame = SetAbsFrameIndex (
@@ -1002,7 +1156,14 @@ turret_postprocess (ELEMENT *ElementPtr)
 				UnlockElement (hSpaceMarine);
 				PutElement (hSpaceMarine);
 
-				DeltaCrew (ShipPtr, -1);
+				if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+					(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
+					((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
+				{
+					// Marines launched does not count towards crew
+				} else {
+					DeltaCrew (ShipPtr, -1);
+				}
 				ProcessSound (SetAbsSoundIndex (
 						StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 1),
 						SpaceMarinePtr);
@@ -1071,8 +1232,11 @@ orz_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_orz (void)
 {
+	static RACE_DESC orz_desc;
 	RACE_DESC *RaceDescPtr;
 
+	orz_desc = (RESOLUTION_FACTOR == 0 ? orz_desc1x : (RESOLUTION_FACTOR == 1 ? orz_desc2x : orz_desc4x));
+
 	orz_desc.preprocess_func = orz_preprocess;
 	orz_desc.init_weapon_func = initialize_turret_missile;
 	orz_desc.cyborg_control.intelligence_func = orz_intelligence;
diff -ruNp src.orig/uqm/ships/pkunk/pkunk.c src/uqm/ships/pkunk/pkunk.c
--- src.orig/uqm/ships/pkunk/pkunk.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/pkunk/pkunk.c	2017-12-30 00:14:54 -0800
@@ -19,10 +19,10 @@
 #include "../ship.h"
 #include "pkunk.h"
 #include "resinst.h"
-
 #include "uqm/globdata.h"
 #include "uqm/tactrans.h"
 #include "libs/mathlib.h"
+#include "../../settings.h" // JMS: For StopMusic
 
 // Core characteristics
 #define MAX_CREW 8
@@ -38,8 +38,8 @@
 // Triple Miniguns
 #define WEAPON_ENERGY_COST 1
 #define WEAPON_WAIT 0
-#define PKUNK_OFFSET 15
-#define MISSILE_OFFSET 1
+#define PKUNK_OFFSET RES_SCALE(15)
+#define MISSILE_OFFSET RES_SCALE(1)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (24)
 #define MISSILE_LIFE 5
 #define MISSILE_HITS 1
@@ -53,9 +53,15 @@
 #define PHOENIX_LIFE 12
 #define START_PHOENIX_COLOR BUILD_COLOR (MAKE_RGB15 (0x1F, 0x15, 0x00), 0x7A)
 #define TRANSITION_LIFE 1
-#define TRANSITION_SPEED DISPLAY_TO_WORLD (20)
+#define TRANSITION_SPEED DISPLAY_TO_WORLD RES_SCALE(20)
+
+// HD
+#define MAX_THRUST_2XRES 128
+#define THRUST_INCREMENT_2XRES 32
+#define MAX_THRUST_4XRES 256
+#define THRUST_INCREMENT_4XRES 64
 
-static RACE_DESC pkunk_desc =
+static RACE_DESC pkunk_desc1x =
 {
 	{ /* SHIP_INFO */
 		"fury",
@@ -127,6 +133,152 @@ static RACE_DESC pkunk_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC pkunk_desc2x =
+{
+	{ /* SHIP_INFO */
+		"fury",
+		FIRES_FORE | FIRES_LEFT | FIRES_RIGHT,
+		20, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		PKUNK_RACE_STRINGS,
+		PKUNK_ICON_MASK_PMAP_ANIM,
+		PKUNK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			502, 401,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		0, /* SPECIAL_WAIT */
+		SHIP_MASS,
+	},
+	{
+		{
+			PKUNK_BIG_MASK_PMAP_ANIM,
+			PKUNK_MED_MASK_PMAP_ANIM,
+			PKUNK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUG_BIG_MASK_PMAP_ANIM,
+			BUG_MED_MASK_PMAP_ANIM,
+			BUG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			PKUNK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		PKUNK_VICTORY_SONG,
+		PKUNK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES + 2,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC pkunk_desc4x =
+{
+	{ /* SHIP_INFO */
+		"fury",
+		FIRES_FORE | FIRES_LEFT | FIRES_RIGHT,
+		20, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		PKUNK_RACE_STRINGS,
+		PKUNK_ICON_MASK_PMAP_ANIM,
+		PKUNK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			502, 401,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		0, /* SPECIAL_WAIT */
+		SHIP_MASS,
+	},
+	{
+		{
+			PKUNK_BIG_MASK_PMAP_ANIM,
+			PKUNK_MED_MASK_PMAP_ANIM,
+			PKUNK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BUG_BIG_MASK_PMAP_ANIM,
+			BUG_MED_MASK_PMAP_ANIM,
+			BUG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			PKUNK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		PKUNK_VICTORY_SONG,
+		PKUNK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES + 4,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 // Private per-instance ship data
 typedef struct
 {
@@ -199,7 +351,7 @@ initialize_bug_missile (ELEMENT *ShipPtr
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = PKUNK_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -217,11 +369,11 @@ initialize_bug_missile (ELEMENT *ShipPtr
 
 		if ((MissileArray[i] = initialize_missile (&MissileBlock)))
 		{
-			SIZE dx, dy;
+			SDWORD dx, dy;
 			ELEMENT *MissilePtr;
 
 			LockElement (MissileArray[i], &MissilePtr);
-			GetCurrentVelocityComponents (&ShipPtr->velocity, &dx, &dy);
+			GetCurrentVelocityComponentsSdword (&ShipPtr->velocity, &dx, &dy);
 			DeltaVelocityComponents (&MissilePtr->velocity, dx, dy);
 			MissilePtr->current.location.x -= VELOCITY_TO_WORLD (dx);
 			MissilePtr->current.location.y -= VELOCITY_TO_WORLD (dy);
@@ -284,8 +436,8 @@ new_pkunk (ELEMENT *ElementPtr)
 	StarShipPtr->RaceDescPtr->ship_info.crew_level = MAX_CREW;
 	StarShipPtr->RaceDescPtr->ship_info.energy_level = MAX_ENERGY;
 				/* fix vux impairment */
-	StarShipPtr->RaceDescPtr->characteristics.max_thrust = MAX_THRUST;
-	StarShipPtr->RaceDescPtr->characteristics.thrust_increment = THRUST_INCREMENT;
+	StarShipPtr->RaceDescPtr->characteristics.max_thrust = RES_SCALE(MAX_THRUST);
+	StarShipPtr->RaceDescPtr->characteristics.thrust_increment = RES_SCALE(THRUST_INCREMENT);
 	StarShipPtr->RaceDescPtr->characteristics.turn_wait = TURN_WAIT;
 	StarShipPtr->RaceDescPtr->characteristics.thrust_wait = THRUST_WAIT;
 	StarShipPtr->RaceDescPtr->characteristics.special_wait = 0;
@@ -450,19 +602,18 @@ phoenix_transition (ELEMENT *ElementPtr)
 		}
 		else
 		{
+			SDWORD temp_x, temp_y;
 			angle = FACING_TO_ANGLE (StarShipPtr->ShipFacing);
 
-			ShipImagePtr->current.location.x -=
-					COSINE (angle, TRANSITION_SPEED)
-					* (ElementPtr->life_span - 1);
-			ShipImagePtr->current.location.y -=
-					SINE (angle, TRANSITION_SPEED)
-					* (ElementPtr->life_span - 1);
-
-			ShipImagePtr->current.location.x =
-					WRAP_X (ShipImagePtr->current.location.x);
-			ShipImagePtr->current.location.y =
-					WRAP_Y (ShipImagePtr->current.location.y);
+            // JMS_GFX: Circumventing overflows by using temp variables instead of
+            // subtracting straight from the POINT sized ShipImagePtr->current.location.
+            temp_x = (SDWORD)ShipImagePtr->current.location.x - 
+				COSINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+            temp_y = (SDWORD)ShipImagePtr->current.location.y - 
+				SINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+            
+            ShipImagePtr->current.location.x = WRAP_X (temp_x);
+            ShipImagePtr->current.location.y = WRAP_Y (temp_y);
 		}
 
 		ShipImagePtr->mass_points = (BYTE)angle;
@@ -614,10 +765,14 @@ uninit_pkunk (RACE_DESC *pRaceDesc)
 RACE_DESC*
 init_pkunk (void)
 {
-	RACE_DESC *RaceDescPtr;
-	// The caller of this func will copy the struct
+	static RACE_DESC pkunk_desc;
 	static RACE_DESC new_pkunk_desc;
+	RACE_DESC *RaceDescPtr;
 	PKUNK_DATA empty_data;
+
+	pkunk_desc = (RESOLUTION_FACTOR == 0 ? pkunk_desc1x : (RESOLUTION_FACTOR == 1 ? pkunk_desc2x : pkunk_desc4x));
+
+	// The caller of this func will copy the struct
 	memset (&empty_data, 0, sizeof (empty_data));
 
 	pkunk_desc.uninit_func = uninit_pkunk;
diff -ruNp src.orig/uqm/ships/shofixti/resinst.h src/uqm/ships/shofixti/resinst.h
--- src.orig/uqm/ships/shofixti/resinst.h	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/shofixti/resinst.h	2017-12-30 00:14:54 -0800
@@ -10,6 +10,7 @@
 #define DESTRUCT_SML_MASK_ANIM "ship.shofixti.graphics.destruct.small"
 #define OLDSHOF_BIG_MASK_PMAP_ANIM "ship.shofixti.graphics.oldscout.large"
 #define OLDSHOF_CAPTAIN_MASK_PMAP_ANIM "ship.shofixti.graphics.oldcaptain"
+#define OLDSHOF_ICON_MASK_PMAP_ANIM "ship.shofixti.oldicons"
 #define OLDSHOF_MED_MASK_PMAP_ANIM "ship.shofixti.graphics.oldscout.medium"
 #define OLDSHOF_SML_MASK_PMAP_ANIM "ship.shofixti.graphics.oldscout.small"
 #define SHOFIXTI_BIG_MASK_PMAP_ANIM "ship.shofixti.graphics.scout.large"
diff -ruNp src.orig/uqm/ships/shofixti/shofixti.c src/uqm/ships/shofixti/shofixti.c
--- src.orig/uqm/ships/shofixti/shofixti.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/shofixti/shofixti.c	2017-12-30 00:14:54 -0800
@@ -39,8 +39,8 @@
 
 // Dart Gun
 #define WEAPON_ENERGY_COST 1
-#define SHOFIXTI_OFFSET 15
-#define MISSILE_OFFSET 1
+#define SHOFIXTI_OFFSET RES_SCALE(15)
+#define MISSILE_OFFSET RES_SCALE(1)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (24)
 #define MISSILE_LIFE 10
 #define MISSILE_HITS 1
@@ -48,13 +48,21 @@
 
 // Glory Device
 #define SPECIAL_ENERGY_COST 0
-#define DESTRUCT_RANGE 180
-#define MAX_DESTRUCTION (DESTRUCT_RANGE / 10)
+#define DESTRUCT_RANGE RES_SCALE(180)
+#define MAX_DESTRUCTION (RES_SCALE(DESTRUCT_RANGE) / 10)
 
 // Full game: Tanaka/Katana's damaged ships
 #define NUM_LIMPETS 3
 
-static RACE_DESC shofixti_desc =
+// HD
+#define MAX_THRUST_2XRES 70
+#define THRUST_INCREMENT_2XRES 10
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (48)
+#define MAX_THRUST_4XRES 140
+#define THRUST_INCREMENT_4XRES 20
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (96)
+
+static RACE_DESC shofixti_desc1x =
 {
 	{ /* SHIP_INFO */
 		"scout",
@@ -126,6 +134,152 @@ static RACE_DESC shofixti_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC shofixti_desc2x =
+{
+	{ /* SHIP_INFO */
+		"scout",
+		FIRES_FORE,
+		5, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SHOFIXTI_RACE_STRINGS,
+		SHOFIXTI_ICON_MASK_PMAP_ANIM,
+		SHOFIXTI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SHOFIXTI_BIG_MASK_PMAP_ANIM,
+			SHOFIXTI_MED_MASK_PMAP_ANIM,
+			SHOFIXTI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DART_BIG_MASK_PMAP_ANIM,
+			DART_MED_MASK_PMAP_ANIM,
+			DART_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DESTRUCT_BIG_MASK_ANIM,
+			DESTRUCT_MED_MASK_ANIM,
+			DESTRUCT_SML_MASK_ANIM,
+		},
+		{
+			SHOFIXTI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SHOFIXTI_VICTORY_SONG,
+		SHOFIXTI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC shofixti_desc4x =
+{
+	{ /* SHIP_INFO */
+		"scout",
+		FIRES_FORE,
+		5, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SHOFIXTI_RACE_STRINGS,
+		SHOFIXTI_ICON_MASK_PMAP_ANIM,
+		SHOFIXTI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SHOFIXTI_BIG_MASK_PMAP_ANIM,
+			SHOFIXTI_MED_MASK_PMAP_ANIM,
+			SHOFIXTI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DART_BIG_MASK_PMAP_ANIM,
+			DART_MED_MASK_PMAP_ANIM,
+			DART_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DESTRUCT_BIG_MASK_ANIM,
+			DESTRUCT_MED_MASK_ANIM,
+			DESTRUCT_SML_MASK_ANIM,
+		},
+		{
+			SHOFIXTI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SHOFIXTI_VICTORY_SONG,
+		SHOFIXTI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_standard_missile (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
@@ -141,7 +295,7 @@ initialize_standard_missile (ELEMENT *Sh
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SHOFIXTI_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -264,7 +418,7 @@ self_destruct_kill_objects (ELEMENT *Ele
 	for (hElement = GetHeadElement (); hElement != 0; hElement = hNextElement)
 	{
 		ELEMENT *ObjPtr;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 		DWORD dist;
 
 		LockElement (hElement, &ObjPtr);
@@ -457,10 +611,13 @@ shofixti_postprocess (ELEMENT *ElementPt
 RACE_DESC*
 init_shofixti (void)
 {
+	static RACE_DESC shofixti_desc;
 	RACE_DESC *RaceDescPtr;
 	// The caller of this func will copy the struct
 	static RACE_DESC new_shofixti_desc;
 
+	shofixti_desc = (RESOLUTION_FACTOR == 0 ? shofixti_desc1x : (RESOLUTION_FACTOR == 1 ? shofixti_desc2x : shofixti_desc4x));
+
 	shofixti_desc.postprocess_func = shofixti_postprocess;
 	shofixti_desc.init_weapon_func = initialize_standard_missile;
 	shofixti_desc.cyborg_control.intelligence_func = shofixti_intelligence;
@@ -480,6 +637,8 @@ init_shofixti (void)
 		new_shofixti_desc.ship_data.special_rsc[2] = NULL_RESOURCE;
 		new_shofixti_desc.ship_data.captain_control.captain_rsc =
 				OLDSHOF_CAPTAIN_MASK_PMAP_ANIM;
+		// JMS: Tanaka also has a corresponding limpeted ship status icon in melee.
+		new_shofixti_desc.ship_info.icons_rsc = OLDSHOF_ICON_MASK_PMAP_ANIM;
 
 		/* Weapon doesn't work as well */
 		new_shofixti_desc.characteristics.weapon_wait = 10;
@@ -493,7 +652,7 @@ init_shofixti (void)
 				--new_shofixti_desc.characteristics.thrust_wait;
 
 /* This should be the same as MIN_THRUST_INCREMENT in vux.c */
-#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1)
+#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD RES_SCALE(1)
 
 			if (new_shofixti_desc.characteristics.thrust_increment <=
 					MIN_THRUST_INCREMENT)
@@ -507,7 +666,7 @@ init_shofixti (void)
 
 				num_thrusts = new_shofixti_desc.characteristics.max_thrust /
 						new_shofixti_desc.characteristics.thrust_increment;
-				--new_shofixti_desc.characteristics.thrust_increment;
+				new_shofixti_desc.characteristics.thrust_increment -= RES_SCALE(1); // JMS_GFX
 				new_shofixti_desc.characteristics.max_thrust =
 						new_shofixti_desc.characteristics.thrust_increment *
 						num_thrusts;
diff -ruNp src.orig/uqm/ships/sis_ship/resinst.h src/uqm/ships/sis_ship/resinst.h
--- src.orig/uqm/ships/sis_ship/resinst.h	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/sis_ship/resinst.h	2017-12-30 00:14:54 -0800
@@ -8,6 +8,7 @@
 #define SIS_BIG_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.large"
 #define SIS_CAPTAIN_MASK_PMAP_ANIM "ship.flagship.graphics.captain"
 #define SIS_HYPER_MASK_PMAP_ANIM "ship.flagship.graphics.hyperspace"
+#define SIS_QUASI_MASK_PMAP_ANIM "ship.flagship.graphics.quasispace"
 #define SIS_ICON_MASK_PMAP_ANIM "ship.flagship.icons"
 #define SIS_MED_MASK_PMAP_ANIM "ship.flagship.graphics.flagship.medium"
 #define SIS_SHIP_SOUNDS "ship.flagship.sounds"
diff -ruNp src.orig/uqm/ships/sis_ship/sis_ship.c src/uqm/ships/sis_ship/sis_ship.c
--- src.orig/uqm/ships/sis_ship/sis_ship.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/sis_ship/sis_ship.c	2017-12-30 00:14:54 -0800
@@ -78,23 +78,30 @@
 		 * InitWeaponSlots */
 #define MAX_TRACKING 3
 #define TRACKER_ENERGY_COST 3
-#define BLASTER_OFFSET 8
-#define SIS_VERT_OFFSET 28
+#define BLASTER_OFFSET RES_SCALE(8)
+#define SIS_VERT_OFFSET RES_SCALE(28)
 		/* Used for foward, spread, and rear slots */
-#define SIS_HORZ_OFFSET 20
+#define SIS_HORZ_OFFSET RES_SCALE(20)
 		/* Used for side slot */
 
-
 /* Secondary weapon */
 #define SPECIAL_ENERGY_COST 0
 		/* Increased by 1 for each point defense module */
 #define ANTIMISSILE_ENERGY_INC 1
 #define SPECIAL_WAIT 9
-#define LASER_RANGE (UWORD)100
+#define LASER_RANGE (UWORD)RES_SCALE(100)
 #define MAX_DEFENSE 8
 
+// HD
+#define MAX_THRUST_2XRES 20
+#define THRUST_INCREMENT_2XRES 8
+#define BLASTER_SPEED_2XRES DISPLAY_TO_WORLD (48)
+#define MAX_THRUST_4XRES 40
+#define THRUST_INCREMENT_4XRES 16
+#define BLASTER_SPEED_4XRES DISPLAY_TO_WORLD (96)
+
 
-static RACE_DESC sis_desc =
+static RACE_DESC sis_desc1x =
 {
 	{ /* SHIP_INFO */
 		"flagship",
@@ -166,6 +173,152 @@ static RACE_DESC sis_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC sis_desc2x =
+{
+	{ /* SHIP_INFO */
+		"flagship",
+		0,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		NULL_RESOURCE,
+		SIS_ICON_MASK_PMAP_ANIM,
+		NULL_RESOURCE,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SIS_BIG_MASK_PMAP_ANIM,
+			SIS_MED_MASK_PMAP_ANIM,
+			SIS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BLASTER_BIG_MASK_PMAP_ANIM,
+			BLASTER_MED_MASK_PMAP_ANIM,
+			BLASTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SIS_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SIS_VICTORY_SONG,
+		SIS_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		BLASTER_SPEED_2XRES * BLASTER_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC sis_desc4x =
+{
+	{ /* SHIP_INFO */
+		"flagship",
+		0,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		NULL_RESOURCE,
+		SIS_ICON_MASK_PMAP_ANIM,
+		NULL_RESOURCE,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SIS_BIG_MASK_PMAP_ANIM,
+			SIS_MED_MASK_PMAP_ANIM,
+			SIS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			BLASTER_BIG_MASK_PMAP_ANIM,
+			BLASTER_MED_MASK_PMAP_ANIM,
+			BLASTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SIS_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SIS_VICTORY_SONG,
+		SIS_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		BLASTER_SPEED_4XRES * BLASTER_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 // Private per-instance SIS data
 typedef struct
 {
@@ -221,35 +374,48 @@ SetCustomShipData (RACE_DESC *pRaceDesc,
 static void
 sis_hyper_preprocess (ELEMENT *ElementPtr)
 {
-	SIZE udx = 0, udy = 0;
 	SIZE dx = 0, dy = 0;
+	SDWORD udx = 0, udy = 0, dtempx, dtempy;
 	SIZE AccelerateDirection;
 	STARSHIP *StarShipPtr;
 
 	if (ElementPtr->state_flags & APPEARING)
 		ElementPtr->velocity = GLOBAL (velocity);
-
+	
 	AccelerateDirection = 0;
-
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	++StarShipPtr->weapon_counter; /* no shooting in hyperspace! */
+	
 	if ((GLOBAL (autopilot)).x == ~0
-			|| (GLOBAL (autopilot)).y == ~0
-			|| (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST)))
+		|| (GLOBAL (autopilot)).y == ~0
+		|| (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST))
+		|| !(GET_GAME_STATE(AUTOPILOT_OK))) // JMS: This check makes autopilot engage only after coming to full stop
 	{
-LeaveAutoPilot:
-		(GLOBAL (autopilot)).x =
-				(GLOBAL (autopilot)).y = ~0;
+	LeaveAutoPilot:
+		
+		// JMS: This re-check is now needed because of the added autopilot_ok variable to previous check
+		if ((GLOBAL (autopilot)).x == ~0 || (GLOBAL (autopilot)).y == ~0 || (StarShipPtr->cur_status_flags & (LEFT | RIGHT | THRUST)))
+			(GLOBAL (autopilot)).x = (GLOBAL (autopilot)).y = ~0;
+		
 		if (!(StarShipPtr->cur_status_flags & THRUST)
-				|| (GLOBAL_SIS (FuelOnBoard) == 0
-				&& GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1))
+			|| (GLOBAL_SIS (FuelOnBoard) == 0
+				&& (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)))
 		{
 			AccelerateDirection = -1;
-			GetCurrentVelocityComponents (&ElementPtr->velocity,
-					&dx, &dy);
-			udx = dx << 4;
-			udy = dy << 4;
-
+			GetCurrentVelocityComponents (&ElementPtr->velocity, &dx, &dy);
+			
+			// JMS: Engage autopilot only after coming to full stop
+			if (dx==0 && dy==0)
+				SET_GAME_STATE (AUTOPILOT_OK, 1);
+			else
+				SET_GAME_STATE (AUTOPILOT_OK, 0);
+			
+			dtempx = (SDWORD)dx;
+			dtempy = (SDWORD)dy;
+			
+			udx = dtempx;
+			udy = dtempy;
+			
 			StarShipPtr->cur_status_flags &= ~THRUST;
 		}
 	}
@@ -262,11 +428,11 @@ LeaveAutoPilot:
 		universe.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
 		udx = (GLOBAL (autopilot)).x - universe.x;
 		udy = -((GLOBAL (autopilot)).y - universe.y);
-		if ((dx = udx) < 0)
+		if ((dx = (SIZE)udx) < 0)
 			dx = -dx;
-		if ((dy = udy) < 0)
+		if ((dy = (SIZE)udy) < 0)
 			dy = -dy;
-		if (dx <= 1 && dy <= 1)
+		if (dx <= (1 << RESOLUTION_FACTOR) && dy <= (1 << RESOLUTION_FACTOR))
 			goto LeaveAutoPilot;
 
 		facing = NORMALIZE_FACING (ANGLE_TO_FACING (ARCTAN (udx, udy)));
@@ -316,8 +482,8 @@ LeaveAutoPilot:
 		else
 		{
 			AccelerateDirection = -1;
-			udx = dx << 4;
-			udy = dy << 4;
+			udx = dx;// << 4;
+			udy = dy;// << 4;
 		}
 	}
 
@@ -349,11 +515,9 @@ LeaveAutoPilot:
 
 			AccelerateDirection = 0;
 
-			max_velocity = WORLD_TO_VELOCITY (
-					StarShipPtr->RaceDescPtr->characteristics.max_thrust);
+			max_velocity = WORLD_TO_VELOCITY (StarShipPtr->RaceDescPtr->characteristics.max_thrust);
+			dy = (speed / velocity_increment + 1) * velocity_increment;
 
-			dy = (speed / velocity_increment + 1)
-					* velocity_increment;
 			if (dy < speed + velocity_increment)
 				dy = speed + velocity_increment;
 			if ((speed = dy) > max_velocity)
@@ -363,12 +527,11 @@ LeaveAutoPilot:
 			}
 		}
 
-		dx = (SIZE)((long)udx * speed / (long)dist);
-		dy = (SIZE)((long)udy * speed / (long)dist);
-		SetVelocityComponents (&ElementPtr->velocity, dx, dy);
-
-		ElementPtr->thrust_wait =
-				StarShipPtr->RaceDescPtr->characteristics.thrust_wait;
+		dtempx = (SDWORD)((long)udx * speed / (long)dist);
+		dtempy = (SDWORD)((long)udy * speed / (long)dist);
+		
+		SetVelocityComponents (&ElementPtr->velocity, dtempx, dtempy);
+		ElementPtr->thrust_wait =StarShipPtr->RaceDescPtr->characteristics.thrust_wait;
 	}
 }
 
@@ -451,7 +614,7 @@ spawn_point_defense (ELEMENT *ElementPtr
 			if (ObjectPtr != ShipPtr && CollidingElement (ObjectPtr) &&
 					!OBJECT_CLOAKED (ObjectPtr))
 			{
-				SIZE delta_x, delta_y;
+				SDWORD delta_x, delta_y;
 
 				delta_x = ObjectPtr->next.location.x -
 						ShipPtr->next.location.x;
@@ -623,7 +786,7 @@ blaster_preprocess (ELEMENT *ElementPtr)
 		facing = NORMALIZE_FACING (ANGLE_TO_FACING (
 				GetVelocityTravelAngle (&ElementPtr->velocity)));
 		if (TrackShip (ElementPtr, &facing) > 0)
-			SetVelocityVector (&ElementPtr->velocity, BLASTER_SPEED, facing);
+			SetVelocityVector (&ElementPtr->velocity, RES_SCALE(BLASTER_SPEED), facing);
 
 		ElementPtr->turn_wait = MAKE_BYTE (wait, wait);
 	}
@@ -696,7 +859,7 @@ sis_intelligence (ELEMENT *ShipPtr, EVAL
 			lpEvalDesc->ObjectPtr = NULL;
 		}
 		else if (MANEUVERABILITY (&StarShipPtr->RaceDescPtr->cyborg_control)
-				< MEDIUM_SHIP
+				< RESOLUTION_COMPENSATED(MEDIUM_SHIP) // JMS_GFX
 				&& lpEvalDesc->MoveState == ENTICE
 				&& (!(lpEvalDesc->ObjectPtr->state_flags & CREW_OBJECT)
 				|| lpEvalDesc->which_turn <= 8)
@@ -717,7 +880,7 @@ sis_intelligence (ELEMENT *ShipPtr, EVAL
 			&& lpEvalDesc->which_turn <= 16)
 	{
 		COUNT direction_facing;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 		UWORD fire_flags, ship_flags;
 		COUNT facing;
 
@@ -770,7 +933,7 @@ InitWeaponSlots (RACE_DESC *RaceDescPtr,
 		
 		lpMB->flags = IGNORE_SIMILAR;
 		lpMB->blast_offs = BLASTER_OFFSET;
-		lpMB->speed = BLASTER_SPEED;
+		lpMB->speed = RES_SCALE(BLASTER_SPEED);
 		lpMB->preprocess_func = blaster_preprocess;
 		lpMB->hit_points = BLASTER_HITS * which_gun;
 		lpMB->damage = BLASTER_DAMAGE * which_gun;
@@ -887,7 +1050,7 @@ InitDriveSlots (RACE_DESC *RaceDescPtr,
 		switch (DriveSlots[i])
 		{
 			case FUSION_THRUSTER:
-				RaceDescPtr->characteristics.max_thrust += 2;
+				RaceDescPtr->characteristics.max_thrust += RES_SCALE(2);
 				++RaceDescPtr->characteristics.thrust_wait;
 				break;
 		}
@@ -927,7 +1090,7 @@ init_sis (void)
 	memset (&empty_data, 0, sizeof (empty_data));
 
 	/* copy initial ship settings to new_sis_desc */
-	new_sis_desc = sis_desc;
+	new_sis_desc = (RESOLUTION_FACTOR == 0 ? sis_desc1x : (RESOLUTION_FACTOR == 1 ? sis_desc2x : sis_desc4x));
 	
 	new_sis_desc.uninit_func = uninit_sis;
 
@@ -944,12 +1107,15 @@ init_sis (void)
 		new_sis_desc.ship_data.victory_ditty_rsc = NULL_RESOURCE;
 		new_sis_desc.ship_data.ship_sounds_rsc = NULL_RESOURCE;
 
-		new_sis_desc.ship_data.ship_rsc[0] = SIS_HYPER_MASK_PMAP_ANIM;
+		if (GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1 && RESOLUTION_FACTOR > 0)
+			new_sis_desc.ship_data.ship_rsc[0] = SIS_QUASI_MASK_PMAP_ANIM;
+		else
+			new_sis_desc.ship_data.ship_rsc[0] = SIS_HYPER_MASK_PMAP_ANIM;
 
 		new_sis_desc.preprocess_func = sis_hyper_preprocess;
 		new_sis_desc.postprocess_func = sis_hyper_postprocess;
 
-		new_sis_desc.characteristics.max_thrust -= 4;
+		new_sis_desc.characteristics.max_thrust -= RES_SCALE(4);
 	}
 	else
 	{
diff -ruNp src.orig/uqm/ships/slylandr/slylandr.c src/uqm/ships/slylandr/slylandr.c
--- src.orig/uqm/ships/slylandr/slylandr.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/slylandr/slylandr.c	2017-12-30 00:14:54 -0800
@@ -38,17 +38,23 @@
 #define WEAPON_ENERGY_COST 2
 #define WEAPON_WAIT 17
 #define SLYLANDRO_OFFSET 9
-#define LASER_LENGTH 32
+#define LASER_LENGTH RES_SCALE(32)
 		/* Total length of lighting bolts. Actual range is usually less than
 		 * this, since the lightning rarely is straight. */
 
 // Harvester
 #define SPECIAL_ENERGY_COST 0
 #define SPECIAL_WAIT 20
-#define HARVEST_RANGE (208 * 3 / 8)
+#define HARVEST_RANGE ((208 * 3 / 8) << RESOLUTION_FACTOR)
 		/* Was originally (SPACE_HEIGHT * 3 / 8) */
 
-static RACE_DESC slylandro_desc =
+// HD
+#define MAX_THRUST_2XRES 120
+#define THRUST_INCREMENT_2XRES MAX_THRUST_2XRES
+#define MAX_THRUST_4XRES 240
+#define THRUST_INCREMENT_4XRES MAX_THRUST_4XRES
+
+static RACE_DESC slylandro_desc1x =
 {
 	{ /* SHIP_INFO */
 		"probe",
@@ -120,6 +126,152 @@ static RACE_DESC slylandro_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC slylandro_desc2x =
+{
+	{ /* SHIP_INFO */
+		"probe",
+		SEEKING_WEAPON | CREW_IMMUNE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SLYLANDRO_RACE_STRINGS,
+		SLYLANDRO_ICON_MASK_PMAP_ANIM,
+		SLYLANDRO_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			333, 9812,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SLYLANDRO_BIG_MASK_PMAP_ANIM,
+			SLYLANDRO_MED_MASK_PMAP_ANIM,
+			SLYLANDRO_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SLYLANDRO_VICTORY_SONG,
+		SLYLANDRO_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES << 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC slylandro_desc4x =
+{
+	{ /* SHIP_INFO */
+		"probe",
+		SEEKING_WEAPON | CREW_IMMUNE,
+		17, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SLYLANDRO_RACE_STRINGS,
+		SLYLANDRO_ICON_MASK_PMAP_ANIM,
+		SLYLANDRO_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		INFINITE_RADIUS, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			333, 9812,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SLYLANDRO_BIG_MASK_PMAP_ANIM,
+			SLYLANDRO_MED_MASK_PMAP_ANIM,
+			SLYLANDRO_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SLYLANDRO_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SLYLANDRO_VICTORY_SONG,
+		SLYLANDRO_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES << 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT initialize_lightning (ELEMENT *ElementPtr,
 		HELEMENT LaserArray[]);
 
@@ -267,8 +419,11 @@ slylandro_intelligence (ELEMENT *ShipPtr
 	EVALUATE_DESC *lpEvalDesc;
 	STARSHIP *StarShipPtr;
 
-	if (LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER)
-			/* no dodging in role playing game */
+	// no dodging in role playing game, unless you haven't
+	// visited the starbase yet
+	if ((LOBYTE (GLOBAL (CurrentActivity)) == IN_ENCOUNTER) &&
+			GET_GAME_STATE (STARBASE_AVAILABLE))
+
 		ObjectsOfConcern[ENEMY_WEAPON_INDEX].ObjectPtr = 0;
 
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
@@ -321,7 +476,7 @@ harvest_space_junk (ELEMENT *ElementPtr)
 				&& !GRAVITY_MASS (ObjPtr->mass_points)
 				&& CollisionPossible (ObjPtr, ElementPtr))
 		{
-			SIZE dx, dy;
+			SDWORD dx, dy;
 
 			if ((dx = ObjPtr->next.location.x
 					- ElementPtr->next.location.x) < 0)
@@ -426,8 +581,11 @@ slylandro_preprocess (ELEMENT *ElementPt
 RACE_DESC*
 init_slylandro (void)
 {
+	static RACE_DESC slylandro_desc;
 	RACE_DESC *RaceDescPtr;
 
+	slylandro_desc = (RESOLUTION_FACTOR == 0 ? slylandro_desc1x : (RESOLUTION_FACTOR == 1 ? slylandro_desc2x : slylandro_desc4x));
+
 	slylandro_desc.preprocess_func = slylandro_preprocess;
 	slylandro_desc.postprocess_func = slylandro_postprocess;
 	slylandro_desc.init_weapon_func = initialize_lightning;
diff -ruNp src.orig/uqm/ships/spathi/spathi.c src/uqm/ships/spathi/spathi.c
--- src.orig/uqm/ships/spathi/spathi.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/spathi/spathi.c	2017-12-30 00:14:54 -0800
@@ -34,27 +34,37 @@
 // Forward gun
 #define WEAPON_ENERGY_COST 2
 #define WEAPON_WAIT 0
-#define SPATHI_FORWARD_OFFSET 16
+#define SPATHI_FORWARD_OFFSET RES_SCALE(16)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 10
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET RES_SCALE(1)
 #define MISSILE_RANGE (MISSILE_SPEED * MISSILE_LIFE)
 		/* This is for the cyborg only. */
 
 // B.U.T.T.
 #define SPECIAL_ENERGY_COST 3
 #define SPECIAL_WAIT 7
-#define SPATHI_REAR_OFFSET 20
-#define DISCRIMINATOR_SPEED DISPLAY_TO_WORLD (8)
+#define SPATHI_REAR_OFFSET RES_SCALE(20)
+#define DISCRIMINATOR_SPEED DISPLAY_TO_WORLD RES_SCALE(8)
 #define DISCRIMINATOR_LIFE 30
 #define DISCRIMINATOR_HITS 1
 #define DISCRIMINATOR_DAMAGE 2
-#define DISCRIMINATOR_OFFSET 4
+#define DISCRIMINATOR_OFFSET RES_SCALE(4)
 #define TRACK_WAIT 1
 
-static RACE_DESC spathi_desc =
+// HD
+#define MAX_THRUST_2XRES 96
+#define THRUST_INCREMENT_2XRES 24
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+#define MAX_THRUST_4XRES 192
+#define THRUST_INCREMENT_4XRES 48
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+
+static RACE_DESC spathi_desc1x =
 {
 	{ /* SHIP_INFO */
 		"eluder",
@@ -126,6 +136,152 @@ static RACE_DESC spathi_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC spathi_desc2x =
+{
+	{ /* SHIP_INFO */
+		"eluder",
+		FIRES_FORE | FIRES_AFT | SEEKING_SPECIAL | DONT_CHASE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SPATHI_RACE_STRINGS,
+		SPATHI_ICON_MASK_PMAP_ANIM,
+		SPATHI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			2549, 3600,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SPATHI_BIG_MASK_PMAP_ANIM,
+			SPATHI_MED_MASK_PMAP_ANIM,
+			SPATHI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MISSILE_BIG_MASK_PMAP_ANIM,
+			MISSILE_MED_MASK_PMAP_ANIM,
+			MISSILE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DISCRIM_BIG_MASK_PMAP_ANIM,
+			DISCRIM_MED_MASK_PMAP_ANIM,
+			DISCRIM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPATHI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SPATHI_VICTORY_SONG,
+		SPATHI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC spathi_desc4x =
+{
+	{ /* SHIP_INFO */
+		"eluder",
+		FIRES_FORE | FIRES_AFT | SEEKING_SPECIAL | DONT_CHASE,
+		18, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SPATHI_RACE_STRINGS,
+		SPATHI_ICON_MASK_PMAP_ANIM,
+		SPATHI_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		1000 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			2549, 3600,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SPATHI_BIG_MASK_PMAP_ANIM,
+			SPATHI_MED_MASK_PMAP_ANIM,
+			SPATHI_SML_MASK_PMAP_ANIM,
+		},
+		{
+			MISSILE_BIG_MASK_PMAP_ANIM,
+			MISSILE_MED_MASK_PMAP_ANIM,
+			MISSILE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DISCRIM_BIG_MASK_PMAP_ANIM,
+			DISCRIM_MED_MASK_PMAP_ANIM,
+			DISCRIM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPATHI_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SPATHI_VICTORY_SONG,
+		SPATHI_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 butt_missile_preprocess (ELEMENT *ElementPtr)
 {
@@ -210,7 +366,7 @@ spathi_intelligence (ELEMENT *ShipPtr, E
 			&& lpEvalDesc->which_turn <= 24)
 	{
 		COUNT travel_facing, direction_facing;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 
 		travel_facing = NORMALIZE_FACING (
 				ANGLE_TO_FACING (GetVelocityTravelAngle (&ShipPtr->velocity)
@@ -259,7 +415,7 @@ initialize_standard_missile (ELEMENT *Sh
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SPATHI_FORWARD_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -290,8 +446,11 @@ spathi_postprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_spathi (void)
 {
+	static RACE_DESC spathi_desc;
 	RACE_DESC *RaceDescPtr;
 
+	spathi_desc = (RESOLUTION_FACTOR == 0 ? spathi_desc1x : (RESOLUTION_FACTOR == 1 ? spathi_desc2x : spathi_desc4x));
+
 	spathi_desc.postprocess_func = spathi_postprocess;
 	spathi_desc.init_weapon_func = initialize_standard_missile;
 	spathi_desc.cyborg_control.intelligence_func = spathi_intelligence;
diff -ruNp src.orig/uqm/ships/supox/supox.c src/uqm/ships/supox/supox.c
--- src.orig/uqm/ships/supox/supox.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/supox/supox.c	2017-12-30 00:14:54 -0800
@@ -36,7 +36,7 @@
 // Gob launcher
 #define WEAPON_ENERGY_COST 1
 #define WEAPON_WAIT 2
-#define SUPOX_OFFSET 23
+#define SUPOX_OFFSET RES_SCALE(23)
 #define MISSILE_OFFSET 2
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 10
@@ -49,7 +49,15 @@
 #define SPECIAL_WAIT 0
 		/* Unused except to initialize supox_desc.special_wait */
 
-static RACE_DESC supox_desc =
+// HD
+#define MAX_THRUST_2XRES 80
+#define THRUST_INCREMENT_2XRES 16
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MAX_THRUST_4XRES 160
+#define THRUST_INCREMENT_4XRES 16
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+static RACE_DESC supox_desc1x =
 {
 	{ /* SHIP_INFO */
 		"blade",
@@ -121,6 +129,152 @@ static RACE_DESC supox_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC supox_desc2x =
+{
+	{ /* SHIP_INFO */
+		"blade",
+		FIRES_FORE,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SUPOX_RACE_STRINGS,
+		SUPOX_ICON_MASK_PMAP_ANIM,
+		SUPOX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			7468, 9246,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SUPOX_BIG_MASK_PMAP_ANIM,
+			SUPOX_MED_MASK_PMAP_ANIM,
+			SUPOX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GOB_BIG_MASK_PMAP_ANIM,
+			GOB_MED_MASK_PMAP_ANIM,
+			GOB_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SUPOX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SUPOX_VICTORY_SONG,
+		SUPOX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_2XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC supox_desc4x =
+{
+	{ /* SHIP_INFO */
+		"blade",
+		FIRES_FORE,
+		16, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		SUPOX_RACE_STRINGS,
+		SUPOX_ICON_MASK_PMAP_ANIM,
+		SUPOX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		333 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			7468, 9246,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SUPOX_BIG_MASK_PMAP_ANIM,
+			SUPOX_MED_MASK_PMAP_ANIM,
+			SUPOX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			GOB_BIG_MASK_PMAP_ANIM,
+			GOB_MED_MASK_PMAP_ANIM,
+			GOB_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SUPOX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SUPOX_VICTORY_SONG,
+		SUPOX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_4XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 supox_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
 		COUNT ConcernCounter)
@@ -137,7 +291,7 @@ supox_intelligence (ELEMENT *ShipPtr, EV
 	{
 		BOOLEAN LinedUp;
 		COUNT direction_angle;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 
 		delta_x = lpEvalDesc->ObjectPtr->next.location.x
 				- ShipPtr->next.location.x;
@@ -200,7 +354,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SUPOX_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -276,8 +430,11 @@ supox_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_supox (void)
 {
+	static RACE_DESC supox_desc;
 	RACE_DESC *RaceDescPtr;
 
+	supox_desc = (RESOLUTION_FACTOR == 0 ? supox_desc1x : (RESOLUTION_FACTOR == 1 ? supox_desc2x : supox_desc4x));
+
 	supox_desc.preprocess_func = supox_preprocess;
 	supox_desc.init_weapon_func = initialize_horn;
 	supox_desc.cyborg_control.intelligence_func = supox_intelligence;
diff -ruNp src.orig/uqm/ships/syreen/syreen.c src/uqm/ships/syreen/syreen.c
--- src.orig/uqm/ships/syreen/syreen.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/syreen/syreen.c	2017-12-30 00:14:54 -0800
@@ -19,7 +19,7 @@
 #include "../ship.h"
 #include "syreen.h"
 #include "resinst.h"
-
+#include "../../setup.h"
 #include "libs/mathlib.h"
 
 // Core characteristics
@@ -37,20 +37,29 @@
 // Particle Beam Stiletto
 #define WEAPON_ENERGY_COST 1
 #define WEAPON_WAIT 8
-#define SYREEN_OFFSET 30
+#define SYREEN_OFFSET RES_SCALE(30)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 10
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 2
-#define MISSILE_OFFSET 3
+#define MISSILE_OFFSET RES_SCALE(3)
 
 // Syreen song
 #define SPECIAL_ENERGY_COST 5
 #define SPECIAL_WAIT 20
-#define ABANDONER_RANGE 208 /* originally SPACE_HEIGHT */
+#define ABANDONER_RANGE RES_SCALE(208) /* originally SPACE_HEIGHT */
 #define MAX_ABANDONERS 8
 
-static RACE_DESC syreen_desc =
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (8) */ 72
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 18
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (8) */ 144
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 36
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
+
+static RACE_DESC syreen_desc1x =
 {
 	{ /* SHIP_INFO */
 		"penetrator",
@@ -122,6 +131,153 @@ static RACE_DESC syreen_desc =
 	0, /* CodeRef */
 };
 
+
+// JMS_GFX
+static RACE_DESC syreen_desc2x =
+{
+	{ /* SHIP_INFO */
+		"penetrator",
+		FIRES_FORE,
+		13, /* Super Melee cost */
+		MAX_CREW, SYREEN_MAX_CREW_SIZE,
+		MAX_ENERGY, MAX_ENERGY,
+		SYREEN_RACE_STRINGS,
+		SYREEN_ICON_MASK_PMAP_ANIM,
+		SYREEN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SYREEN_BIG_MASK_PMAP_ANIM,
+			SYREEN_MED_MASK_PMAP_ANIM,
+			SYREEN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DAGGER_BIG_MASK_PMAP_ANIM,
+			DAGGER_MED_MASK_PMAP_ANIM,
+			DAGGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SYREEN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SYREEN_VICTORY_SONG,
+		SYREEN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_2XRES * MISSILE_LIFE * 2 / 3),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC syreen_desc4x =
+{
+	{ /* SHIP_INFO */
+		"penetrator",
+		FIRES_FORE,
+		13, /* Super Melee cost */
+		MAX_CREW, SYREEN_MAX_CREW_SIZE,
+		MAX_ENERGY, MAX_ENERGY,
+		SYREEN_RACE_STRINGS,
+		SYREEN_ICON_MASK_PMAP_ANIM,
+		SYREEN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		0, /* Initial sphere of influence radius */
+		{ /* Known location (center of SoI) */
+			0, 0,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			SYREEN_BIG_MASK_PMAP_ANIM,
+			SYREEN_MED_MASK_PMAP_ANIM,
+			SYREEN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			DAGGER_BIG_MASK_PMAP_ANIM,
+			DAGGER_MED_MASK_PMAP_ANIM,
+			DAGGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			SYREEN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		SYREEN_VICTORY_SONG,
+		SYREEN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_4XRES * MISSILE_LIFE * 2 / 3),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_dagger (ELEMENT *ShipPtr, HELEMENT DaggerArray[])
 {
@@ -136,7 +292,7 @@ initialize_dagger (ELEMENT *ShipPtr, HEL
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = SYREEN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -188,7 +344,7 @@ spawn_crew (ELEMENT *ElementPtr)
 					&& !elementsOfSamePlayer (ObjPtr, ElementPtr)
 					&& ObjPtr->crew_level > 1)
 			{
-				SIZE dx, dy;
+				SDWORD dx, dy;
 				DWORD d_squared;
 
 				dx = ObjPtr->next.location.x - ElementPtr->next.location.x;
@@ -207,9 +363,14 @@ spawn_crew (ELEMENT *ElementPtr)
 				{
 					COUNT crew_loss;
 
-					crew_loss = ((MAX_ABANDONERS
-							* (ABANDONER_RANGE - square_root (d_squared)))
-							/ ABANDONER_RANGE) + 1;
+					if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+						(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0) || 
+						((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1))))
+					{
+						crew_loss = 0;
+					} else {
+						crew_loss = ((MAX_ABANDONERS * (ABANDONER_RANGE - square_root (d_squared))) / ABANDONER_RANGE) + 1;
+					}
 					if (crew_loss >= ObjPtr->crew_level)
 						crew_loss = ObjPtr->crew_level - 1;
 
@@ -272,12 +433,15 @@ syreen_postprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_syreen (void)
 {
+	
+	static RACE_DESC syreen_desc;
 	RACE_DESC *RaceDescPtr;
 
+	syreen_desc = (RESOLUTION_FACTOR == 0 ? syreen_desc1x : (RESOLUTION_FACTOR == 1 ? syreen_desc2x : syreen_desc4x));
+
 	syreen_desc.postprocess_func = syreen_postprocess;
 	syreen_desc.init_weapon_func = initialize_dagger;
 	syreen_desc.cyborg_control.intelligence_func = syreen_intelligence;
-
 	RaceDescPtr = &syreen_desc;
 
 	return (RaceDescPtr);
diff -ruNp src.orig/uqm/ships/thradd/thradd.c src/uqm/ships/thradd/thradd.c
--- src.orig/uqm/ships/thradd/thradd.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/thradd/thradd.c	2017-12-30 00:14:54 -0800
@@ -38,16 +38,16 @@
 #define WEAPON_WAIT 12
 #define MISSILE_SPEED DISPLAY_TO_WORLD (30)
 #define MISSILE_LIFE 15
-#define MISSILE_OFFSET 3
-#define THRADDASH_OFFSET 9
+#define MISSILE_OFFSET RES_SCALE(3)
+#define THRADDASH_OFFSET RES_SCALE(9)
 #define MISSILE_HITS 2
 #define MISSILE_DAMAGE 1
 
 // Afterburner
 #define SPECIAL_ENERGY_COST 1
 #define SPECIAL_WAIT 0
-#define SPECIAL_THRUST_INCREMENT 12
-#define SPECIAL_MAX_THRUST 72
+#define SPECIAL_THRUST_INCREMENT RES_SCALE(12)
+#define SPECIAL_MAX_THRUST RES_SCALE(72)
 #define NAPALM_LIFE 48
 #define NAPALM_OFFSET 0
 #define NAPALM_HITS 1
@@ -57,9 +57,18 @@
 		 * decay one step (one animation frame) per NAPALM_DECAY_RATE
 		 * frames. */
 #define NUM_NAPALM_FADES 6
+#define STATIONARY_SPEED WORLD_TO_VELOCITY (DISPLAY_TO_WORLD RES_SCALE(4))
 
+// HD
+#define MAX_THRUST_2XRES 56
+#define THRUST_INCREMENT_2XRES 14
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (60)
+#define MAX_THRUST_4XRES 112
+#define THRUST_INCREMENT_4XRES 28
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (120)
 
-static RACE_DESC thraddash_desc =
+
+static RACE_DESC thraddash_desc1x =
 {
 	{ /* SHIP_INFO */
 		"torch",
@@ -131,6 +140,152 @@ static RACE_DESC thraddash_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC thraddash_desc2x =
+{
+	{ /* SHIP_INFO */
+		"torch",
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		THRADDASH_RACE_STRINGS,
+		THRADDASH_ICON_MASK_PMAP_ANIM,
+		THRADDASH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			2535, 8358,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			THRADDASH_BIG_MASK_PMAP_ANIM,
+			THRADDASH_MED_MASK_PMAP_ANIM,
+			THRADDASH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HORN_BIG_MASK_PMAP_ANIM,
+			HORN_MED_MASK_PMAP_ANIM,
+			HORN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NAPALM_BIG_MASK_PMAP_ANIM,
+			NAPALM_MED_MASK_PMAP_ANIM,
+			NAPALM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			THRADDASH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		THRADDASH_VICTORY_SONG,
+		THRADDASH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_2XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC thraddash_desc4x =
+{
+	{ /* SHIP_INFO */
+		"torch",
+		FIRES_FORE,
+		10, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		THRADDASH_RACE_STRINGS,
+		THRADDASH_ICON_MASK_PMAP_ANIM,
+		THRADDASH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			2535, 8358,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			THRADDASH_BIG_MASK_PMAP_ANIM,
+			THRADDASH_MED_MASK_PMAP_ANIM,
+			THRADDASH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			HORN_BIG_MASK_PMAP_ANIM,
+			HORN_MED_MASK_PMAP_ANIM,
+			HORN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NAPALM_BIG_MASK_PMAP_ANIM,
+			NAPALM_MED_MASK_PMAP_ANIM,
+			NAPALM_SML_MASK_PMAP_ANIM,
+		},
+		{
+			THRADDASH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		THRADDASH_VICTORY_SONG,
+		THRADDASH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(MISSILE_SPEED_4XRES * MISSILE_LIFE) >> 1,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 thraddash_intelligence (ELEMENT *ShipPtr, EVALUATE_DESC *ObjectsOfConcern,
 		COUNT ConcernCounter)
@@ -142,10 +297,9 @@ thraddash_intelligence (ELEMENT *ShipPtr
 	lpEvalDesc = &ObjectsOfConcern[ENEMY_SHIP_INDEX];
 	if (lpEvalDesc->ObjectPtr)
 	{
-#define STATIONARY_SPEED WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (4))
-		SIZE dx, dy;
+		SDWORD dx, dy;
 
-		GetCurrentVelocityComponents (
+		GetCurrentVelocityComponentsSdword (
 				&lpEvalDesc->ObjectPtr->velocity, &dx, &dy
 				);
 		if (lpEvalDesc->which_turn > 8
@@ -190,7 +344,7 @@ thraddash_intelligence (ELEMENT *ShipPtr
 			else if (lpEvalDesc->MoveState == ENTICE)
 			{
 				COUNT direction_angle;
-				SIZE delta_x, delta_y;
+				SDWORD delta_x, delta_y;
 
 				delta_x = lpEvalDesc->ObjectPtr->next.location.x
 						- ShipPtr->next.location.x;
@@ -275,7 +429,7 @@ initialize_horn (ELEMENT *ShipPtr, HELEM
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = THRADDASH_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -389,8 +543,11 @@ thraddash_preprocess (ELEMENT *ElementPt
 RACE_DESC*
 init_thraddash (void)
 {
+	static RACE_DESC thraddash_desc;
 	RACE_DESC *RaceDescPtr;
 
+	thraddash_desc = (RESOLUTION_FACTOR == 0 ? thraddash_desc1x : (RESOLUTION_FACTOR == 1 ? thraddash_desc2x : thraddash_desc4x));
+
 	thraddash_desc.preprocess_func = thraddash_preprocess;
 	thraddash_desc.init_weapon_func = initialize_horn;
 	thraddash_desc.cyborg_control.intelligence_func = thraddash_intelligence;
diff -ruNp src.orig/uqm/ships/umgah/umgah.c src/uqm/ships/umgah/umgah.c
--- src.orig/uqm/ships/umgah/umgah.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/umgah/umgah.c	2017-12-30 00:14:54 -0800
@@ -46,9 +46,15 @@
 // Retropropulsion
 #define SPECIAL_ENERGY_COST 1
 #define SPECIAL_WAIT 2
-#define JUMP_DIST DISPLAY_TO_WORLD (40)
+#define JUMP_DIST DISPLAY_TO_WORLD RES_SCALE(40)
 
-static RACE_DESC umgah_desc =
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (5) */ 36
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 12
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (5) */ 72
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 24
+
+static RACE_DESC umgah_desc1x =
 {
 	{ /* SHIP_INFO */
 		"drone",
@@ -120,6 +126,152 @@ static RACE_DESC umgah_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC umgah_desc2x =
+{
+	{ /* SHIP_INFO */
+		"drone",
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		7, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		UMGAH_RACE_STRINGS,
+		UMGAH_ICON_MASK_PMAP_ANIM,
+		UMGAH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			1798, 6000,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UMGAH_BIG_MASK_PMAP_ANIM,
+			UMGAH_MED_MASK_PMAP_ANIM,
+			UMGAH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPRITZ_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			CONE_BIG_MASK_ANIM,
+			CONE_MED_MASK_ANIM,
+			CONE_SML_MASK_ANIM,
+		},
+		{
+			UMGAH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UMGAH_VICTORY_SONG,
+		UMGAH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(LONG_RANGE_WEAPON_2XRES << 2),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC umgah_desc4x =
+{
+	{ /* SHIP_INFO */
+		"drone",
+		FIRES_FORE | IMMEDIATE_WEAPON,
+		7, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		UMGAH_RACE_STRINGS,
+		UMGAH_ICON_MASK_PMAP_ANIM,
+		UMGAH_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		833 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			1798, 6000,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UMGAH_BIG_MASK_PMAP_ANIM,
+			UMGAH_MED_MASK_PMAP_ANIM,
+			UMGAH_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPRITZ_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			CONE_BIG_MASK_ANIM,
+			CONE_MED_MASK_ANIM,
+			CONE_SML_MASK_ANIM,
+		},
+		{
+			UMGAH_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UMGAH_VICTORY_SONG,
+		UMGAH_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		(LONG_RANGE_WEAPON_4XRES << 2),
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 
 // Private per-instance ship data
 typedef struct
@@ -226,7 +378,7 @@ umgah_intelligence (ELEMENT *ShipPtr, EV
 	else
 	{
 		BYTE this_turn;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 		BOOLEAN EnemyBehind, EnoughJuice;
 
 		if (lpEvalDesc->which_turn >= 0xFF + 1)
@@ -234,10 +386,10 @@ umgah_intelligence (ELEMENT *ShipPtr, EV
 		else
 			this_turn = (BYTE)lpEvalDesc->which_turn;
 
-		EnoughJuice = (BOOLEAN)(WORLD_TO_TURN (
+		EnoughJuice = (BOOLEAN)((WORLD_TO_TURN (
 				JUMP_DIST * StarShipPtr->RaceDescPtr->ship_info.energy_level
 				/ SPECIAL_ENERGY_COST
-				) > this_turn);
+				) >> RESOLUTION_FACTOR) > this_turn); // JMS_GFX
 		delta_x = lpEvalDesc->ObjectPtr->next.location.x -
 				ShipPtr->next.location.x;
 		delta_y = lpEvalDesc->ObjectPtr->next.location.y -
@@ -255,7 +407,7 @@ umgah_intelligence (ELEMENT *ShipPtr, EV
 				|| (this_turn > 6
 				&& MANEUVERABILITY (
 				&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-				) <= SLOW_SHIP)
+				) <= RESOLUTION_COMPENSATED(SLOW_SHIP)) // JMS_GFX
 				|| (this_turn >= 16 && this_turn <= 24)))
 			StarShipPtr->RaceDescPtr->cyborg_control.WeaponRange = (LONG_RANGE_WEAPON << 3);
 		else
@@ -420,8 +572,11 @@ uninit_umgah (RACE_DESC *pRaceDesc)
 RACE_DESC*
 init_umgah (void)
 {
+	static RACE_DESC umgah_desc;
 	RACE_DESC *RaceDescPtr;
 
+	umgah_desc = (RESOLUTION_FACTOR == 0 ? umgah_desc1x : (RESOLUTION_FACTOR == 1 ? umgah_desc2x : umgah_desc4x));
+
 	umgah_desc.uninit_func = uninit_umgah;
 	umgah_desc.preprocess_func = umgah_preprocess;
 	umgah_desc.postprocess_func = umgah_postprocess;
diff -ruNp src.orig/uqm/ships/urquan/urquan.c src/uqm/ships/urquan/urquan.c
--- src.orig/uqm/ships/urquan/urquan.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/urquan/urquan.c	2017-12-30 00:14:54 -0800
@@ -19,9 +19,10 @@
 #include "../ship.h"
 #include "urquan.h"
 #include "resinst.h"
-
+#include "../../intel.h"
 #include "uqm/globdata.h"
-
+#include "../../setup.h"
+#include "uqm/colors.h"
 #include <stdlib.h>
 
 // Core characteristics
@@ -42,23 +43,31 @@
 #define MISSILE_LIFE 20
 #define MISSILE_HITS 10
 #define MISSILE_DAMAGE 6
-#define MISSILE_OFFSET 8
-#define URQUAN_OFFSET 32
+#define MISSILE_OFFSET RES_SCALE(8)
+#define URQUAN_OFFSET RES_SCALE(32)
 
 // Fighters
 #define SPECIAL_ENERGY_COST 8
 #define SPECIAL_WAIT 9
-#define FIGHTER_OFFSET 4
-#define FIGHTER_SPEED DISPLAY_TO_WORLD (8)
+#define FIGHTER_OFFSET RES_SCALE(4)
+#define FIGHTER_SPEED DISPLAY_TO_WORLD RES_SCALE(8)
 #define ONE_WAY_FLIGHT 125
 #define TRACK_THRESHOLD 6
 #define FIGHTER_LIFE (ONE_WAY_FLIGHT + ONE_WAY_FLIGHT + 150)
 #define FIGHTER_HITS 1
 #define FIGHTER_MASS 0
 #define FIGHTER_WEAPON_WAIT 8
-#define FIGHTER_LASER_RANGE DISPLAY_TO_WORLD (40 + FIGHTER_OFFSET)
+#define FIGHTER_LASER_RANGE DISPLAY_TO_WORLD (RES_SCALE(40) + FIGHTER_OFFSET)
+
+// HD
+#define MAX_THRUST_2XRES 60
+#define THRUST_INCREMENT_2XRES 12
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (40)
+#define MAX_THRUST_4XRES 120
+#define THRUST_INCREMENT_4XRES 24
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (80)
 
-static RACE_DESC urquan_desc =
+static RACE_DESC urquan_desc1x =
 {
 	{ /* SHIP_INFO */
 		"dreadnought",
@@ -130,6 +139,152 @@ static RACE_DESC urquan_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC urquan_desc2x =
+{
+	{ /* SHIP_INFO */
+		"dreadnought",
+		FIRES_FORE | SEEKING_SPECIAL,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		URQUAN_RACE_STRINGS,
+		URQUAN_ICON_MASK_PMAP_ANIM,
+		URQUAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			5750, 6000,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			URQUAN_BIG_MASK_PMAP_ANIM,
+			URQUAN_MED_MASK_PMAP_ANIM,
+			URQUAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FUSION_BIG_MASK_PMAP_ANIM,
+			FUSION_MED_MASK_PMAP_ANIM,
+			FUSION_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIGHTER_BIG_MASK_PMAP_ANIM,
+			FIGHTER_MED_MASK_PMAP_ANIM,
+			FIGHTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			URQUAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		URQUAN_VICTORY_SONG,
+		URQUAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC urquan_desc4x =
+{
+	{ /* SHIP_INFO */
+		"dreadnought",
+		FIRES_FORE | SEEKING_SPECIAL,
+		30, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		URQUAN_RACE_STRINGS,
+		URQUAN_ICON_MASK_PMAP_ANIM,
+		URQUAN_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		2666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			5750, 6000,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			URQUAN_BIG_MASK_PMAP_ANIM,
+			URQUAN_MED_MASK_PMAP_ANIM,
+			URQUAN_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FUSION_BIG_MASK_PMAP_ANIM,
+			FUSION_MED_MASK_PMAP_ANIM,
+			FUSION_SML_MASK_PMAP_ANIM,
+		},
+		{
+			FIGHTER_BIG_MASK_PMAP_ANIM,
+			FIGHTER_MED_MASK_PMAP_ANIM,
+			FIGHTER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			URQUAN_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		URQUAN_VICTORY_SONG,
+		URQUAN_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_fusion (ELEMENT *ShipPtr, HELEMENT FusionArray[])
 {
@@ -144,7 +299,7 @@ initialize_fusion (ELEMENT *ShipPtr, HEL
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = URQUAN_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -205,7 +360,7 @@ fighter_preprocess (ELEMENT *ElementPtr)
 	{
 		BOOLEAN Enroute;
 		COUNT orig_facing, facing;
-		SIZE delta_x, delta_y;
+		SDWORD delta_x, delta_y;
 		ELEMENT *eptr;
 
 		Enroute = TRUE;
@@ -278,16 +433,16 @@ fighter_preprocess (ELEMENT *ElementPtr)
 				if (ElementPtr->turn_wait & LEFT)
 				{
 					delta_x += COSINE (FACING_TO_ANGLE (facing - 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD RES_SCALE(30));
 					delta_y += SINE (FACING_TO_ANGLE (facing - 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD RES_SCALE(30));
 				}
 				else
 				{
 					delta_x += COSINE (FACING_TO_ANGLE (facing + 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD RES_SCALE(30));
 					delta_y += SINE (FACING_TO_ANGLE (facing + 4),
-							DISPLAY_TO_WORLD (30));
+							DISPLAY_TO_WORLD RES_SCALE(30));
 				}
 				facing = NORMALIZE_FACING (
 						ANGLE_TO_FACING (ARCTAN (delta_x, delta_y))
@@ -398,23 +553,30 @@ spawn_fighters (ELEMENT *ElementPtr)
 {
 	SIZE i;
 	COUNT facing;
-	SIZE delta_x, delta_y;
+	SDWORD delta_x, delta_y;
 	HELEMENT hFighterElement;
 	STARSHIP *StarShipPtr;
 
 	GetElementStarShip (ElementPtr, &StarShipPtr);
 	facing = StarShipPtr->ShipFacing + ANGLE_TO_FACING (HALF_CIRCLE);
-	delta_x = COSINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14));
-	delta_y = SINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD (14));
+	delta_x = COSINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD RES_SCALE(14));
+	delta_y = SINE (FACING_TO_ANGLE (facing), DISPLAY_TO_WORLD RES_SCALE(14));
 
 	i = ElementPtr->crew_level > 2 ? 2 : 1;
 	while (i-- && (hFighterElement = AllocElement ()))
 	{
-		SIZE sx, sy;
+		SDWORD sx, sy;
 		COUNT fighter_facing;
 		ELEMENT *FighterElementPtr;
 
-		DeltaCrew (ElementPtr, -1);
+		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+			(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr->playerNr == 1) || 
+			((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr->playerNr == 0))))
+		{
+			//DeltaCrew (ElementPtr, -1);
+		} else {
+			DeltaCrew (ElementPtr, -1);
+		}
 
 		PutElement (hFighterElement);
 		LockElement (hFighterElement, &FighterElementPtr);
@@ -505,12 +667,13 @@ urquan_intelligence (ELEMENT *ShipPtr, E
 				&& (StarShipPtr->RaceDescPtr->characteristics.special_wait < 6
 				|| (MANEUVERABILITY (
 						&EnemyStarShipPtr->RaceDescPtr->cyborg_control
-						) <= SLOW_SHIP
+						) <= RESOLUTION_COMPENSATED(SLOW_SHIP)
 				&& !(EnemyStarShipPtr->cur_status_flags & SHIP_BEYOND_MAX_SPEED))
 				|| (lpEvalDesc->which_turn <= 12
 				&& (StarShipPtr->ship_input_state & (LEFT | RIGHT))
 				&& StarShipPtr->RaceDescPtr->ship_info.energy_level >=
-				(BYTE)(StarShipPtr->RaceDescPtr->ship_info.max_energy >> 1))))
+				(BYTE)(StarShipPtr->RaceDescPtr->ship_info.max_energy >> 1)))
+				&& !OBJECT_CLOAKED (lpEvalDesc->ObjectPtr))
 			StarShipPtr->ship_input_state |= SPECIAL;
 		else
 			StarShipPtr->ship_input_state &= ~SPECIAL;
@@ -542,8 +705,11 @@ urquan_postprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_urquan (void)
 {
+	static RACE_DESC urquan_desc;
 	RACE_DESC *RaceDescPtr;
 
+	urquan_desc = (RESOLUTION_FACTOR == 0 ? urquan_desc1x : (RESOLUTION_FACTOR == 1 ? urquan_desc2x : urquan_desc4x));
+
 	urquan_desc.postprocess_func = urquan_postprocess;
 	urquan_desc.init_weapon_func = initialize_fusion;
 	urquan_desc.cyborg_control.intelligence_func = urquan_intelligence;
diff -ruNp src.orig/uqm/ships/utwig/utwig.c src/uqm/ships/utwig/utwig.c
--- src.orig/uqm/ships/utwig/utwig.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/utwig/utwig.c	2017-12-30 00:14:54 -0800
@@ -38,23 +38,29 @@
 #define WEAPON_ENERGY_COST 0
 #define WEAPON_WAIT 7
 #define UTWIG_OFFSET 9
-#define MISSILE_SPEED DISPLAY_TO_WORLD (30)
+#define MISSILE_SPEED DISPLAY_TO_WORLD RES_SCALE(30)
 #define MISSILE_LIFE 10
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
-#define LAUNCH_XOFFS0 DISPLAY_TO_WORLD (5)
-#define LAUNCH_YOFFS0 -DISPLAY_TO_WORLD (18)
-#define LAUNCH_XOFFS1 DISPLAY_TO_WORLD (13)
-#define LAUNCH_YOFFS1 -DISPLAY_TO_WORLD (9)
-#define LAUNCH_XOFFS2 DISPLAY_TO_WORLD (17)
-#define LAUNCH_YOFFS2 -DISPLAY_TO_WORLD (4)
+#define MISSILE_OFFSET RES_SCALE(1)
+#define LAUNCH_XOFFS0 DISPLAY_TO_WORLD RES_SCALE(5)
+#define LAUNCH_YOFFS0 -DISPLAY_TO_WORLD RES_SCALE(18)
+#define LAUNCH_XOFFS1 DISPLAY_TO_WORLD RES_SCALE(13)
+#define LAUNCH_YOFFS1 -DISPLAY_TO_WORLD RES_SCALE(9)
+#define LAUNCH_XOFFS2 DISPLAY_TO_WORLD RES_SCALE(17)
+#define LAUNCH_YOFFS2 -DISPLAY_TO_WORLD RES_SCALE(4)
 
 // Shield
 #define SPECIAL_ENERGY_COST 1
 #define SPECIAL_WAIT 12
 
-static RACE_DESC utwig_desc =
+// HD
+#define MAX_THRUST_2XRES 72
+#define THRUST_INCREMENT_2XRES 12
+#define MAX_THRUST_4XRES 144
+#define THRUST_INCREMENT_4XRES 24
+
+static RACE_DESC utwig_desc1x =
 {
 	{ /* SHIP_INFO */
 		"jugger",
@@ -126,6 +132,152 @@ static RACE_DESC utwig_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC utwig_desc2x =
+{
+	{ /* SHIP_INFO */
+		"jugger",
+		FIRES_FORE | SHIELD_DEFENSE | LIGHT_POINT_DEFENSE,
+		22, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY >> 1, MAX_ENERGY,
+		UTWIG_RACE_STRINGS,
+		UTWIG_ICON_MASK_PMAP_ANIM,
+		UTWIG_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			8534, 8797,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UTWIG_BIG_MASK_PMAP_ANIM,
+			UTWIG_MED_MASK_PMAP_ANIM,
+			UTWIG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LANCE_BIG_MASK_PMAP_ANIM,
+			LANCE_MED_MASK_PMAP_ANIM,
+			LANCE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			UTWIG_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UTWIG_VICTORY_SONG,
+		UTWIG_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC utwig_desc4x =
+{
+	{ /* SHIP_INFO */
+		"jugger",
+		FIRES_FORE | SHIELD_DEFENSE | LIGHT_POINT_DEFENSE,
+		22, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY >> 1, MAX_ENERGY,
+		UTWIG_RACE_STRINGS,
+		UTWIG_ICON_MASK_PMAP_ANIM,
+		UTWIG_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		666 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			8534, 8797,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			UTWIG_BIG_MASK_PMAP_ANIM,
+			UTWIG_MED_MASK_PMAP_ANIM,
+			UTWIG_SML_MASK_PMAP_ANIM,
+		},
+		{
+			LANCE_BIG_MASK_PMAP_ANIM,
+			LANCE_MED_MASK_PMAP_ANIM,
+			LANCE_SML_MASK_PMAP_ANIM,
+		},
+		{
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			UTWIG_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		UTWIG_VICTORY_SONG,
+		UTWIG_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_lance (ELEMENT *ShipPtr, HELEMENT WeaponArray[])
 {
@@ -368,8 +520,11 @@ utwig_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_utwig (void)
 {
+	static RACE_DESC utwig_desc;
 	RACE_DESC *RaceDescPtr;
 
+	utwig_desc = (RESOLUTION_FACTOR == 0 ? utwig_desc1x : (RESOLUTION_FACTOR == 1 ? utwig_desc2x : utwig_desc4x));
+
 	utwig_desc.preprocess_func = utwig_preprocess;
 	utwig_desc.init_weapon_func = initialize_lance;
 	utwig_desc.cyborg_control.intelligence_func = utwig_intelligence;
diff -ruNp src.orig/uqm/ships/vux/vux.c src/uqm/ships/vux/vux.c
--- src.orig/uqm/ships/vux/vux.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/vux/vux.c	2017-12-30 00:14:54 -0800
@@ -19,7 +19,7 @@
 #include "../ship.h"
 #include "vux.h"
 #include "resinst.h"
-
+#include "../../setup.h"
 #include "uqm/globdata.h"
 #include "libs/mathlib.h"
 
@@ -37,22 +37,22 @@
 // Laser
 #define WEAPON_ENERGY_COST 1
 #define WEAPON_WAIT 0
-#define VUX_OFFSET 12
-#define LASER_BASE 150
+#define VUX_OFFSET RES_SCALE(12)
+#define LASER_BASE RES_SCALE(150)
 #define LASER_RANGE DISPLAY_TO_WORLD (LASER_BASE + VUX_OFFSET)
 
 // Limpet
 #define SPECIAL_ENERGY_COST 2
 #define SPECIAL_WAIT 7
-#define LIMPET_SPEED 25
-#define LIMPET_OFFSET 8
+#define LIMPET_SPEED RES_SCALE(25)
+#define LIMPET_OFFSET RES_SCALE(8)
 #define LIMPET_LIFE 80
 #define LIMPET_HITS 1
 #define LIMPET_DAMAGE 0
-#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD (1)
+#define MIN_THRUST_INCREMENT DISPLAY_TO_WORLD RES_SCALE(1)
 
 // Aggressive Entry
-#define WARP_OFFSET 46
+#define WARP_OFFSET RES_SCALE(46)
 		/* How far outside of the laser range can the ship warp in. */
 #define MAXX_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
 #define MAXY_ENTRY_DIST DISPLAY_TO_WORLD ((LASER_BASE + VUX_OFFSET + WARP_OFFSET) << 1)
@@ -61,7 +61,13 @@
 		 * where SPACE_HEIGHT = SCREEN_HEIGHT - (SAFE_Y * 2)
 		 * But in reality this should be relative to the laser-range. */
 
-static RACE_DESC vux_desc =
+// HD
+#define MAX_THRUST_2XRES /* DISPLAY_TO_WORLD (5) */ 42
+#define THRUST_INCREMENT_2XRES /* DISPLAY_TO_WORLD (2) */ 14
+#define MAX_THRUST_4XRES /* DISPLAY_TO_WORLD (5) */ 84
+#define THRUST_INCREMENT_4XRES /* DISPLAY_TO_WORLD (2) */ 28
+
+static RACE_DESC vux_desc1x =
 {
 	{ /* SHIP_INFO */
 		"intruder",
@@ -133,6 +139,152 @@ static RACE_DESC vux_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC vux_desc2x =
+{
+	{ /* SHIP_INFO */
+		"intruder",
+		FIRES_FORE | SEEKING_SPECIAL | IMMEDIATE_WEAPON,
+		12, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		VUX_RACE_STRINGS,
+		VUX_ICON_MASK_PMAP_ANIM,
+		VUX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		900 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			4412, 1558,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			VUX_BIG_MASK_PMAP_ANIM,
+			VUX_MED_MASK_PMAP_ANIM,
+			VUX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SLIME_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			LIMPETS_BIG_MASK_PMAP_ANIM,
+			LIMPETS_MED_MASK_PMAP_ANIM,
+			LIMPETS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			VUX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		VUX_VICTORY_SONG,
+		VUX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC vux_desc4x =
+{
+	{ /* SHIP_INFO */
+		"intruder",
+		FIRES_FORE | SEEKING_SPECIAL | IMMEDIATE_WEAPON,
+		12, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		VUX_RACE_STRINGS,
+		VUX_ICON_MASK_PMAP_ANIM,
+		VUX_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		900 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			4412, 1558,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			VUX_BIG_MASK_PMAP_ANIM,
+			VUX_MED_MASK_PMAP_ANIM,
+			VUX_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SLIME_MASK_PMAP_ANIM,
+			NULL_RESOURCE,
+			NULL_RESOURCE,
+		},
+		{
+			LIMPETS_BIG_MASK_PMAP_ANIM,
+			LIMPETS_MED_MASK_PMAP_ANIM,
+			LIMPETS_SML_MASK_PMAP_ANIM,
+		},
+		{
+			VUX_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		VUX_VICTORY_SONG,
+		VUX_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		CLOSE_RANGE_WEAPON_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 
 static void
 limpet_preprocess (ELEMENT *ElementPtr)
@@ -155,47 +307,41 @@ limpet_preprocess (ELEMENT *ElementPtr)
 }
 
 static void
-limpet_collision (ELEMENT *ElementPtr0, POINT *pPt0,
-		ELEMENT *ElementPtr1, POINT *pPt1)
-{
-	if (ElementPtr1->state_flags & PLAYER_SHIP)
-	{
-		STAMP s;
-		STARSHIP *StarShipPtr;
-		RACE_DESC *RDPtr;
-
+limpet_collision (ELEMENT *ElementPtr0, POINT *pPt0, ELEMENT *ElementPtr1, POINT *pPt1) {
+	STAMP s;
+	STARSHIP *StarShipPtr;
+	RACE_DESC *RDPtr;
+	if (ElementPtr1->state_flags & PLAYER_SHIP) {
 		GetElementStarShip (ElementPtr1, &StarShipPtr);
 		RDPtr = StarShipPtr->RaceDescPtr;
-
-		if (++RDPtr->characteristics.turn_wait == 0)
-			--RDPtr->characteristics.turn_wait;
-		if (++RDPtr->characteristics.thrust_wait == 0)
-			--RDPtr->characteristics.thrust_wait;
-		if (RDPtr->characteristics.thrust_increment <= MIN_THRUST_INCREMENT)
+		if (!(PlayerControl[0] & COMPUTER_CONTROL && PlayerControl[1] & COMPUTER_CONTROL) && ((optGodMode) && 
+			(((PlayerControl[0] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 1) || 
+			((PlayerControl[1] & COMPUTER_CONTROL) && ElementPtr1->playerNr == 0))))
 		{
-			RDPtr->characteristics.max_thrust =
-					RDPtr->characteristics.thrust_increment << 1;
+			RDPtr->cyborg_control.ManeuverabilityIndex = 0;
+			GetElementStarShip (ElementPtr0, &StarShipPtr);
+			ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1); // LIMPET_AFFIXES
+			s.frame = SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.weapon[0], (COUNT)TFB_Random ());
+			ModifySilhouette (ElementPtr1, &s, MODIFY_IMAGE);
+		} else {
+			if (++RDPtr->characteristics.turn_wait == 0)
+				--RDPtr->characteristics.turn_wait;
+			if (++RDPtr->characteristics.thrust_wait == 0)
+				--RDPtr->characteristics.thrust_wait;
+			if (RDPtr->characteristics.thrust_increment <= MIN_THRUST_INCREMENT) {
+				RDPtr->characteristics.max_thrust = RDPtr->characteristics.thrust_increment << 1;
+			} else {
+				COUNT num_thrusts;
+				num_thrusts = RDPtr->characteristics.max_thrust / RDPtr->characteristics.thrust_increment;
+				RDPtr->characteristics.thrust_increment -= RES_SCALE(1);
+				RDPtr->characteristics.max_thrust = RDPtr->characteristics.thrust_increment * num_thrusts;
+			}
+			RDPtr->cyborg_control.ManeuverabilityIndex = 0;
+			GetElementStarShip (ElementPtr0, &StarShipPtr);
+			ProcessSound (SetAbsSoundIndex (StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1); // LIMPET_AFFIXES
+			s.frame = SetAbsFrameIndex (StarShipPtr->RaceDescPtr->ship_data.weapon[0], (COUNT)TFB_Random ());
+			ModifySilhouette (ElementPtr1, &s, MODIFY_IMAGE);
 		}
-		else
-		{
-			COUNT num_thrusts;
-
-			num_thrusts = RDPtr->characteristics.max_thrust /
-					RDPtr->characteristics.thrust_increment;
-			--RDPtr->characteristics.thrust_increment;
-			RDPtr->characteristics.max_thrust =
-					RDPtr->characteristics.thrust_increment * num_thrusts;
-		}
-		RDPtr->cyborg_control.ManeuverabilityIndex = 0;
-
-		GetElementStarShip (ElementPtr0, &StarShipPtr);
-		ProcessSound (SetAbsSoundIndex (
-						/* LIMPET_AFFIXES */
-				StarShipPtr->RaceDescPtr->ship_data.ship_sounds, 2), ElementPtr1);
-		s.frame = SetAbsFrameIndex (
-				StarShipPtr->RaceDescPtr->ship_data.weapon[0], (COUNT)TFB_Random ()
-				);
-		ModifySilhouette (ElementPtr1, &s, MODIFY_IMAGE);
 	}
 
 	ElementPtr0->hit_points = 0;
@@ -334,36 +480,37 @@ vux_preprocess (ELEMENT *ElementPtr)
 				&& TrackShip (ElementPtr, &facing) >= 0)
 		{
 			ELEMENT *OtherShipPtr;
-
+			SDWORD SA_MATRA_EXTRA_DIST = 0;
 			LockElement (ElementPtr->hTarget, &OtherShipPtr);
 
-			do
-			{
-				SIZE dx, dy;
+			// JMS: Not REALLY necessary as VUX can ordinarily never be played against Sa-Matra. 
+            // But handy in debugging as a single VUX limpet incapacitates Sa-Matra completely.
+            if (LOBYTE (GLOBAL (CurrentActivity)) == IN_LAST_BATTLE) {
+				SA_MATRA_EXTRA_DIST += RES_SCALE(1000);
+			}
+			do {
+                // JMS_GFX: Circumventing overflows by using temp variables instead of
+                // subtracting straight from the POINT sized ShipImagePtr->current.location.
+				SDWORD dx, dy;
 
-				ElementPtr->current.location.x =
-						(OtherShipPtr->current.location.x -
+				SDWORD temp_x =
+						((SDWORD)OtherShipPtr->current.location.x -
 						(MAXX_ENTRY_DIST >> 1)) +
 						((COUNT)TFB_Random () % MAXX_ENTRY_DIST);
-				ElementPtr->current.location.y =
-						(OtherShipPtr->current.location.y -
+				SDWORD temp_y =
+						((SDWORD)OtherShipPtr->current.location.y -
 						(MAXY_ENTRY_DIST >> 1)) +
 						((COUNT)TFB_Random () % MAXY_ENTRY_DIST);
-				dx = OtherShipPtr->current.location.x -
-						ElementPtr->current.location.x;
-				dy = OtherShipPtr->current.location.y -
-						ElementPtr->current.location.y;
-				facing = NORMALIZE_FACING (
-						ANGLE_TO_FACING (ARCTAN (dx, dy))
-						);
-				ElementPtr->current.image.frame =
-						SetAbsFrameIndex (ElementPtr->current.image.frame,
-						facing);
-
-				ElementPtr->current.location.x =
-						WRAP_X (DISPLAY_ALIGN (ElementPtr->current.location.x));
-				ElementPtr->current.location.y =
-						WRAP_Y (DISPLAY_ALIGN (ElementPtr->current.location.y));
+				temp_x += temp_x > 0 ? SA_MATRA_EXTRA_DIST : -SA_MATRA_EXTRA_DIST;
+				temp_y += temp_y > 0 ? SA_MATRA_EXTRA_DIST : -SA_MATRA_EXTRA_DIST;
+                
+				dx = OtherShipPtr->current.location.x - temp_x;
+				dy = OtherShipPtr->current.location.y - temp_y;
+				facing = NORMALIZE_FACING ( ANGLE_TO_FACING (ARCTAN (dx, dy)) );
+				ElementPtr->current.image.frame = SetAbsFrameIndex (ElementPtr->current.image.frame, facing);
+
+				ElementPtr->current.location.x = WRAP_X (DISPLAY_ALIGN (temp_x));
+				ElementPtr->current.location.y = WRAP_Y (DISPLAY_ALIGN (temp_y));
 			} while (CalculateGravity (ElementPtr)
 					|| TimeSpaceMatterConflict (ElementPtr));
 
@@ -385,8 +532,11 @@ vux_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_vux (void)
 {
+	static RACE_DESC vux_desc;
 	RACE_DESC *RaceDescPtr;
 
+	vux_desc = (RESOLUTION_FACTOR == 0 ? vux_desc1x : (RESOLUTION_FACTOR == 1 ? vux_desc2x : vux_desc4x));
+
 	vux_desc.preprocess_func = vux_preprocess;
 	vux_desc.postprocess_func = vux_postprocess;
 	vux_desc.init_weapon_func = initialize_horrific_laser;
diff -ruNp src.orig/uqm/ships/yehat/yehat.c src/uqm/ships/yehat/yehat.c
--- src.orig/uqm/ships/yehat/yehat.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/yehat/yehat.c	2017-12-30 00:14:54 -0800
@@ -36,20 +36,28 @@
 // Twin Pulse Cannon
 #define WEAPON_ENERGY_COST 1
 #define WEAPON_WAIT 0
-#define YEHAT_OFFSET 16
-#define LAUNCH_OFFS DISPLAY_TO_WORLD (8)
+#define YEHAT_OFFSET RES_SCALE(16)
+#define LAUNCH_OFFS DISPLAY_TO_WORLD RES_SCALE(8)
 #define MISSILE_SPEED DISPLAY_TO_WORLD (20)
 #define MISSILE_LIFE 10
 #define MISSILE_HITS 1
 #define MISSILE_DAMAGE 1
-#define MISSILE_OFFSET 1
+#define MISSILE_OFFSET RES_SCALE(1)
 
 // Force Shield
 #define SPECIAL_ENERGY_COST 3
 #define SPECIAL_WAIT 2
 #define SHIELD_LIFE 10
 
-static RACE_DESC yehat_desc =
+// HD
+#define MAX_THRUST_2XRES 60
+#define THRUST_INCREMENT_2XRES 12
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (40)
+#define MAX_THRUST_4XRES 120
+#define THRUST_INCREMENT_4XRES 24
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (80)
+
+static RACE_DESC yehat_desc1x =
 {
 	{ /* SHIP_INFO */
 		"terminator",
@@ -121,10 +129,156 @@ static RACE_DESC yehat_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC yehat_desc2x =
+{
+	{ /* SHIP_INFO */
+		"terminator",
+		FIRES_FORE | SHIELD_DEFENSE,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		YEHAT_RACE_STRINGS,
+		YEHAT_ICON_MASK_PMAP_ANIM,
+		YEHAT_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		750 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			4970, 40,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			YEHAT_BIG_MASK_PMAP_ANIM,
+			YEHAT_MED_MASK_PMAP_ANIM,
+			YEHAT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YEHAT_CANNON_BIG_MASK_PMAP_ANIM,
+			YEHAT_CANNON_MED_MASK_PMAP_ANIM,
+			YEHAT_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SHIELD_BIG_MASK_ANIM,
+			SHIELD_MED_MASK_ANIM,
+			SHIELD_SML_MASK_ANIM,
+		},
+		{
+			YEHAT_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		YEHAT_VICTORY_SONG,
+		YEHAT_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_2XRES * MISSILE_LIFE / 3,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC yehat_desc4x =
+{
+	{ /* SHIP_INFO */
+		"terminator",
+		FIRES_FORE | SHIELD_DEFENSE,
+		23, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		YEHAT_RACE_STRINGS,
+		YEHAT_ICON_MASK_PMAP_ANIM,
+		YEHAT_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		750 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			4970, 40,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			YEHAT_BIG_MASK_PMAP_ANIM,
+			YEHAT_MED_MASK_PMAP_ANIM,
+			YEHAT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			YEHAT_CANNON_BIG_MASK_PMAP_ANIM,
+			YEHAT_CANNON_MED_MASK_PMAP_ANIM,
+			YEHAT_CANNON_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SHIELD_BIG_MASK_ANIM,
+			SHIELD_MED_MASK_ANIM,
+			SHIELD_SML_MASK_ANIM,
+		},
+		{
+			YEHAT_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		YEHAT_VICTORY_SONG,
+		YEHAT_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_SPEED_4XRES * MISSILE_LIFE / 3,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static COUNT
 initialize_standard_missiles (ELEMENT *ShipPtr, HELEMENT MissileArray[])
 {
-	SIZE offs_x, offs_y;
+	SDWORD offs_x, offs_y;
 	STARSHIP *StarShipPtr;
 	MISSILE_BLOCK MissileBlock;
 
@@ -134,7 +288,7 @@ initialize_standard_missiles (ELEMENT *S
 	MissileBlock.sender = ShipPtr->playerNr;
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = YEHAT_OFFSET;
-	MissileBlock.speed = MISSILE_SPEED;
+	MissileBlock.speed = RES_SCALE(MISSILE_SPEED);
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -357,8 +511,11 @@ yehat_preprocess (ELEMENT *ElementPtr)
 RACE_DESC*
 init_yehat (void)
 {
+	static RACE_DESC yehat_desc;
 	RACE_DESC *RaceDescPtr;
 
+	yehat_desc = (RESOLUTION_FACTOR == 0 ? yehat_desc1x : (RESOLUTION_FACTOR == 1 ? yehat_desc2x : yehat_desc4x));
+
 	yehat_desc.preprocess_func = yehat_preprocess;
 	yehat_desc.postprocess_func = yehat_postprocess;
 	yehat_desc.init_weapon_func = initialize_standard_missiles;
diff -ruNp src.orig/uqm/ships/zoqfot/zoqfot.c src/uqm/ships/zoqfot/zoqfot.c
--- src.orig/uqm/ships/zoqfot/zoqfot.c	2017-12-30 00:14:41 -0800
+++ src/uqm/ships/zoqfot/zoqfot.c	2017-12-30 00:14:54 -0800
@@ -36,7 +36,7 @@
 // Main weapon
 #define WEAPON_ENERGY_COST 1
 #define WEAPON_WAIT 0
-#define ZOQFOTPIK_OFFSET 13
+#define ZOQFOTPIK_OFFSET RES_SCALE(13)
 #define MISSILE_OFFSET 0
 #define MISSILE_SPEED DISPLAY_TO_WORLD (10)
 		/* Used by the cyborg only. */
@@ -54,9 +54,19 @@
 #define TONGUE_SPEED 0
 #define TONGUE_HITS 1
 #define TONGUE_DAMAGE 12
-#define TONGUE_OFFSET 4
+#define TONGUE_OFFSET RES_SCALE(4)
 
-static RACE_DESC zoqfotpik_desc =
+// HD
+#define MAX_THRUST_2XRES 80
+#define THRUST_INCREMENT_2XRES 20
+#define MISSILE_SPEED_2XRES DISPLAY_TO_WORLD (20)
+#define MISSILE_RANGE_2XRES (MISSILE_SPEED_2XRES * MISSILE_LIFE)
+#define MAX_THRUST_4XRES 160
+#define THRUST_INCREMENT_4XRES 40
+#define MISSILE_SPEED_4XRES DISPLAY_TO_WORLD (40)
+#define MISSILE_RANGE_4XRES (MISSILE_SPEED_4XRES * MISSILE_LIFE)
+
+static RACE_DESC zoqfotpik_desc1x =
 {
 	{ /* SHIP_INFO */
 		"stinger",
@@ -128,6 +138,152 @@ static RACE_DESC zoqfotpik_desc =
 	0, /* CodeRef */
 };
 
+// JMS_GFX
+static RACE_DESC zoqfotpik_desc2x =
+{
+	{ /* SHIP_INFO */
+		"stinger",
+		FIRES_FORE,
+		6, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ZOQFOTPIK_RACE_STRINGS,
+		ZOQFOTPIK_ICON_MASK_PMAP_ANIM,
+		ZOQFOTPIK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		320 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			3761, 5333,
+		},
+	},
+	{
+		MAX_THRUST_2XRES,
+		THRUST_INCREMENT_2XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ZOQFOTPIK_BIG_MASK_PMAP_ANIM,
+			ZOQFOTPIK_MED_MASK_PMAP_ANIM,
+			ZOQFOTPIK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPIT_BIG_MASK_PMAP_ANIM,
+			SPIT_MED_MASK_PMAP_ANIM,
+			SPIT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			STINGER_BIG_MASK_PMAP_ANIM,
+			STINGER_MED_MASK_PMAP_ANIM,
+			STINGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ZOQFOTPIK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ZOQFOTPIK_VICTORY_SONG,
+		ZOQFOTPIK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_2XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
+// JMS_GFX
+static RACE_DESC zoqfotpik_desc4x =
+{
+	{ /* SHIP_INFO */
+		"stinger",
+		FIRES_FORE,
+		6, /* Super Melee cost */
+		MAX_CREW, MAX_CREW,
+		MAX_ENERGY, MAX_ENERGY,
+		ZOQFOTPIK_RACE_STRINGS,
+		ZOQFOTPIK_ICON_MASK_PMAP_ANIM,
+		ZOQFOTPIK_MICON_MASK_PMAP_ANIM,
+		NULL, NULL, NULL
+	},
+	{ /* FLEET_STUFF */
+		320 / SPHERE_RADIUS_INCREMENT * 2, /* Initial SoI radius */
+		{ /* Known location (center of SoI) */
+			3761, 5333,
+		},
+	},
+	{
+		MAX_THRUST_4XRES,
+		THRUST_INCREMENT_4XRES,
+		ENERGY_REGENERATION,
+		WEAPON_ENERGY_COST,
+		SPECIAL_ENERGY_COST,
+		ENERGY_WAIT,
+		TURN_WAIT,
+		THRUST_WAIT,
+		WEAPON_WAIT,
+		SPECIAL_WAIT,
+		SHIP_MASS,
+	},
+	{
+		{
+			ZOQFOTPIK_BIG_MASK_PMAP_ANIM,
+			ZOQFOTPIK_MED_MASK_PMAP_ANIM,
+			ZOQFOTPIK_SML_MASK_PMAP_ANIM,
+		},
+		{
+			SPIT_BIG_MASK_PMAP_ANIM,
+			SPIT_MED_MASK_PMAP_ANIM,
+			SPIT_SML_MASK_PMAP_ANIM,
+		},
+		{
+			STINGER_BIG_MASK_PMAP_ANIM,
+			STINGER_MED_MASK_PMAP_ANIM,
+			STINGER_SML_MASK_PMAP_ANIM,
+		},
+		{
+			ZOQFOTPIK_CAPTAIN_MASK_PMAP_ANIM,
+			NULL, NULL, NULL, NULL, NULL
+		},
+		ZOQFOTPIK_VICTORY_SONG,
+		ZOQFOTPIK_SHIP_SOUNDS,
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		{ NULL, NULL, NULL },
+		NULL, NULL
+	},
+	{
+		0,
+		MISSILE_RANGE_4XRES,
+		NULL,
+	},
+	(UNINIT_FUNC *) NULL,
+	(PREPROCESS_FUNC *) NULL,
+	(POSTPROCESS_FUNC *) NULL,
+	(INIT_WEAPON_FUNC *) NULL,
+	0,
+	0, /* CodeRef */
+};
+
 static void
 spit_preprocess (ELEMENT *ElementPtr)
 {
@@ -145,7 +301,7 @@ spit_preprocess (ELEMENT *ElementPtr)
 			angle = angle + (((COUNT)TFB_Random () % 3) - 1);
 
 		speed = WORLD_TO_VELOCITY (DISPLAY_TO_WORLD (
-				GetFrameCount (ElementPtr->next.image.frame) - index) << 1);
+				(GetFrameCount (ElementPtr->next.image.frame) << RESOLUTION_FACTOR )- index) << 1);
 		SetVelocityComponents (&ElementPtr->velocity,
 				(SIZE)COSINE (angle, speed),
 				(SIZE)SINE (angle, speed));
@@ -172,7 +328,7 @@ initialize_spit (ELEMENT *ShipPtr, HELEM
 	MissileBlock.flags = IGNORE_SIMILAR;
 	MissileBlock.pixoffs = ZOQFOTPIK_OFFSET;
 	MissileBlock.speed = DISPLAY_TO_WORLD (
-			GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.weapon[0])) << 1;
+			(GetFrameCount (StarShipPtr->RaceDescPtr->ship_data.weapon[0])) << RESOLUTION_FACTOR) << 1;
 	MissileBlock.hit_points = MISSILE_HITS;
 	MissileBlock.damage = MISSILE_DAMAGE;
 	MissileBlock.life = MISSILE_LIFE;
@@ -243,7 +399,7 @@ spawn_tongue (ELEMENT *ElementPtr)
 		{
 			COUNT angle;
 			RECT r;
-			SIZE x_offs, y_offs;
+			SDWORD x_offs, y_offs;
 
 			TonguePtr->turn_wait = ElementPtr->turn_wait - 1;
 
@@ -292,7 +448,7 @@ zoqfotpik_intelligence (ELEMENT *ShipPtr
 #endif /* NEVER */
 				)
 		{
-			SIZE delta_x, delta_y;
+			SDWORD delta_x, delta_y;
 
 			GiveTongueJob = TRUE;
 
@@ -330,7 +486,7 @@ zoqfotpik_intelligence (ELEMENT *ShipPtr
 #endif /* NEVER */
 						))
 						&& ship_weapons (ShipPtr,
-						ObjectsOfConcern->ObjectPtr, DISPLAY_TO_WORLD (20)))
+						ObjectsOfConcern->ObjectPtr, DISPLAY_TO_WORLD (RES_SCALE(20))))
 				{
 					StarShipPtr->ship_input_state |= WEAPON;
 					break;
@@ -365,8 +521,11 @@ zoqfotpik_postprocess (ELEMENT *ElementP
 RACE_DESC*
 init_zoqfotpik (void)
 {
+	static RACE_DESC zoqfotpik_desc;
 	RACE_DESC *RaceDescPtr;
 
+	zoqfotpik_desc = (RESOLUTION_FACTOR == 0 ? zoqfotpik_desc1x : (RESOLUTION_FACTOR == 1 ? zoqfotpik_desc2x : zoqfotpik_desc4x));
+
 	zoqfotpik_desc.postprocess_func = zoqfotpik_postprocess;
 	zoqfotpik_desc.init_weapon_func = initialize_spit;
 	zoqfotpik_desc.cyborg_control.intelligence_func = zoqfotpik_intelligence;
diff -ruNp src.orig/uqm/shipstat.c src/uqm/shipstat.c
--- src.orig/uqm/shipstat.c	2017-12-30 00:14:41 -0800
+++ src/uqm/shipstat.c	2017-12-30 00:14:54 -0800
@@ -29,10 +29,10 @@ DrawCrewFuelString (COORD y, SIZE state)
 {
 	STAMP Stamp;
 
-	Stamp.origin.y = y + GAUGE_YOFFS + STARCON_TEXT_HEIGHT;
+	Stamp.origin.y = y + GAUGE_YOFFS + STARCON_TEXT_HEIGHT - RES_CASE(0,6,12);
 	if (state == 0)
 	{
-		Stamp.origin.x = CREW_XOFFS + (STAT_WIDTH >> 1) + 6;
+		Stamp.origin.x = CREW_XOFFS + (STAT_WIDTH >> 1) + RES_STAT_SCALE(6) - RES_CASE(0,8,8); // JMS_GFX
 		if (optWhichMenu == OPT_PC)
 			Stamp.frame = SetAbsFrameIndex (StatusFrame, 4);
 		else
@@ -40,7 +40,7 @@ DrawCrewFuelString (COORD y, SIZE state)
 		DrawStamp (&Stamp);
 	}
 
-	Stamp.origin.x = ENERGY_XOFFS + (STAT_WIDTH >> 1) - 5;
+	Stamp.origin.x = ENERGY_XOFFS + (STAT_WIDTH >> 1) - RES_STAT_SCALE(5) + RES_CASE(0,10,10); // JMS_GFX
 	if (optWhichMenu == OPT_PC)
 		Stamp.frame = SetAbsFrameIndex (StatusFrame, 5);
 	else
@@ -67,7 +67,7 @@ DrawShipNameString (UNICODE *pStr, COUNT
 	Text.CharCount = CharCount;
 	Text.align = ALIGN_CENTER;
 
-	Text.baseline.y = STARCON_TEXT_HEIGHT + 3 + y;
+	Text.baseline.y = STARCON_TEXT_HEIGHT + y + (3 << RESOLUTION_FACTOR) - 6 * RESOLUTION_FACTOR; // JMS_GFX
 	Text.baseline.x = STATUS_WIDTH >> 1;
 
 	SetContextForeGroundColor (
@@ -81,7 +81,7 @@ DrawShipNameString (UNICODE *pStr, COUNT
 }
 
 void
-ClearShipStatus (COORD y)
+ClearShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu)
 {
 	RECT r;
 
@@ -89,13 +89,13 @@ ClearShipStatus (COORD y)
 			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 	r.corner.x = 2;
 	r.corner.y = 3 + y;
-	r.extent.width = STATUS_WIDTH - 4;
-	r.extent.height = SHIP_INFO_HEIGHT - 3;
+	r.extent.width = w - 4;
+	r.extent.height = SHIP_INFO_HEIGHT - (inMeleeMenu ? RES_CASE(3,1,6) : 3); // JMS_GFX
 	DrawFilledRectangle (&r);
 }
 
 void
-OutlineShipStatus (COORD y)
+OutlineShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu)
 {
 	RECT r;
 
@@ -103,40 +103,54 @@ OutlineShipStatus (COORD y)
 			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 	r.corner.x = 0;
 	r.corner.y = 1 + y;
-	r.extent.width = STATUS_WIDTH;
+	r.extent.width = w;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
 	++r.corner.y;
 	--r.extent.width;
 	DrawFilledRectangle (&r);
 	r.extent.width = 1;
-	r.extent.height = SHIP_INFO_HEIGHT - 2;
+	r.extent.height = SHIP_INFO_HEIGHT - RES_CASE((1), (inMeleeMenu ? -1 : 2), (inMeleeMenu ? 3 : 0));
 	DrawFilledRectangle (&r);
 	++r.corner.x;
 	DrawFilledRectangle (&r);
 
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
-	r.corner.x = STATUS_WIDTH - 1;
+	r.corner.x = w - 1;
 	DrawFilledRectangle (&r);
-	r.corner.x = STATUS_WIDTH - 2;
+	r.corner.x = w - 2;
 	++r.corner.y;
 	--r.extent.height;
 	DrawFilledRectangle (&r);
 
-	SetContextForeGroundColor (BLACK_COLOR);
-	r.corner.x = 0;
-	r.corner.y = y;
-	r.extent.width = STATUS_WIDTH;
+	r.corner.x = 1;
+	r.corner.y = SHIP_INFO_HEIGHT + RES_CASE(2,3,-2);
+	r.extent.width = w - 2;
 	r.extent.height = 1;
-	DrawFilledRectangle (&r);
+	if (inMeleeMenu)
+		DrawFilledRectangle (&r);
+	++r.corner.x;
+	--r.corner.y;
+	if (inMeleeMenu)
+		DrawFilledRectangle (&r);
+
+	if(RESOLUTION_FACTOR == 0){
+		SetContextForeGroundColor (BLACK_COLOR);
+		r.corner.x = 0;
+		r.corner.y = y;
+		r.extent.width = w;
+		r.extent.height = 1;
+		DrawFilledRectangle (&r);
+	}
 }
 
 void
-InitShipStatus (SHIP_INFO *SIPtr, STARSHIP *StarShipPtr, RECT *pClipRect)
+InitShipStatus (SHIP_INFO *SIPtr, STARSHIP *StarShipPtr, RECT *pClipRect, BOOLEAN inMeleeMenu)
 {
 	RECT r;
 	COORD y = 0; // default, for Melee menu
+	COORD width = STATUS_WIDTH; // BW: ShipStatus has less space in 2x and 4x MeleeMenu
 	STAMP Stamp;
 	CONTEXT OldContext;
 	RECT oldClipRect;
@@ -165,66 +179,83 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 
 	BatchGraphics ();
 	
-	OutlineShipStatus (y);
-	ClearShipStatus (y);
+	OutlineShipStatus (y, width, inMeleeMenu);
+	ClearShipStatus (y, width, inMeleeMenu);
 
 	Stamp.origin.x = (STATUS_WIDTH >> 1);
-	Stamp.origin.y = 31 + y;
+	Stamp.origin.y = (31 << RESOLUTION_FACTOR) + y;
 	Stamp.frame = IncFrameIndex (SIPtr->icons);
 	DrawStamp (&Stamp);
-
+	
 	{
 		SIZE crew_height, energy_height;
-
+		
 #define MIN(a, b) (((a) <= (b)) ? (a) : (b))
-		crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) & ~1) + 1;
+		if (RESOLUTION_FACTOR == 0) {
+			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) & ~1) + 1;
+			energy_height = (((SIPtr->max_energy + 1) >> 1) << 1) + 1;
+		} else if (RESOLUTION_FACTOR == 1) {
+			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) * 1.5);
+			energy_height = (((SIPtr->max_energy + 1) >> 1) * 3) + 1;
+		} else {
+			crew_height = ((MIN(SIPtr->max_crew, MAX_CREW_SIZE) + 1) * 2.5) - 1;
+			energy_height = (((SIPtr->max_energy + 1) >> 1) * 5) + 1;
+		}
 #undef MIN
-		energy_height = (((SIPtr->max_energy + 1) >> 1) << 1) + 1;
-
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
+		
+		// Dark gray line on the right of energy box
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 		r.corner.x = CREW_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS + 1 + y;
 		r.extent.width = STAT_WIDTH + 2;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		// Dark gray line on the right of crew box
 		r.corner.x = ENERGY_XOFFS - 1;
 		DrawFilledRectangle (&r);
+		// Dark gray line on the right of energy box
 		r.corner.x = ENERGY_XOFFS + STAT_WIDTH;
 		r.corner.y -= energy_height;
 		r.extent.width = 1;
 		r.extent.height = energy_height;
 		DrawFilledRectangle (&r);
+		// Dark gray line on the right of crew box
 		r.corner.x = CREW_XOFFS + STAT_WIDTH;
 		r.corner.y = (GAUGE_YOFFS + 1 + y) - crew_height;
 		r.extent.width = 1;
 		r.extent.height = crew_height;
 		DrawFilledRectangle (&r);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
+
+		// Light gray line on the top of crew box
+		SetContextForeGroundColor (BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 		r.corner.x = CREW_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS - crew_height + y;
 		r.extent.width = STAT_WIDTH + 2;
 		r.extent.height = 1;
 		DrawFilledRectangle (&r);
+		// Light gray line on the top of energy box
 		r.corner.x = ENERGY_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS - energy_height + y;
 		DrawFilledRectangle (&r);
+		// Light gray line on the left of energy box
 		r.extent.width = 1;
 		r.extent.height = energy_height + 1;
 		DrawFilledRectangle (&r);
+		// Light gray line on the left of crew box
 		r.corner.x = CREW_XOFFS - 1;
 		r.corner.y = GAUGE_YOFFS - crew_height + y;
 		r.extent.height = crew_height + 1;
 		DrawFilledRectangle (&r);
-
+		
 		SetContextForeGroundColor (BLACK_COLOR);
-
+		
+		// Black rectangle behind green crew boxes
 		r.extent.width = STAT_WIDTH;
 		r.corner.x = CREW_XOFFS;
 		r.extent.height = crew_height;
 		r.corner.y = y - r.extent.height + GAUGE_YOFFS + 1;
 		DrawFilledRectangle (&r);
+		// Black rectangle behind red energy boxes
 		r.corner.x = ENERGY_XOFFS;
 		r.extent.height = energy_height;
 		r.corner.y = y - r.extent.height + GAUGE_YOFFS + 1;
@@ -266,7 +297,7 @@ InitShipStatus (SHIP_INFO *SIPtr, STARSH
 			Text.align = ALIGN_CENTER;
 
 			Text.baseline.x = STATUS_WIDTH >> 1;
-			Text.baseline.y = y + GAUGE_YOFFS + 3;
+			Text.baseline.y = y + GAUGE_YOFFS + RES_CASE(3,3,7);
 
 			SetContextForeGroundColor (BLACK_COLOR);
 			font_DrawText (&Text);
@@ -315,6 +346,7 @@ DeltaStatistics (SHIP_INFO *ShipInfoPtr,
 		return;
 
 	x = 0;
+	// Y coordinates for the crew and energy rectangles
 	y = GAUGE_YOFFS + y_offs;
 
 	r.extent.width = UNIT_WIDTH;
diff -ruNp src.orig/uqm/shipyard.c src/uqm/shipyard.c
--- src.orig/uqm/shipyard.c	2017-12-30 00:14:41 -0800
+++ src/uqm/shipyard.c	2017-12-30 00:14:54 -0800
@@ -37,7 +37,7 @@
 #include "sounds.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/inplib.h"
-
+#include "uqmdebug.h"
 
 #ifdef USE_3DO_HANGAR
 // 3DO 4x3 hangar layout
@@ -53,12 +53,24 @@ static const COORD hangar_x_coords[HANGA
 #else // use PC hangar
 // modified PC 6x2 hangar layout
 #	define HANGAR_SHIPS_ROW  6
-#	define HANGAR_Y          88
-#	define HANGAR_DY         84
 
-static const COORD hangar_x_coords[HANGAR_SHIPS_ROW] =
-{
-	0, 38, 76,  131, 169, 207
+// The Y position of the upper line of hangar bay doors.
+# define HANGAR_Y          ((88 << RESOLUTION_FACTOR) - RES_CASE(0,3,2)) // JMS_GFX
+
+// The Y position of the lower line of hangar bay doors.
+# define HANGAR_DY         ((84 << RESOLUTION_FACTOR) + RES_CASE(0,1,2)) // JMS_GFX
+
+
+// The X positions of the hangar bay doors for each resolution mode.
+// Calculated from the right edge of the left grey border bar on the screen.
+static const COORD hangar_x_coords_1x[HANGAR_SHIPS_ROW] = {
+	0, 38, 76, 131, 169, 207
+};
+static const COORD hangar_x_coords_2x[HANGAR_SHIPS_ROW] = {
+	2, 79, 157, 268, 346, 424
+};
+static const COORD hangar_x_coords_4x[HANGAR_SHIPS_ROW] = {
+	3, 171, 339, 578, 746, 914
 };
 #endif // USE_3DO_HANGAR
 
@@ -99,7 +111,7 @@ animatePowerLines (MENU_STATE *pMS)
 	{	// Init animation
 		s.origin.x = 0;
 		s.origin.y = 0;
-		s.frame = SetAbsFrameIndex (pMS->ModuleFrame, 24);
+		s.frame = SetAbsFrameIndex (pMS->ModuleFrame, 25);
 		ColorMap = SetAbsColorMapIndex (pMS->CurString, 0);
 	}
 
@@ -124,7 +136,6 @@ on_input_frame (void)
 	SetContext (oldContext);
 }
 
-#ifdef WANT_SHIP_SPINS
 static void
 SpinStarShip (MENU_STATE *pMS, HFLEETINFO hStarShip)
 {
@@ -140,7 +151,6 @@ SpinStarShip (MENU_STATE *pMS, HFLEETINF
 		DoShipSpin (Index, pMS->hMusic);
 	}
 }
-#endif
 
 // Count the ships which can be built by the player.
 static COUNT
@@ -156,7 +166,7 @@ GetAvailableRaceCount (void)
 		FLEET_INFO *FleetPtr;
 
 		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
-		if (FleetPtr->allied_state == GOOD_GUY)
+		if (FleetPtr->allied_state == GOOD_GUY || FleetPtr->allied_state == CAN_BUILD)
 			++Index;
 
 		hNextShip = _GetSuccLink (FleetPtr);
@@ -177,7 +187,7 @@ GetAvailableRaceFromIndex (BYTE Index)
 		FLEET_INFO *FleetPtr;
 
 		FleetPtr = LockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
-		if (FleetPtr->allied_state == GOOD_GUY && Index-- == 0)
+		if (FleetPtr->allied_state == GOOD_GUY && Index-- == 0 || FleetPtr->allied_state == CAN_BUILD && Index-- == 0)
 		{
 			UnlockFleetInfo (&GLOBAL (avail_race_q), hStarShip);
 			return hStarShip;
@@ -203,9 +213,9 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 	s.origin.x = RADAR_X - r.corner.x;
 	s.origin.y = RADAR_Y - r.corner.y;
 	r.corner.x = s.origin.x - 1;
-	r.corner.y = s.origin.y - 11;
+	r.corner.y = s.origin.y - RES_CASE(11,24,33); // JMS_GFX
 	r.extent.width = RADAR_WIDTH + 2;
-	r.extent.height = 11;
+	r.extent.height = RES_CASE(11,24,33); // JMS_GFX
 	BatchGraphics ();
 	ClearSISRect (CLEAR_SIS_RADAR);
 	SetContextForeGroundColor (
@@ -247,8 +257,12 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 		t.pStr = buf;
 		sprintf (buf, "%u", ShipCost[NewRaceItem]);
 		SetContextFont (TinyFont);
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x1F, 0x00), 0x02));
+		if ((ShipCost[NewRaceItem]) <= (GLOBAL_SIS (ResUnits))) {
+			SetContextForeGroundColor (BRIGHT_GREEN_COLOR);
+		} else if ((ShipCost[NewRaceItem]) > (GLOBAL_SIS (ResUnits)))
+		{ /* We don't have enough to purchase this ship. */
+			SetContextForeGroundColor (BRIGHT_RED_COLOR);
+		}
 		font_DrawText (&t);
 	}
 	UnbatchGraphics ();
@@ -256,9 +270,16 @@ DrawRaceStrings (MENU_STATE *pMS, BYTE N
 
 }
 
-#define SHIP_WIN_WIDTH 34
-#define SHIP_WIN_HEIGHT (SHIP_WIN_WIDTH + 6)
-#define SHIP_WIN_FRAMES ((SHIP_WIN_WIDTH >> 1) + 1)
+// Width of an escort ship window.
+#define SHIP_WIN_WIDTH RES_CASE(34, 72, 156) // JMS_GFX
+
+// Height of an escort ship window.
+#define SHIP_WIN_HEIGHT (SHIP_WIN_WIDTH + RES_CASE(6,6,11)) // JMS_GFX
+
+// For how many animation frames' time the escort ship bay doors
+// are slid left and right when opening them. If this number is not large
+// enough, part of the doors are left visible upon opening.
+#define SHIP_WIN_FRAMES ((SHIP_WIN_WIDTH >> 1) + RES_CASE(1,1,2))
 
 // Print the crew count of an escort ship on top of its (already drawn)
 // image, either as '30' (full), '28/30' (partially full), or 'SCRAP'
@@ -290,15 +311,15 @@ ShowShipCrew (SHIP_FRAGMENT *StarShipPtr
 
 	r = *pRect;
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + r.extent.height - 1;
+	t.baseline.y = r.corner.y + r.extent.height - 1 - (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 	if (r.corner.y)
 	{
-		r.corner.y = t.baseline.y - 6;
+		r.corner.y = t.baseline.y - (6 << RESOLUTION_FACTOR); //JMS_GFX
 		r.extent.width = SHIP_WIN_WIDTH;
-		r.extent.height = 6;
+		r.extent.height = (6 << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
 	}
@@ -316,6 +337,7 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 	COUNT num_ships;
 	HSHIPFRAG hStarShip, hNextShip;
 	SHIP_FRAGMENT *StarShipPtr;
+	static const COORD *hangar_x_coords;
 	struct
 	{
 		SHIP_FRAGMENT *StarShipPtr;
@@ -325,6 +347,19 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 		STAMP rtdoor_s;
 	} ship_win_info[MAX_BUILT_SHIPS], *pship_win_info;
 
+	switch (RESOLUTION_FACTOR) {
+		case 2:
+			hangar_x_coords = hangar_x_coords_4x;
+			break;
+		case 1:
+			hangar_x_coords = hangar_x_coords_2x;
+			break;
+		case 0:
+		default:
+			hangar_x_coords = hangar_x_coords_1x;
+			break;
+	}
+
 	num_ships = 1;
 	pship_win_info = &ship_win_info[0];
 	if (YankedStarShipPtr)
@@ -435,7 +470,7 @@ ShowCombatShip (MENU_STATE *pMS, COUNT w
 		FlushInput ();
 		TimeIn = GetTimeCounter ();
 
-		for (j = 0; (j < SHIP_WIN_FRAMES) && !AllDoorsFinished; j++)
+		for (j = 0; (j < (int)SHIP_WIN_FRAMES) && !AllDoorsFinished; j++)
 		{
 			SleepThreadUntil (TimeIn + ONE_SECOND / 24);
 			TimeIn = GetTimeCounter ();
@@ -550,7 +585,7 @@ DMS_FlashFlagShip (void)
 	r.corner.x = 0;
 	r.corner.y = 0;
 	r.extent.width = SIS_SCREEN_WIDTH;
-	r.extent.height = 61;
+	r.extent.height = RES_CASE(61, 122, 295); // JMS_GFX
 	SetFlashRect (&r);
 }
 
@@ -559,6 +594,20 @@ DMS_GetEscortShipRect (RECT *rOut, BYTE
 {
 	BYTE row = slotNr / HANGAR_SHIPS_ROW;
 	BYTE col = slotNr % HANGAR_SHIPS_ROW;
+	static const COORD *hangar_x_coords;
+
+	switch (RESOLUTION_FACTOR) {
+		case 2:
+			hangar_x_coords = hangar_x_coords_4x;
+			break;
+		case 1:
+			hangar_x_coords = hangar_x_coords_2x;
+			break;
+		case 0:
+		default:
+			hangar_x_coords = hangar_x_coords_1x;
+			break;
+	}
 
 	rOut->corner.x = hangar_x_coords[col];
 	rOut->corner.y = HANGAR_Y + (HANGAR_DY * row);
@@ -590,11 +639,25 @@ DMS_FlashEscortShipCrewCount (BYTE slotN
 	RECT r;
 	BYTE row = slotNr / HANGAR_SHIPS_ROW;
 	BYTE col = slotNr % HANGAR_SHIPS_ROW;
+	static const COORD *hangar_x_coords;
+
+	switch (RESOLUTION_FACTOR) {
+		case 2:
+			hangar_x_coords = hangar_x_coords_4x;
+			break;
+		case 1:
+			hangar_x_coords = hangar_x_coords_2x;
+			break;
+		case 0:
+		default:
+			hangar_x_coords = hangar_x_coords_1x;
+			break;
+	}
 
 	r.corner.x = hangar_x_coords[col];
-	r.corner.y = (HANGAR_Y + (HANGAR_DY * row)) + (SHIP_WIN_HEIGHT - 6);
+	r.corner.y = (HANGAR_Y + (HANGAR_DY * row)) + (SHIP_WIN_HEIGHT - (6 << RESOLUTION_FACTOR));
 	r.extent.width = SHIP_WIN_WIDTH;
-	r.extent.height = 5;
+	r.extent.height = 5 << RESOLUTION_FACTOR; // JMS_GFX
 
 	SetContext (SpaceContext);
 	SetFlashRect (&r);
@@ -635,7 +698,7 @@ DMS_SetMode (MENU_STATE *pMS, DMS_Mode m
 			SetFlashRect (SFR_MENU_ANY);
 			break;
 		case DMS_Mode_editCrew:
-			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN,
+			SetMenuSounds (MENU_SOUND_UP | MENU_SOUND_DOWN | MENU_SOUND_PAGEUP | MENU_SOUND_PAGEDOWN,
 					MENU_SOUND_SELECT | MENU_SOUND_CANCEL);
 			if (HINIBBLE (pMS->CurState))
 			{
@@ -656,7 +719,6 @@ DMS_SetMode (MENU_STATE *pMS, DMS_Mode m
 }
 
 #define MODIFY_CREW_FLAG (1 << 8)
-#ifdef WANT_SHIP_SPINS
 // Helper function for DoModifyShips(), called when the player presses the
 // special button.
 // It works both when the cursor is over an escort ship, while not editing
@@ -707,7 +769,6 @@ DMS_SpinShip (MENU_STATE *pMS, HSHIPFRAG
 
 	return TRUE;
 }
-#endif  /* WANT_SHIP_SPINS */
 
 // Helper function for DoModifyShips(), called when the player presses the
 // up button when modifying the crew of the flagship.
@@ -731,7 +792,25 @@ DMS_HireFlagShipCrew (void)
 	}
 
 	// Draw a crew member.
-	DrawPoint (&r.corner);
+	// Crew dots/rectangles for 1x and 2x resolutions.
+	if (RESOLUTION_FACTOR < 2) {
+		r.extent.width = 1 << RESOLUTION_FACTOR;
+		r.extent.height = r.extent.width;
+		DrawFilledRectangle (&r);
+	} else {
+		r.corner.x += 1;
+		r.extent.width = (1 << RESOLUTION_FACTOR) - 2;
+		r.extent.height = 1 << RESOLUTION_FACTOR;
+		DrawFilledRectangle (&r);
+									
+		r.corner.x -= 1;
+		r.corner.y += 1;
+		r.extent.width = 1 << RESOLUTION_FACTOR;
+		r.extent.height = (1 << RESOLUTION_FACTOR) - 2;
+		DrawFilledRectangle (&r);
+									
+		r.corner.y -= 1;
+	}
 
 	// Update the crew counter and RU. Note that the crew counter is
 	// flashing.
@@ -771,8 +850,10 @@ DMS_DismissFlagShipCrew (void)
 
 	// Remove the pixel representing the crew member.
 	GetCPodCapacity (&r.corner);
+	r.extent.width = 1 << RESOLUTION_FACTOR;
+	r.extent.height = r.extent.width;
 	SetContextForeGroundColor (BLACK_COLOR);
-	DrawPoint (&r.corner);
+	DrawFilledRectangle (&r);
 
 	return -1;
 }
@@ -888,62 +969,57 @@ DMS_DismissEscortShipCrew (SHIP_FRAGMENT
 // 'dy' is -1 if the 'up' button was pressed, or '1' if the down button was
 // pressed.
 static void
-DMS_ModifyCrew (MENU_STATE *pMS, HSHIPFRAG hStarShip, SBYTE dy)
+DMS_ModifyCrew (MENU_STATE *pMS, HSHIPFRAG hStarShip, SBYTE dy, SBYTE dx, SBYTE DoLoop)
 {
 	SIZE crew_delta = 0;
+	int loop;
 	SHIP_FRAGMENT *StarShipPtr = NULL;
 
 	if (hStarShip)
 		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 
-	if (hStarShip == 0)
-	{
-		// Add/Dismiss crew for the flagship.
-		if (dy < 0)
-		{
-			// Add crew for the flagship.
-			crew_delta = DMS_HireFlagShipCrew ();
-		}
-		else
+	for (loop = 0; loop < (DoLoop ? 10 : 1); loop++) {
+		if (hStarShip == 0)
 		{
-			// Dismiss crew from the flagship.
-			crew_delta = DMS_DismissFlagShipCrew ();
-		}
+			// Add/Dismiss crew for the flagship.
+			if (dy < 0 || dx > 0) {
+				// Add crew for the flagship.
+				crew_delta += DMS_HireFlagShipCrew ();
+			} else {
+				// Dismiss crew from the flagship.
+				crew_delta -= DMS_DismissFlagShipCrew ();
+			}
 
-		if (crew_delta != 0)
-			DMS_FlashFlagShipCrewCount ();
-	}
-	else
-	{
-		// Add/Dismiss crew for an escort ship.
-		if (dy < 0)
-		{
-			// Add crew for an escort ship.
-			crew_delta = DMS_HireEscortShipCrew (StarShipPtr);
-		}
-		else
-		{
-			// Dismiss crew from an escort ship.
-			crew_delta = DMS_DismissEscortShipCrew (StarShipPtr);
-		}
+			if (crew_delta != 0)
+				DMS_FlashFlagShipCrewCount ();
+		} else {
+			// Add/Dismiss crew for an escort ship.
+			if (dy < 0 || dx > 0) {
+				// Add crew for an escort ship.
+				crew_delta = DMS_HireEscortShipCrew (StarShipPtr);
+			} else {
+				// Dismiss crew from an escort ship.
+				crew_delta = DMS_DismissEscortShipCrew (StarShipPtr);
+			}
 		
-		if (crew_delta != 0)
-			DMS_FlashEscortShipCrewCount (StarShipPtr->index);
-	}
+			if (crew_delta != 0)
+				DMS_FlashEscortShipCrewCount (StarShipPtr->index);
+		}
 
-	if (crew_delta == 0)
-		PlayMenuSound (MENU_SOUND_FAILURE);
+		if (crew_delta == 0)
+			PlayMenuSound (MENU_SOUND_FAILURE);
 
-	if (hStarShip)
-	{
-		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
+		if (hStarShip)
+		{
+			UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 		
-		// Clear out the bought ship index so that flash rects work
-		// correctly.
-		pMS->delta_item &= MODIFY_CREW_FLAG;
-	}
+			// Clear out the bought ship index so that flash rects work
+			// correctly.
+			pMS->delta_item &= MODIFY_CREW_FLAG;
+		}
 
-	CrewTransaction (crew_delta);
+		CrewTransaction (crew_delta);
+	}
 }
 
 // Helper function for DoModifyShips(), called when the player presses the
@@ -985,7 +1061,6 @@ DMS_AddEscortShip (MENU_STATE *pMS, BOOL
 {
 	assert (pMS->delta_item & MODIFY_CREW_FLAG);
 
-#ifdef WANT_SHIP_SPINS
 	if (special)
 	{
 		HSHIPFRAG hStarShip = GetEscortByStarShipIndex (pMS->delta_item);
@@ -993,9 +1068,6 @@ DMS_AddEscortShip (MENU_STATE *pMS, BOOL
 			DMS_SetMode (pMS, DMS_Mode_addEscort);
 		return;
 	}
-#else
-	(void) special;  // Satisfying compiler.
-#endif  /* WANT_SHIP_SPINS */
 
 	if (cancel)
 	{
@@ -1107,7 +1179,7 @@ DMS_MoveCursor (BYTE curState, SBYTE dx,
 // called when we are in crew editing mode.
 static void
 DMS_EditCrewMode (MENU_STATE *pMS, HSHIPFRAG hStarShip,
-		BOOLEAN select, BOOLEAN cancel, SBYTE dy)
+		BOOLEAN select, BOOLEAN cancel, SBYTE dy, SBYTE dx, SBYTE DoLoop)
 {
 	if (select || cancel)
 	{
@@ -1131,11 +1203,11 @@ DMS_EditCrewMode (MENU_STATE *pMS, HSHIP
 		pMS->delta_item &= ~MODIFY_CREW_FLAG;
 		DMS_SetMode (pMS, DMS_Mode_navigate);
 	}
-	else if (dy)
+	else if (dy || DoLoop)
 	{
 		// Hire or dismiss crew for the flagship or an escort
 		// ship.
-		DMS_ModifyCrew (pMS, hStarShip, dy);
+		DMS_ModifyCrew (pMS, hStarShip, dy, dx, DoLoop);
 	}
 }
 
@@ -1158,17 +1230,12 @@ DMS_NavigateShipSlots (MENU_STATE *pMS,
 		}
 	}
 
-#ifndef WANT_SHIP_SPINS
-	(void) special;  // Satisfying compiler.
-#else
 	if (special)
 	{
 		if (DMS_SpinShip (pMS, hStarShip))
 			DMS_SetMode (pMS, DMS_Mode_navigate);
 	}
-	else
-#endif  /* WANT_SHIP_SPINS */
-	if (select)
+	else if (select)
 	{
 		if (hStarShip == 0 && HINIBBLE (pMS->CurState) == 0)
 		{
@@ -1186,8 +1253,7 @@ DMS_NavigateShipSlots (MENU_STATE *pMS,
 			DMS_SetMode (pMS, DMS_Mode_editCrew);
 		}
 	}
-	else if (cancel)
-	{
+	else if (cancel) {
 		// Leave escort ship editor.
 		pMS->InputFunc = DoShipyard;
 		pMS->CurState = SHIPYARD_CREW;
@@ -1229,6 +1295,7 @@ DoModifyShips (MENU_STATE *pMS)
 		BOOLEAN cancel = (PulsedInputState.menu[KEY_MENU_CANCEL] != 0);
 		SBYTE dx = 0;
 		SBYTE dy = 0;
+		SBYTE DoLoop = 0;
 
 		if (PulsedInputState.menu[KEY_MENU_RIGHT])
 			dx = 1;
@@ -1238,6 +1305,10 @@ DoModifyShips (MENU_STATE *pMS)
 			dy = -1;
 		if (PulsedInputState.menu[KEY_MENU_DOWN])
 			dy = 1;
+		if (PulsedInputState.menu[KEY_MENU_PAGE_UP]) 
+			DoLoop = dx = 1;
+		if (PulsedInputState.menu[KEY_MENU_PAGE_DOWN]) 
+			DoLoop = dx = -1;
 
 
 		if (!(pMS->delta_item & MODIFY_CREW_FLAG))
@@ -1259,7 +1330,7 @@ DoModifyShips (MENU_STATE *pMS)
 			else
 			{
 				// Crew editing mode.
-				DMS_EditCrewMode (pMS, hStarShip, select, cancel, dy);
+				DMS_EditCrewMode (pMS, hStarShip, select, cancel, dy, dx, DoLoop);
 			}
 		}
 
@@ -1306,8 +1377,9 @@ DrawBluePrint (MENU_STATE *pMS)
 			DrawShipPiece (ModuleFrame, which_piece, num_frames, TRUE);
 	}
 
-	SetContextForeGroundColor (
-			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09));
+	if (RESOLUTION_FACTOR == 0)
+		SetContextForeGroundColor (
+				BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09));
 	for (num_frames = 0; num_frames < NUM_MODULE_SLOTS; ++num_frames)
 	{
 		BYTE which_piece;
@@ -1323,10 +1395,30 @@ DrawBluePrint (MENU_STATE *pMS)
 
 		while (num_frames--)
 		{
-			POINT pt;
-
-			GetCPodCapacity (&pt);
-			DrawPoint (&pt);
+			RECT r;
+			// Crew dots/rectangles for 1x and 2x resolutions.
+			if (RESOLUTION_FACTOR < 2) {
+				r.extent.width = 1 << RESOLUTION_FACTOR;
+				r.extent.height = r.extent.width;
+				
+				GetCPodCapacity (&r.corner);
+				DrawFilledRectangle (&r);
+			} else {
+				GetCPodCapacity (&r.corner);
+				
+				r.corner.x += 1;
+				r.extent.width = (1 << RESOLUTION_FACTOR) - 2;
+				r.extent.height = 1 << RESOLUTION_FACTOR;
+				DrawFilledRectangle (&r);
+				
+				r.corner.x -= 1;
+				r.corner.y += 1;
+				r.extent.width = 1 << RESOLUTION_FACTOR;
+				r.extent.height = (1 << RESOLUTION_FACTOR) - 2;
+				DrawFilledRectangle (&r);
+				
+				r.corner.y -= 1;
+			}
 
 			++GLOBAL_SIS (CrewEnlisted);
 		}
@@ -1337,8 +1429,8 @@ DrawBluePrint (MENU_STATE *pMS)
 		num_frames = GLOBAL_SIS (TotalElementMass);
 		GLOBAL_SIS (TotalElementMass) = 0;
 
-		r.extent.width = 9;
-		r.extent.height = 1;
+		r.extent.width = 9 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 1 << RESOLUTION_FACTOR; // JMS_GFX
 		while (num_frames)
 		{
 			COUNT m;
@@ -1359,13 +1451,52 @@ DrawBluePrint (MENU_STATE *pMS)
 		FuelVolume = GLOBAL_SIS (FuelOnBoard) - FUEL_RESERVE;
 		GLOBAL_SIS (FuelOnBoard) = FUEL_RESERVE;
 
-		r.extent.width = 3;
-		r.extent.height = 1;
+		r.extent.width = (3 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height = 1; // JMS_GFX
 		while (FuelVolume)
 		{
 			COUNT m;
 
+			// JMS_GFX
+			COUNT slotNr = 0;
+			DWORD compartmentNr = 0;
+			BYTE moduleType;
+			DWORD fuelAmount;
+			DWORD volume;
+			
+			// JMS_GFX
+			fuelAmount = GLOBAL_SIS (FuelOnBoard);
+			if (fuelAmount >= FUEL_RESERVE)
+			{
+				COUNT slotI;
+				DWORD capacity = FUEL_RESERVE;
+				
+				slotI = NUM_MODULE_SLOTS;
+				while (slotI--)
+				{
+					BYTE moduleType = GLOBAL_SIS (ModuleSlots[slotI]);
+					
+					capacity += GetModuleFuelCapacity (moduleType);
+					
+					//log_add (log_Debug, "fuelAmount %d, capacity %d, moduletype %d, slotI %d", fuelAmount, capacity, moduleType, slotI);
+					
+					if (fuelAmount < capacity)
+					{
+						slotNr = slotI;
+						compartmentNr = capacity - fuelAmount;
+						break;
+					}
+				}
+				
+				moduleType = GLOBAL_SIS (ModuleSlots[slotNr]);
+				volume = GetModuleFuelCapacity (moduleType);
+			}
+
+				
 			GetFTankCapacity (&r.corner);
+			//log_add(log_Debug, "volume on %u, hefueltankcapacity %u", volume, HEFUEL_TANK_CAPACITY);
+			r.corner.y -= volume == HEFUEL_TANK_CAPACITY ? RES_CASE(0,11,19) : RES_CASE(0,14,28); // JMS_GFX
+			r.corner.x += volume == HEFUEL_TANK_CAPACITY ? RES_CASE(0,0,2) : RES_CASE(0,0,1); // JMS_GFX
 			DrawPoint (&r.corner);
 			r.corner.x += r.extent.width + 1;
 			DrawPoint (&r.corner);
diff -ruNp src.orig/uqm/sis.c src/uqm/sis.c
--- src.orig/uqm/sis.c	2017-12-30 00:14:41 -0800
+++ src/uqm/sis.c	2017-12-30 00:14:54 -0800
@@ -130,16 +130,16 @@ DrawSISTitle (UNICODE *pStr)
 	RECT r;
 
 	t.baseline.x = SIS_TITLE_WIDTH >> 1;
-	t.baseline.y = SIS_TITLE_HEIGHT - 2;
+	t.baseline.y = SIS_TITLE_HEIGHT - RES_CASE(2,6,8); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 
 	OldContext = SetContext (OffScreenContext);
-	r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH + 1;
+	r.corner.x = SIS_ORG_X + SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH + (1 << RESOLUTION_FACTOR); // JMS_GFX
 	r.corner.y = SIS_ORG_Y - SIS_TITLE_HEIGHT;
 	r.extent.width = SIS_TITLE_WIDTH;
-	r.extent.height = SIS_TITLE_HEIGHT - 1;
+	r.extent.height = SIS_TITLE_HEIGHT - RES_STAT_SCALE(1); // JMS_GFX
 	SetContextFGFrame (Screen);
 	SetContextClipRect (&r);
 	SetContextFont (TinyFont);
@@ -232,7 +232,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 	if (!(flags & DSME_MYCOLOR))
 		SetContextForeGroundColor (SIS_MESSAGE_TEXT_COLOR);
 
-	t.baseline.y = SIS_MESSAGE_HEIGHT - 2;
+	t.baseline.y = SIS_MESSAGE_HEIGHT - RES_CASE(2,6,8); // JMS_GFX
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 	SetContextFont (TinyFont);
@@ -256,7 +256,7 @@ DrawSISMessageEx (const UNICODE *pStr, S
 		BYTE char_deltas[128];
 		BYTE *pchar_deltas;
 
-		t.baseline.x = 3;
+		t.baseline.x = RES_STAT_SCALE(3); // JMS_GFX
 		t.align = ALIGN_LEFT;
 
 		TextRect (&t, &text_r, char_deltas);
@@ -347,16 +347,34 @@ void
 DateToString (char *buf, size_t bufLen,
 		BYTE month_index, BYTE day_index, COUNT year_index)
 {
-	snprintf (buf, bufLen, "%s %02d" STR_MIDDLE_DOT "%04d",
-			GAME_STRING (MONTHS_STRING_BASE + month_index - 1),
-			day_index, year_index);
+	switch (optDateFormat) {
+		case 1: /* MM.DD.YYYY */
+			snprintf (buf, bufLen, "%02d%s%02d%s%04d", month_index,
+					STR_MIDDLE_DOT, day_index, STR_MIDDLE_DOT, year_index);
+			break;
+		case 2: /* DD MMM YYYY */
+			snprintf (buf, bufLen, "%02d %s%s%04d", day_index,
+					GAME_STRING (MONTHS_STRING_BASE + month_index - 1),
+					STR_MIDDLE_DOT, year_index);
+			break;
+		case 3: /* DD.MM.YYYY */
+			snprintf (buf, bufLen, "%02d%s%02d%s%04d", day_index,
+					STR_MIDDLE_DOT, month_index, STR_MIDDLE_DOT, year_index);
+			break;
+		case 0:
+		default: /* MMM DD.YYYY */
+			snprintf (buf, bufLen, "%s %02d%s%04d",
+					GAME_STRING (MONTHS_STRING_BASE + month_index - 1),
+					day_index, STR_MIDDLE_DOT, year_index);
+			break;
+	}
 }
 
 void
 GetStatusMessageRect (RECT *r)
 {
-	r->corner.x = 2;
-	r->corner.y = 130;
+	r->corner.x = RES_STAT_SCALE(2) - RES_CASE(0,1,2); // JMS_GFX
+	r->corner.y = RES_STAT_SCALE(130) + RES_CASE(0,6,18); // JMS_GFX
 	r->extent.width = STATUS_MESSAGE_WIDTH;
 	r->extent.height = STATUS_MESSAGE_HEIGHT;
 }
@@ -396,18 +414,15 @@ DrawStatusMessage (const UNICODE *pStr)
 		}
 		else if (curMsgMode == SMM_RES_UNITS)
 		{
-			if (GET_GAME_STATE (CHMMR_BOMB_STATE) < 2)
-			{
-				snprintf (buf, sizeof buf, "%u %s", GLOBAL_SIS (ResUnits),
-						GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
-			}
-			else
-			{
+			if (GET_GAME_STATE (CHMMR_BOMB_STATE) > 2 || GLOBAL_SIS (ResUnits) > 2000000L) {
 				snprintf (buf, sizeof buf, "%s %s",
 						(optWhichMenu == OPT_PC) ?
 							GAME_STRING (STATUS_STRING_BASE + 2)
 							: STR_INFINITY_SIGN, // "UNLIMITED"
 						GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
+			} else {
+				snprintf (buf, sizeof buf, "%u %s", GLOBAL_SIS (ResUnits),
+						GAME_STRING (STATUS_STRING_BASE + 1)); // "RU"
 			}
 		}
 		else
@@ -421,11 +436,19 @@ DrawStatusMessage (const UNICODE *pStr)
 	}
 
 	t.baseline.x = STATUS_MESSAGE_WIDTH >> 1;
-	t.baseline.y = STATUS_MESSAGE_HEIGHT - 1;
+	t.baseline.y = STATUS_MESSAGE_HEIGHT - RES_CASE(1,4,5); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = pStr;
 	t.CharCount = (COUNT)~0;
 
+	if (curMsgMode == SMM_WARNING) {
+		SetContextForeGroundColor (STATUS_MESSAGE_WARNING_TEXT_COLOR);
+	} else if (curMsgMode == SMM_ALERT) {
+		SetContextForeGroundColor (STATUS_MESSAGE_ALERT_TEXT_COLOR);
+	} else {
+		SetContextForeGroundColor (STATUS_MESSAGE_TEXT_COLOR);
+	}
+
 	SetContextFont (TinyFont);
 	SetContextForeGroundColor (STATUS_MESSAGE_TEXT_COLOR);
 	font_DrawText (&t);
@@ -457,14 +480,14 @@ DrawCaptainsName (void)
 	OldFont = SetContextFont (TinyFont);
 	OldColor = SetContextForeGroundColor (CAPTAIN_NAME_BACKGROUND_COLOR);
 
-	r.corner.x = 2 + 1;
-	r.corner.y = 10;
-	r.extent.width = SHIP_NAME_WIDTH - 2;
-	r.extent.height = SHIP_NAME_HEIGHT;
+	r.corner.x = RES_STAT_SCALE(3) - RES_CASE(0,2,5);		// JMS_GFX
+	r.corner.y = RES_CASE(10,20,32);						// JMS_GFX
+	r.extent.width = SHIP_NAME_WIDTH - RES_CASE(2,2,0);		// JMS_GFX
+	r.extent.height = SHIP_NAME_HEIGHT + RESOLUTION_FACTOR;	// JMS_GFX
 	DrawFilledRectangle (&r);
 
-	t.baseline.x = (STATUS_WIDTH >> 1) - 1;
-	t.baseline.y = r.corner.y + 6;
+	t.baseline.x = (STATUS_WIDTH >> 1) - RES_CASE(1,0,-1);
+	t.baseline.y = r.corner.y + RES_CASE(6,11,16); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.pStr = GLOBAL_SIS (CommanderName);
 	t.CharCount = (COUNT)~0;
@@ -492,10 +515,10 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 		OldContext = SetContext (StatusContext);
 		OldFont = SetContextFont (StarConFont);
 
-		r.corner.x = 2;
-		r.corner.y = 20;
-		r.extent.width = SHIP_NAME_WIDTH;
-		r.extent.height = SHIP_NAME_HEIGHT;
+		r.corner.x = RES_CASE(2,3,5);		// JMS_GFX
+		r.corner.y = RES_CASE(20,40,63);	// JMS_GFX
+		r.extent.width = SHIP_NAME_WIDTH;	// JMS_GFX
+		r.extent.height = SHIP_NAME_HEIGHT + RES_CASE(0,0,1);
 
 		t.pStr = GLOBAL_SIS (ShipName);
 	}
@@ -504,23 +527,39 @@ DrawFlagshipName (BOOLEAN InStatusArea)
 		OldContext = SetContext (SpaceContext);
 		OldFont = SetContextFont (MicroFont);
 
-		r.corner.x = 0;
+		r.corner.x = RES_CASE(0,24,0);
 		r.corner.y = 1;
-		r.extent.width = SIS_SCREEN_WIDTH;
-		r.extent.height = SHIP_NAME_HEIGHT;
+		r.extent.width = SIS_SCREEN_WIDTH - RES_CASE(0,24,0); // JMS_GFX
+		r.extent.height = SHIP_NAME_HEIGHT + RES_CASE(0,1,6);// JMS_GFX
 
 		t.pStr = buf;
 		snprintf (buf, sizeof buf, "%s %s",
 				GAME_STRING (NAMING_STRING_BASE + 1), GLOBAL_SIS (ShipName));
 		// XXX: this will not work with UTF-8 strings
 		strupr (buf);
+
+		// JMS: Handling the a-umlaut and o-umlaut characters
+        {
+            unsigned char *ptr;
+            ptr = (unsigned char*)buf;
+            while (*ptr) {
+                if (*ptr == 0xc3) {
+                    ptr++;
+                    if (*ptr == 0xb6 || *ptr == 0xa4) {
+                        *ptr += 'A' - 'a';
+                    }
+                }
+                ptr++;
+            }
+        }
 	}
 	OldFontEffect = SetContextFontEffect (NULL);
 	OldColor = SetContextForeGroundColor (FLAGSHIP_NAME_BACKGROUND_COLOR);
 	DrawFilledRectangle (&r);
 
 	t.baseline.x = r.corner.x + (r.extent.width >> 1);
-	t.baseline.y = r.corner.y + (SHIP_NAME_HEIGHT - InStatusArea);
+	t.baseline.y = r.corner.y + (SHIP_NAME_HEIGHT -
+					(InStatusArea ? RES_CASE(1,4,2) : RES_CASE(0,-4,-8))); // JMS_GFX
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	if (optWhichFonts == OPT_PC)
@@ -600,9 +639,9 @@ DrawFlagshipStats (void)
 
 	/* we need room to play.  full screen width, 4 lines tall */
 	r.corner.x = 0;
-	r.corner.y = SIS_SCREEN_HEIGHT - (4 * leading);
+	r.corner.y = SIS_SCREEN_HEIGHT - (4 * leading) - RES_CASE(0, 30, 60); // JMS_GFX
 	r.extent.width = SIS_SCREEN_WIDTH;
-	r.extent.height = (4 * leading);
+	r.extent.height = (4 * leading) + RES_CASE(0, 30, 60);// JMS_GFX
 
 	OldColor = SetContextForeGroundColor (BLACK_COLOR);
 	DrawFilledRectangle (&r);
@@ -611,8 +650,8 @@ DrawFlagshipStats (void)
 	   now that we've cleared out our playground, compensate for the
 	   fact that the leading is way more than is generally needed.
 	*/
-	leading -= 3;
-	t.baseline.x = SIS_SCREEN_WIDTH / 6; //wild-assed guess, but it worked
+	leading -= RES_CASE(3, -3, -6);// JMS_GFX
+	t.baseline.x = SIS_SCREEN_WIDTH / RES_CASE(6, 10, 11); //JMS_GFX
 	t.baseline.y = r.corner.y + leading + 3;
 	t.align = ALIGN_RIGHT;
 	t.CharCount = (COUNT)~0;
@@ -652,7 +691,7 @@ DrawFlagshipStats (void)
 			"%-7.7s", describeWeapon (GLOBAL_SIS (ModuleSlots[0])));
 	font_DrawText (&t);
 
-	t.baseline.x = r.extent.width - 25;
+	t.baseline.x = r.extent.width - 25 - RES_CASE(0,15,60); // JMS_GFX
 	t.baseline.y = r.corner.y + leading + 3;
 	t.align = ALIGN_RIGHT;
 
@@ -670,7 +709,7 @@ DrawFlagshipStats (void)
 	t.pStr = GAME_STRING (FLAGSHIP_STRING_BASE + 7); // "maximum fuel:"
 	font_DrawText (&t);
 
-	t.baseline.x = r.extent.width - 2;
+	t.baseline.x = r.extent.width - RES_CASE(2, 10, 40); // JMS_GFX
 	t.baseline.y = r.corner.y + leading + 3;
 	t.pStr = buf;
 
@@ -736,13 +775,12 @@ DrawLanders (void)
 	GetFrameRect (s.frame, &r);
 
 	i = GLOBAL_SIS (NumLanders);
-	r.corner.x = (STATUS_WIDTH >> 1) - r.corner.x;
-	s.origin.x = r.corner.x - (((r.extent.width * i) + (2 * (i - 1))) >> 1);
-	s.origin.y = 29;
+	r.corner.x = (STATUS_WIDTH >> 1) - r.corner.x + RES_CASE(0,0,16);
+	s.origin.x = r.corner.x - (((r.extent.width * i) + (2 * (i - 1))) >> 1) + RES_CASE(0,1,-16);
+	s.origin.y = RES_STAT_SCALE(29) + RES_CASE(0,0,2); // JMS_GFX
 
 	width = r.extent.width + 2;
-	r.extent.width = (r.extent.width * MAX_LANDERS)
-			+ (2 * (MAX_LANDERS - 1)) + 2;
+	r.extent.width = (r.extent.width * MAX_LANDERS) + (2 * (MAX_LANDERS - 1)) + RES_CASE(2,2,-16); // JMS_GFX
 	r.corner.x -= r.extent.width >> 1;
 	r.corner.y += s.origin.y;
 	SetContextForeGroundColor (BLACK_COLOR);
@@ -766,17 +804,17 @@ DrawStorageBays (BOOLEAN Refresh)
 
 	OldContext = SetContext (StatusContext);
 
-	r.extent.width = 2;
-	r.extent.height = 4;
-	r.corner.y = 123;
+	r.extent.width  = RES_STAT_SCALE(2); // JMS_GFX
+	r.extent.height = RES_STAT_SCALE(4); // JMS_GFX
+	r.corner.y		= RES_STAT_SCALE(123) + RES_CASE(0,8,23); // JMS_GFX
 	if (Refresh)
 	{
 		r.extent.width = NUM_MODULE_SLOTS * (r.extent.width + 1);
-		r.corner.x = (STATUS_WIDTH >> 1) - (r.extent.width >> 1);
+		r.corner.x = (STATUS_WIDTH >> 1) - (r.extent.width >> 1) + RES_CASE(0,2,2);
 
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawFilledRectangle (&r);
-		r.extent.width = 2;
+		r.extent.width = RES_STAT_SCALE(2); // JMS_GFX
 	}
 
 	i = (BYTE)CountSISPieces (STORAGE_BAY);
@@ -784,42 +822,40 @@ DrawStorageBays (BOOLEAN Refresh)
 	{
 		COUNT j;
 
-		r.corner.x = (STATUS_WIDTH >> 1)
-				- ((i * (r.extent.width + 1)) >> 1);
+		r.corner.x = (STATUS_WIDTH >> 1) - ((i * (r.extent.width + RES_STAT_SCALE(1))) >> 1) + RES_CASE(0,2,2);
 		SetContextForeGroundColor (STORAGE_BAY_FULL_COLOR);
 		for (j = GLOBAL_SIS (TotalElementMass);
 				j >= STORAGE_BAY_CAPACITY; j -= STORAGE_BAY_CAPACITY)
 		{
 			DrawFilledRectangle (&r);
-			r.corner.x += r.extent.width + 1;
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1); // JMS_GFX;
 
 			--i;
 		}
 
-		r.extent.height = (4 * j + (STORAGE_BAY_CAPACITY - 1)) /
-				STORAGE_BAY_CAPACITY;
+		r.extent.height = (RES_STAT_SCALE (4) * j + (STORAGE_BAY_CAPACITY - 1)) / STORAGE_BAY_CAPACITY;
 		if (r.extent.height)
 		{
-			r.corner.y += 4 - r.extent.height;
+			r.corner.y += RES_STAT_SCALE (4) - r.extent.height;
 			DrawFilledRectangle (&r);
-			r.extent.height = 4 - r.extent.height;
+			r.extent.height = RES_STAT_SCALE(4) - r.extent.height;
 			if (r.extent.height)
 			{
-				r.corner.y = 123;
+				r.corner.y = RES_STAT_SCALE(123) + RES_CASE(0,8,23);
 				SetContextForeGroundColor (STORAGE_BAY_EMPTY_COLOR);
 				DrawFilledRectangle (&r);
 			}
-			r.corner.x += r.extent.width + 1;
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1);
 
 			--i;
 		}
-		r.extent.height = 4;
+		r.extent.height = RES_STAT_SCALE(4);
 
 		SetContextForeGroundColor (STORAGE_BAY_EMPTY_COLOR);
 		while (i--)
 		{
 			DrawFilledRectangle (&r);
-			r.corner.x += r.extent.width + 1;
+			r.corner.x += r.extent.width + RES_STAT_SCALE(1);
 		}
 	}
 
@@ -829,10 +865,10 @@ DrawStorageBays (BOOLEAN Refresh)
 void
 GetGaugeRect (RECT *pRect, BOOLEAN IsCrewRect)
 {
-	pRect->extent.width = 24;
-	pRect->corner.x = (STATUS_WIDTH >> 1) - (pRect->extent.width >> 1);
-	pRect->extent.height = 5;
-	pRect->corner.y = IsCrewRect ? 117 : 38;
+	pRect->extent.width = RES_STAT_SCALE(24); // JMS_GFX
+	pRect->corner.x = (STATUS_WIDTH >> 1) - (pRect->extent.width >> 1) + RES_CASE(0,0,4);
+	pRect->extent.height = RES_STAT_SCALE(5); // JMS_GFX
+	pRect->corner.y = IsCrewRect ? RES_CASE(117,244,375) : RES_CASE(38,76,120); // JMS_GFX
 }
 
 static void
@@ -843,23 +879,26 @@ DrawPC_SIS (void)
 
 	GetGaugeRect (&r, FALSE);
 	t.baseline.x = STATUS_WIDTH >> 1;
-	t.baseline.y = r.corner.y - 1;
+	t.baseline.y = r.corner.y - RES_CASE(1,0,2);
 	t.align = ALIGN_CENTER;
 	t.CharCount = (COUNT)~0;
 	SetContextFont (TinyFont);
 	SetContextForeGroundColor (BLACK_COLOR);
 
-	r.corner.y -= 6;
-	r.corner.x--;
-	r.extent.width += 2;
+	// Black rectangle behind "FUEL" text and fuel amount.
+	r.corner.y -= RES_STAT_SCALE(6); // JMS_GFX
+	r.corner.x -= RES_STAT_SCALE(1); // JMS_GFX
+	r.extent.width += RES_STAT_SCALE(2);
+	r.extent.height += RES_CASE(0,2,2);
 	DrawFilledRectangle (&r);
 
 	SetContextFontEffect (SetAbsFrameIndex (FontGradFrame, 1));
 	t.pStr = GAME_STRING (STATUS_STRING_BASE + 3); // "FUEL"
 	font_DrawText (&t);
 
-	r.corner.y += 79;
-	t.baseline.y += 79;
+	// Black rectangle behind "CREW" text and crew amount.
+	r.corner.y += RES_STAT_SCALE(79) + RES_CASE(0,12,19); // JMS_GFX
+	t.baseline.y += RES_STAT_SCALE(79) + RES_CASE(0,9,18); // JMS_GFX
 	DrawFilledRectangle (&r);
 
 	SetContextFontEffect (SetAbsFrameIndex (FontGradFrame, 2));
@@ -868,16 +907,16 @@ DrawPC_SIS (void)
 	SetContextFontEffect (NULL);
 
 	// Background of text "CAPTAIN".
-	r.corner.x = 2 + 1;
-	r.corner.y = 3;
-	r.extent.width = 58;
-	r.extent.height = 7;
+	r.corner.x = (2 + 1) << RESOLUTION_FACTOR; // JMS_GFX;
+	r.corner.y = RES_STAT_SCALE(3); // JMS_GFX
+	r.extent.width = RES_STAT_SCALE(58); // JMS_GFX
+	r.extent.height = RES_STAT_SCALE(7); // JMS_GFX
 	SetContextForeGroundColor (PC_CAPTAIN_STRING_BACKGROUND_COLOR);
 	DrawFilledRectangle (&r);
 
 	// Text "CAPTAIN".
 	SetContextForeGroundColor (PC_CAPTAIN_STRING_TEXT_COLOR);
-	t.baseline.y = r.corner.y + 6;
+	t.baseline.y = r.corner.y + RES_CASE(6,10,18); // JMS_GFX
 	t.pStr = GAME_STRING (STATUS_STRING_BASE + 5); // "CAPTAIN"
 	font_DrawText (&t);
 }
@@ -888,7 +927,7 @@ DrawThrusters (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1;
+	s.origin.x = RES_STAT_SCALE(1); // JMS_GFX
 	s.origin.y = 0;
 	for (i = 0; i < NUM_DRIVE_SLOTS; ++i)
 	{
@@ -901,7 +940,7 @@ DrawThrusters (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -911,7 +950,7 @@ DrawTurningJets (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1;
+	s.origin.x = RES_STAT_SCALE(1); // JMS_GFX
 	s.origin.y = 0;
 	for (i = 0; i < NUM_JET_SLOTS; ++i)
 	{
@@ -924,7 +963,7 @@ DrawTurningJets (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -934,7 +973,7 @@ DrawModules (void)
 	STAMP s;
 	COUNT i;
 
-	s.origin.x = 1; // This properly centers the modules.
+	s.origin.x = RES_STAT_SCALE(1); // JMS_GFX // This properly centers the modules.
 	s.origin.y = 1;
 	for (i = 0; i < NUM_MODULE_SLOTS; ++i)
 	{
@@ -945,7 +984,7 @@ DrawModules (void)
 			DrawStamp (&s);
 		}
 
-		s.origin.y -= 3;
+		s.origin.y -= RES_STAT_SCALE(3); // JMS_GFX
 	}
 }
 
@@ -970,8 +1009,10 @@ DrawSupportShips (void)
 		StarShipPtr = LockShipFrag (&GLOBAL (built_ship_q), hStarShip);
 		hNextShip = _GetSuccLink (StarShipPtr);
 
-		s.origin = *pship_pos;
-		s.frame = StarShipPtr->icons;
+		s.origin.x = RES_STAT_SCALE(pship_pos->x) 
+			+ ((pship_pos - ship_pos) % 2 ? RES_CASE(0,3,5) : RES_CASE(0,-2,-2)); // JMS_GFX
+		s.origin.y = RES_STAT_SCALE(pship_pos->y) + RES_CASE(0,5,0); // JMS_GFX
+		s.frame = SetAbsFrameIndex (StarShipPtr->icons, 2);
 		DrawStamp (&s);
 
 		UnlockShipFrag (&GLOBAL (built_ship_q), hStarShip);
@@ -1010,7 +1051,7 @@ DeltaSISGauges_crewDelta (SIZE crew_delt
 		GetGaugeRect (&r, TRUE);
 		
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = r.corner.y + r.extent.height;
+		t.baseline.y = r.corner.y + r.extent.height - (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
@@ -1058,15 +1099,21 @@ DeltaSISGauges_fuelDelta (SIZE fuel_delt
 	if (new_coarse_fuel != old_coarse_fuel)
 	{
 		TEXT t;
-		UNICODE buf[60];
+		// buf from [60] to [4]: The max fuel anyone can ever get is 1610
+		// I.E. only 4 characters, we don't need that much extra padding.
+		UNICODE buf[4];
 		RECT r;
 
-		snprintf (buf, sizeof buf, "%u", new_coarse_fuel);
+		if(!optInfiniteFuel)
+			snprintf (buf, sizeof buf, "%u", new_coarse_fuel);
+		else
+			snprintf (buf, sizeof buf, "%s", STR_INFINITY_SIGN);
+
 
 		GetGaugeRect (&r, FALSE);
 		
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = r.corner.y + r.extent.height;
+		t.baseline.y = r.corner.y + r.extent.height - (RESOLUTION_FACTOR == 1 ? 1 : 0); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
@@ -1099,10 +1146,7 @@ DeltaSISGauges_resunitDelta (SIZE resuni
 	{
 		RECT r;
 
-		r.corner.x = 2;
-		r.corner.y = 130;
-		r.extent.width = STATUS_MESSAGE_WIDTH;
-		r.extent.height = STATUS_MESSAGE_HEIGHT;
+		GetStatusMessageRect (&r);
 		SetContextForeGroundColor (
 				BUILD_COLOR (MAKE_RGB15 (0x00, 0x08, 0x00), 0x6E));
 		DrawFilledRectangle (&r);
@@ -1115,6 +1159,8 @@ void
 DeltaSISGauges (SIZE crew_delta, SIZE fuel_delta, int resunit_delta)
 {
 	CONTEXT OldContext;
+	Color OldColor;
+	RECT r;
 
 	if (crew_delta == 0 && fuel_delta == 0 && resunit_delta == 0)
 		return;
@@ -1127,6 +1173,15 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 		STAMP s;
 		s.origin.x = 0;
 		s.origin.y = 0;
+
+		// JMS: These lines prevent the flagship status box from turning grey.
+		OldColor = SetContextForeGroundColor (BLACK_COLOR);
+		r.corner.y = 23;
+		r.corner.x = 2;
+		r.extent.width = STATUS_WIDTH - 4;
+		r.extent.height = 105;
+		DrawFilledRectangle (&r);
+
 		s.frame = FlagStatFrame;
 		DrawStamp (&s);
 
@@ -1138,6 +1193,8 @@ DeltaSISGauges (SIZE crew_delta, SIZE fu
 		DrawModules ();
 
 		DrawSupportShips ();
+		// JMS: In conjunction with the JMS lines above.
+		SetContextForeGroundColor (OldColor);
 	}
 
 	SetContextFont (TinyFont);
@@ -1232,12 +1289,8 @@ GetCrewPodForCrewMember (COUNT crewNr, C
 COUNT
 GetCPodCapacity (POINT *ppt)
 {
-	COUNT crewCount;
-	COUNT slotNr;
-	COUNT seatNr;
-
-	COUNT rowNr;
-	COUNT colNr;
+	COUNT crewCount, slotNr, seatNr, rowNr, colNr;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 				
 	static const Color crewRows[] = PC_CREW_COLOR_TABLE;
 
@@ -1256,8 +1309,9 @@ GetCPodCapacity (POINT *ppt)
 	else
 		SetContextForeGroundColor (THREEDO_CREW_COLOR);
 		
-	ppt->x = 27 + (slotNr * SHIP_PIECE_OFFSET) - (colNr * 2);
-	ppt->y = 34 - (rowNr * 2);
+	ppt->x = (27 << RESOLUTION_FACTOR) + (slotNr * ship_piece_offset_scaled) -
+				((colNr * 2) << RESOLUTION_FACTOR) + RES_CASE(0,19,53); // JMS_GFX
+	ppt->y = ((34 - (rowNr * 2)) << RESOLUTION_FACTOR) + RES_CASE(0,6,20); // JMS_GFX
 
 	return GetCrewPodCapacity ();
 }
@@ -1334,19 +1388,15 @@ GetStorageCellForMineralUnit (COUNT unit
 COUNT
 GetSBayCapacity (POINT *ppt)
 {
-	COUNT massCount;
-	COUNT slotNr;
-	COUNT cellNr;
-
-	COUNT rowNr;
-	COUNT colNr;
+	COUNT massCount, slotNr, cellNr, rowNr, colNr;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 				
 	static const Color colorBars[] = STORAGE_BAY_COLOR_TABLE;
 
 	massCount = GetElementMass ();
 	if (!GetStorageCellForMineralUnit (massCount, &slotNr, &cellNr))
 	{
-		// Crew does not fit. *ppt is unchanged.
+		// Mineral does not fit. *ppt is unchanged.
 		return GetStorageBayCapacity ();
 	}
 
@@ -1361,8 +1411,8 @@ GetSBayCapacity (POINT *ppt)
 		SetContextForeGroundColor (colorBars[rowNr]);
 	}
 		
-	ppt->x = 19 + (slotNr * SHIP_PIECE_OFFSET);
-	ppt->y = 34 - (rowNr * 2);
+	ppt->x = (19 << RESOLUTION_FACTOR) + (slotNr * ship_piece_offset_scaled) + RES_CASE(0,19,53); // JMS_GFX
+	ppt->y = ((34 - (rowNr * 2)) << RESOLUTION_FACTOR) - RES_CASE(0,0,9); // JMS_GFX
 
 	return GetStorageBayCapacity ();
 }
@@ -1444,14 +1494,10 @@ GetFuelTankForFuelUnit (DWORD unitNr, CO
 DWORD
 GetFTankCapacity (POINT *ppt)
 {
-	DWORD capacity;
-	DWORD fuelAmount;
+	DWORD capacity, rowNr, fuelAmount, compartmentNr, volume, volumehelper;
 	COUNT slotNr;
-	DWORD compartmentNr;
 	BYTE moduleType;
-	DWORD volume;
-
-	COUNT rowNr;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET + RES_CASE(0,1,1);  // JMS_GFX
 	
 	static const Color fuelColors[] = FUEL_COLOR_TABLE;
 		
@@ -1473,13 +1519,23 @@ GetFTankCapacity (POINT *ppt)
 	moduleType = GLOBAL_SIS (ModuleSlots[slotNr]);
 	volume = GetModuleFuelCapacity (moduleType);
 
-	rowNr = ((volume - compartmentNr) * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY);
-		
-	ppt->x = 21 + (slotNr * SHIP_PIECE_OFFSET);
 	if (volume == FUEL_TANK_CAPACITY)
-		ppt->y = 27 - rowNr;
+		volumehelper = (volume * 10) / RES_CASE(10,22,22);
 	else
-		ppt->y = 30 - rowNr;
+		volumehelper = volume;
+
+	rowNr = ((volumehelper - compartmentNr) * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY);
+	ppt->x = (21 << RESOLUTION_FACTOR) + (slotNr * ship_piece_offset_scaled);
+	if (volume == FUEL_TANK_CAPACITY) {
+		ppt->x += RES_CASE(0,20,54); // JMS_GFX
+		ppt->y = (27 << RESOLUTION_FACTOR) - rowNr + RES_CASE(0,11,27); // JMS_GFX
+	} else {
+		ppt->x += RES_CASE(0,20,53); // JMS_GFX
+		ppt->y = (30 << RESOLUTION_FACTOR) - rowNr + RES_CASE(0,21,43); // JMS_GFX
+	}
+	
+	rowNr = ((volume - compartmentNr) * 10 * MAX_FUEL_BARS / HEFUEL_TANK_CAPACITY) /
+		MAX_FUEL_BARS;
 
 	assert (rowNr + 1 < (COUNT) (sizeof fuelColors / sizeof fuelColors[0]));
 	SetContextForeGroundColor (fuelColors[rowNr]);
diff -ruNp src.orig/uqm/sis.h src/uqm/sis.h
--- src.orig/uqm/sis.h	2017-12-30 00:14:41 -0800
+++ src/uqm/sis.h	2017-12-30 00:14:54 -0800
@@ -21,6 +21,8 @@
 #include "libs/gfxlib.h"
 #include "planets/elemdata.h"
 		// for NUM_ELEMENT_CATEGORIES
+#include "units.h"
+                // for RESOLUTION_FACTOR
 
 #if defined(__cplusplus)
 extern "C" {
@@ -47,9 +49,10 @@ extern "C" {
 #define CREW_PER_ROW 5
 #define SBAY_MASS_PER_ROW 50
 
-#define MAX_FUEL_BARS 10
+#define MAX_FUEL_BARS RES_CASE(10,40,80)
 #define FUEL_VOLUME_PER_ROW (HEFUEL_TANK_CAPACITY / MAX_FUEL_BARS)
-#define FUEL_RESERVE FUEL_VOLUME_PER_ROW
+#define FUEL_RESERVE (10 * FUEL_TANK_SCALE) // JMS_GFX
+#define FUEL_COST_RU 20 // JMS
 
 #define IP_SHIP_THRUST_INCREMENT 8
 #define IP_SHIP_TURN_WAIT 17
@@ -92,22 +95,22 @@ enum
 #define EMPTY_SLOT NUM_MODULES
 #define NUM_BOMB_MODULES 10
 
-#define DRIVE_SIDE_X 31
-#define DRIVE_SIDE_Y 56
-#define DRIVE_TOP_X 33
-#define DRIVE_TOP_Y (65 + 21)
-
-#define JET_SIDE_X 71
-#define JET_SIDE_Y 48
-#define JET_TOP_X 70
-#define JET_TOP_Y (73 + 21)
-
-#define MODULE_SIDE_X 17
-#define MODULE_SIDE_Y 14
-#define MODULE_TOP_X 17
-#define MODULE_TOP_Y (96 + 21)
+#define DRIVE_SIDE_X ((31 << RESOLUTION_FACTOR)) // JMS_GFX
+#define DRIVE_SIDE_Y ((56 << RESOLUTION_FACTOR)) // JMS_GFX
+#define DRIVE_TOP_X ((33 << RESOLUTION_FACTOR) + RES_CASE(0,42,100)) // JMS_GFX
+#define DRIVE_TOP_Y ((86 << RESOLUTION_FACTOR) - RES_CASE(0,45,73)) // JMS_GFX
+
+#define JET_SIDE_X ((71 << RESOLUTION_FACTOR)) // JMS_GFX
+#define JET_SIDE_Y ((48 << RESOLUTION_FACTOR)) // JMS_GFX
+#define JET_TOP_X ((70 << RESOLUTION_FACTOR) + RES_CASE(0,32,86)) // JMS_GFX
+#define JET_TOP_Y ((94 << RESOLUTION_FACTOR) - RES_CASE(0,69,120)) // JMS_GFX
+
+#define MODULE_SIDE_X ((17 << RESOLUTION_FACTOR) + RES_CASE(0,21,55)) // JMS_GFX
+#define MODULE_SIDE_Y ((14 << RESOLUTION_FACTOR) - RES_CASE(0,2,5)) // JMS_GFX
+#define MODULE_TOP_X ((17 << RESOLUTION_FACTOR) + RES_CASE(0,22,55)) // JMS_GFX
+#define MODULE_TOP_Y ((117 << RESOLUTION_FACTOR) + RES_CASE(0,14,59)) // JMS_GFX
 
-#define SHIP_PIECE_OFFSET 12
+#define SHIP_PIECE_OFFSET ((12 << RESOLUTION_FACTOR) - RES_CASE(0,3,2)) // JMS_GFX
 
 #define MAX_BUILT_SHIPS 12
 		/* Maximum number of ships escorting the SIS */
@@ -128,6 +131,8 @@ enum
 	{3 + 42, 30 + (5 * 16)},
 
 #define SIS_NAME_SIZE 16
+#define SAVE_NAME_CHECKER "MegaMod" // JMS
+#define SAVE_CHECKER_SIZE SIS_NAME_SIZE
 
 typedef struct
 {
@@ -199,6 +204,8 @@ typedef enum
 	SMM_DATE,
 	SMM_RES_UNITS,
 	SMM_CREDITS,
+	SMM_WARNING,
+	SMM_ALERT,
 
 	SMM_DEFAULT = SMM_DATE,
 } StatMsgMode;
diff -ruNp src.orig/uqm/sounds.h src/uqm/sounds.h
--- src.orig/uqm/sounds.h	2017-12-30 00:14:41 -0800
+++ src/uqm/sounds.h	2017-12-30 00:14:54 -0800
@@ -43,6 +43,7 @@ typedef enum
 	MENU_SOUND_SUCCESS,
 	MENU_SOUND_FAILURE,
 	MENU_SOUND_INVOKED,
+	MENU_SOUND_BUBBLEWARP,
 } MENU_SOUND_EFFECT;
 
 extern SOUND MenuSounds;
diff -ruNp src.orig/uqm/starbase.c src/uqm/starbase.c
--- src.orig/uqm/starbase.c	2017-12-30 00:14:41 -0800
+++ src/uqm/starbase.c	2017-12-30 00:14:54 -0800
@@ -32,6 +32,13 @@
 #include "sounds.h"
 #include "libs/graphics/gfx_common.h"
 #include "libs/tasklib.h"
+#include "libs/log.h"
+
+#include "planets/planets.h"
+// JMS: For MIN_MOON_RADIUS
+
+#include <math.h>
+// JMS: For sin and cos
 
 
 static void CleanupAfterStarBase (void);
@@ -40,18 +47,21 @@ static void
 DrawBaseStateStrings (STARBASE_STATE OldState, STARBASE_STATE NewState)
 {
 	TEXT t;
+	RECT r;
+	COUNT text_base_y = 106 + 28 - RES_CASE (0,2,0);
+	COUNT text_spacing_y = 23 - 4;
 	//STRING locString;
 
 	SetContext (ScreenContext);
 	SetContextFont (StarConFont);
 	SetContextForeGroundColor (BLACK_COLOR);
 
-	t.baseline.x = 73 - 4 + SAFE_X;
+	t.baseline.x = (73 - 4 + SAFE_X) << RESOLUTION_FACTOR; // JMS_GFX
 	t.align = ALIGN_CENTER;
 
 	if (OldState == (STARBASE_STATE)~0)
 	{
-		t.baseline.y = 106 + 28 + (SAFE_Y + 4);
+		t.baseline.y = (text_base_y  << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX;
 		for (OldState = TALK_COMMANDER; OldState < DEPART_BASE; ++OldState)
 		{
 			if (OldState != NewState)
@@ -60,18 +70,24 @@ DrawBaseStateStrings (STARBASE_STATE Old
 				t.CharCount = (COUNT)~0;
 				font_DrawText (&t);
 			}
-			t.baseline.y += (23 - 4);
+			t.baseline.y += text_spacing_y << RESOLUTION_FACTOR; // JMS_GFX
 		}
 	}
 
-	t.baseline.y = 106 + 28 + (SAFE_Y + 4) + ((23 - 4) * OldState);
+	t.baseline.y = ((text_base_y + (text_spacing_y * OldState)) << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX
 	t.pStr = GAME_STRING (STARBASE_STRING_BASE + 1 + OldState);
+	// BW: erase previously selected string before redrawing it
+	TextRect(&t, &r, NULL);
+	SetContextForeGroundColor (
+			   BUILD_COLOR_RGBA (0x88, 0x88, 0x88, 0xff));
+	DrawFilledRectangle (&r);
+	SetContextForeGroundColor (BLACK_COLOR);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
 
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x1F, 0x1F, 0x0A), 0x0E));
-	t.baseline.y = 106 + 28 + (SAFE_Y + 4) + ((23 - 4) * NewState);
+	t.baseline.y = ((text_base_y + (text_spacing_y * NewState)) << RESOLUTION_FACTOR) + (SAFE_Y + 4); // JMS_GFX
 	t.pStr = GAME_STRING (STARBASE_STRING_BASE + 1 + NewState);
 	t.CharCount = (COUNT)~0;
 	font_DrawText (&t);
@@ -86,6 +102,13 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 	RECT r;
 	STAMP Side, Top;
 	SBYTE RepairSlot;
+	COUNT ship_piece_offset_scaled = SHIP_PIECE_OFFSET;
+ 
+	// JMS_GFX
+	if (RESOLUTION_FACTOR != 0 &&
+		which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+		 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1)
+		ship_piece_offset_scaled += 1;
 
 	RepairSlot = 0;
 	switch (which_piece)
@@ -138,54 +161,103 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 			break;
 	}
 
-	Side.origin.x += which_slot * SHIP_PIECE_OFFSET;
+	Side.origin.x += which_slot * ship_piece_offset_scaled;
 	Side.frame = NULL;
 	if (RepairSlot < 0)
 	{
 		Side.frame = SetAbsFrameIndex (ModuleFrame,
 				((NUM_MODULES - 1) + (6 - 2)) + (NUM_MODULES + 6)
 				- (RepairSlot + 1));
-		DrawStamp (&Side);
+		// JMS_GFX:
+		if (RESOLUTION_FACTOR == 0 ||
+			(which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+			 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1))
+			DrawStamp (&Side);
 	}
-	else if (RepairSlot)
+	else if (RepairSlot && !(RESOLUTION_FACTOR > 0 && DrawBluePrint))
 	{
-		r.corner = Side.origin;
-		r.extent.width = SHIP_PIECE_OFFSET;
-		r.extent.height = 1;
 		OldColor = SetContextForeGroundColor (BLACK_COLOR);
+
+		r.corner = Side.origin;
+		r.corner.y += RES_CASE(0,0,8);
+		r.extent.width = ship_piece_offset_scaled;
+		r.extent.height = 1 << RESOLUTION_FACTOR;
+
 		DrawFilledRectangle (&r);
-		r.corner.y += 23 - 1;
+
+		r.corner.y += ((23 - 1) << RESOLUTION_FACTOR); // JMS_GFX
+		if (RESOLUTION_FACTOR != 0)
+			r.extent.height += RES_CASE(0,15,30); 
+		
+		if (which_slot == 0 && RESOLUTION_FACTOR !=0)
+			r.corner.x += RES_CASE(0,2,4); // JMS_GFX
+		else if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0)
+			r.extent.width -= RES_CASE(0,4,9); // JMS_GFX
 		DrawFilledRectangle (&r);
+		
+		r.extent.width = RES_CASE(1,5,12);
+		r.extent.height = (8 << RESOLUTION_FACTOR) + RES_CASE(0,13,30); // JMS_GFX
 
-		r.extent.width = 1;
-		r.extent.height = 8;
 		if (RepairSlot == 2)
 		{
 			r.corner = Side.origin;
+			r.corner.y += RES_CASE(0,0,8);
 			DrawFilledRectangle (&r);
-			r.corner.y += 15;
+			if (RESOLUTION_FACTOR > 0) {
+				r.corner.x += ship_piece_offset_scaled - r.extent.width;
+				if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0) {
+					r.extent.height -= RES_CASE(0,8,16); // JMS_GFX
+					r.extent.width += RES_CASE(0,2,4); // JMS_GFX
+					DrawFilledRectangle (&r);
+					r.extent.width -= RES_CASE(0,2,4); // JMS_GFX
+				} else
+					DrawFilledRectangle (&r);
+				
+				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+			}
+			r.corner.y += 15 << RESOLUTION_FACTOR; // JMS_GFX
 			DrawFilledRectangle (&r);
+			if (RESOLUTION_FACTOR > 0) {
+				r.corner.x += ship_piece_offset_scaled - r.extent.width;
+				if (which_slot == NUM_MODULE_SLOTS - 1 && RESOLUTION_FACTOR !=0) {
+					r.corner.y += RES_CASE(0,16,32);
+					r.extent.height -= RES_CASE(0,17,36); // JMS_GFX
+					r.extent.width += RES_CASE(0,1,3); // JMS_GFX
+					DrawFilledRectangle (&r);
+					r.extent.width -= RES_CASE(0,1,3); // JMS_GFX
+					r.extent.height += RES_CASE(0,17,36); // JMS_GFX
+				} else
+					DrawFilledRectangle (&r);
+				
+				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+			}
 		}
 		if (which_slot < (NUM_MODULE_SLOTS - 1))
 		{
 			r.corner = Side.origin;
-			r.corner.x += SHIP_PIECE_OFFSET;
+			r.corner.y += RES_CASE(0,0,8);
+			r.corner.x += ship_piece_offset_scaled;
 			DrawFilledRectangle (&r);
-			r.corner.y += 15;
+			if (RESOLUTION_FACTOR == 2) {
+				r.corner.x += ship_piece_offset_scaled - r.extent.width;
+				DrawFilledRectangle (&r);
+				r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+			}
+			r.corner.y += 15 << RESOLUTION_FACTOR; // JMS_GFX
 			DrawFilledRectangle (&r);
 		}
 	}
 
 	if (DrawBluePrint)
 	{
-		if (RepairSlot)
+		if (RepairSlot && !(RESOLUTION_FACTOR > 0 && DrawBluePrint))
 			SetContextForeGroundColor (OldColor);
 		Side.frame = SetAbsFrameIndex (ModuleFrame, which_piece - 1);
 		DrawFilledStamp (&Side);
 	}
 	else
 	{
-		Top.origin.x += which_slot * SHIP_PIECE_OFFSET;
+		Top.origin.x += which_slot * ship_piece_offset_scaled;
 		if (RepairSlot < 0)
 		{
 			Top.frame = SetRelFrameIndex (Side.frame, -((NUM_MODULES - 1) + 6));
@@ -194,28 +266,38 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 		else if (RepairSlot)
 		{
 			r.corner = Top.origin;
-			r.extent.width = SHIP_PIECE_OFFSET;
-			r.extent.height = 1;
+			r.extent.width = ship_piece_offset_scaled;
+			r.extent.height = (1 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR;
 			DrawFilledRectangle (&r);
-			r.corner.y += 32 - 1;
+			r.corner.y += ((32 - 1) << RESOLUTION_FACTOR) + RES_CASE(0,3,16);  // JMS_GFX
 			DrawFilledRectangle (&r);
 
-			r.extent.width = 1;
-			r.extent.height = 12;
+			r.extent.width = (1 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR;
+			r.extent.height = (12 << RESOLUTION_FACTOR) + RES_CASE(0,1,17); // JMS_GFX
 			if (RepairSlot == 2)
 			{
 				r.corner = Top.origin;
 				DrawFilledRectangle (&r);
-				r.corner.y += 20;
-				DrawFilledRectangle (&r);
+				if (RESOLUTION_FACTOR == 2) {
+					r.corner.x += ship_piece_offset_scaled - r.extent.width;
+					DrawFilledRectangle (&r);
+					r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+				}
+				r.corner.y += 20 << RESOLUTION_FACTOR; // JMS_GFX
+ 				DrawFilledRectangle (&r);
+				if (RESOLUTION_FACTOR == 2) {
+					r.corner.x += ship_piece_offset_scaled - r.extent.width;
+					DrawFilledRectangle (&r);
+					r.corner.x -= ship_piece_offset_scaled - r.extent.width;
+				}
 			}
 			RepairSlot = (which_slot < NUM_MODULE_SLOTS - 1);
 			if (RepairSlot)
 			{
 				r.corner = Top.origin;
-				r.corner.x += SHIP_PIECE_OFFSET;
+				r.corner.x += ship_piece_offset_scaled;
 				DrawFilledRectangle (&r);
-				r.corner.y += 20;
+				r.corner.y += 20 << RESOLUTION_FACTOR; // JMS_GFX
 				DrawFilledRectangle (&r);
 			}
 		}
@@ -224,26 +306,44 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 		DrawStamp (&Top);
 
 		Side.frame = SetRelFrameIndex (Top.frame, (NUM_MODULES - 1) + 6);
-		DrawStamp (&Side);
+		if (RESOLUTION_FACTOR != 0 
+			&& (which_piece == EMPTY_SLOT + 2 
+				|| which_piece == EMPTY_SLOT + 3))
+		{
+			if (which_slot == 0)
+				Side.frame = SetRelFrameIndex (Side.frame, 8);
+			if (which_slot == 1)
+				Side.frame = SetRelFrameIndex (Side.frame, 10);
+			if (which_slot == NUM_MODULE_SLOTS - 2)
+				Side.frame = SetRelFrameIndex (Side.frame, 10);
+			if (which_slot == NUM_MODULE_SLOTS - 1)
+				Side.frame = SetRelFrameIndex (Side.frame, 11);
+		}
+		
+		// JMS_GFX:
+		if (RESOLUTION_FACTOR == 0 ||
+			(which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+			 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1))
+			DrawStamp (&Side);
 
-		if (which_slot == 1 && which_piece == EMPTY_SLOT + 2)
+		if (which_slot == 1 && which_piece == EMPTY_SLOT + 2 && RESOLUTION_FACTOR == 0)
 		{
 			STAMP s;
 
 			s.origin = Top.origin;
-			s.origin.x -= SHIP_PIECE_OFFSET;
+			s.origin.x -= ship_piece_offset_scaled;
 			s.frame = SetAbsFrameIndex (ModuleFrame, NUM_MODULES + 5);
 			DrawStamp (&s);
 			s.origin = Side.origin;
-			s.origin.x -= SHIP_PIECE_OFFSET;
+			s.origin.x -= ship_piece_offset_scaled;
 			s.frame = SetRelFrameIndex (s.frame, (NUM_MODULES - 1) + 6);
 			DrawStamp (&s);
 		}
 
 		if (RepairSlot)
 		{
-			Top.origin.x += SHIP_PIECE_OFFSET;
-			Side.origin.x += SHIP_PIECE_OFFSET;
+			Top.origin.x += ship_piece_offset_scaled;
+			Side.origin.x += ship_piece_offset_scaled;
 			which_piece = GLOBAL_SIS (ModuleSlots[++which_slot]);
 			if (which_piece == EMPTY_SLOT + 2
 					&& which_slot >= NUM_MODULE_SLOTS - 3)
@@ -253,7 +353,25 @@ DrawShipPiece (FRAME ModuleFrame, COUNT
 			DrawStamp (&Top);
 
 			Side.frame = SetRelFrameIndex (Top.frame, (NUM_MODULES - 1) + 6);
-			DrawStamp (&Side);
+			if (RESOLUTION_FACTOR != 0)
+			{
+				if (which_slot == 0 && which_piece == EMPTY_SLOT + 3)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-4);
+				if (which_slot == 1 && which_piece == EMPTY_SLOT + 2)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-3);
+				if (which_slot == NUM_MODULE_SLOTS - 2 
+					&& which_piece == EMPTY_SLOT + 3)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-2);
+				if (which_slot == NUM_MODULE_SLOTS - 1 
+					&& which_piece == EMPTY_SLOT + 3)
+					Side.frame = SetAbsFrameIndex (ModuleFrame, GetFrameCount (ModuleFrame)-1);
+			}
+			
+			// JMS_GFX:
+			if (RESOLUTION_FACTOR == 0 ||
+				(which_piece != FUSION_THRUSTER && which_piece != TURNING_JETS
+				 && which_piece != EMPTY_SLOT + 0 && which_piece != EMPTY_SLOT + 1))
+				DrawStamp (&Side);
 		}
 	}
 }
@@ -425,6 +543,41 @@ DoTimePassage (void)
 #define LOST_DAYS 14
 	SleepThreadUntil (FadeScreen (FadeAllToBlack, ONE_SECOND * 2));
 	MoveGameClockDays (LOST_DAYS);
+
+	// JMS: Calculate flagship location in IP.
+	{
+		double newAngle;
+		POINT starbase_coords;
+		RECT r;
+		COORD dx, dy;
+		
+		// Starbase's radius from earth is MIN_MOON_RADIUS.
+		dx = MIN_MOON_RADIUS;
+		dy = MIN_MOON_RADIUS;
+		
+		// Calculate the starbase position on a circle with the help of sin and cos.
+		newAngle = ((double)(10) + daysElapsed() * (FULL_CIRCLE / 11.46)) * M_PI / 32 - M_PI/2 ; // JMS: Starbase orbit values copied from gensol.c
+		starbase_coords.x = (COORD)(cos(newAngle) * MIN_MOON_RADIUS);
+		starbase_coords.y = (COORD)(sin(newAngle) * MIN_MOON_RADIUS);
+		
+		//log_add (log_Debug, "startangle:%d angle:%f, radius:%d, speed:%f, days:%f X:%d, y:%d", 10, newAngle, MIN_MOON_RADIUS, FULL_CIRCLE / 11.46, daysElapsed(), starbase_coords.x, starbase_coords.y);
+		
+		// Translate the coordinates on a circle to an ellipse.
+		r.corner.x = (SIS_SCREEN_WIDTH >> 1) + (long)-dx;
+		r.corner.y = (SIS_SCREEN_HEIGHT >> 1) + (long)-dy / 2;
+		r.extent.width = (long)MIN_MOON_RADIUS * (2 << 1) / 2;
+		r.extent.height = r.extent.width >> 1;
+		r.corner.x += r.extent.width >> 1;
+		r.corner.y += r.extent.height >> 1;
+		r.corner.x += (long)starbase_coords.x;
+		r.corner.y += (long)starbase_coords.y / 2;
+		
+		//log_add (log_Debug, "X:%d, y:%d", r.corner.x, r.corner.y);
+		
+		// Update the ship's graphics' coordinates on the screen.
+		GLOBAL (ShipStamp.origin.x) = r.corner.x;
+		GLOBAL (ShipStamp.origin.y) = r.corner.y;
+	}
 }
 
 void
diff -ruNp src.orig/uqm/starcon.c src/uqm/starcon.c
--- src.orig/uqm/starcon.c	2017-12-30 00:14:41 -0800
+++ src/uqm/starcon.c	2017-12-30 00:14:54 -0800
@@ -47,9 +47,16 @@
 #include "libs/graphics/tfb_draw.h"
 #include "libs/misc.h"
 #include "libs/scriptlib.h"
-
+#include "build.h"
 #include "uqmversion.h"
 #include "options.h"
+#include "setupmenu.h"
+#include "build.h"
+#include "gameopt.h" // JMS: For naming captain and ship at game start.
+#include "nameref.h"
+#include "settings.h"
+#include "cons_res.h"
+#include <time.h>//required to use 'srand(time(NULL))'
 
 volatile int MainExited = FALSE;
 #ifdef DEBUG_SLEEP
@@ -85,8 +92,11 @@ on_battle_frame (void)
 	GameClockTick ();
 	checkArilouGate ();
 
-	if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD)))
+	if (!(GLOBAL (CurrentActivity) & (CHECK_ABORT | CHECK_LOAD))){		
+		if(RESOLUTION_FACTOR == 1)				
+			DrawSubmenu (0);
 		SeedUniverse ();
+	}
 
 	DrawAutoPilotMessage (FALSE);
 }
@@ -206,7 +216,26 @@ while (--ac > 0)
 
 	GLOBAL (CurrentActivity) = 0;
 	luaUqm_initState ();
-	// show splash and init the kernel in the meantime
+	// show logo then splash and init the kernel in the meantime
+	if(optFMV && !optSkipIntro){
+		Logo ();
+	}
+
+	{
+		srand(time(NULL));
+		
+		Rando = (rand() % NUM_MM_THEMES);
+
+		// printf("Random Music #: %d\n", Rando);
+
+		FadeMusic(0,0);
+		PlayMusic (loadMainMenuMusic(Rando), TRUE, 1);
+		
+		if (optMainMenuMusic)
+			FadeMusic (NORMAL_VOLUME+70, ONE_SECOND * 3);
+		comingFromInit = TRUE;
+	}
+
 	SplashScreen (BackgroundInitKernel);
 
 //	OpenJournal ();
@@ -224,9 +253,13 @@ while (--ac > 0)
 		initEventSystem ();
 		AddInitialGameEvents();
 
+		// JMS: Name Captain & Ship at start (not at loading old game).
+		if (LastActivity == (CHECK_LOAD | CHECK_RESTART))
+			AskNameForCaptainAndShip();
+
 		do
 		{
-#ifdef DEBUG
+//#ifdef DEBUG
 			if (debugHook != NULL)
 			{
 				void (*saveDebugHook) (void);
@@ -237,7 +270,7 @@ while (--ac > 0)
 				(*saveDebugHook) ();
 				continue;
 			}
-#endif
+//#endif
 			SetStatusMessageMode (SMM_DEFAULT);
 
 			if (!((GLOBAL (CurrentActivity) | NextActivity) & CHECK_LOAD))
@@ -307,6 +340,9 @@ while (--ac > 0)
 					GLOBAL (CurrentActivity) &= ~CHECK_RESTART;
 				break;
 			}
+			if (optInfiniteRU){
+				GLOBAL_SIS (ResUnits) = 4000000000L;
+			}
 		} while (!(GLOBAL (CurrentActivity) & CHECK_ABORT));
 
 		StopSound ();
diff -ruNp src.orig/uqm/state.c src/uqm/state.c
--- src.orig/uqm/state.c	2017-12-30 00:14:41 -0800
+++ src/uqm/state.c	2017-12-30 00:14:54 -0800
@@ -236,17 +236,25 @@ UninitPlanetInfo (void)
 }
 
 #define OFFSET_SIZE       (sizeof (DWORD))
-#define SCAN_RECORD_SIZE  (sizeof (DWORD) * NUM_SCAN_TYPES)
+//#define SCAN_RECORD_SIZE  (sizeof (DWORD) * NUM_SCAN_TYPES)
+// JMS: Increased the size of scan record to house partially scavenged minerals.
+#define SCAN_RECORD_SIZE  ((sizeof (DWORD) * NUM_SCAN_TYPES) + (sizeof(BYTE) * NUM_SCAN_TYPES * 32))
 
 void
 GetPlanetInfo (void)
 {
 	GAME_STATE_FILE *fp;
+	COUNT k,l;
 
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[BIOLOGICAL_SCAN] = 0;
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[MINERAL_SCAN] = 0;
 	pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask[ENERGY_SCAN] = 0;
 
+	// JMS: Init also the partially scavenged mineral deposit values.
+	for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+		for (k = 0; k < 32; k++)
+			pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[l][k] = 0;
+
 	fp = OpenStateFile (STARINFO_FILE, "rb");
 	if (fp)
 	{
@@ -280,6 +288,15 @@ GetPlanetInfo (void)
 			SeekStateFile (fp, offset, SEEK_SET);
 			sread_a32 (fp, pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask,
 					NUM_SCAN_TYPES);
+
+			{
+				BYTE *ar = &(pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[0][0]); // JMS
+				
+				// JMS: Read which mineral deposits are partially retrieved (and how much).
+				for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+					for (k = 0; k < 32; k++, ar++)
+						sread_8 (fp, ar);
+			}
 		}
 
 		CloseStateFile (fp);
@@ -294,7 +311,7 @@ PutPlanetInfo (void)
 	fp = OpenStateFile (STARINFO_FILE, "r+b");
 	if (fp)
 	{
-		COUNT i;
+		COUNT i, k, l;
 		COUNT star_index, planet_index, moon_index;
 		DWORD offset;
 
@@ -317,6 +334,12 @@ PutPlanetInfo (void)
 				0, 0, 0,
 			};
 
+			// JMS: Init also the partially scavenged mineral deposit values.
+			BYTE PartiallyScavengedList[NUM_SCAN_TYPES][32];
+			for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+				for (k = 0; k < 32; k++)
+					PartiallyScavengedList[l][k] = 0;
+
 			offset = LengthStateFile (fp);
 
 			// Write the record offset
@@ -328,11 +351,26 @@ PutPlanetInfo (void)
 			for (i = 0; i < pSolarSysState->SunDesc[0].NumPlanets; ++i)
 			{
 				COUNT j;
+				BYTE *ar = &(PartiallyScavengedList[0][0]); // JMS
 
 				swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
+
+				// JMS: Also init with zeroes the list of partially scavenged mineral amounts.
+				for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+					for (k = 0; k < 32; k++, ar++)
+						swrite_8 (fp, *ar);
+
 				// init moons
-				for (j = 0; j < pSolarSysState->PlanetDesc[i].NumPlanets; ++j)
-					swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
+				for (j = 0; j < pSolarSysState->PlanetDesc[i].NumPlanets; ++j) {
+					BYTE *ar = &(PartiallyScavengedList[0][0]); // JMS
+					
+ 					swrite_a32 (fp, ScanRetrieveMask, NUM_SCAN_TYPES);
+					
+					// JMS: Ditto for the moons.
+					for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+						for (k = 0; k < 32; k++, ar++)
+							swrite_8 (fp, *ar);
+				}
 			}
 		}
 
@@ -345,9 +383,20 @@ PutPlanetInfo (void)
 		offset += moon_index * SCAN_RECORD_SIZE;
 
 		SeekStateFile (fp, offset, SEEK_SET);
+
+		// Store which mineral deposits we have already retrieved.
 		swrite_a32 (fp, pSolarSysState->SysInfo.PlanetInfo.ScanRetrieveMask,
 				NUM_SCAN_TYPES);
 
+		{
+			BYTE *ar = &(pSolarSysState->SysInfo.PlanetInfo.PartiallyScavengedList[0][0]); // JMS
+			
+			// JMS: Store which mineral deposits are partially retrieved (and how much).
+			for (l = MINERAL_SCAN; l < NUM_SCAN_TYPES; l++)
+				for (k = 0; k < 32; k++, ar++)
+					swrite_8 (fp, *ar);
+		}
+
 		CloseStateFile (fp);
 	}
 }
diff -ruNp src.orig/uqm/status.c src/uqm/status.c
--- src.orig/uqm/status.c	2017-12-30 00:14:42 -0800
+++ src/uqm/status.c	2017-12-30 00:14:54 -0800
@@ -137,18 +137,18 @@ DrawBattleCrewAmount (SHIP_INFO *ShipInf
 	TEXT t;
 	UNICODE buf[40];
 
-	t.baseline.x = BATTLE_CREW_X + 2;
+	t.baseline.x = BATTLE_CREW_X + RES_STAT_SCALE(2) - RES_CASE(0,1,2); // JMS_GFX
 	if (optWhichMenu == OPT_PC)
-			t.baseline.x -= 8;
+			t.baseline.x -= RES_STAT_SCALE(8); // JMS_GFX
 	t.baseline.y = BATTLE_CREW_Y + y_offs;
 	t.align = ALIGN_LEFT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
 
 	r.corner.x = t.baseline.x;
-	r.corner.y = t.baseline.y - 5;
-	r.extent.width = 6 * MAX_CREW_DIGITS + 6;
-	r.extent.height = 5;
+	r.corner.y = t.baseline.y - (5 << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.width = 6 * MAX_CREW_DIGITS + (6 << RESOLUTION_FACTOR) + RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.height = (5 << RESOLUTION_FACTOR) + RES_CASE(0,2,3); // JMS_GFX
 
 	sprintf (buf, "%u", ShipInfoPtr->crew_level);
 	SetContextFont (StarConFont);
@@ -188,17 +188,19 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 
 	BatchGraphics ();
 	
+	// Grey area under and around captain's window.
 	assert (StarShipPtr->playerNr >= 0);
 	y_offs = status_y_offsets[StarShipPtr->playerNr];
 
-	r.corner.x = CAPTAIN_XOFFS - 2;
+	r.corner.x = CAPTAIN_XOFFS - RES_STAT_SCALE(4); // JMS_GFX
 	r.corner.y = y_offs + SHIP_INFO_HEIGHT;
-	r.extent.width = STATUS_WIDTH - CAPTAIN_XOFFS;
-	r.extent.height = SHIP_STATUS_HEIGHT - CAPTAIN_YOFFS + 2;
+	r.extent.width = STATUS_WIDTH - 2;
+	r.extent.height = SHIP_STATUS_HEIGHT - CAPTAIN_YOFFS + (4 << RESOLUTION_FACTOR); // JMS_GFX
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x0A), 0x08));
 	DrawFilledRectangle (&r);
 
+	// Left border of the status panel.
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
 	r.corner.x = 1;
@@ -210,6 +212,7 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 	++r.extent.height;
 	DrawFilledRectangle (&r);
 
+	// Lower and right border of the status panel.
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
 	r.corner.x = STATUS_WIDTH - 1;
@@ -231,30 +234,32 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 
 	y = y_offs + CAPTAIN_YOFFS;
 
+	// Darker grey rectangle at bottom and right of captain's window
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x08, 0x08, 0x08), 0x1F));
-	r.corner.x = 59;
+	r.corner.x = CAPTAIN_WIDTH + CAPTAIN_XOFFS;
 	r.corner.y = y;
 	r.extent.width = 1;
-	r.extent.height = 30;
+	r.extent.height = CAPTAIN_HEIGHT;
 	DrawFilledRectangle (&r);
-	r.corner.x = 3;
-	r.corner.y += 30;
-	r.extent.width = 57;
+	r.corner.x = CAPTAIN_XOFFS - 1;
+	r.corner.y += CAPTAIN_HEIGHT;
+	r.extent.width = CAPTAIN_WIDTH + 2;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
 
+	// Light grey rectangle at top and left of captains window
 	SetContextForeGroundColor (
 			BUILD_COLOR (MAKE_RGB15 (0x10, 0x10, 0x10), 0x19));
-	r.corner.x = 3;
-	r.extent.width = 57;
+	r.corner.x = CAPTAIN_XOFFS - 1;
+	r.extent.width = CAPTAIN_WIDTH + 2;
 	r.corner.y = y - 1;
 	r.extent.height = 1;
 	DrawFilledRectangle (&r);
-	r.corner.x = 3;
+	r.corner.x = CAPTAIN_XOFFS - 1;
 	r.extent.width = 1;
 	r.corner.y = y;
-	r.extent.height = 30;
+	r.extent.height = CAPTAIN_HEIGHT;
 	DrawFilledRectangle (&r);
 
 	s.frame = RDPtr->ship_data.captain_control.background;
@@ -268,12 +273,11 @@ DrawCaptainsWindow (STARSHIP *StarShipPt
 		TEXT t;
 
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = y + 6;
+		t.baseline.y = y + RES_CASE(6,-22,-44); // JMS_GFX
 		t.align = ALIGN_CENTER;
 		t.pStr = GLOBAL_SIS (CommanderName);
 		t.CharCount = (COUNT)~0;
-		SetContextForeGroundColor (
-				BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02));
+		SetContextForeGroundColor (RES_CASE(BUILD_COLOR (MAKE_RGB15 (0x00, 0x14, 0x00), 0x02), BLACK_COLOR, BLACK_COLOR));
 		SetContextFont (TinyFont);
 		font_DrawText (&t);
 	}
@@ -421,7 +425,7 @@ PostProcessStatus (ELEMENT *ShipPtr)
 
 			if (StarShipPtr->RaceDescPtr->ship_info.crew_level == 0)
 			{
-				BYTE i;
+				BYTE i, j;
 				Color c;
 				RECT r;
 
@@ -469,49 +473,56 @@ PostProcessStatus (ELEMENT *ShipPtr)
 						};
 
 						c = flash_tab1[i];
-						r.corner.x = CAPTAIN_XOFFS + i;
-						r.corner.y = y + CAPTAIN_YOFFS + i;
-						r.extent.width = CAPTAIN_WIDTH - (i << 1);
-						r.extent.height = CAPTAIN_HEIGHT - (i << 1);
+
+						// JMS_GFX
+						r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(i);
+						r.corner.y = y + CAPTAIN_YOFFS + RES_STAT_SCALE(i);
+						r.extent.width = CAPTAIN_WIDTH - RES_STAT_SCALE((i << 1));
+						r.extent.height = CAPTAIN_HEIGHT - RES_STAT_SCALE((i << 1));
+
 						if (r.extent.height == 2)
 							++r.extent.height;
-						DrawRectangle (&r);
-						++r.corner.x;
-						++r.corner.y;
-						r.extent.width -= 2;
-						r.extent.height -= 2;
+						
+						// JMS_GFX
+						for (j=0 ; j<RES_STAT_SCALE(1); j++) {
+							DrawRectangle (&r);
+							++r.corner.x;
+							++r.corner.y;
+							r.extent.width -= 2;
+							r.extent.height -= 2;
+						}
 					}
 					else if ((i -= 15) <= 4)
 					{
-						r.corner.y = y + (CAPTAIN_YOFFS + 15);
-						r.extent.width = i + 1;
+						r.corner.y = y + (CAPTAIN_YOFFS + RES_STAT_SCALE(15)); // JMS_GFX
+						r.extent.width = RES_STAT_SCALE(i + 1); // JMS_GFX
 						r.extent.height = 1;
 						switch (i)
 						{
 							case 0:
-								r.corner.x = CAPTAIN_XOFFS + 15;
-								i = CAPTAIN_WIDTH - ((15 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(15);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((15 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x13, 0x00, 0x00), 0x2C);
 								break;
 							case 1:
-								r.corner.x = CAPTAIN_XOFFS + 16;
-								i = CAPTAIN_WIDTH - ((17 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(16);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((17 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x07, 0x00, 0x00), 0x2F);
 								break;
 							case 2:
-								r.corner.x = CAPTAIN_XOFFS + 18;
-								i = CAPTAIN_WIDTH - ((20 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(18);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((20 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1B, 0x00, 0x00), 0x2A);
 								break;
 							case 3:
-								r.corner.x = CAPTAIN_XOFFS + 21;
-								i = CAPTAIN_WIDTH - ((24 + 1) << 1);
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(21);
+								i = CAPTAIN_WIDTH - RES_STAT_SCALE((24 + 1) << 1);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x00, 0x00), 0x29);
 								break;
 							case 4:
-								r.corner.x = CAPTAIN_XOFFS + 25;
-								i = 1;
-								r.extent.width = 2;
+								r.corner.x = CAPTAIN_XOFFS + RES_STAT_SCALE(25);
+								i = RES_STAT_SCALE(1);
+								r.extent.width = RES_STAT_SCALE(2);
 								c = BUILD_COLOR (MAKE_RGB15 (0x1F, 0x50, 0x05), 0x28);
 								break;
 							default:
diff -ruNp src.orig/uqm/status.h src/uqm/status.h
--- src.orig/uqm/status.h	2017-12-30 00:14:42 -0800
+++ src/uqm/status.h	2017-12-30 00:14:54 -0800
@@ -26,36 +26,36 @@
 extern "C" {
 #endif
 
-#define CREW_XOFFS 4
-#define ENERGY_XOFFS 52
-#define GAUGE_YOFFS (SHIP_INFO_HEIGHT - 10)
-#define UNIT_WIDTH 2
-#define UNIT_HEIGHT 1
+#define CREW_XOFFS RES_STAT_SCALE(4) // JMS_GFX
+#define ENERGY_XOFFS (RES_STAT_SCALE(52) + (3 * RESOLUTION_FACTOR) + (RESOLUTION_FACTOR / 2)) // JMS_GFX
+#define GAUGE_YOFFS ((SHIP_INFO_HEIGHT - (10 << RESOLUTION_FACTOR) + 6 * RESOLUTION_FACTOR) - RES_CASE(0,0,4)) // JMS_GFX
+#define UNIT_WIDTH RES_SCALE(2)
+#define UNIT_HEIGHT RES_SCALE(1)
 #define STAT_WIDTH (1 + UNIT_WIDTH + 1 + UNIT_WIDTH + 1)
 
-#define SHIP_INFO_HEIGHT 65
-#define CAPTAIN_XOFFS 4
-#define CAPTAIN_YOFFS (SHIP_INFO_HEIGHT + 4)
-#define CAPTAIN_WIDTH 55
-#define CAPTAIN_HEIGHT 30
+#define SHIP_INFO_HEIGHT (65 << RESOLUTION_FACTOR) // JMS_GFX
+#define CAPTAIN_WIDTH RES_STAT_SCALE(55) // JMS_GFX
+#define CAPTAIN_HEIGHT RES_STAT_SCALE(30) // JMS_GFX
+#define CAPTAIN_XOFFS ((STATUS_WIDTH - CAPTAIN_WIDTH) >> 1) // JMS_GFX
+#define CAPTAIN_YOFFS (SHIP_INFO_HEIGHT + (4 << RESOLUTION_FACTOR)) // JMS_GFX
+
 #define SHIP_STATUS_HEIGHT (STATUS_HEIGHT >> 1)
 #define BAD_GUY_YOFFS 0
 #define GOOD_GUY_YOFFS SHIP_STATUS_HEIGHT
-#define STARCON_TEXT_HEIGHT 7
-#define TINY_TEXT_HEIGHT 9
 
-#define BATTLE_CREW_X 10
-#define BATTLE_CREW_Y (64 - SAFE_Y)
+#define STARCON_TEXT_HEIGHT (7 << RESOLUTION_FACTOR) // JMS_GFX
+#define TINY_TEXT_HEIGHT (9 << RESOLUTION_FACTOR) // JMS_GFX
+#define BATTLE_CREW_X RES_STAT_SCALE(10) // JMS_GFX
+#define BATTLE_CREW_Y (((64 - SAFE_Y) << RESOLUTION_FACTOR) - RES_CASE(0,0,4))// JMS_GFX
 
 extern COORD status_y_offsets[];
 
 extern void InitStatusOffsets (void);
 
 extern void DrawCrewFuelString (COORD y, SIZE state);
-extern void ClearShipStatus (COORD y);
-extern void OutlineShipStatus (COORD y);
-extern void InitShipStatus (SHIP_INFO *ShipInfoPtr, STARSHIP *StarShipPtr,
-		RECT *pClipRect);
+extern void ClearShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu);
+extern void OutlineShipStatus (COORD y, COORD w, BOOLEAN inMeleeMenu); // JMS: now is needed elsewhere
+extern void InitShipStatus (SHIP_INFO *ShipInfoPtr, STARSHIP *StarShipPtr, RECT *pClipRect, BOOLEAN inMeleeMenu);
 			// StarShipPtr or pClipRect can be NULL
 extern void DeltaStatistics (SHIP_INFO *ShipInfoPtr, COORD y_offs,
 		SIZE crew_delta, SIZE energy_delta);
diff -ruNp src.orig/uqm/supermelee/buildpick.c src/uqm/supermelee/buildpick.c
--- src.orig/uqm/supermelee/buildpick.c	2017-12-30 00:14:42 -0800
+++ src/uqm/supermelee/buildpick.c	2017-12-30 00:14:54 -0800
@@ -69,8 +69,9 @@ DrawPickIcon (MeleeShip ship, bool DrawE
 
 	GetFrameRect (BuildPickFrame, &r);
 
-	s.origin.x = r.corner.x + 20 + (ship % NUM_PICK_COLS) * 18;
-	s.origin.y = r.corner.y +  5 + (ship / NUM_PICK_COLS) * 18;
+	s.origin.x = r.corner.x + (20 << RESOLUTION_FACTOR) + (ship % NUM_PICK_COLS) * (18 << RESOLUTION_FACTOR) - RES_CASE(0,0,2); // JMS_GFX
+	s.origin.y = r.corner.y + (5 << RESOLUTION_FACTOR) + (ship / NUM_PICK_COLS) * (18 << RESOLUTION_FACTOR); // JMS_GFX
+
 	s.frame = GetShipIconsFromIndex (ship);
 	if (DrawErase)
 	{	// draw icon
diff -ruNp src.orig/uqm/supermelee/loadmele.c src/uqm/supermelee/loadmele.c
--- src.orig/uqm/supermelee/loadmele.c	2017-12-30 00:14:42 -0800
+++ src/uqm/supermelee/loadmele.c	2017-12-30 00:14:54 -0800
@@ -41,9 +41,9 @@
 		BUILD_COLOR (MAKE_RGB15 (0x17, 0x18, 0x1D), 0x00)
 
 
-#define LOAD_MELEE_BOX_WIDTH 34
-#define LOAD_MELEE_BOX_HEIGHT 34
-#define LOAD_MELEE_BOX_SPACE 1
+#define LOAD_MELEE_BOX_WIDTH (RES_CASE(34,65,131)) // JMS_GFX
+#define LOAD_MELEE_BOX_HEIGHT (34 << RESOLUTION_FACTOR) // JMS_GFX
+#define LOAD_MELEE_BOX_SPACE (1 << RESOLUTION_FACTOR) // JMS_GFX
 
 
 static void DrawFileStrings (MELEE_STATE *pMS);
@@ -177,7 +177,7 @@ DrawFileString (const MeleeTeam *team, c
 		sprintf (buf, "%u", MeleeTeam_getValue (team));
 		Text.baseline = *origin;
 		Text.baseline.x += NUM_MELEE_COLUMNS *
-				(LOAD_MELEE_BOX_WIDTH + LOAD_MELEE_BOX_SPACE) - 1;
+				(LOAD_MELEE_BOX_WIDTH + LOAD_MELEE_BOX_SPACE) - RES_CASE(1,-5,1);
 		Text.align = ALIGN_RIGHT;
 		Text.pStr = buf;
 		Text.CharCount = (COUNT)~0;
@@ -190,8 +190,8 @@ DrawFileString (const MeleeTeam *team, c
 		STAMP s;
 		FleetShipIndex slotI;
 
-		s.origin.x = origin->x + 1;
-		s.origin.y = origin->y + 4;
+		s.origin.x = origin->x + (1 << RESOLUTION_FACTOR); // JMS_GFX
+		s.origin.y = origin->y + (RES_CASE(4,8,12)); // JMS_GFX
 		for (slotI = 0; slotI < MELEE_FLEET_SIZE; slotI++)
 		{
 			BYTE StarShip;
@@ -201,7 +201,7 @@ DrawFileString (const MeleeTeam *team, c
 			{
 				s.frame = GetShipIconsFromIndex (StarShip);
 				DrawStamp (&s);
-				s.origin.x += 17;
+				s.origin.x += 17 << RESOLUTION_FACTOR; // JMS_GFX
 			}
 		}
 	}
@@ -230,9 +230,9 @@ FillFileView (MELEE_STATE *pMS)
 	return true;
 }
 
-#define FILE_STRING_ORIGIN_X  5
-#define FILE_STRING_ORIGIN_Y  34
-#define ENTRY_HEIGHT 32
+#define FILE_STRING_ORIGIN_X (RES_CASE(5,18,45)) // JMS_GFX
+#define FILE_STRING_ORIGIN_Y  ((34 << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR * 23)) // JMS_GFX
+#define ENTRY_HEIGHT (RES_CASE(32,64,132)) // JMS_GFX
 
 static void
 SelectFileString (MELEE_STATE *pMS, bool hilite)
diff -ruNp src.orig/uqm/supermelee/melee.c src/uqm/supermelee/melee.c
--- src.orig/uqm/supermelee/melee.c	2017-12-30 00:14:42 -0800
+++ src/uqm/supermelee/melee.c	2017-12-30 00:14:54 -0800
@@ -96,28 +96,32 @@ enum
 #define TOP_ENTRY CONTROLS_TOP
 #endif
 
-#define MELEE_X_OFFS 2
-#define MELEE_Y_OFFS 21
-#define MELEE_BOX_WIDTH 34
-#define MELEE_BOX_HEIGHT 34
-#define MELEE_BOX_SPACE 1
-
-#define MENU_X_OFFS 29
-
-#define INFO_ORIGIN_X 4
-#define INFO_WIDTH 58
-#define TEAM_INFO_ORIGIN_Y 3
-#define TEAM_INFO_HEIGHT (SHIP_INFO_HEIGHT + 75)
-#define MODE_INFO_ORIGIN_Y (TEAM_INFO_HEIGHT + 6)
-#define MODE_INFO_HEIGHT ((STATUS_HEIGHT - 3) - MODE_INFO_ORIGIN_Y)
-#define RACE_INFO_ORIGIN_Y (SHIP_INFO_HEIGHT + 6)
-#define RACE_INFO_HEIGHT ((STATUS_HEIGHT - 3) - RACE_INFO_ORIGIN_Y)
+// Start of JMS_GFX
+// Top Melee Menu
+#define MELEE_X_OFFS (2 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_Y_OFFS ((21 << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR * 21)) // JMS_GFX
+#define MELEE_BOX_WIDTH (34 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_BOX_HEIGHT (34 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_BOX_SPACE (1 << RESOLUTION_FACTOR) // JMS_GFX
+
+#define MENU_X_OFFS (29 << RESOLUTION_FACTOR) // JMS_GFX
+
+
+#define INFO_ORIGIN_X (4 << RESOLUTION_FACTOR) // JMS_GFX
+#define INFO_WIDTH (58 << RESOLUTION_FACTOR) // JMS_GFX
+#define TEAM_INFO_ORIGIN_Y (3 << RESOLUTION_FACTOR) // JMS_GFX
+#define TEAM_INFO_HEIGHT (SHIP_INFO_HEIGHT + (75 << RESOLUTION_FACTOR)) // JMS_GFX
+#define MODE_INFO_ORIGIN_Y (TEAM_INFO_HEIGHT + (6 << RESOLUTION_FACTOR)) // JMS_GFX
+#define MODE_INFO_HEIGHT ((STATUS_HEIGHT - (3 << RESOLUTION_FACTOR)) - MODE_INFO_ORIGIN_Y) // JMS_GFX
+#define RACE_INFO_ORIGIN_Y (SHIP_INFO_HEIGHT + (6 << RESOLUTION_FACTOR)) // JMS_GFX
+#define RACE_INFO_HEIGHT ((STATUS_HEIGHT - (3 << RESOLUTION_FACTOR)) - RACE_INFO_ORIGIN_Y) // JMS_GFX
 
-#define MELEE_STATUS_X_OFFS 1
-#define MELEE_STATUS_Y_OFFS 201
+#define MELEE_STATUS_X_OFFS ((1 << RESOLUTION_FACTOR)) // JMS_GFX
+#define MELEE_STATUS_Y_OFFS (RES_SCALE(201) + RES_CASE(0,20,40)) // JMS_GFX
 #define MELEE_STATUS_WIDTH  (NUM_MELEE_COLUMNS * \
 		(MELEE_BOX_WIDTH + MELEE_BOX_SPACE))
-#define MELEE_STATUS_HEIGHT 38
+#define MELEE_STATUS_HEIGHT (38 << RESOLUTION_FACTOR) // JMS_GFX
+//End JMS_GFX
 
 #define MELEE_BACKGROUND_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x14, 0x00, 0x00), 0x04)
@@ -429,19 +433,19 @@ GetTeamStringRect (COUNT side, RECT *r)
 	r->corner.y = (side + 1) * (MELEE_Y_OFFS
 			+ ((MELEE_BOX_HEIGHT + MELEE_BOX_SPACE) * NUM_MELEE_ROWS + 2));
 	r->extent.width = NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE)
-			- 29;
-	r->extent.height = 13;
+			- (29 << RESOLUTION_FACTOR);
+	r->extent.height = RES_CASE(13,16,32);
 }
 
 static void
 GetFleetValueRect (COUNT side, RECT *r)
 {
 	r->corner.x = MELEE_X_OFFS
-			+ NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE) - 30;
+			+ NUM_MELEE_COLUMNS * (MELEE_BOX_WIDTH + MELEE_BOX_SPACE) - (30 << RESOLUTION_FACTOR);
 	r->corner.y = (side + 1) * (MELEE_Y_OFFS
 			+ ((MELEE_BOX_HEIGHT + MELEE_BOX_SPACE) * NUM_MELEE_ROWS + 2));
-	r->extent.width = 29;
-	r->extent.height = 13;
+	r->extent.width = 29 << RESOLUTION_FACTOR;
+	r->extent.height = RES_CASE(13,16,32);
 }
 
 static void
@@ -495,7 +499,7 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 	lfText.pStr = (teamName != NULL) ? teamName :
 			MeleeSetup_getTeamName (pMS->meleeSetup, side);
 	lfText.baseline.y = r.corner.y + r.extent.height - 3;
-	lfText.baseline.x = r.corner.x + 1;
+	lfText.baseline.x = r.corner.x + (1 << RESOLUTION_FACTOR);
 	lfText.align = ALIGN_LEFT;
 	lfText.CharCount = strlen (lfText.pStr);
 
@@ -514,7 +518,7 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 		BYTE *pchar_deltas;
 
 		TextRect (&lfText, &text_r, char_deltas);
-		if ((text_r.extent.width + 2) >= r.extent.width)
+		if ((text_r.extent.width + (2 << RESOLUTION_FACTOR)) >= r.extent.width)
 		{	// the text does not fit the input box size and so
 			// will not fit when displayed later
 			UnbatchGraphics ();
@@ -536,25 +540,25 @@ DrawTeamString (MELEE_STATE *pMS, COUNT
 		{	// Use block cursor for keyboardless systems
 			if (pMS->CurIndex == lfText.CharCount)
 			{	// cursor at end-line -- use insertion point
-				text_r.extent.width = 1;
+				text_r.extent.width = (1 << RESOLUTION_FACTOR);
 			}
 			else if (pMS->CurIndex + 1 == lfText.CharCount)
 			{	// extra pixel for last char margin
-				text_r.extent.width = (SIZE)*pchar_deltas + 2;
+				text_r.extent.width = (SIZE)*pchar_deltas + (2 << RESOLUTION_FACTOR);
 			}
 			else
 			{	// normal mid-line char
-				text_r.extent.width = (SIZE)*pchar_deltas + 1;
+				text_r.extent.width = (SIZE)*pchar_deltas + (1 << RESOLUTION_FACTOR);
 			}
 		}
 		else
 		{	// Insertion point cursor
-			text_r.extent.width = 1;
+			text_r.extent.width = 1 << RESOLUTION_FACTOR;
 		}
 		// position cursor within input field rect
 		++text_r.corner.x;
 		++text_r.corner.y;
-		text_r.extent.height -= 2;
+		text_r.extent.height -= 2 << RESOLUTION_FACTOR;
 		SetContextForeGroundColor (TEAM_NAME_EDIT_CURS_COLOR);
 		DrawFilledRectangle (&text_r);
 
@@ -870,9 +874,9 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 	OldContext = SetContext (StatusContext);
 	GetContextClipRect (&OldRect);
 	r = OldRect;
-	r.corner.x += ((SAFE_X << 1) - 32) + MENU_X_OFFS;
-	r.corner.y += 76;
-	r.extent.height = SHIP_INFO_HEIGHT;
+	r.corner.x += ((SAFE_X << 1) - (32 << RESOLUTION_FACTOR)) + MENU_X_OFFS - RES_CASE(0,0,3);
+	r.corner.y += (76 << RESOLUTION_FACTOR) + RES_CASE(0,2,6);
+	r.extent.height = SHIP_INFO_HEIGHT + RES_CASE(3,6,3);
 	SetContextClipRect (&r);
 	BatchGraphics ();
 
@@ -881,16 +885,21 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 		RECT r;
 		TEXT t;
 
-		ClearShipStatus (0);
+		ClearShipStatus (0, STATUS_WIDTH, TRUE);
+		
+		// JMS_GFX
+		if (RESOLUTION_FACTOR > 0)
+			OutlineShipStatus (0, STATUS_WIDTH, TRUE);
+		
 		SetContextFont (StarConFont);
-		r.corner.x = 3;
-		r.corner.y = 4;
-		r.extent.width = 57;
-		r.extent.height = 60;
+		r.corner.x = RES_STAT_SCALE(3); // JMS_GFX;
+		r.corner.y = RES_STAT_SCALE(4); // JMS_GFX;
+		r.extent.width = RES_STAT_SCALE(57) + RESOLUTION_FACTOR; // JMS_GFX;
+		r.extent.height = (60 << RESOLUTION_FACTOR) - RES_CASE(0,0,6); // JMS_GFX;
 		SetContextForeGroundColor (BLACK_COLOR);
 		DrawRectangle (&r);
 		t.baseline.x = STATUS_WIDTH >> 1;
-		t.baseline.y = 32;
+		t.baseline.y = 32 << RESOLUTION_FACTOR; 
 		t.align = ALIGN_CENTER;
 		if (pMS->row < NUM_MELEE_ROWS)
 		{
@@ -920,7 +929,7 @@ DrawMeleeShipStrings (MELEE_STATE *pMS,
 		hMasterShip = GetStarShipFromIndex (&master_q, NewStarShip);
 		MasterPtr = LockMasterShip (&master_q, hMasterShip);
 
-		InitShipStatus (&MasterPtr->ShipInfo, NULL, NULL);
+		InitShipStatus (&MasterPtr->ShipInfo, NULL, NULL, TRUE);
 
 		UnlockMasterShip (&master_q, hMasterShip);
 	}
@@ -1632,7 +1641,7 @@ DoConnectingDialog (MELEE_STATE *pMS)
 			t.pStr = GAME_STRING (NETMELEE_STRING_BASE + 2);
 					/* "Awaiting outgoing connection */
 		}
-		t.baseline.y = r.corner.y + 10;
+		t.baseline.y = r.corner.y + (10 << RESOLUTION_FACTOR);
 		t.baseline.x = SCREEN_WIDTH >> 1;
 		t.align = ALIGN_CENTER;
 		t.CharCount = ~0;
@@ -1640,7 +1649,7 @@ DoConnectingDialog (MELEE_STATE *pMS)
 
 		t.pStr = GAME_STRING (NETMELEE_STRING_BASE + 18);
 				/* "Press SPACE to cancel" */
-		t.baseline.y += 16;
+		t.baseline.y += 16 << RESOLUTION_FACTOR;
 		font_DrawText (&t);
 
 		// Restore original graphics
diff -ruNp src.orig/uqm/supermelee/melee.h src/uqm/supermelee/melee.h
--- src.orig/uqm/supermelee/melee.h	2017-12-30 00:14:42 -0800
+++ src/uqm/supermelee/melee.h	2017-12-30 00:14:54 -0800
@@ -38,8 +38,8 @@ typedef struct melee_state MELEE_STATE;
 #define NUM_MELEE_COLUMNS 7
 //#define NUM_MELEE_COLUMNS 6
 #define MELEE_FLEET_SIZE (NUM_MELEE_ROWS * NUM_MELEE_COLUMNS)
-#define ICON_WIDTH 16
-#define ICON_HEIGHT 16
+#define ICON_WIDTH (16 << RESOLUTION_FACTOR)
+#define ICON_HEIGHT (16 << RESOLUTION_FACTOR)
 
 extern FRAME PickMeleeFrame;
 
diff -ruNp src.orig/uqm/supermelee/pickmele.c src/uqm/supermelee/pickmele.c
--- src.orig/uqm/supermelee/pickmele.c	2017-12-30 00:14:42 -0800
+++ src/uqm/supermelee/pickmele.c	2017-12-30 00:14:54 -0800
@@ -45,13 +45,13 @@
 #define NUM_PICKMELEE_ROWS 2
 #define NUM_PICKMELEE_COLUMNS 7
 
-#define PICK_X_OFFS 57
-#define PICK_Y_OFFS 24
-#define PICK_SIDE_OFFS 100
-
-#define NAME_AREA_HEIGHT 7
-#define MELEE_WIDTH 149
-#define MELEE_HEIGHT (48 + NAME_AREA_HEIGHT)
+#define PICK_X_OFFS (57 << RESOLUTION_FACTOR) // JMS_GFX
+#define PICK_Y_OFFS (24 << RESOLUTION_FACTOR) // JMS_GFX
+#define PICK_SIDE_OFFS (100 << RESOLUTION_FACTOR) // JMS_GFX
+
+#define NAME_AREA_HEIGHT (7 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_WIDTH (149 << RESOLUTION_FACTOR) // JMS_GFX
+#define MELEE_HEIGHT ((48 << RESOLUTION_FACTOR) + NAME_AREA_HEIGHT)
 
 #define PICKSHIP_TEAM_NAME_TEXT_COLOR \
 		BUILD_COLOR (MAKE_RGB15 (0x0A, 0x0A, 0x1F), 0x09)
@@ -148,11 +148,11 @@ static void
 PickMelee_ChangedSelection (GETMELEE_STATE *gms, COUNT playerI)
 {
 	RECT r;
-	r.corner.x = PICK_X_OFFS + ((ICON_WIDTH + 2) * gms->player[playerI].col);
-	r.corner.y = PICK_Y_OFFS + ((ICON_HEIGHT + 2) * gms->player[playerI].row)
+	r.corner.x = PICK_X_OFFS + ((ICON_WIDTH + (2 << RESOLUTION_FACTOR)) * gms->player[playerI].col); // JMS_GFX
+	r.corner.y = PICK_Y_OFFS + ((ICON_HEIGHT + (2 << RESOLUTION_FACTOR)) * gms->player[playerI].row) // JMS_GFX
 			+ ((1 - playerI) * PICK_SIDE_OFFS);
-	r.extent.width = (ICON_WIDTH + 2);
-	r.extent.height = (ICON_HEIGHT + 2);
+	r.extent.width = (ICON_WIDTH + (2 << RESOLUTION_FACTOR));
+	r.extent.height = (ICON_HEIGHT + (2 << RESOLUTION_FACTOR));
 	Flash_setRect (gms->player[playerI].flashContext, &r);
 }
 
@@ -424,8 +424,8 @@ CrossOutShip (FRAME frame, COUNT shipNr)
 	
 	SetContextFGFrame (frame);
 
-	s.origin.x = 3 + ((ICON_WIDTH + 2) * col);
-	s.origin.y = 9 + ((ICON_HEIGHT + 2) * row);
+	s.origin.x = (3 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (2 << RESOLUTION_FACTOR)) * col); // JMS_GFX
+	s.origin.y = (9 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (2 << RESOLUTION_FACTOR)) * row); // JMS_GFX
 	s.frame = SetAbsFrameIndex (StatusFrame, 3);
 			// Cross for through the ship image.
 	DrawStamp (&s);
@@ -451,18 +451,18 @@ UpdatePickMeleeFleetValue (FRAME frame,
 
 	// Erase the old value text.
 	GetFrameRect (frame, &r);
-	r.extent.width -= 4;
+	r.extent.width -= (4 << RESOLUTION_FACTOR);
 	t.baseline.x = r.extent.width;
-	r.corner.x = r.extent.width - (6 * 3);
-	r.corner.y = 2;
-	r.extent.width = (6 * 3);
-	r.extent.height = 7 - 2;
+	r.corner.x = r.extent.width - ((6 * 3) << RESOLUTION_FACTOR); // JMS_GFX
+	r.corner.y = 2 << RESOLUTION_FACTOR; // JMS_GFX
+	r.extent.width = ((6 * 3) << RESOLUTION_FACTOR); // JMS_GFX
+	r.extent.height = ((7 - 2) << RESOLUTION_FACTOR) + (RESOLUTION_FACTOR); // JMS_GFX
 	SetContextForeGroundColor (PICK_BG_COLOR);
 	DrawFilledRectangle (&r);
 
 	// Draw the new value text.
 	sprintf (buf, "%d", value);
-	t.baseline.y = 7;
+	t.baseline.y = 7 << RESOLUTION_FACTOR;
 	t.align = ALIGN_RIGHT;
 	t.pStr = buf;
 	t.CharCount = (COUNT)~0;
@@ -531,17 +531,17 @@ FillPickMeleeFrame (MeleeSetup *setup)
 
 		GetFrameRect (s.frame, &r);
 		t.baseline.x = r.extent.width >> 1;
-		t.baseline.y = r.extent.height - NAME_AREA_HEIGHT + 4;
+		t.baseline.y = r.extent.height - NAME_AREA_HEIGHT + (4 << RESOLUTION_FACTOR);
 
-		r.corner.x += 2;
-		r.corner.y += 2;
-		r.extent.width -= (2 * 2) + (ICON_WIDTH + 2) + 1;
-		r.extent.height -= (2 * 2) + NAME_AREA_HEIGHT;
+		r.corner.x += 2 << RESOLUTION_FACTOR;
+		r.corner.y += 2 << RESOLUTION_FACTOR;
+		r.extent.width -= ( (2 * 2) + ((ICON_WIDTH >> RESOLUTION_FACTOR) + 2) + 1) << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.height -= ((2 * 2) << RESOLUTION_FACTOR) + NAME_AREA_HEIGHT; // JMS_GFX
 		SetContextForeGroundColor (PICK_BG_COLOR);
 		DrawFilledRectangle (&r);
 
-		r.corner.x += 2;
-		r.extent.width += (ICON_WIDTH + 2) - (2 * 2);
+		r.corner.x += 2 << RESOLUTION_FACTOR; // JMS_GFX
+		r.extent.width += (((ICON_WIDTH >> RESOLUTION_FACTOR) + 2) - (2 * 2)) << RESOLUTION_FACTOR; // JMS_GFX
 		r.corner.y += r.extent.height;
 		r.extent.height = NAME_AREA_HEIGHT;
 		DrawFilledRectangle (&r);
@@ -556,8 +556,8 @@ FillPickMeleeFrame (MeleeSetup *setup)
 
 		// Total team value of the starting team:
 		sprintf (buf, "%u", MeleeSetup_getFleetValue (setup, sideI));
-		t.baseline.x = 4;
-		t.baseline.y = 7;
+		t.baseline.x = 4 << RESOLUTION_FACTOR;
+		t.baseline.y = 7 << RESOLUTION_FACTOR;
 		t.align = ALIGN_LEFT;
 		t.pStr = buf;
 		t.CharCount = (COUNT)~0;
@@ -593,8 +593,8 @@ FillPickMeleeFrame (MeleeSetup *setup)
 				// Draw the icon.
 				row = PickMelee_GetShipRow (index);
 				col = PickMelee_GetShipColumn (index);
-				s.origin.x = 4 + ((ICON_WIDTH + 2) * col);
-				s.origin.y = 10 + ((ICON_HEIGHT + 2) * row);
+				s.origin.x = (4 << RESOLUTION_FACTOR) + ((ICON_WIDTH + (2 << RESOLUTION_FACTOR)) * col); // JMS_GFX
+				s.origin.y = (10 << RESOLUTION_FACTOR) + ((ICON_HEIGHT + (2 << RESOLUTION_FACTOR)) * row);
 				s.frame = MasterPtr->ShipInfo.icons;
 				DrawStamp (&s);
 
@@ -636,8 +636,8 @@ DrawPickMeleeFrame (COUNT which_player)
 
 	oldContext = SetContext (SpaceContext);
 	s.frame = SetAbsFrameIndex (PickMeleeFrame, which_player);
-	s.origin.x = PICK_X_OFFS - 3;
-	s.origin.y = PICK_Y_OFFS - 9 + ((1 - which_player) * PICK_SIDE_OFFS);
+	s.origin.x = PICK_X_OFFS - (3 << RESOLUTION_FACTOR); // JMS_GFX
+	s.origin.y = PICK_Y_OFFS - (9 << RESOLUTION_FACTOR) + ((1 - which_player) * PICK_SIDE_OFFS);
 	DrawStamp (&s);
 			// Draw the selection box to screen.
 	
diff -ruNp src.orig/uqm/tactrans.c src/uqm/tactrans.c
--- src.orig/uqm/tactrans.c	2017-12-30 00:14:42 -0800
+++ src/uqm/tactrans.c	2017-12-30 00:14:54 -0800
@@ -789,7 +789,7 @@ cycle_ion_trail (ELEMENT *ElementPtr)
 }
 
 void
-spawn_ion_trail (ELEMENT *ElementPtr)
+spawn_ion_trail (ELEMENT *ElementPtr, SIZE x_offset, SIZE y_offset)
 {
 	HELEMENT hIonElement;
 
@@ -818,20 +818,36 @@ spawn_ion_trail (ELEMENT *ElementPtr)
 				// When the element "dies", in the death_func
 				// 'cycle_ion_trail', it is given new life a number of
 				// times, by setting life_span to thrust_wait.
-		SetPrimType (&DisplayArray[IonElementPtr->PrimIndex], POINT_PRIM);
+
+		// JMS_GFX
+		if (RESOLUTION_FACTOR == 0) {
+			SetPrimType (&DisplayArray[IonElementPtr->PrimIndex], POINT_PRIM);
+			IonElementPtr->current.image.frame = DecFrameIndex (stars_in_space);
+			IonElementPtr->current.image.farray = &stars_in_space;
+		}
+		else {
+			SetPrimType (&DisplayArray[IonElementPtr->PrimIndex], STAMPFILL_PRIM);
+			IonElementPtr->current.image.frame = SetAbsFrameIndex (ion_trails[0], 0);
+			IonElementPtr->current.image.farray = ion_trails;
+		}
 		SetPrimColor (&DisplayArray[IonElementPtr->PrimIndex],
 				START_ION_COLOR);
 		IonElementPtr->colorCycleIndex = 0;
-		IonElementPtr->current.image.frame =
+		/*IonElementPtr->current.image.frame =
 				DecFrameIndex (stars_in_space);
-		IonElementPtr->current.image.farray = &stars_in_space;
+		IonElementPtr->current.image.farray = &stars_in_space;*/
 		IonElementPtr->current.location = ElementPtr->current.location;
 		IonElementPtr->current.location.x +=
-				(COORD)COSINE (angle, r.extent.height);
+				(COORD)COSINE (angle, r.extent.height) + x_offset;
 		IonElementPtr->current.location.y +=
-				(COORD)SINE (angle, r.extent.height);
+				(COORD)SINE (angle, r.extent.height) + y_offset;
 		IonElementPtr->death_func = cycle_ion_trail;
 
+		if (RESOLUTION_FACTOR > 0) {
+			IonElementPtr->next.image.frame = IonElementPtr->current.image.frame;
+			IonElementPtr->next.image.farray = IonElementPtr->current.image.farray;
+		}
+
 		SetElementStarShip (IonElementPtr, StarShipPtr);
 
 		{
@@ -904,7 +920,7 @@ ship_transition (ELEMENT *ElementPtr)
 		}
 		else if ((hShipImage = AllocElement ()))
 		{
-#define TRANSITION_SPEED DISPLAY_TO_WORLD (40)
+#define TRANSITION_SPEED DISPLAY_TO_WORLD ((40 << RESOLUTION_FACTOR)) // JMS_GFX
 #define TRANSITION_LIFE 1
 			COUNT angle;
 
@@ -937,17 +953,15 @@ ship_transition (ELEMENT *ElementPtr)
 			}
 			else if (ElementPtr->crew_level)
 			{
-				ShipImagePtr->current.location.x -=
-						COSINE (angle, TRANSITION_SPEED)
-						* (ElementPtr->life_span - 1);
-				ShipImagePtr->current.location.y -=
-						SINE (angle, TRANSITION_SPEED)
-						* (ElementPtr->life_span - 1);
-
-				ShipImagePtr->current.location.x =
-						WRAP_X (ShipImagePtr->current.location.x);
-				ShipImagePtr->current.location.y =
-						WRAP_Y (ShipImagePtr->current.location.y);
+				// JMS_GFX: Circumventing overflows by using temp variables instead of 
+				// subtracting straight from the POINT sized ShipImagePtr->current.location.
+				SDWORD temp_x = (SDWORD)ShipImagePtr->current.location.x -
+					COSINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+				SDWORD temp_y = (SDWORD)ShipImagePtr->current.location.y -
+					SINE (angle, TRANSITION_SPEED) * (ElementPtr->life_span - 1);
+                
+				ShipImagePtr->current.location.x = WRAP_X (temp_x);
+				ShipImagePtr->current.location.y = WRAP_Y (temp_y);
 			}
 			ShipImagePtr->preprocess_func = ship_transition;
 			ShipImagePtr->death_func = cycle_ion_trail;
diff -ruNp src.orig/uqm/tactrans.h src/uqm/tactrans.h
--- src.orig/uqm/tactrans.h	2017-12-30 00:14:42 -0800
+++ src/uqm/tactrans.h	2017-12-30 00:14:54 -0800
@@ -38,7 +38,7 @@ extern void ship_transition (ELEMENT *El
 extern BOOLEAN OpponentAlive (STARSHIP *TestStarShipPtr);
 extern void new_ship (ELEMENT *ElementPtr);
 extern void ship_death (ELEMENT *ShipPtr);
-extern void spawn_ion_trail (ELEMENT *ElementPtr);
+extern void spawn_ion_trail (ELEMENT *ElementPtr, SIZE x, SIZE y);
 extern void flee_preprocess (ELEMENT *ElementPtr);
 
 extern void StopDitty (void);
diff -ruNp src.orig/uqm/trans.c src/uqm/trans.c
--- src.orig/uqm/trans.c	2017-12-30 00:14:42 -0800
+++ src/uqm/trans.c	2017-12-30 00:14:54 -0800
@@ -20,7 +20,7 @@
 #include "libs/compiler.h"
 
 
-SIZE sinetab[] =
+SDWORD sinetab[] =
 {
 	-FLT_ADJUST (1.000000),
 	-FLT_ADJUST (0.995185),
@@ -89,9 +89,9 @@ SIZE sinetab[] =
 };
 
 COUNT
-ARCTAN (SIZE delta_x, SIZE delta_y)
+ARCTAN (SDWORD delta_x, SDWORD delta_y)
 {
-	SIZE v1, v2;
+	SDWORD v1, v2;
 	static COUNT atantab[] =
 	{
 		0,
diff -ruNp src.orig/uqm/units.h src/uqm/units.h
--- src.orig/uqm/units.h	2017-12-30 00:14:42 -0800
+++ src/uqm/units.h	2017-12-30 00:14:54 -0800
@@ -20,6 +20,7 @@
 #define _UNITS_H
 
 #include "libs/gfxlib.h"
+#include "options.h"
 
 #if defined(__cplusplus)
 extern "C" {
@@ -28,46 +29,62 @@ extern "C" {
 extern int ScreenWidth;
 extern int ScreenHeight;
 
+		/* Most basic resolution units. */
 #define SCREEN_WIDTH ScreenWidth
 #define SCREEN_HEIGHT ScreenHeight
+#define RESOLUTION_FACTOR resolutionFactor														// JMS_GFX
+#define RES_CASE(a,b,c) (RESOLUTION_FACTOR == 0 ? (a) : (RESOLUTION_FACTOR == 1 ? (b) : (c)))	// JMS_GFX
+#define RES_STAT_SCALE(a) (RESOLUTION_FACTOR < 2 ? ((a) << RESOLUTION_FACTOR) : ((a) * 3))		// JMS_GFX
+#define RES_SCALE(a) ((a) << RESOLUTION_FACTOR)
+
+		/* Margins. */
 #define SAFE_X 0
-		/* Left and right screen margin to be left unused */
+/* Left and right screen margin to be left unused */
 #define SAFE_Y 0
-		/* Top and bottom screen margin to be left unused */
-#define SIS_ORG_X (7 + SAFE_X)
-#define SIS_ORG_Y (10 + SAFE_Y)
-#define STATUS_WIDTH 64
-		/* Width of the status "window" (the right part of the screen) */
+/* Top and bottom screen margin to be left unused */
+#define SIS_ORG_X (7 + SAFE_X)								// JMS_GFX
+//#define SIS_ORG_X (7 * RESOLUTION_FACTOR + SAFE_X)	// JMS_GFX
+#define SIS_ORG_Y RES_STAT_SCALE(10)						// DC: top status window. Manually entered in for 4x mode.
+//#define SIS_ORG_Y (10 * RESOLUTION_FACTOR + SAFE_Y)	// JMS_GFX
+
+/* Status bar & play area sizes. */
+#define STATUS_WIDTH RES_STAT_SCALE(64)
+/* Width of the status "window" (the right part of the screen) */
 #define STATUS_HEIGHT (SCREEN_HEIGHT - (SAFE_Y * 2))
-		/* Height of the status "window" (the right part of the screen) */
+/* Height of the status "window" (the right part of the screen) */
 #define SPACE_WIDTH (SCREEN_WIDTH - STATUS_WIDTH - (SAFE_X * 2))
-		/* Width of the space "window" (the left part of the screen) */
+/* Width of the space "window" (the left part of the screen) */
 #define SPACE_HEIGHT (SCREEN_HEIGHT - (SAFE_Y * 2))
-		/* Height of the space "window" (the left part of the screen) */
-#define SIS_SCREEN_WIDTH (SPACE_WIDTH - 14)
-		/* Width of the usable part of the space "window" */
-#define SIS_SCREEN_HEIGHT (SPACE_HEIGHT - 13)
-		/* Height of the usable part of the space "window" */
-#define RADAR_X (4 + (SCREEN_WIDTH - STATUS_WIDTH - SAFE_X))
-#define RADAR_WIDTH (STATUS_WIDTH - 8)
-#define RADAR_HEIGHT 53
-#define RADAR_Y (SIS_ORG_Y + SIS_SCREEN_HEIGHT - RADAR_HEIGHT)
-
-#define SIS_TITLE_BOX_WIDTH    57
-#define SIS_TITLE_WIDTH        (SIS_TITLE_BOX_WIDTH - 2)
-#define SIS_TITLE_HEIGHT       8
-#define SIS_SPACER_BOX_WIDTH   12
-#define SIS_MESSAGE_BOX_WIDTH  (SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH \
-			- SIS_SPACER_BOX_WIDTH)
+/* Height of the space "window" (the left part of the screen) */
+#define SIS_SCREEN_WIDTH (SPACE_WIDTH - 2 * SIS_ORG_X) // DC: Gray area on the right. just a spacer box
+/* Width of the usable part of the space "window" */
+#define SIS_SCREEN_HEIGHT (SPACE_HEIGHT - RES_CASE(3,6,6) - RES_STAT_SCALE(10)) // JMS_GFX
+/* Height of the usable part of the space "window": 3, 6, 6 for the grey bottom border and 10, 20, 30 for the title */
+#define RES_SIS_SCALE(a) ((SIZE)(a) * SIS_SCREEN_WIDTH / 242) // JMS_GFX
+
+		/* Radar. */
+#define RADAR_X (RES_STAT_SCALE(4) + (SCREEN_WIDTH - STATUS_WIDTH - SAFE_X))	// JMS_GFX
+#define RADAR_WIDTH (STATUS_WIDTH - RES_STAT_SCALE(8))							// JMS_GFX
+#define RADAR_HEIGHT RES_STAT_SCALE(53)											// JMS_GFX
+#define RADAR_Y (SIS_ORG_Y + SIS_SCREEN_HEIGHT - RADAR_HEIGHT)		// JMS_GFX
+
+		/* Blue boxes which display messages and the green date box. */
+#define SIS_TITLE_BOX_WIDTH    (57 << RESOLUTION_FACTOR)						// JMS_GFX
+#define SIS_TITLE_WIDTH        (SIS_TITLE_BOX_WIDTH - (2 << RESOLUTION_FACTOR)) // JMS_GFX
+#define SIS_TITLE_HEIGHT       RES_CASE(8,19,29)								// JMS_GFX
+#define SIS_SPACER_BOX_WIDTH   (12 << RESOLUTION_FACTOR)						// JMS_GFX
+
+#define SIS_MESSAGE_BOX_WIDTH  (SIS_SCREEN_WIDTH - SIS_TITLE_BOX_WIDTH - SIS_SPACER_BOX_WIDTH)
 #define SIS_MESSAGE_WIDTH      (SIS_MESSAGE_BOX_WIDTH - 2)
 #define SIS_MESSAGE_HEIGHT     SIS_TITLE_HEIGHT
 
-#define STATUS_MESSAGE_WIDTH   (STATUS_WIDTH - 4)
-#define STATUS_MESSAGE_HEIGHT  7
+#define STATUS_MESSAGE_WIDTH   (STATUS_WIDTH - RES_CASE(4,6,7))	 // JMS_GFX
+#define STATUS_MESSAGE_HEIGHT  RES_CASE(7,14,24) // JMS_GFX
 
-#define SHIP_NAME_WIDTH        (STATUS_WIDTH - 4)
-#define SHIP_NAME_HEIGHT       7
+#define SHIP_NAME_WIDTH        (STATUS_WIDTH - RES_CASE(4,6,9))// JMS_GFX
+#define SHIP_NAME_HEIGHT       (RES_STAT_SCALE(7) - RES_CASE(0,0,4)) // JMS_GFX
 
+		/* A lot of other shit. */
 #define MAX_REDUCTION 3
 #define MAX_VIS_REDUCTION 2
 #define REDUCTION_SHIFT 1
@@ -81,41 +98,35 @@ extern int ScreenHeight;
 #define SCALED_ONE (1 << ONE_SHIFT)
 #define DISPLAY_TO_WORLD(x) ((x)<<ONE_SHIFT)
 #define WORLD_TO_DISPLAY(x) ((x)>>ONE_SHIFT)
-#define DISPLAY_ALIGN(x) ((COORD)(x)&~(SCALED_ONE-1))
-#define DISPLAY_ALIGN_X(x) ((COORD)((COUNT)(x)%LOG_SPACE_WIDTH)&~(SCALED_ONE-1))
-#define DISPLAY_ALIGN_Y(y) ((COORD)((COUNT)(y)%LOG_SPACE_HEIGHT)&~(SCALED_ONE-1))
-
-#define LOG_SPACE_WIDTH \
-		(DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_REDUCTION)
-#define LOG_SPACE_HEIGHT \
-		(DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_REDUCTION)
-#define TRANSITION_WIDTH \
-		(DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_VIS_REDUCTION)
-#define TRANSITION_HEIGHT \
-		(DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_VIS_REDUCTION)
-		
+
+// JMS_GFX: Changed from COORD to SDWORD and from COUNT to DWORD
+#define DISPLAY_ALIGN(x) ((SDWORD)(x)&~(SCALED_ONE-1))
+#define DISPLAY_ALIGN_X(x) ((SDWORD)((DWORD)(x)%LOG_SPACE_WIDTH)&~(SCALED_ONE-1))
+#define DISPLAY_ALIGN_Y(y) ((SDWORD)((DWORD)(y)%LOG_SPACE_HEIGHT)&~(SCALED_ONE-1))
+
+#define LOG_SPACE_WIDTH   (DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_REDUCTION)
+#define LOG_SPACE_HEIGHT  (DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_REDUCTION)
+#define TRANSITION_WIDTH  (DISPLAY_TO_WORLD (SPACE_WIDTH) << MAX_VIS_REDUCTION)
+#define TRANSITION_HEIGHT (DISPLAY_TO_WORLD (SPACE_HEIGHT) << MAX_VIS_REDUCTION)
+
 #define MAX_X_UNIVERSE 9999
 #define MAX_Y_UNIVERSE 9999
-// Due to the added rounding error correction, the maximum logical X and Y
-// in Hyperspace cannot go past 999.94999, otherwise the values will be
-// rounded up to 1000.0. We do not want that so we subtract half a unit.
 #define MAX_X_LOGICAL \
-		(UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) - (UNIVERSE_TO_LOGX (1) >> 1) \
-			- 1L)
-// The Y axis is inverted with respect to the screen Y axis.
-// (MAX_Y_UNIVERSE - 1) is really 1 for our purposes.
+((UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) > UNIVERSE_TO_LOGX (-1) ? \
+UNIVERSE_TO_LOGX (MAX_X_UNIVERSE + 1) : UNIVERSE_TO_LOGX (-1)) - 1L)
 #define MAX_Y_LOGICAL \
-		(UNIVERSE_TO_LOGY (-1) - (UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE - 1) >> 1) \
-			- 1L)
+((UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE + 1) > UNIVERSE_TO_LOGY (-1) ? \
+UNIVERSE_TO_LOGY (MAX_Y_UNIVERSE + 1) : UNIVERSE_TO_LOGY (-1)) - 1L)
 
 #define SPHERE_RADIUS_INCREMENT 11
-
 #define MAX_FLEET_STRENGTH (254 * SPHERE_RADIUS_INCREMENT)
 
 // XXX: These corrected for the weird screen aspect ratio on DOS
 //   In part because of them, hyperflight is slower vertically
-#define UNIT_SCREEN_WIDTH 63
-#define UNIT_SCREEN_HEIGHT 50
+#define UNIT_SCREEN_WIDTH ((63 << (COUNT)RESOLUTION_FACTOR) + (COUNT)RESOLUTION_FACTOR * 10) // JMS_GFX
+#define UNIT_SCREEN_HEIGHT ((50 << (COUNT)RESOLUTION_FACTOR) + (COUNT)RESOLUTION_FACTOR * 10) // JMS_GFX
+
+#define NORMALIZED_HYPERSPACE_SPEED // JMS_GFX
 
 // Bug #945: Simplified, these set the speed of SIS in Hyperspace and
 //   Quasispace. The ratio between UNIVERSE_UNITS_ and LOG_UNITS_ is
@@ -125,14 +136,12 @@ extern int ScreenHeight;
 //   on the screen resolution when it should not.
 //   Using the new math will break old savegames.
 #ifdef NORMALIZED_HYPERSPACE_SPEED
-#define LOG_UNITS_X      ((SDWORD)(UNIVERSE_UNITS_X * 16))
-#define LOG_UNITS_Y      ((SDWORD)(UNIVERSE_UNITS_Y * 16))
+#define LOG_UNITS_X      ((SDWORD)(UNIVERSE_UNITS_X * (16 << RESOLUTION_FACTOR))) // JMS_GFX
+#define LOG_UNITS_Y      ((SDWORD)(UNIVERSE_UNITS_Y * (16 << RESOLUTION_FACTOR))) // JMS_GFX 
 #define UNIVERSE_UNITS_X (((MAX_X_UNIVERSE + 1) >> 4))
 #define UNIVERSE_UNITS_Y (((MAX_Y_UNIVERSE + 1) >> 4))
 #else
 // Original (and now broken) Hyperspace speed factors
-#define SECTOR_WIDTH 195
-#define SECTOR_HEIGHT 25
 
 #define LOG_UNITS_X      ((SDWORD)(LOG_SPACE_WIDTH >> 4) * SECTOR_WIDTH)
 #define LOG_UNITS_Y      ((SDWORD)(LOG_SPACE_HEIGHT >> 4) * SECTOR_HEIGHT)
@@ -142,18 +151,18 @@ extern int ScreenHeight;
 
 #define ROUNDING_ERROR(div)  ((div) >> 1)
 
-static inline COORD
+static inline SDWORD
 logxToUniverse (SDWORD lx)
 {
-	return (COORD) ((lx * UNIVERSE_UNITS_X + ROUNDING_ERROR(LOG_UNITS_X))
+	return (SDWORD) ((lx * UNIVERSE_UNITS_X + ROUNDING_ERROR(LOG_UNITS_X))
 			/ LOG_UNITS_X);
 }
 #define LOGX_TO_UNIVERSE(lx) \
 		logxToUniverse (lx)
-static inline COORD
+static inline SDWORD
 logyToUniverse (SDWORD ly)
 {
-	return (COORD) (MAX_Y_UNIVERSE -
+	return (SDWORD) (MAX_Y_UNIVERSE -
 			((ly * UNIVERSE_UNITS_Y + ROUNDING_ERROR(LOG_UNITS_Y))
 			/ LOG_UNITS_Y));
 }
@@ -190,8 +199,8 @@ universeToLogy (COORD uy)
 										>>(CIRCLE_SHIFT-FACING_SHIFT))
 #define FACING_TO_ANGLE(f) ((f)<<(CIRCLE_SHIFT-FACING_SHIFT))
 
-#define NORMALIZE_ANGLE(a) ((COUNT)((a)&(FULL_CIRCLE-1)))
-#define NORMALIZE_FACING(f) ((COUNT)((f)&((1 << FACING_SHIFT)-1)))
+#define NORMALIZE_ANGLE(a) ((DWORD)((a)&(FULL_CIRCLE-1)))
+#define NORMALIZE_FACING(f) ((DWORD)((f)&((1 << FACING_SHIFT)-1)))
 
 #define DEGREES_TO_ANGLE(d) NORMALIZE_ANGLE((((d) % 360) * FULL_CIRCLE \
 				+ HALF_CIRCLE) / 360)
@@ -204,14 +213,14 @@ universeToLogy (COORD uy)
 #define UNADJUST(x) (SIZE)((x)>>SIN_SHIFT)
 #define ROUND(x,y) ((x)+((x)>=0?((y)>>1):-((y)>>1)))
 
-extern SIZE sinetab[];
+extern SDWORD sinetab[];
 #define SINVAL(a) sinetab[NORMALIZE_ANGLE(a)]
 #define COSVAL(a) SINVAL((a)+QUADRANT)
-#define SINE(a,m) ((SIZE)((((long)SINVAL(a))*(long)(m))>>SIN_SHIFT))
+#define SINE(a,m) ((SDWORD)((((long)SINVAL(a))*(long)(m))>>SIN_SHIFT)) // JMS: SDWORD was SIZE. Changed to avoid overflows in hires.
 #define COSINE(a,m) SINE((a)+QUADRANT,m)
-extern COUNT ARCTAN (SIZE delta_x, SIZE delta_y);
+extern COUNT ARCTAN (SDWORD delta_x, SDWORD delta_y); // JMS: SDWORD was SIZE. Changed to avoid overflows in hires.
 
-#define WRAP_VAL(v,w) ((COUNT)((v)<0?((v)+(w)):((v)>=(w)?((v)-(w)):(v))))
+#define WRAP_VAL(v,w) ((DWORD)((v)<0?((v)+(w)):((v)>=(w)?((v)-(w)):(v)))) // JMS: DWORD was COUNT. Changed to avoid overflows in hires.
 #define WRAP_X(x) WRAP_VAL(x,LOG_SPACE_WIDTH)
 #define WRAP_Y(y) WRAP_VAL(y,LOG_SPACE_HEIGHT)
 #define WRAP_DELTA_X(dx) ((dx)<0 ? \
diff -ruNp src.orig/uqm/uqmdebug.c src/uqm/uqmdebug.c
--- src.orig/uqm/uqmdebug.c	2017-12-30 00:14:42 -0800
+++ src/uqm/uqmdebug.c	2017-12-30 00:14:54 -0800
@@ -14,7 +14,6 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#if defined(DEBUG) || defined(USE_DEBUG_KEY)
 
 #include "uqmdebug.h"
 
@@ -23,7 +22,7 @@
 #include "controls.h"
 #include "clock.h"
 #include "starmap.h"
-#include "element.h"
+#include "intel.h"
 #include "sis.h"
 #include "status.h"
 #include "gamestr.h"
@@ -41,6 +40,114 @@
 #include <stdio.h>
 #include <errno.h>
 
+void (* volatile debugHook) (void) = NULL;
+
+// Move the Flagship to the destination of the autopilot.
+// Should only be called from HyperSpace/QuasiSpace.
+// It can be called from debugHook directly after entering HS/QS though.
+void
+doInstantMove (void)
+{
+	// Move to the new location:
+	if ((GLOBAL (autopilot)).x == ~0 || (GLOBAL (autopilot)).y == ~0)
+	{
+		// If no destination has been selected, use the current location
+		// as the destination.
+		(GLOBAL (autopilot)).x = LOGX_TO_UNIVERSE(GLOBAL_SIS (log_x));
+		(GLOBAL (autopilot)).y = LOGY_TO_UNIVERSE(GLOBAL_SIS (log_y));
+	}
+	else
+	{
+		// A new destination has been selected.
+		GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX((GLOBAL (autopilot)).x);
+		GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY((GLOBAL (autopilot)).y);
+	}
+
+	// Check for a solar systems at the destination.
+	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
+	{
+		// If there's a solar system at the destination, enter it.
+		CurStarDescPtr = FindStar (0, &(GLOBAL (autopilot)), 0, 0);
+		if (CurStarDescPtr)
+		{
+			// Leave HyperSpace/QuasiSpace if we're there:
+			SET_GAME_STATE (USED_BROADCASTER, 0);
+			GLOBAL (CurrentActivity) &= ~IN_BATTLE;
+
+			// Enter IP:
+			GLOBAL (ShipFacing) = 0;
+			GLOBAL (ip_planet) = 0;
+			GLOBAL (in_orbit) = 0;
+					// This causes the ship position in IP to be reset.
+			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
+		}
+	}
+
+	// Turn off the autopilot:
+	(GLOBAL (autopilot)).x = ~0;
+	(GLOBAL (autopilot)).y = ~0;
+}
+
+// playerNr should be 0 or 1
+STARSHIP*
+findPlayerShip (SIZE playerNr)
+{
+	HELEMENT hElement, hNextElement;
+
+	for (hElement = GetHeadElement (); hElement; hElement = hNextElement)
+	{
+		ELEMENT *ElementPtr;
+
+		LockElement (hElement, &ElementPtr);
+		hNextElement = GetSuccElement (ElementPtr);
+					
+		if ((ElementPtr->state_flags & PLAYER_SHIP)	&&
+				ElementPtr->playerNr == playerNr)
+		{
+			STARSHIP *StarShipPtr;
+			GetElementStarShip (ElementPtr, &StarShipPtr);
+			UnlockElement (hElement);
+			return StarShipPtr;
+		}
+		
+		UnlockElement (hElement);
+	}
+	return NULL;
+}
+
+////////////////////////////////////////////////////////////////////////////
+
+void
+resetEnergyBattle (void)
+{
+	STARSHIP *StarShipPtr;
+	COUNT delta;
+	CONTEXT OldContext;
+	
+	if (!(GLOBAL (CurrentActivity) & IN_BATTLE) ||
+			inHQSpace())
+		return;	
+
+	if (PlayerControl[1] & HUMAN_CONTROL){
+		StarShipPtr = findPlayerShip (NPC_PLAYER_NUM);
+	} else if (PlayerControl[0] & HUMAN_CONTROL) {
+		StarShipPtr = findPlayerShip (RPG_PLAYER_NUM);
+	} else {
+		StarShipPtr = NULL;
+	}
+
+	if (StarShipPtr == NULL || StarShipPtr->RaceDescPtr == NULL)
+		return;
+
+	delta = StarShipPtr->RaceDescPtr->ship_info.max_energy -
+			StarShipPtr->RaceDescPtr->ship_info.energy_level;
+
+	OldContext = SetContext (StatusContext);
+	DeltaEnergy (StarShipPtr->hShip, delta);
+	SetContext (OldContext);
+}
+
+#if defined(DEBUG) || defined(USE_DEBUG_KEY)
 
 static void dumpEventCallback (const EVENT *eventPtr, void *arg);
 
@@ -72,7 +179,6 @@ static void dumpPlanetTypeCallback (int
 
 BOOLEAN instantMove = FALSE;
 BOOLEAN disableInteractivity = FALSE;
-void (* volatile debugHook) (void) = NULL;
 
 
 // Must be called on the Starcon2Main thread.
@@ -81,12 +187,12 @@ void
 debugKeyPressedSynchronous (void)
 {
 	// State modifying:
-	equipShip ();
-	giveDevices ();
+//	equipShip ();
+//	giveDevices ();
 
 	// Give the player the ships you can't ally with under normal
 	// conditions.
-	clearEscorts ();
+	/*clearEscorts ();
 	AddEscortShips (ARILOU_SHIP, 1);
 	AddEscortShips (PKUNK_SHIP, 1);
 	AddEscortShips (VUX_SHIP, 1);
@@ -98,14 +204,14 @@ debugKeyPressedSynchronous (void)
 	AddEscortShips (SLYLANDRO_SHIP, 1);
 	AddEscortShips (UMGAH_SHIP, 1);
 	AddEscortShips (URQUAN_SHIP, 1);
-	AddEscortShips (BLACK_URQUAN_SHIP, 1);
+	AddEscortShips (BLACK_URQUAN_SHIP, 1);*/
 
-	resetCrewBattle ();
-	resetEnergyBattle ();
-	instantMove = !instantMove;
+//	resetCrewBattle ();
+//	resetEnergyBattle ();
+//	instantMove = !instantMove;
 	showSpheres ();
-	activateAllShips ();
-//	forwardToNextEvent (TRUE);
+//	activateAllShips ();
+	forwardToNextEvent (TRUE);
 //	SET_GAME_STATE (MELNORME_CREDIT1, 100);
 //	GLOBAL_SIS (ResUnits) = 100000;
 
@@ -383,8 +489,8 @@ equipShip (void)
 void
 giveDevices (void) {
 	SET_GAME_STATE (ROSY_SPHERE_ON_SHIP, 1);
-	SET_GAME_STATE (ARTIFACT_2_ON_SHIP, 1);
-	SET_GAME_STATE (ARTIFACT_3_ON_SHIP, 1);
+	SET_GAME_STATE (WIMBLIS_TRIDENT_ON_SHIP, 1);
+	SET_GAME_STATE (GLOWING_ROD_ON_SHIP, 1);
 	SET_GAME_STATE (SUN_DEVICE_ON_SHIP, 1);
 	SET_GAME_STATE (UTWIG_BOMB_ON_SHIP, 1);
 	SET_GAME_STATE (ULTRON_CONDITION, 1);
@@ -465,52 +571,6 @@ findFlagshipElement (void)
 }
 #endif
 
-// Move the Flagship to the destination of the autopilot.
-// Should only be called from HyperSpace/QuasiSpace.
-// It can be called from debugHook directly after entering HS/QS though.
-void
-doInstantMove (void)
-{
-	// Move to the new location:
-	if ((GLOBAL (autopilot)).x == ~0 || (GLOBAL (autopilot)).y == ~0)
-	{
-		// If no destination has been selected, use the current location
-		// as the destination.
-		(GLOBAL (autopilot)).x = LOGX_TO_UNIVERSE(GLOBAL_SIS (log_x));
-		(GLOBAL (autopilot)).y = LOGY_TO_UNIVERSE(GLOBAL_SIS (log_y));
-	}
-	else
-	{
-		// A new destination has been selected.
-		GLOBAL_SIS (log_x) = UNIVERSE_TO_LOGX((GLOBAL (autopilot)).x);
-		GLOBAL_SIS (log_y) = UNIVERSE_TO_LOGY((GLOBAL (autopilot)).y);
-	}
-
-	// Check for a solar systems at the destination.
-	if (GET_GAME_STATE (ARILOU_SPACE_SIDE) <= 1)
-	{
-		// If there's a solar system at the destination, enter it.
-		CurStarDescPtr = FindStar (0, &(GLOBAL (autopilot)), 0, 0);
-		if (CurStarDescPtr)
-		{
-			// Leave HyperSpace/QuasiSpace if we're there:
-			SET_GAME_STATE (USED_BROADCASTER, 0);
-			GLOBAL (CurrentActivity) &= ~IN_BATTLE;
-
-			// Enter IP:
-			GLOBAL (ShipFacing) = 0;
-			GLOBAL (ip_planet) = 0;
-			GLOBAL (in_orbit) = 0;
-					// This causes the ship position in IP to be reset.
-			GLOBAL (CurrentActivity) |= START_INTERPLANETARY;
-		}
-	}
-
-	// Turn off the autopilot:
-	(GLOBAL (autopilot)).x = ~0;
-	(GLOBAL (autopilot)).y = ~0;
-}
-
 ////////////////////////////////////////////////////////////////////////////
 
 void
@@ -1473,35 +1533,6 @@ depositQualityString (BYTE quality)
 
 ////////////////////////////////////////////////////////////////////////////
 
-// playerNr should be 0 or 1
-STARSHIP*
-findPlayerShip (SIZE playerNr)
-{
-	HELEMENT hElement, hNextElement;
-
-	for (hElement = GetHeadElement (); hElement; hElement = hNextElement)
-	{
-		ELEMENT *ElementPtr;
-
-		LockElement (hElement, &ElementPtr);
-		hNextElement = GetSuccElement (ElementPtr);
-					
-		if ((ElementPtr->state_flags & PLAYER_SHIP)	&&
-				ElementPtr->playerNr == playerNr)
-		{
-			STARSHIP *StarShipPtr;
-			GetElementStarShip (ElementPtr, &StarShipPtr);
-			UnlockElement (hElement);
-			return StarShipPtr;
-		}
-		
-		UnlockElement (hElement);
-	}
-	return NULL;
-}
-
-////////////////////////////////////////////////////////////////////////////
-
 void
 resetCrewBattle (void)
 {
@@ -1525,29 +1556,6 @@ resetCrewBattle (void)
 	SetContext (OldContext);
 }
 
-void
-resetEnergyBattle (void)
-{
-	STARSHIP *StarShipPtr;
-	COUNT delta;
-	CONTEXT OldContext;
-	
-	if (!(GLOBAL (CurrentActivity) & IN_BATTLE) ||
-			(inHQSpace ()))
-		return;
-	
-	StarShipPtr = findPlayerShip (RPG_PLAYER_NUM);
-	if (StarShipPtr == NULL || StarShipPtr->RaceDescPtr == NULL)
-		return;
-
-	delta = StarShipPtr->RaceDescPtr->ship_info.max_energy -
-			StarShipPtr->RaceDescPtr->ship_info.energy_level;
-
-	OldContext = SetContext (StatusContext);
-	DeltaEnergy (StarShipPtr->hShip, delta);
-	SetContext (OldContext);
-}
-
 ////////////////////////////////////////////////////////////////////////////
 
 // This function should help in making sure that gamestr.h matches
diff -ruNp src.orig/uqm/uqmdebug.h src/uqm/uqmdebug.h
--- src.orig/uqm/uqmdebug.h	2017-12-30 00:14:42 -0800
+++ src/uqm/uqmdebug.h	2017-12-30 00:14:54 -0800
@@ -14,25 +14,36 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-#if !defined(_DEBUG_H) && (defined(DEBUG) || defined(USE_DEBUG_KEY))
-#define _DEBUG_H
-
 #include "clock.h"
 #include "planets/planets.h"
 #include "races.h"
 #include "libs/compiler.h"
 
 #include <stdio.h>
+ 
+// If a function is assigned to this, it will be called from the
+// Starcon2Main thread, in the main game loop.
+extern void (* volatile debugHook) (void);
+
+// Move the Flagship to the destination of the autopilot.
+// Should only be called from HS/QS.
+// It can be called from debugHook directly after entering HS/QS though.
+void doInstantMove (void);
+
+// Find a player ship. Setting playerNr to non-0 is only meaningful in battle.
+STARSHIP* findPlayerShip (SIZE playerNr);
+
+// Resets the energy of the first player (the bottom one) to its maximum.
+void resetEnergyBattle(void);
+
+#if !defined(_DEBUG_H) && (defined(DEBUG) || defined(USE_DEBUG_KEY))
+#define _DEBUG_H
 
 
 // If set to true, interactive routines that are called (indirectly) in debug
 // functions are a no-op.
 extern BOOLEAN disableInteractivity;
 
-// If a function is assigned to this, it will be called from the
-// Starcon2Main thread, in the main game loop.
-extern void (* volatile debugHook) (void);
-
 // Called on the main() thread when the debug key (symbol 'Debug' in the
 // keys.cfg) is pressed
 void debugKeyPressed (void);
@@ -40,6 +51,15 @@ void debugKeyPressed (void);
 // in the keys.cfg) is pressed.
 void debugKeyPressedSynchronous (void);
 
+// JMS: Called when the debug key (symbol 'Debug_2' in the keys.cfg) is pressed.
+void debugKey2Pressed (void);
+
+// JMS: Called when the debug key (symbol 'Debug_3' in the keys.cfg) is pressed.
+void debugKey3Pressed (void);
+
+// JMS: Called when the debug key (symbol 'Debug_4' in the keys.cfg) is pressed.
+void debugKey4Pressed (void);
+
 // Forward time to the next event. If skipHEE is set, the event named
 // HYPERSPACE_ENCOUNTER_EVENT, which normally occurs every game day,
 // is skipped. Must be called on the Starcon2Main thread.
@@ -66,12 +86,6 @@ void showSpheres (void);
 // Make the ships of all races available for building at the shipyard.
 void activateAllShips (void);
 
-// Move the Flagship to the destination of the autopilot.
-// Should only be called from HS/QS.
-// It can be called from debugHook directly after entering HS/QS though.
-void doInstantMove (void);
-
-
 // Call a function for all stars.
 void forAllStars (void (*callback) (STAR_DESC *, void *), void *arg);
 // Call a function for all planets in a star system.
@@ -169,17 +183,9 @@ const char *densityString (BYTE density)
 // Get a string describing the quality of a deposit.
 const char *depositQualityString (BYTE quality);
 
-
-// Find a player ship. Setting playerNr to non-0 is only meaningful in battle.
-STARSHIP* findPlayerShip (SIZE playerNr);
-
 // Resets the crew of the first player (the bottom one) to its maximum.
 void resetCrewBattle(void);
 
-// Resets the energy of the first player (the bottom one) to its maximum.
-void resetEnergyBattle(void);
-
-
 // Move instantly across hyperspace/quasispace.
 extern BOOLEAN instantMove;
 
diff -ruNp src.orig/uqm/util.c src/uqm/util.c
--- src.orig/uqm/util.c	2017-12-30 00:14:42 -0800
+++ src/uqm/util.c	2017-12-30 00:14:54 -0800
@@ -25,7 +25,7 @@
 #include "libs/sound/trackplayer.h"
 #include "libs/mathlib.h"
 #include "libs/log.h"
-
+#include "hyper.h"
 
 void
 DrawStarConBox (RECT *pRect, SIZE BorderWidth, Color TopLeftColor,
@@ -310,3 +310,24 @@ SleepGame (void)
 
 	TaskSwitch ();
 }
+
+/* Returns the fuel requirement to get to Sol (in fuel units * 100)
+ */
+DWORD
+get_fuel_to_sol (void)
+{
+	POINT pt;
+	DWORD f;
+
+	pt.x = LOGX_TO_UNIVERSE (GLOBAL_SIS (log_x));
+	pt.y = LOGY_TO_UNIVERSE (GLOBAL_SIS (log_y));
+	
+	pt.x -= SOL_X;
+	pt.y -= SOL_Y;
+
+	f = (DWORD)((long)pt.x * pt.x + (long)pt.y * pt.y);
+	if (f == 0 || GET_GAME_STATE (ARILOU_SPACE_SIDE) > 1)
+		return 0;
+	else
+		return (square_root (f) + (FUEL_TANK_SCALE / 20));
+}
\ No newline at end of file
diff -ruNp src.orig/uqm/util.h src/uqm/util.h
--- src.orig/uqm/util.h	2017-12-30 00:14:42 -0800
+++ src/uqm/util.h	2017-12-30 00:14:54 -0800
@@ -32,6 +32,8 @@ extern DWORD SeedRandomNumbers (void);
 // saveRect can be NULL to save the entire context frame
 extern STAMP SaveContextFrame (const RECT *saveRect);
 
+extern DWORD get_fuel_to_sol (void);
+
 #if defined(__cplusplus)
 }
 #endif
diff -ruNp src.orig/uqm/velocity.c src/uqm/velocity.c
--- src.orig/uqm/velocity.c	2017-12-30 00:14:42 -0800
+++ src/uqm/velocity.c	2017-12-30 00:14:54 -0800
@@ -20,7 +20,7 @@
 
 #include "units.h"
 #include "libs/compiler.h"
-
+#include "libs/log.h"
 
 #define VELOCITY_REMAINDER(v) ((v) & (VELOCITY_SCALE - 1))
 
@@ -28,40 +28,78 @@ void
 GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy)
 {
 	*pdx = WORLD_TO_VELOCITY (velocityptr->vector.width)
-			+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
+	+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
 	*pdy = WORLD_TO_VELOCITY (velocityptr->vector.height)
-			+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
+	+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
 }
 
 void
-GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy,
-		COUNT num_frames)
+GetCurrentVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy)
 {
-	COUNT e;
+	*pdx = WORLD_TO_VELOCITY (velocityptr->vector.width)
+	+ ((SDWORD)velocityptr->fract.width - (SDWORD)HIBYTE (velocityptr->incr.width));
+	*pdy = WORLD_TO_VELOCITY (velocityptr->vector.height)
+	+ ((SDWORD)velocityptr->fract.height - (SDWORD)HIBYTE (velocityptr->incr.height));
+}
 
+void
+GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy, COUNT num_frames)
+{
+	COUNT e;
+	
 	e = (COUNT)((COUNT)velocityptr->error.width +
-			((COUNT)velocityptr->fract.width * num_frames));
+				((COUNT)velocityptr->fract.width * num_frames));
+	
 	*pdx = (velocityptr->vector.width * num_frames)
-			+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.width))
-			* (e >> VELOCITY_SHIFT));
+	+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.width))
+	   * (e >> VELOCITY_SHIFT));
+	
 	velocityptr->error.width = VELOCITY_REMAINDER (e);
-
+	
 	e = (COUNT)((COUNT)velocityptr->error.height +
-			((COUNT)velocityptr->fract.height * num_frames));
+				((COUNT)velocityptr->fract.height * num_frames));
+	
 	*pdy = (velocityptr->vector.height * num_frames)
-			+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.height))
-			* (e >> VELOCITY_SHIFT));
+	+ ((SIZE)((SBYTE)LOBYTE (velocityptr->incr.height))
+	   * (e >> VELOCITY_SHIFT));
+	
 	velocityptr->error.height = VELOCITY_REMAINDER (e);
 }
 
+// JMS_GFX: New function to prevent overflows in hi-res.
+void
+GetNextVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy, DWORD num_frames)
+{
+	DWORD e;
+	
+	e = (DWORD)((DWORD)velocityptr->error.width +
+				((DWORD)velocityptr->fract.width * num_frames));
+	
+	*pdx = ((SDWORD)velocityptr->vector.width * num_frames)
+	+ ((SDWORD)((SBYTE)LOBYTE (velocityptr->incr.width))
+	   * (e >> VELOCITY_SHIFT));
+	
+	velocityptr->error.width = (COUNT)(VELOCITY_REMAINDER (e));
+	
+	e = (DWORD)((DWORD)velocityptr->error.height +
+				((DWORD)velocityptr->fract.height * num_frames));
+	
+	*pdy = ((SDWORD)velocityptr->vector.height * num_frames)
+	+ ((SDWORD)((SBYTE)LOBYTE (velocityptr->incr.height))
+	   * (e >> VELOCITY_SHIFT));
+	
+	velocityptr->error.height = (COUNT)(VELOCITY_REMAINDER (e));
+}
+
+// JMS_GFX: Preventing overflows in hi-res: The SDWORD in this function's parameters was SIZE.
 void
-SetVelocityVector (VELOCITY_DESC *velocityptr, SIZE magnitude, COUNT facing)
+SetVelocityVector (VELOCITY_DESC *velocityptr, SDWORD magnitude, COUNT facing)
 {
 	COUNT angle;
 	SIZE dx, dy;
-
+	
 	angle = velocityptr->TravelAngle =
-			FACING_TO_ANGLE (NORMALIZE_FACING (facing));
+	FACING_TO_ANGLE (NORMALIZE_FACING (facing));
 	magnitude = WORLD_TO_VELOCITY (magnitude);
 	dx = COSINE (angle, magnitude);
 	dy = SINE (angle, magnitude);
@@ -75,7 +113,7 @@ SetVelocityVector (VELOCITY_DESC *veloci
 		dx = -dx;
 		velocityptr->vector.width = -VELOCITY_TO_WORLD (dx);
 		velocityptr->incr.width =
-				MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
+		MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
 	}
 	if (dy >= 0)
 	{
@@ -87,19 +125,20 @@ SetVelocityVector (VELOCITY_DESC *veloci
 		dy = -dy;
 		velocityptr->vector.height = -VELOCITY_TO_WORLD (dy);
 		velocityptr->incr.height =
-				MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
+		MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
 	}
-
+	
 	velocityptr->fract.width = VELOCITY_REMAINDER (dx);
 	velocityptr->fract.height = VELOCITY_REMAINDER (dy);
 	velocityptr->error.width = velocityptr->error.height = 0;
 }
 
+// JMS_GFX: Preventing overflows in hi-res: The SDWORDs in this function's parameters were SIZEs.
 void
-SetVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx, SIZE dy)
+SetVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy)
 {
 	COUNT angle;
-
+	
 	if ((angle = ARCTAN (dx, dy)) == FULL_CIRCLE)
 	{
 		ZeroVelocityComponents (velocityptr);
@@ -115,8 +154,7 @@ SetVelocityComponents (VELOCITY_DESC *ve
 		{
 			dx = -dx;
 			velocityptr->vector.width = -VELOCITY_TO_WORLD (dx);
-			velocityptr->incr.width =
-					MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
+			velocityptr->incr.width = MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dx) << 1));
 		}
 		if (dy >= 0)
 		{
@@ -127,27 +165,27 @@ SetVelocityComponents (VELOCITY_DESC *ve
 		{
 			dy = -dy;
 			velocityptr->vector.height = -VELOCITY_TO_WORLD (dy);
-			velocityptr->incr.height =
-					MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
+			velocityptr->incr.height = MAKE_WORD ((BYTE)0xFF, (BYTE)(VELOCITY_REMAINDER (dy) << 1));
 		}
-
+		
 		velocityptr->fract.width = VELOCITY_REMAINDER (dx);
 		velocityptr->fract.height = VELOCITY_REMAINDER (dy);
 		velocityptr->error.width = velocityptr->error.height = 0;
 	}
-
+	
 	velocityptr->TravelAngle = angle;
 }
 
+// JMS_GFX: Preventing overflows in hi-res: The SDWORDs in this function's parameters were SIZEs.
 void
-DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx, SIZE dy)
+DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy)
 {
-
+	
 	dx += WORLD_TO_VELOCITY (velocityptr->vector.width)
-			+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
+	+ (velocityptr->fract.width - (SIZE)HIBYTE (velocityptr->incr.width));
 	dy += WORLD_TO_VELOCITY (velocityptr->vector.height)
-			+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
-
+	+ (velocityptr->fract.height - (SIZE)HIBYTE (velocityptr->incr.height));
+	
 	SetVelocityComponents (velocityptr, dx, dy);
 }
 
diff -ruNp src.orig/uqm/velocity.h src/uqm/velocity.h
--- src.orig/uqm/velocity.h	2017-12-30 00:14:42 -0800
+++ src/uqm/velocity.h	2017-12-30 00:14:54 -0800
@@ -38,16 +38,21 @@ typedef struct velocity_desc
 #define ZeroVelocityComponents(pv) memset(pv,0,sizeof (*(pv)))
 #define GetVelocityTravelAngle(pv) (pv)->TravelAngle
 
-extern void GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr,
-		SIZE *pdx, SIZE *pdy);
-extern void GetNextVelocityComponents (VELOCITY_DESC *velocityptr,
-		SIZE *pdx, SIZE *pdy, COUNT num_frames);
-extern void SetVelocityVector (VELOCITY_DESC *velocityptr, SIZE magnitude,
-		COUNT facing);
-extern void SetVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx,
-		SIZE dy);
-extern void DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SIZE dx,
-		SIZE dy);
+extern void GetCurrentVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy);
+
+// JMS_GFX: New function to prevent overflows in hi-res.
+extern void GetCurrentVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy);
+
+extern void GetNextVelocityComponents (VELOCITY_DESC *velocityptr, SIZE *pdx, SIZE *pdy, COUNT num_frames);
+
+// JMS_GFX: New function to prevent overflows in hi-res.
+extern void GetNextVelocityComponentsSdword (VELOCITY_DESC *velocityptr, SDWORD *pdx, SDWORD *pdy, DWORD num_frames);
+
+extern void SetVelocityVector (VELOCITY_DESC *velocityptr, SDWORD magnitude, COUNT facing); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
+
+extern void SetVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
+
+extern void DeltaVelocityComponents (VELOCITY_DESC *velocityptr, SDWORD dx, SDWORD dy); // JMS_GFX: Changed SIZE to SDWORD to prevent overflows
 
 static inline bool
 IsVelocityZero (VELOCITY_DESC *vptr)
diff -ruNp src.orig/uqm/weapon.c src/uqm/weapon.c
--- src.orig/uqm/weapon.c	2017-12-30 00:14:42 -0800
+++ src/uqm/weapon.c	2017-12-30 00:14:54 -0800
@@ -285,7 +285,7 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 				&ShipIntersect, MAX_TIME_VALUE));
 
 		ObjectIntersect.IntersectStamp.origin.x += STATUS_WIDTH >> 1;
-		ObjectIntersect.IntersectStamp.origin.y += 31;
+		ObjectIntersect.IntersectStamp.origin.y += (31 << RESOLUTION_FACTOR); // JMS_GFX
 	}
 
 	ObjectIntersect.IntersectStamp.origin.y +=
@@ -296,7 +296,7 @@ ModifySilhouette (ELEMENT *ElementPtr, S
 		or.corner.x += ObjectIntersect.IntersectStamp.origin.x;
 		or.corner.y += ObjectIntersect.IntersectStamp.origin.y;
 		InitShipStatus (&StarShipPtr->RaceDescPtr->ship_info,
-				StarShipPtr, &or);
+				StarShipPtr, &or, FALSE);
 	}
 	else
 	{
diff -ruNp src.orig/uqm.c src/uqm.c
--- src.orig/uqm.c	2017-12-30 00:14:42 -0800
+++ src/uqm.c	2017-12-30 00:14:54 -0800
@@ -130,6 +130,33 @@ struct options_struct
 	DECL_CONFIG_OPTION(float, sfxVolumeScale);
 	DECL_CONFIG_OPTION(float, speechVolumeScale);
 	DECL_CONFIG_OPTION(bool, safeMode);
+	DECL_CONFIG_OPTION(int, resolutionFactor); // JMS_GFX
+	DECL_CONFIG_OPTION(int, loresBlowupScale); // JMS_GFX
+ 	DECL_CONFIG_OPTION(bool, cheatMode); // JMS
+	// Serosis
+	DECL_CONFIG_OPTION(bool, godMode);
+	DECL_CONFIG_OPTION(int, timeDilationScale);
+	DECL_CONFIG_OPTION(bool, bubbleWarp);
+	DECL_CONFIG_OPTION(bool, unlockShips);
+	DECL_CONFIG_OPTION(bool, headStart);
+	DECL_CONFIG_OPTION(bool, unlockUpgrades);
+	DECL_CONFIG_OPTION(bool, infiniteRU);
+	DECL_CONFIG_OPTION(bool, skipIntro);
+	DECL_CONFIG_OPTION(bool, FMV);
+	// JMS
+	DECL_CONFIG_OPTION(bool, mainMenuMusic);
+	DECL_CONFIG_OPTION(bool, nebulae);
+	DECL_CONFIG_OPTION(bool, orbitingPlanets);
+	DECL_CONFIG_OPTION(bool, texturedPlanets);
+	// Nic
+	DECL_CONFIG_OPTION(int, optDateFormat);
+	// Serosis
+	DECL_CONFIG_OPTION(bool, infiniteFuel);
+	DECL_CONFIG_OPTION(bool, thraddStory);
+	DECL_CONFIG_OPTION(bool, partialPickup);
+	DECL_CONFIG_OPTION(bool, submenu);
+	DECL_CONFIG_OPTION(bool, addDevices);
+	DECL_CONFIG_OPTION(bool, scalePlanets);
 
 #define INIT_CONFIG_OPTION(name, val) \
 	{ val, false }
@@ -238,32 +265,58 @@ main (int argc, char *argv[])
 		/* .addons = */             NULL,
 		/* .numAddons = */          0,
 
-		INIT_CONFIG_OPTION(  opengl,            false ),
+		INIT_CONFIG_OPTION(  opengl,            true ),
 		INIT_CONFIG_OPTION2( resolution,        640, 480 ),
 		INIT_CONFIG_OPTION(  fullscreen,        false ),
 		INIT_CONFIG_OPTION(  scanlines,         false ),
 		INIT_CONFIG_OPTION(  scaler,            0 ),
 		INIT_CONFIG_OPTION(  showFps,           false ),
-		INIT_CONFIG_OPTION(  keepAspectRatio,   false ),
+		INIT_CONFIG_OPTION(  keepAspectRatio,   true ),
 		INIT_CONFIG_OPTION(  gamma,             1.0f ),
 		INIT_CONFIG_OPTION(  soundDriver,       audio_DRIVER_MIXSDL ),
-		INIT_CONFIG_OPTION(  soundQuality,      audio_QUALITY_MEDIUM ),
+		INIT_CONFIG_OPTION(  soundQuality,      audio_QUALITY_HIGH ),
 		INIT_CONFIG_OPTION(  use3doMusic,       true ),
 		INIT_CONFIG_OPTION(  useRemixMusic,     false ),
 		INIT_CONFIG_OPTION(  useSpeech,         true ),
 		INIT_CONFIG_OPTION(  whichCoarseScan,   OPT_PC ),
-		INIT_CONFIG_OPTION(  whichMenu,         OPT_PC ),
+		INIT_CONFIG_OPTION(  whichMenu,         OPT_3DO ),
 		INIT_CONFIG_OPTION(  whichFonts,        OPT_PC ),
-		INIT_CONFIG_OPTION(  whichIntro,        OPT_PC ),
-		INIT_CONFIG_OPTION(  whichShield,       OPT_PC ),
+		INIT_CONFIG_OPTION(  whichIntro,        OPT_3DO ),
+		INIT_CONFIG_OPTION(  whichShield,       OPT_3DO ),
 		INIT_CONFIG_OPTION(  smoothScroll,      OPT_PC ),
 		INIT_CONFIG_OPTION(  meleeScale,        TFB_SCALE_TRILINEAR ),
 		INIT_CONFIG_OPTION(  subtitles,         true ),
-		INIT_CONFIG_OPTION(  stereoSFX,         false ),
+		INIT_CONFIG_OPTION(  stereoSFX,         true ),
 		INIT_CONFIG_OPTION(  musicVolumeScale,  1.0f ),
 		INIT_CONFIG_OPTION(  sfxVolumeScale,    1.0f ),
-		INIT_CONFIG_OPTION(  speechVolumeScale, 1.0f ),
+		INIT_CONFIG_OPTION(  speechVolumeScale, 0.8f ),
 		INIT_CONFIG_OPTION(  safeMode,          false ),
+		INIT_CONFIG_OPTION(  resolutionFactor,  0 ),
+		INIT_CONFIG_OPTION(  loresBlowupScale,  1 ),
+		INIT_CONFIG_OPTION(  cheatMode,			false ), // JMS
+		//Serosis
+		INIT_CONFIG_OPTION(  godMode,			false ), 
+		INIT_CONFIG_OPTION(  timeDilationScale,	0 ),
+		INIT_CONFIG_OPTION(  bubbleWarp,		false ),
+		INIT_CONFIG_OPTION(  unlockShips,		false ),
+		INIT_CONFIG_OPTION(  headStart,			false ),
+		INIT_CONFIG_OPTION(  unlockUpgrades,	false ),
+		INIT_CONFIG_OPTION(  infiniteRU,		false ),
+		INIT_CONFIG_OPTION(  skipIntro,			false ),
+		INIT_CONFIG_OPTION(  FMV,				false ),
+		// JMS
+		INIT_CONFIG_OPTION(  mainMenuMusic,     true ),
+		INIT_CONFIG_OPTION(  nebulae,			true ),
+		INIT_CONFIG_OPTION(  orbitingPlanets,	false),
+		INIT_CONFIG_OPTION(  texturedPlanets,	false),
+		// Nic
+		INIT_CONFIG_OPTION(  optDateFormat,		0),
+		INIT_CONFIG_OPTION(  infiniteFuel,		false),
+		INIT_CONFIG_OPTION(  thraddStory,		false),
+		INIT_CONFIG_OPTION(  partialPickup,		false),
+		INIT_CONFIG_OPTION(  submenu,			true),
+		INIT_CONFIG_OPTION(  addDevices,		false),
+		INIT_CONFIG_OPTION(  scalePlanets,		true),
 	};
 	struct options_struct defaults = options;
 	int optionsResult;
@@ -291,6 +344,9 @@ main (int argc, char *argv[])
 #endif
 		for (i = 0; i < argc; ++i)
 			log_add (log_User, "argv[%d] = [%s]", i, argv[i]);
+	} else {
+		// MB: Output log to logfile by default, not console
+		freopen("uqm.log", "w", stderr);
 	}
 
 	if (options.runMode == runMode_version)
@@ -348,6 +404,7 @@ main (int argc, char *argv[])
 	if (!options.safeMode.value)
 	{
 		LoadResourceIndex (configDir, "uqm.cfg", "config.");
+		LoadResourceIndex (configDir, "cheats.cfg", "cheat.");
 		getUserConfigOptions (&options);
 	}
 
@@ -391,6 +448,36 @@ main (int argc, char *argv[])
 	sfxVolumeScale = options.sfxVolumeScale.value;
 	speechVolumeScale = options.speechVolumeScale.value;
 	optAddons = options.addons;
+	
+	resolutionFactor = (unsigned int) options.resolutionFactor.value; // JMS_GFX
+	loresBlowupScale = (unsigned int) options.loresBlowupScale.value; // JMS_GFX
+	
+	optGodMode = options.godMode.value; // JMS
+	// Serosis
+	timeDilationScale = options.timeDilationScale.value;
+	optBubbleWarp = options.bubbleWarp.value;
+	optUnlockShips = options.unlockShips.value;
+	optHeadStart = options.headStart.value;
+	optUnlockUpgrades = options.unlockUpgrades.value;
+	optInfiniteRU = options.infiniteRU.value;
+	optSkipIntro = options.skipIntro.value;
+	optFMV = options.FMV.value;
+	// JMS
+	optMainMenuMusic = options.mainMenuMusic.value;
+	optNebulae = options.nebulae.value;
+	optOrbitingPlanets = options.orbitingPlanets.value;
+	optTexturedPlanets = options.texturedPlanets.value;
+ 	optCheatMode = options.cheatMode.value;
+	// Nic
+	optDateFormat = options.optDateFormat.value;
+	// Serosis	
+	optInfiniteFuel = options.infiniteFuel.value;
+	optThraddStory = options.thraddStory.value;
+	optPartialPickup = options.partialPickup.value;
+	optSubmenu = options.submenu.value;
+	optAddDevices = options.addDevices.value;
+	optScalePlanets = options.scalePlanets.value;
+	resFactorWasChanged = FALSE; // JMS_GFX
 
 	prepareContentDir (options.contentDir, options.addonDir, argv[0]);
 	prepareMeleeDir ();
@@ -423,7 +510,7 @@ main (int argc, char *argv[])
 	if (options.showFps.value)
 		gfxFlags |= TFB_GFXFLAGS_SHOWFPS;
 	TFB_InitGraphics (gfxDriver, gfxFlags, options.resolution.width,
-			options.resolution.height);
+			options.resolution.height, &resolutionFactor);
 	if (options.gamma.set && setGammaCorrection (options.gamma.value))
 		optGamma = options.gamma.value;
 	else
@@ -676,6 +763,49 @@ getUserConfigOptions (struct options_str
 	getVolumeConfigValue (&options->sfxVolumeScale, "config.sfxvol");
 	getVolumeConfigValue (&options->speechVolumeScale, "config.speechvol");
 	
+	// JMS_GFX
+	if (res_IsInteger ("config.resolutionfactor") && !options->resolutionFactor.set)
+	{
+		options->resolutionFactor.value = res_GetInteger ("config.resolutionfactor");
+		options->resolutionFactor.set = true;
+	}
+	
+	// JMS_GFX
+	if (res_IsInteger ("config.loresBlowupScale"))
+	{
+		options->loresBlowupScale.value = res_GetInteger ("config.loresBlowupScale");
+	}
+
+	getBoolConfigValue (&options->cheatMode, "cheat.kohrStahp"); // JMS
+	// Serosis
+	getBoolConfigValue (&options->godMode, "cheat.godMode");
+	if (res_IsInteger ("cheat.timeDilation") && !options->timeDilationScale.set) {
+		options->timeDilationScale.value = res_GetInteger ("cheat.timeDilation");
+	}
+	getBoolConfigValue (&options->bubbleWarp, "cheat.bubbleWarp");
+	getBoolConfigValue (&options->unlockShips, "cheat.unlockShips");
+	getBoolConfigValue (&options->headStart, "cheat.headStart");
+	getBoolConfigValue (&options->unlockUpgrades, "cheat.unlockUpgrades");
+	getBoolConfigValue (&options->infiniteRU, "cheat.infiniteRU");
+	getBoolConfigValue (&options->skipIntro, "config.skipIntro");
+	getBoolConfigValue (&options->FMV, "config.FMV");
+	// JMS
+	getBoolConfigValue (&options->mainMenuMusic, "config.mainMenuMusic");
+	getBoolConfigValue (&options->nebulae, "config.nebulae");
+	getBoolConfigValue (&options->orbitingPlanets, "config.orbitingPlanets");
+	getBoolConfigValue (&options->texturedPlanets, "config.texturedPlanets");
+	// Nic	
+	if (res_IsInteger ("config.dateFormat") && !options->optDateFormat.set) {
+		options->optDateFormat.value = res_GetInteger ("config.dateFormat");
+	}
+	// Serosis	
+	getBoolConfigValue (&options->infiniteFuel, "cheat.infiniteFuel");
+	getBoolConfigValue (&options->thraddStory, "config.thraddStory");
+	getBoolConfigValue (&options->partialPickup, "config.partialPickup");
+	getBoolConfigValue (&options->submenu, "config.submenu");
+	getBoolConfigValue (&options->addDevices, "cheat.addDevices");
+	getBoolConfigValue (&options->scalePlanets, "config.scalePlanets");
+	
 	if (res_IsInteger ("config.player1control"))
 	{
 		PlayerControls[0] = res_GetInteger ("config.player1control");
@@ -714,6 +844,28 @@ enum
 	ADDONDIR_OPT,
 	ACCEL_OPT,
 	SAFEMODE_OPT,
+	CHEATMODE_OPT, //Serosis
+	GODMODE_OPT,
+	TDM_OPT,
+	BWARP_OPT,
+	UNLOCKSHIPS_OPT,
+	HEADSTART_OPT,
+	UPGRADES_OPT,
+	INFINITERU_OPT,
+	SKIPINTRO_OPT,
+	FMV_OPT,
+	MENUMUS_OPT,
+	NEBU_OPT,
+	ORBITS_OPT,
+	TEXTPLAN_OPT,
+	DATE_OPT,
+	INFFUEL_OPT,
+	THRADD_OPT,
+	PICKUP_OPT,
+	SUBMENU_OPT,
+	DEVICES_OPT,
+	SCALEPLAN_OPT,
+	MELEE_OPT,
 #ifdef NETPLAY
 	NETHOST1_OPT,
 	NETPORT1_OPT,
@@ -761,6 +913,28 @@ static struct option longOptions[] =
 	{"addondir", 1, NULL, ADDONDIR_OPT},
 	{"accel", 1, NULL, ACCEL_OPT},
 	{"safe", 0, NULL, SAFEMODE_OPT},
+	{"kohrstahp", 0, NULL, CHEATMODE_OPT}, //Serosis
+	{"godmode", 0, NULL, GODMODE_OPT},
+	{"timedilation", 1, NULL, TDM_OPT},
+	{"bubblewarp", 0, NULL, BWARP_OPT},
+	{"unlockships", 0, NULL, UNLOCKSHIPS_OPT},
+	{"headstart", 0, NULL, HEADSTART_OPT},
+	{"unlockupgrades", 0, NULL, UPGRADES_OPT},
+	{"infiniteru", 0, NULL, INFINITERU_OPT},
+	{"skipintro", 0, NULL, SKIPINTRO_OPT},
+	{"fmv", 0, NULL, FMV_OPT},
+	{"mainmenumusic", 0, NULL, MENUMUS_OPT},
+	{"nebulae", 0, NULL, NEBU_OPT},
+	{"orbitingplanets", 0, NULL, ORBITS_OPT},
+	{"texturedplanets", 0, NULL, TEXTPLAN_OPT},
+	{"dateformat", 0, NULL, DATE_OPT},
+	{"infinitefuel", 0, NULL, INFFUEL_OPT},
+	{"thraddstory", 0, NULL, THRADD_OPT},
+	{"partialpickup", 0, NULL, PICKUP_OPT},
+	{"submenu", 0, NULL, SUBMENU_OPT},
+	{"adddevices", 0, NULL, DEVICES_OPT},
+	{"scaledevices", 0, NULL, SCALEPLAN_OPT},
+	{"melee", 0, NULL, MELEE_OPT},
 #ifdef NETPLAY
 	{"nethost1", 1, NULL, NETHOST1_OPT},
 	{"netport1", 1, NULL, NETPORT1_OPT},
@@ -1017,6 +1191,94 @@ parseOptions (int argc, char *argv[], st
 			case STEREOSFX_OPT:
 				setBoolOption (&options->stereoSFX, true);
 				break;
+			case CHEATMODE_OPT:
+				setBoolOption (&options->cheatMode, true); //Serosis
+				break;
+			case GODMODE_OPT:
+				setBoolOption (&options->godMode, true);
+				break;
+			case TDM_OPT:{
+				int temp;
+				if (parseIntOption (optarg, &temp, "Time Dilation scale") == -1) {
+					badArg = true;
+					break;
+				} else if (temp < 0 || temp > 2) {					
+					saveError ("\nTime Dilation scale has to be 0, 1, or 2.\n");
+					badArg = true;
+				} else {
+					options->timeDilationScale.value = temp;
+					options->timeDilationScale.set = true;
+				}
+				break;
+			}
+			case BWARP_OPT:
+				setBoolOption (&options->bubbleWarp, true);
+				break;
+			case UNLOCKSHIPS_OPT:
+				setBoolOption (&options->unlockShips, true);
+				break;
+			case HEADSTART_OPT:
+				setBoolOption (&options->headStart, true);
+				break;
+			case UPGRADES_OPT:
+				setBoolOption (&options->unlockUpgrades, true);
+				break;
+			case INFINITERU_OPT:
+				setBoolOption (&options->infiniteRU, true);
+				break;
+			case SKIPINTRO_OPT:
+				setBoolOption (&options->skipIntro, true);
+				break;
+			case FMV_OPT:
+				setBoolOption (&options->FMV, true);
+				break;
+			case MENUMUS_OPT:
+				setBoolOption (&options->mainMenuMusic, true);
+				break;
+			case NEBU_OPT:
+				setBoolOption (&options->nebulae, true);
+				break;
+			case ORBITS_OPT:
+				setBoolOption (&options->orbitingPlanets, true);
+				break;
+			case TEXTPLAN_OPT:
+				setBoolOption (&options->texturedPlanets, true);
+				break;
+			case DATE_OPT:{
+				int temp;
+				if (parseIntOption (optarg, &temp, "Date Format") == -1) {
+					badArg = true;
+					break;
+				} else if (temp < 0 || temp > 3) {					
+					saveError ("\nDate Format has to be 0, 1, 2, or 3.\n");
+					badArg = true;
+				} else {
+					options->optDateFormat.value = temp;
+					options->optDateFormat.set = true;
+				}
+				break;
+			}
+			case INFFUEL_OPT:
+				setBoolOption (&options->infiniteFuel, true);
+				break;
+			case THRADD_OPT:
+				setBoolOption (&options->thraddStory, true);
+				break;
+			case PICKUP_OPT:
+				setBoolOption (&options->partialPickup, true);
+				break;
+			case SUBMENU_OPT:
+				setBoolOption (&options->submenu, true);
+				break;
+			case DEVICES_OPT:
+				setBoolOption (&options->addDevices, true);
+				break;
+			case SCALEPLAN_OPT:
+				setBoolOption (&options->scalePlanets, true);
+				break;
+			case MELEE_OPT:
+				optSuperMelee = TRUE;
+				break;
 			case ADDON_OPT:
 				options->numAddons++;
 				options->addons = HRealloc ((void *) options->addons,
@@ -1166,27 +1428,27 @@ usage (FILE *out, const struct options_s
 	log_captureLines (LOG_CAPTURE_ALL);
 	
 	log_add (log_User, "Options:");
-	log_add (log_User, "  -r, --res=WIDTHxHEIGHT (default 640x480, bigger "
+	log_add (log_User, "  -r, --res=WIDTHxHEIGHT (default: 640x480, bigger "
 			"works only with --opengl)");
-	log_add (log_User, "  -f, --fullscreen (default %s)",
+	log_add (log_User, "  -f, --fullscreen (default: %s)",
 			boolOptString (&defaults->fullscreen));
-	log_add (log_User, "  -w, --windowed (default %s)",
+	log_add (log_User, "  -w, --windowed (default: %s)",
 			boolNotOptString (&defaults->fullscreen));
-	log_add (log_User, "  -o, --opengl (default %s)",
+	log_add (log_User, "  -o, --opengl (default: %s)",
 			boolOptString (&defaults->opengl));
-	log_add (log_User, "  -x, --nogl (default %s)",
+	log_add (log_User, "  -x, --nogl (default: %s)",
 			boolNotOptString (&defaults->opengl));
-	log_add (log_User, "  -k, --keepaspectratio (default %s)",
+	log_add (log_User, "  -k, --keepaspectratio (default: %s)",
 			boolOptString (&defaults->keepAspectRatio));
 	log_add (log_User, "  -c, --scale=MODE (bilinear, biadapt, biadv, "
 			"triscan, hq or none (default) )");
 	log_add (log_User, "  -b, --meleezoom=MODE (step, aka pc, or smooth, "
 			"aka 3do; default is 3do)");
-	log_add (log_User, "  -s, --scanlines (default %s)",
+	log_add (log_User, "  -s, --scanlines (default: %s)",
 			boolOptString (&defaults->scanlines));
-	log_add (log_User, "  -p, --fps (default %s)",
+	log_add (log_User, "  -p, --fps (default: %s)",
 			boolOptString (&defaults->showFps));
-	log_add (log_User, "  -g, --gamma=CORRECTIONVALUE (default 1.0, which "
+	log_add (log_User, "  -g, --gamma=CORRECTIONVALUE (default: 1.0, which "
 			"causes no change)");
 	log_add (log_User, "  -C, --configdir=CONFIGDIR");
 	log_add (log_User, "  -n, --contentdir=CONTENTDIR");
@@ -1217,21 +1479,71 @@ usage (FILE *out, const struct options_s
 #endif
 	log_add (log_User, "The following options can take either '3do' or 'pc' "
 			"as an option:");
-	log_add (log_User, "  -i, --intro : Intro/ending version (default %s)",
+	log_add (log_User, "  -i, --intro : Intro/ending version (default: %s)",
 			choiceOptString (&defaults->whichIntro));
 	log_add (log_User, "  --cscan     : coarse-scan display, pc=text, "
-			"3do=hieroglyphs (default %s)",
+			"3do=hieroglyphs (default: %s)",
 			choiceOptString (&defaults->whichCoarseScan));
 	log_add (log_User, "  --menu      : menu type, pc=text, 3do=graphical "
-			"(default %s)", choiceOptString (&defaults->whichMenu));
-	log_add (log_User, "  --font      : font types and colors (default %s)",
+			"(default: %s)", choiceOptString (&defaults->whichMenu));
+	log_add (log_User, "  --font      : font types and colors (default: %s)",
 			choiceOptString (&defaults->whichFonts));
 	log_add (log_User, "  --shield    : slave shield type; pc=static, "
-			"3do=throbbing (default %s)",
+			"3do=throbbing (default: %s)",
 			choiceOptString (&defaults->whichShield));
 	log_add (log_User, "  --scroll    : ff/frev during comm.  pc=per-page, "
-			"3do=smooth (default %s)",
+			"3do=smooth (default: %s)",
 			choiceOptString (&defaults->smoothScroll));
+
+	log_add (log_User, "The following options are for the Mega Mod"); // Serosis
+	log_add (log_User, "  --kohrstahp : Stops Kohr-Ah advancing.    (default: %s)",
+			boolOptString (&defaults->cheatMode));
+	log_add (log_User, "  --godmode : Player ships and lander invulnerable. "
+			"Also refills energy every shot during melee.    (default: %s)",
+			boolOptString (&defaults->godMode));
+	log_add (log_User, "  --timedilation : =1 Time is slowed down times 6. "
+			"=2 Time is sped up times 5    (default: 0)");
+	log_add (log_User, "  --bubblewarp : Instantaneous travel to any point on "
+			"the Starmap.    (default: %s)",
+			boolOptString (&defaults->bubbleWarp));
+	log_add (log_User, "  --unlockships : Allows you to purchase ships that you can't "
+			"normally acquire in the main game.    (default: %s)",
+			boolOptString (&defaults->unlockShips));
+	log_add (log_User, "  --headstart : Gives you an extra storage bay full of minerals, Fwiffo, "
+			"and the Moonbase during a new game   (default: %s)",
+			boolOptString (&defaults->headStart));
+	log_add (log_User, "  --unlockupgrades : Unlocks every upgrade for your flagship "
+			"and landers.    (default: %s)",
+			boolOptString (&defaults->unlockUpgrades));
+	log_add (log_User, "  --infiniteru : Gives you infinite R.U. as long as the cheat is on "
+			" (default: %s)",
+			boolOptString (&defaults->infiniteRU));
+	log_add (log_User, "  --skipintro : Skips the intro and Logo fmv    (default: %s)",
+			boolOptString (&defaults->skipIntro));
+	log_add (log_User, "  --fmv : Plays Logo and Commercial 3DO videos    (default: %s)",
+			boolOptString (&defaults->FMV));
+	log_add (log_User, "  --mainmenumusic : Switches the main menu music on/off    (default: %s)",
+			boolOptString (&defaults->mainMenuMusic));
+	log_add (log_User, "  --nebulae : Enables/Disables nebulae in star systems    (default: %s)",
+			boolOptString (&defaults->nebulae));
+	log_add (log_User, "  --orbitingplanets : Enables/Disables orbiting planets in star systems    (default: %s)",
+			boolOptString (&defaults->orbitingPlanets));
+	log_add (log_User, "  --texturedplanets : Enables/Disables textured planets in star systems    (default: %s)",
+			boolOptString (&defaults->texturedPlanets));
+	log_add (log_User, "  --infinitefuel : Infinite fuel in the main game    (default: %s)",
+			boolOptString (&defaults->infiniteFuel));
+	log_add (log_User, "  --thraddstory : Enables/Disables the Alt Thraddash Storyline    (default: %s)",
+			boolOptString (&defaults->thraddStory));
+	log_add (log_User, "  --partialpickup : Enables/Disables partial mineral pickup    (default: %s)",
+			boolOptString (&defaults->partialPickup));
+	log_add (log_User, "  --submenu : Enables/Disables mineral and star map keys submenu    (default: %s)",
+			boolOptString (&defaults->submenu));
+	log_add (log_User, "  --dateformat : 0: MMM DD.YYYY | 1: MM.DD.YYYY | "
+			"2: DD MMM.YYYY | 3: DD.MM.YYYY   (default: 0)");
+	log_add (log_User, "  --adddevices : Gives you all available devices    (default: %s)",
+			boolOptString (&defaults->addDevices));
+	log_add (log_User, "  --scaleplanets : Scales textured planets in HD    (default: %s)",
+			boolOptString (&defaults->scalePlanets));
 	log_setOutput (old);
 }
 
diff -ruNp src.orig/uqmversion.h src/uqmversion.h
--- src.orig/uqmversion.h	2017-12-30 00:14:42 -0800
+++ src/uqmversion.h	2017-12-30 00:14:54 -0800
@@ -19,11 +19,11 @@
 
 #define UQM_MAJOR_VERSION     0
 #define UQM_MAJOR_VERSION_S  "0"
-#define UQM_MINOR_VERSION     7
-#define UQM_MINOR_VERSION_S  "7"
+#define UQM_MINOR_VERSION     8
+#define UQM_MINOR_VERSION_S  "8"
 #define UQM_PATCH_VERSION     0
 #define UQM_PATCH_VERSION_S  "0"
-#define UQM_EXTRA_VERSION    ""
+#define UQM_EXTRA_VERSION    "-HD MegaMod Beta"
 /* The final version is interpreted as:
  * printf ("%d.%d.%d%s", UQM_MAJOR_VERSION, UQM_MINOR_VERSION,
  * 		UQM_PATCH_VERSION, UQM_EXTRA_VERSION);
